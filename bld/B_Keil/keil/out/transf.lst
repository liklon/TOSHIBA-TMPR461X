L 1 "..\..\..\..\lldd\src\transf.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver (Transformation Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Transformation Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.13 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/*======================================
N            Include Files
N=======================================*/
N#include "transf.h"
L 1 "..\..\..\..\lldd\inc\transf.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver (Transformation Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Transformation Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.15 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef TRANSF_H
N#define TRANSF_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\lldd\inc\transf.h" 2
N#include "ga_common.h"
L 1 "..\..\..\..\lldd\inc\ga_common.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/07/21 12:30:20 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_COMMON_H
N#define GA_COMMON_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
N
N#define LLDD_GA_COMMON_H_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_COMMON_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*==========================================================================
N|                       GA Configuration Parameters                         |
N ==========================================================================*/
N/*---------------------------------------
N|        GA Sub-Module inclusion         |
N ---------------------------------------*/
N/* Blitting Engine */
N#define GA_USE_BLITTING
N
N/* Transformation Engine */
N#define GA_USE_TRANSFORM
N
N/* Rotation Engine */
N#define GA_USE_ROTATION
N
N/* Drawing Engine */
N#define GA_USE_DRAWING
N
N/*---------------------------------------
N|         GA List Configuration          |
N ---------------------------------------*/
N/* Maximal Number of commands in one list */
N#define GA_CMD_MAX    2048
N
N/*---------------------------------------
N|  Enable/Disable boundary check for     |
N|         GA Command List                |
N ---------------------------------------*/
N/* Enable/Disable boundary check in drivers for command buffer: */
N/* #define GA_CMDSLIST_BOUNDARY_CHECK */
N
N
N/* 1 double word more will be reserved by calculation of needed
N   buffers for GA-API's. This is necesary to add later an END-Command to 
N   finalize the command: 
N*/   
N#define RESERVED_FOR_END_CMD    1
N
N/*======================================
N                Defs
N=======================================*/
N
N/*--------------------------------------
N|     GA General Purpose Registers      |
N --------------------------------------*/
N#define GA_GPR0   0
N#define GA_GPR1   1
N#define GA_GPR2   2
N#define GA_GPR3   3
N#define GA_GPR4   4
N#define GA_GPR5   5
N#define GA_GPR6   6
N#define GA_GPR7   7
N#define GA_GPR8   8
N#define GA_GPR9   9
N#define GA_GPR10  10
N#define GA_GPR11  11
N#define GA_GPR12  12
N#define GA_GPR13  13
N#define GA_GPR14  14
N#define GA_GPR15  15
N#define GA_GPR16  16
N#define GA_GPR17  17
N#define GA_GPR18  18
N#define GA_GPR19  19
N#define GA_GPR20  20
N#define GA_GPR21  21
N#define GA_GPR22  22
N#define GA_GPR23  23
N#define GA_GPR24  24
N#define GA_GPR25  25
N#define GA_GPR26  26
N#define GA_GPR27  27
N#define GA_GPR28  28
N#define GA_GPR29  29
N#define GA_GPR30  30
N#define GA_GPR31  31
N
N
N/*--------------------------------------
N|         GA Command Parameters         |
N --------------------------------------*/
N/* Selection of module to wait on */
Ntypedef enum tag_ga_modul_e
N{
N    GA_GDC0        = 0x0u,
N    GA_FG0         = 0x1u,
N    GA_GDC1        = 0x2u
N} ga_modul_e;
N
N/* Enables/Disables option */
Ntypedef enum tag_ga_en_e
N{
N    GA_DIS         = 0x0u,     /* Disable/off */
N    GA_EN          = 0x1u      /* Enable/on */
N} ga_en_e;
N
N/* Blending Order */
Ntypedef enum tag_blendOrd_e
N{
N    GA_ONTO_DEST   = 0x0u,     /* Onto destination */
N    GA_BEHIND_DEST = 0x1u      /* Behind destination */
N} ga_blendOrd_e;
N
N/* Color format selection */
Ntypedef enum tag_ga_colFmt_e
N{
N    GA_RGB16       = 0x0u,      /* 16-bit RGB format */
N    GA_RGBA32      = 0x1u       /* 32-bit RGBA format */
N} ga_colFmt_e;
N
N/*--------------------------------------
N|        GA Command Construction        |
N --------------------------------------*/
N/* Command Field Masks */
N#define GA_MASK1           0x1u
N#define GA_MASK2           0x3u
N#define GA_MASK3           0x7u
N#define GA_MASK4           0xfu
N#define GA_MASK5           0x1fu
N#define GA_MASK6           0x3fu
N#define GA_MASK7           0x7fu
N#define GA_MASK8           0xffu
N#define GA_MASK9           0x1ffu
N#define GA_MASK10          0x3ffu
N#define GA_MASK12          0xfffu
N#define GA_MASK14          0x3fffu
N#define GA_MASK15          0x7fffu
N#define GA_MASK16          0xffffu
N#define GA_MASK22          0x3fffffu
N#define GA_MASK24          0xffffffu
N#define GA_MASK32          0xffffffffu
N#define GA_MASK36          0xfffffffffull
N#define GA_MASK48          0xffffffffffffull
N#define GA_MASK64          0xffffffffffffffffull
N
N/* GA Unit selection */
N#define GA_SCHED           0x0u
N#define GA_BLITING         0x1u
N#define GA_DRAWING         0x2u
N#define GA_ROTATION        0x3u
N#define GA_TRANSFORM       0x4u
N
N/*** Command Codes ***/
N#define GA_CMC_LGPR        0x1u
N#define GA_CMC_CSWVSYNC    0x2u
N#define GA_CMC_CSUIC	     0x3u
N#define GA_CMC_CSGDC0CC	   0x4u
N#define GA_CMC_CSGDC1CC	   0x5u
N#define GA_CMC_END         0xffu
N
N/* Blitting Engine Command Codes */
N
N#define GA_CMC_BLTO16      0x02u
N#define GA_CMC_BLTO32      0x04u
N#define GA_CMC_BLTORLEI16  0x0au
N#define GA_CMC_BLTORLEI24  0x06u
N#define GA_CMC_BLTORLEI24A 0x0Eu
N#define GA_CMC_BLTORLEI32  0x0cu
N#define GA_CMC_BLTOP16     0x12u
N#define GA_CMC_BLTOP32     0x14u
N#define GA_CMC_BLTB16      0x03u
N#define GA_CMC_BLTB32      0x07u
N#define GA_CMC_BLTBRLEI16  0x0bu
N#define GA_CMC_BLTBRLEI24  0x05u
N#define GA_CMC_BLTBRLEI24A 0x0fu
N#define GA_CMC_BLTBRLEI32  0x0du
N#define GA_CMC_BLTBP16     0x13u
N#define GA_CMC_BLTBP32     0x17u
N
N/* Transformation Engine Command Code */
N#define GA_CMC_TRANSF      0x01u
N#define GA_CMC_TRANSFB     0x00u
N
N/* Rotation Engine Command Code */
N#define GA_CMC_ROT         0x01u
N#define GA_CMC_ROTB        0x00u
N
N/* Drawing Engine Command Codes */
N#define GA_CMC_DE_DLRGBA32 0x03u
N#define GA_CMC_DE_DLRGB16  0x04u
N#define GA_CMC_DE_DTRGBA32 0x05u
N#define GA_CMC_DE_DTRGB16  0x06u
N
N/* Command Field Offsets */
N#define GA_ENG_OFF         60
N#define GA_LEN_OFF         56
N#define GA_CMC_OFF         48
N#define GA_SPC_OFF          0
N
N/* Command Field Masks */
N#define GA_ENG_MSK         (GA_MASK3)
N#define GA_LEN_MSK         (GA_MASK4)
N#define GA_CMC_MSK         (GA_MASK8)
N#define GA_SPC_MSK         (GA_MASK48)
N
N/* Macro for command field positioning */
N#define GA_FP(val, offset, mask) (((uint64_t)(val) & (mask)) << (offset))
N
N/* GA Command Fields (Engine, Length, Command code, Cmd Specific Params.)*/
N#define GA_ENG(Engine) (GA_FP((Engine), GA_ENG_OFF, GA_ENG_MSK))
N#define GA_LEN(Len)    (GA_FP((Len)   , GA_LEN_OFF, GA_LEN_MSK))
N#define GA_CMC(Code)   (GA_FP((Code)  , GA_CMC_OFF, GA_CMC_MSK))
N#define GA_SPC(spec)   (GA_FP((spec)  , GA_SPC_OFF, GA_SPC_MSK))
N
N/* GA Command Construction Macro */
N#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    | \
N                                                GA_ENG((Engine))   | \
N                                                GA_LEN((Len))      | \
N                                                GA_CMC((CmdCode))  | \
N                                                GA_SPC((CmdSpec)))
X#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    |                                                 GA_ENG((Engine))   |                                                 GA_LEN((Len))      |                                                 GA_CMC((CmdCode))  |                                                 GA_SPC((CmdSpec)))
N
N/*=========================================================================
N|                        SCHEDULER OPERATION COMMANDS                      |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load General-Purpose Register Command (LGPR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to configure
N|             one out of the 32 General-Purpose Registers. The command
N|             specific parameter for this command is the number of the
N|             register that should be loaded and the value itself.
N|
N|  Params:    regNr   - The number of the General-Purpose Register that
N|                       should be loaded
N|
N|             uiVal   - Value that should be stored within the selected
N|                       register. If the register does not encapsulate
N|                       32 bits the value within the command has to be right
N|                       aligned.
N|
N -------------------------------------------------------------------------*/
N#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,       \
N                               GA_FP ((regNr), 32, GA_MASK5)      |   \
N                               GA_FP ((uiVal),  0,  GA_MASK32)))
X#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,                                      GA_FP ((regNr), 32, GA_MASK5)      |                                  GA_FP ((uiVal),  0,  GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   END Command (CSEND)
N|
N|  Descr  :   The CSEND command must be placed at the end of every command
N|             list. It signals the Command Scheduler that all commands have
N|             been executed. When the Command Scheduler is detecting this
N|             mark, a flag in the status register signals that the command
N|             list was executed. Optionally an interrupt is generated.
N|
N|  Params:    none
N|
N -------------------------------------------------------------------------*/
N#define GA_END() (GA_CMN(GA_SCHED, 0x1u, GA_CMC_END,0x0u))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Wait VSYNC Command (CSWVSYNC)
N|
N|  Descr  :   The CSWVSYNC command can be used to synchronize parts of the
N|             command list with the vertical synchronization signal VSYNC
N|             from the GDC or the Frame Grabber.
N|
N|             When the Command Scheduler is reading the CSWVSYNC command
N|             it waits until the next vertical synchronization of the
N|             display/camera input takes place before executing the next
N|             command.
N|
N|  Params:    module   -  VSYNC select:
N|                         Use: GA_GDC0     - Wait on GDC0
N|                              GA_FG0      - Wait on FG0
N|                              GA_GDC1     - Wait on GDC1
N|                              GA_FG1      - Wait on FG1
N|
N|
N -------------------------------------------------------------------------*/
N#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,        \
N                         GA_FP ((module), 0, GA_MASK2)))
X#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,                                 GA_FP ((module), 0, GA_MASK2)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   User Interrupt Command (CSUIC)
N|
N|  Descr  :   The CSUIC command can be used to signal the MCU that a
N|             certain part of the Command List is already executed or
N|             will now start execution.
N|
N|  Params:    interrupt number:
N|                          Use: 0 - 23
N|                               values > 23 will be ignored
N|
N -------------------------------------------------------------------------*/
N#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,    \
N                                  GA_FP ((number), 0, GA_MASK6)))
X#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,                                      GA_FP ((number), 0, GA_MASK6)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC0 Configuration Command (CSGDC0CC)
N|
N|  Descr  :   The CSGDC0CC command can be used to change the content of GDC0 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC0 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC1 Configuration Command (CSGDC1CC)
N|
N|  Descr  :   The CSGDC1CC command can be used to change the content of GDC1 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC1 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N
N/*======================================
N              Structures
N=======================================*/
N/* Command List Structure */
Ntypedef struct tag_ga_list_st
N{
N    uint64_t  ullCommands[GA_CMD_MAX] ;
X    uint64_t  ullCommands[2048] ;
N    uint64_t* pu64Current;
N    uint32_t  u32UsedDoubleWords; /* used or needed double words for an  GA-API */
N    int32_t   i32FreeSpaceStat;   /* C_SUCCESS: OK no space free error,
N                                     C_FAILED:  No free space for GA-API */
N} ga_list_st ;
N
N/****************************************************************************/
N
N
N#endif /* GA_COMMON_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_common.h
N**  $Revision: 1.14 $
N**  $Date: 2015/07/21 12:30:20 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  : 
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 27 "..\..\..\..\lldd\inc\transf.h" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
S
N#endif  
N
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_TRANSF_H_REVISION     "$Revision: 1.15 $"
N#define LLDD_GA_TRANSF_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*--------------------------------------------------------------------------
N|       ------------------------------------------------------------        |
N|      | >>>>>>     TRANSFORMATION ENGINE COMMAND INDEX      <<<<<< |       |
N|       ------------------------------------------------------------        |
N|---------------------------------------------------------------------------|
N|---------------------------------------------------------------------------|
N|                                                                           |
N|                      ------------------------------                       |
N|                     |      OPERATION COMMANDS      |                      |
N|                      ------------------------------                       |
N|                                                                           |
N| - Commands:                                                               |
N|   1. TSF_TRANSF           -Transformation Command                         |
N|   2. TSF_TRANSFB          -Transformation Command with blend              |
N|                                                                           |
N|---------------------------------------------------------------------------|
N|                                                                           |
N|                    ----------------------------------                     |
N|                   |      LOAD REGISTER COMMANDS      |                    |
N|                    ----------------------------------                     |
N|                                                                           |
N| - Source Regs:                                                            |
N|   1. TSF_LOAD_SOURCEADDR  -  Load Source Address Reg.               (SAR) |
N|   2. TSF_LOAD_SRCWIDTH    -  Load Source Memory Width Reg.         (SMWR) |
N|   3. TSF_LOAD_SRCALPHA    -  Load Source Alpha Value Register      (SAVR) |
N|   4. TSF_LOAD_SRCFADEFACT -  Load Source Fading Factor register    (SFFR) |
N|                                                                           |
N| - Destination Regs:                                                       |
N|   5. TSF_LOAD_DESTADDR    -  Load Destination Address Reg.          (DAR) |
N|   6. TSF_LOAD_DESTWIDTH   -  Load Destination Memory Width Reg.    (DMWR) |
N|   7. TSF_LOAD_DEST_IMAGEWIDTH  -  Load Destination Image Width Reg. (DWR) |
N|   8. TSF_LOAD_DESTLINECNT -  Load Destination Blit LINE Count Reg. (DLCR) |
N|   9. TSF_LOAD_DESTALPHA   -  Load Destination Alpha Value Register (DAVR) |
N|                                                                           |
N| - CLUT Regs:                                                              |
N|  10. TSF_LOAD_LUTADDR     -  Load LUT Address Register              (LAR) |
N|  11. TSF_LOAD_LUTWIDTH    -  Load LUT Width Register                (LWR) |
N|  12. TSF_LOAD_LUTLINECNT  -  Load LUT Line Count Register          (LLCR) |
N|                                                                           |
N| - Color Regs:                                                             |
N|  13. TSF_LOAD_COLORFMT    - Load Color Format Register              (CFR) |
N|  14. TSF_LOAD_PRECOLOR    - Load Clipping Window Width Reg.        (CWWR) |
N|                                                                           |
N --------------------------------------------------------------------------*/
N
N/*=========================================================================
N|                            OPERATION COMMANDS                             |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Transform
N|
N|  Descr  :   The Transformation Engine uses only one command pattern to be
N|             triggered.
N|
N|  Params:    modeSel  - Mode Control
N|                        Use: GA_MODE_PIXEL   - Pixel Mode
N|                             GA_MODE_COLORCH - Color channel Mode
N|
N|             filterEn - Filter Control
N|                        Use: GA_EN           - Enable Filter
N|                             GA_DIS          - Disable Filter
N|
N|
N -------------------------------------------------------------------------*/
N#define TSF_TRANSF(modeSel,filterEn)(GA_CMN(GA_TRANSFORM, 1, GA_CMC_TRANSF,\
N                                     GA_FP ((modeSel),    1, GA_MASK1)   | \
N                                     GA_FP ((filterEn),   0, GA_MASK1)))
X#define TSF_TRANSF(modeSel,filterEn)(GA_CMN(GA_TRANSFORM, 1, GA_CMC_TRANSF,                                     GA_FP ((modeSel),    1, GA_MASK1)   |                                      GA_FP ((filterEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Transform blend
N|
N|  Descr  :   The Transformation Engine uses only one command pattern to be
N|             triggered.
N|
N|  Params:   modeSel      - Mode Control
N|                           Use: GA_MODE_PIXEL    - Pixel Mode
N|                                GA_MODE_COLORCH  - Color channel Mode
N|                         
N|            redChProt    - Red Channel Protection
N|                           Use: GA_EN            - Channel Protected
N|                                GA_DIS           - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN            - Channel Protected
N|                                GA_DIS           - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN            - Channel Protected
N|                                GA_DIS           - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN            - Channel Protected
N|                                GA_DIS           - Channel Not Protected
N|                         
N|             redChFad    - Red Channel Fading
N|                            Use: GA_EN           - Channel Protected
N|                                 GA_DIS          - Channel Not Protected
N|                         
N|             greenChFad  - Green Channel Fading
N|                            Use: GA_EN           - Channel Protected
N|                                 GA_DIS          - Channel Not Protected
N|                         
N|             blueChFad   - Blue Channel Fading
N|                            Use: GA_EN           - Channel Protected
N|                                 GA_DIS          - Channel Not Protected
N|                         
N|             alphaFad    - Alpha Channel Fading
N|                            Use: GA_EN           - Channel Protected
N|                                 GA_DIS          - Channel Not Protected
N|                         
N|             blndOrder    - Blending Order
N|                            Use: TSF_ONTO_DEST   - Onto destination
N|                                 TSF_BEHIND_DEST - Behind the destination
N|                         
N|             filterEn     - Filter Control
N|                            Use: GA_EN           - Enable Filter
N|                                 GA_DIS          - Disable Filter
N|
N|
N -------------------------------------------------------------------------*/
N#define TSF_TRANSFB(modeSel,                                               \
N                    redChProt,                                             \
N                    greenChProt,                                           \
N                    blueChProt,                                            \
N                    alphaProt,                                             \
N                    redChFad,                                              \
N                    greenChFad,                                            \
N                    blueChFad,                                             \
N                    alphaFad,                                              \
N                    blndOrder,                                             \
N                    filterEn)                                              \
N                        (GA_CMN(GA_TRANSFORM,  1, GA_CMC_TRANSFB,          \
N                         GA_FP ((redChProt),  15, GA_MASK1)        |       \
N                         GA_FP ((greenChProt),14, GA_MASK1)        |       \
N                         GA_FP ((blueChProt), 13, GA_MASK1)        |       \
N                         GA_FP ((alphaProt),  12, GA_MASK1)        |       \
N                         GA_FP ((redChFad),   11, GA_MASK1)        |       \
N                         GA_FP ((greenChFad), 10, GA_MASK1)        |       \
N                         GA_FP ((blueChFad),   9, GA_MASK1)        |       \
N                         GA_FP ((alphaFad),    8, GA_MASK1)        |       \
N                         GA_FP ((blndOrder),   3, GA_MASK2)        |       \
N                         GA_FP ((modeSel),     1, GA_MASK1)        |       \
N                         GA_FP ((filterEn),    0, GA_MASK1)))
X#define TSF_TRANSFB(modeSel,                                                                   redChProt,                                                                 greenChProt,                                                               blueChProt,                                                                alphaProt,                                                                 redChFad,                                                                  greenChFad,                                                                blueChFad,                                                                 alphaFad,                                                                  blndOrder,                                                                 filterEn)                                                                      (GA_CMN(GA_TRANSFORM,  1, GA_CMC_TRANSFB,                                   GA_FP ((redChProt),  15, GA_MASK1)        |                                GA_FP ((greenChProt),14, GA_MASK1)        |                                GA_FP ((blueChProt), 13, GA_MASK1)        |                                GA_FP ((alphaProt),  12, GA_MASK1)        |                                GA_FP ((redChFad),   11, GA_MASK1)        |                                GA_FP ((greenChFad), 10, GA_MASK1)        |                                GA_FP ((blueChFad),   9, GA_MASK1)        |                                GA_FP ((alphaFad),    8, GA_MASK1)        |                                GA_FP ((blndOrder),   3, GA_MASK2)        |                                GA_FP ((modeSel),     1, GA_MASK1)        |                                GA_FP ((filterEn),    0, GA_MASK1)))
N
N
N/*=========================================================================
N|                          LOAD REGISTER COMMANDS                           |
N ==========================================================================*/
N/*------------------------------
N|        SOURCE REGISTERS       |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Address Register (SAR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load SAR.
N|             The physical 32-bit address within the source address register
N|             is the pointer to the first dot of the source.
N|
N|  Params:    addr - Source Address
N|                    The lower 32 physical address bits that point to the
N|                    first dot of the source.
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_SOURCEADDR(addr) (GA_LOAD(GA_GPR9, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Memory Width Register (SMWR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load SMWR.
N|             The source memory width register specifies the memory reserved
N|             for one line within the source image in number of dots.
N|
N|
N|  Params:    width - Source Memory Width
N|                     Memory reserved per line within the source in dots
N|                     (1 up to 4095)
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_SRCWIDTH(width) (GA_LOAD(GA_GPR10, (width)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Alpha Value Register (SAVR)
N|
N|  Descr  :   The Source Alpha Value Register keeps the alpha value for
N|             conversion of the source dots from the 16-bit RGB format to
N|             the 32-bit RGBA format for internal processing.
N|
N|  Params:    srcalpha - source alpha value
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_SRCALPHA(srcalpha) (GA_LOAD(GA_GPR27,                     \
N                                     ((srcalpha) & GA_MASK8)))
X#define TSF_LOAD_SRCALPHA(srcalpha) (GA_LOAD(GA_GPR27,                                                          ((srcalpha) & GA_MASK8)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Fading Factor Register (SFFR)
N|
N|  Descr  :   The Source Fading Factor Register holds the fading factor enumerator
N|             (SFFE) of the fading factor.
N|
N|  Params:    factor  - Source Fading Factor Enumerator
N|                       These bits specify the enumerator of the fading
N|                       factor FFACT.
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_SRCFADEFACT(factor) (GA_LOAD(GA_GPR26,                       \
N                                   ((factor) & GA_MASK8)))
X#define TSF_LOAD_SRCFADEFACT(factor) (GA_LOAD(GA_GPR26,                                                          ((factor) & GA_MASK8)))
N
N/*------------------------------
N|     DESTINATION REGISTERS     |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Address Register (DAR)
N|
N|  Descr  :   The physical 32-bit address within the destination address
N|             register is the pointer to the first dot in the memory region,
N|             where the transformed bitmap will be placed. Depending on
N|             the source color format, which is equal to the destination
N|             color format, this address has to be word- (RGBA32) or
N|             halfword- (RGB16) aligned.
N|
N|  Params:    addr - Destination Address
N|                    The lower 32 physical address bits that point to the
N|                    first dot of the destination.
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_DESTADDR(addr) (GA_LOAD(GA_GPR4, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Memory Width Register (DMWR)
N|
N|  Descr  :   The destination memory width register specifies the memory
N|             reserved for one line within the destination image in number
N|             of dots.
N|             Note that this value can be greater than the number of dots
N|             to be blitted per line.
N|
N|  Params:    width - Destination Memory Width
N|                     Memory reserved per line within the source in dots
N|                     (1 up to 4095)
N|
N|  Limit.:    The content of this register is not taken into account when the
N|             Blitting Engine is configured to read a run-length encoded
N|             image. When the source is run-length encoded the destinations
N|             dimensions have to match the dimensions of the source exactly
N|             (number of dots).
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_DESTWIDTH(width) (GA_LOAD(GA_GPR5, (width)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Image Width Register (DWR)
N|
N|  Descr  :   The destination image width register specifies the number of
N|             dots per line of the destination image. In pixel mode, the
N|             least value of LUT Width Register and Destination Image Width
N|             Register is used to determine the width of the processed area.
N|
N|  Params:    width - Destination Image Width
N|                     Dots per line within the destination
N|                     (from 1 up to 1023).
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_DEST_IMAGEWIDTH(width) (GA_LOAD(GA_GPR6,                 \
N                                         ((width)& GA_MASK10)))
X#define TSF_LOAD_DEST_IMAGEWIDTH(width) (GA_LOAD(GA_GPR6,                                                          ((width)& GA_MASK10)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Image Line Count Register (DLCR)
N|
N|  Descr  :   The destination line count register specifies the number of
N|             lines of the destination image. The least value of LUT Line
N|             Count Register and Destination Image Line Count Register is
N|             used to determine the height of the processed area.
N|
N|  Params:    lineCnt - Number of destination lines to be processed
N|                       (from 1 up to 1023).
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_DESTLINECNT(lineCnt) (GA_LOAD(GA_GPR7,                   \
N                                       ((lineCnt) & GA_MASK10)))
X#define TSF_LOAD_DESTLINECNT(lineCnt) (GA_LOAD(GA_GPR7,                                                          ((lineCnt) & GA_MASK10)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Alpha Value Register (DAVR)
N|
N|  Descr  :   The Destination Alpha Value Register keeps the alpha value
N|             used during conversion of the destination dots from the
N|             16-bit RGB format to the 32-bit RGBA format.
N|
N|  Params:    dstalpha - destination alpha value
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_DESTALPHA(dstalpha) (GA_LOAD(GA_GPR28,                    \
N                                      ((dstalpha) & GA_MASK8)))
X#define TSF_LOAD_DESTALPHA(dstalpha) (GA_LOAD(GA_GPR28,                                                          ((dstalpha) & GA_MASK8)))
N
N
N/*------------------------------
N|         L U T REGISTERS       |
N -------------------------------*/
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load LUT Address Register (LAR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load LAR.
N|             The physical 32-bit address within the look-up table address
N|             register is the pointer to the first look-up table entry in
N|             memory. This address has to be word-aligned.
N|
N|  Params:    addr - LUT Address
N|                    The lower 32 physical address bits that point to the
N|                    first entry of the LUT.
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_LUTADDR(addr) (GA_LOAD(GA_GPR13, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load LUT Width Register (LWR)
N|
N|  Descr  :   The LUT width register specifies the number of entries per line
N|             within the look-up table. In pixel mode, the least value of LUT
N|             width register and destination image width register is used to
N|             determine the width of the processed area. In color channel
N|             mode, this width has to be three times the destination image
N|             width for RGB16 color format and four times the destination
N|             image width for RGBA32 color format.
N|
N|
N|  Params:    width - LUT Width
N|                     Entries per line within the look-up table
N|                     (from 1 up to 4095).
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_LUTWIDTH(width) (GA_LOAD(GA_GPR14,                        \
N                                  ((width)& GA_MASK12)))
X#define TSF_LOAD_LUTWIDTH(width) (GA_LOAD(GA_GPR14,                                                          ((width)& GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load LUT Line Count Register (LLCR)
N|
N|  Descr  :   The source line count register specifies the number of lines
N|             of the look-up table. The least value of LUT Line Count
N|             Register and Destination Image Line Count Register is used to
N|             determine the height of the processed area.
N|
N|
N|  Params:    lineCnt - LUT Line Count
N|                       Number of source lines to be transformed
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_LUTLINECNT(lineCnt) (GA_LOAD(GA_GPR15,                   \
N                                      ((lineCnt) & GA_MASK10)))
X#define TSF_LOAD_LUTLINECNT(lineCnt) (GA_LOAD(GA_GPR15,                                                         ((lineCnt) & GA_MASK10)))
N
N
N
N/*------------------------------
N|        COLOR REGISTERS        |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Color Format Register (CFR)
N|
N|  Descr  :   This register specifies the color format of source
N|             and destination.
N|
N|  Params:    srcformat  - Source color format
N|                       	 Use parameters:
N|                       	 GA_RGB16    - 16-bit RGB
N|                       	 GA_RGBA32   - 32-bit RGBA
N|  				 dstformat   - destination color format
N|                       	 Use parameters:
N|                       	 GA_RGB16    - 16-bit RGB
N|                       	 GA_RGBA32   - 32-bit RGBA
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_COLORFMT(dstformat, srcformat) (GA_LOAD(GA_GPR16,        \
N                                   (GA_FP((dstformat), 1, GA_MASK1)   |	  \
N                                    GA_FP((srcformat), 0, GA_MASK1))))
X#define TSF_LOAD_COLORFMT(dstformat, srcformat) (GA_LOAD(GA_GPR16,                                           (GA_FP((dstformat), 1, GA_MASK1)   |	                                      GA_FP((srcformat), 0, GA_MASK1))))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Predefined Color Register (PCR)
N|
N|  Descr  :   The Predefined Color Register gives the color of the
N|             destination dot, if the LUT indexes position 0xFFFF for the x
N|             coordinate and 0xFFFF for the y coordinate.
N|
N|             When using 32-bit RGBA color format, the complete 32 bit of
N|             the register are assigned as color value to the corresponding
N|             pixel. When using 16-bit RGB color format, only the bits [15:0]
N|             are used as predefined color. The bits [31:16] are not
N|             regarded.
N|
N|  Params:    colVal - Predefined Color
N|                      This color is used for LUT entries which point to
N|                      (0xFFFF/0xFFFF).
N|
N -------------------------------------------------------------------------*/
N#define TSF_LOAD_PRECOLOR(colVal) (GA_LOAD(GA_GPR17, (colVal)))
N
N/*======================================
N                Enums
N=======================================*/
N/* Transformation mode */
Ntypedef enum tag_transf_Mode_e
N{
N    TSF_MODE_PIXEL = 0x0u,          /* Pixel Mode Operation */
N    TSF_MODE_COLOR = 0x1u           /* Color Mode Operation */
N} transf_Mode_e;
N
N/*======================================
N              Structures
N=======================================*/
N/* LUT Configuration Strucuture */
Ntypedef struct tag_transf_Lut_st
N{
N    uint32_t u32Addr;               /* Look-up table address */
N    uint16_t u16Width;              /* Look-up table width  (1 to 4095) */
N    uint16_t u16LineCnt;            /* Look-up table line count(1 to 1023) */
N} transf_Lut_st;
N
N/* Memory Configuration structure */
Ntypedef struct tag_transf_mem_st
N{
N    /* Source Mem. Params */
N    uint16_t      u16SrcWidth;      /* Source Memory Width (Dots Per Line) */
N    uint32_t      u32SrcAddr;       /* Source Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    /* Destination Mem. Params */
N    uint16_t      u16DstWidth;      /* Dest. Memory Width (Dots Per Line) */
N    uint32_t      u32DstAddr;       /* Dest. Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    /* Dest. Image Area Size */
N    uint16_t      u16DstImgWidth;   /* Dot Number per line to be blitted */
N    uint16_t      u16LineCnt;       /* Line Number to be blitted */
N} transf_mem_st;
N
N/* Transform Config Struct */
Ntypedef struct tag_transf_Prm_st
N{
N    transf_Mode_e   eTsfMode;       /* Transform. Mode (Pixel-/Color-Mode) */
N    ga_en_e         eFilterEn;      /* Enable Filtering */
N    ga_colFmt_e     eSrcColFmt;     /* Source Color Format selection */
N    ga_colFmt_e     eDstColFmt;     /* Destination Color Format selection */
N    uint32_t        u32Color;       /* Predefined Color (used for
N                                       LUT 0xFFFF entries) */
N    uint8_t        u8SrcAlphaVal;   /* Source Alpha value */
N    uint8_t        u8DstAlphaVal;   /* Destination Alpha value */
N} transf_Prm_st;
N
N/* Transform Blend Config Struct */
Ntypedef struct tag_transf_PrmBlend_st
N{
N    transf_Mode_e   eTsfMode;       /* Transform. Mode (Pixel-/Color-Mode) */
N    ga_en_e         eFilterEn;      /* Enable Filtering */
N    ga_en_e         eDstRedProt;    /* Destination red color protection */
N    ga_en_e         eDstGreenProt;  /* Destination green color protection */
N    ga_en_e         eDstBlueProt;   /* Destination blue color protection */
N    ga_en_e         eDstAlphaProt;  /* Destination alpha protection */
N    ga_en_e         eSrcRedFad;     /* Source red color protection */
N    ga_en_e         eSrcGreenFad;   /* Source green color protection */
N    ga_en_e         eSrcBlueFad;    /* Source blue color protection */
N    ga_en_e         eSrcAlphaFad;   /* Source alpha protection */
N    ga_blendOrd_e   eBldOrd;        /* Blend order */
N    ga_colFmt_e     eSrcColFmt;     /* Source Color Format selection */
N    ga_colFmt_e     eDstColFmt;     /* Destination Color Format selection */
N    uint32_t        u32Color;       /* Predefined Color (used for
N                                       LUT 0xFFFF entries) */
N    uint8_t        u8FadingFctr;    /* Fading facror */
N    uint8_t        u8SrcAlphaVal;   /* Source Alpha value */
N    uint8_t        u8DstAlphaVal;   /* Destination Alpha value */
N} transf_PrmBlend_st;
N
N
N/*======================================
N      Exported Function Prototypes
N=======================================*/
N
N/****************************************************************************
N *
N * Function:      vTransf_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                        uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag);
N
N/*-------------------------------------------------------------------------
N|
N|                      B A S I C      O P E R A T I O N S
N|
N --------------------------------------------------------------------------*/
N/****************************************************************************
N *
N * Function:      vTransf_SetMemSrc
N *
N * Purpose:       Sets Transf source parameters in Command List
N *
N * Inputs:        u32Addr    - Source Memory Address
N *                             (First Dot of the source)
N *
N *                u32Width   - Source Memory Width
N *                             (Memory reserved per line within the source in
N *                              dots: 1 up to 4095)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_SetMemSrc(uint32_t u32Addr, uint32_t u32Width, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_SetDstImgSize
N *
N * Purpose:       Sets in the Command List the size of the destination image
N *                (number of dots per line and number of image lines)
N *
N * Inputs:        u32Width   - Destination Image Width in Dot Number
N *                             (1 up to 4095)
N *                u32Lines   - Destination Image Line Number
N *                             (1 up to 1023)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_SetDstImgSize(uint32_t u32Width, uint32_t u32Lines,
N                           ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_SetMemDest
N *
N * Purpose:       Sets the destination memory parameters in the Command List
N *
N * Inputs:        u32Addr    - Destination Memory Address
N *                             (First Dot of the destination)
N *
N *                u32Width   - Destination Memory Width
N *                             (Memory reserved per line within the destinatio
N *                              in dots: 1 up to 4095)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_SetMemDest(uint32_t u32Addr, uint32_t u32Width, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_ConfigLUT
N *
N * Purpose:       Configures the transformation look-up table parameters
N *                  - Memory location,
N *                  - LUT Width,
N *                  - LUT line count
N *
N * Inputs:        stCfg      - pointer to LUT configuration parameters
N *                             (for more details see the struct. desc.s)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_ConfigLUT(transf_Lut_st* pstCfg, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_SetColorFmt
N *
N * Purpose:       Sets the color format of the both source and destination.
N *
N * Inputs:        eSrcColFormat - Source Color Format Selection
N *                             		(16-bit RGB/ 32-bit RGBA)
N * 								eDstColFormat - Destination Color Format Selection
N *                             	  (16-bit RGB/ 32-bit RGBA)
N *
N *                pstCmdList    - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Please note that Transformation Engine cannot convert color
N *                format, therefore formats for both (src. and dst.) must be
N *                the same.
N *
N ***************************************************************************/
Nvoid vTransf_SetColorFmt(ga_colFmt_e eSrcColFormat, ga_colFmt_e eDstColFormat, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_SetPredefColor
N *
N * Purpose:       Sets the predefined color which is used for LUT entries
N *                which point to (0xFFFF/0xFFFF).
N *
N * Inputs:        u32Color   - Color Value. Must be set in the same format as
N *                             the format specified by Transf_SetColorFmt().
N *                             This means that in RGBA format all 32-bits will
N *                             be evaluated and in case of RGB only 16-bits.
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_SetPredefColor(uint32_t u32Color, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_SetTransfCmd
N *
N * Purpose:       Inserts the transformation command in the Command List
N *
N * Inputs:        eOpMode    - Mode Control selects between Pixel Mode and
N *                             Channel Control Mode.
N *
N *                eFilterEn  - Filter Control (Enables/Disables the filter)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_SetTransfCmd(transf_Mode_e eOpMode, ga_en_e eFilterEn,
N                         ga_list_st* pstCmdList);
N
N/*-------------------------------------------------------------------------
N|
N|            T R A N S F O R M A T I O N     O P E R A T I O N
N|
N --------------------------------------------------------------------------*/
N/****************************************************************************
N *
N * Function:      vTransf_ConfigTransfOp
N *
N * Purpose:       Inserts in the Command List the transformation-command and
N *                commands for loading of all parameters required for the
N *                transformation command execution.
N *
N * Inputs:        stMem      - pointer to memory configuration parameters
N *
N *                tLutCfg    - pointer to look-up table configuration parameters
N *
N *                tColCfg    - pointer to color Config Parameters
N *
N *                pstCmdList - Pointer to the Command List
N *
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_ConfigTransfOp(transf_mem_st* pstMem, transf_Lut_st* pstLutCfg,
N                            transf_Prm_st* pstTsfPrm, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vTransf_ConfigTransfBlendOp
N *
N * Purpose:       Inserts in the Command List the transformation-command and
N *                commands for loading of all parameters required for the
N *                transformation blen command execution.
N *
N * Inputs:        stMem      - pointer to memory configuration parameters
N *
N *                tLutCfg    - pointer to look-up table configuration parameters
N *
N *                tColCfg    - pointer to color Config Parameters
N *
N *                pstCmdList - pointer to the Command List
N *
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTransf_ConfigTransfBlendOp(transf_mem_st* pstMem, transf_Lut_st* pstLutCfg,
N                                 transf_PrmBlend_st* pstTsfPrm, ga_list_st* pstCmdList);
N
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N#endif /* TRANSF_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: transf.h
N**  $Revision: 1.15 $
N**  $Date: 2015/05/04 09:07:14 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** |
N** | CONS.  :
N** |
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\transf.c" 2
N#include "ga.h"
L 1 "..\..\..\..\lldd\inc\ga.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.19 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_H
N#define GA_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "ga_common.h"
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_H_REVISION     "$Revision: 1.19 $"
N#define LLDD_GA_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/* Timeout */
N#define GA_TIMEOUT  10000
N
N/* Size of Draw Engine Filter RAM (in doublewords) */
N#define GA_DE_FILTER_SIZE 64
N
N/* GA Interrupt Masks */
N#define GA_IRQ_MASK_CENDIM  0x00000001U    /* GA Command End Interrupt Mask.                          */
N#define GA_IRQ_MASK_CSCEIM  0x00000004U    /* Command Scheduler Command Error Interrupt Mask          */
N#define GA_IRQ_MASK_CSLEIM  0x00000008U    /* Command Scheduler Command List Executed Interrupt Mask  */
N#define GA_IRQ_MASK_WBWIM   0x00000010U    /* GA Write Buffer Write Bus-Error Interrupt Mask          */
N#define GA_IRQ_MASK_WBRIM   0x00000020U    /* GA Write Buffer Read Bus-Error Interrupt Mask           */
N#define GA_IRQ_MASK_CBIM    0x00000040U    /* GA Cache Buffer Bus-Error Interrupt Mask                */
N#define GA_IRQ_MASK_RBIM    0x00000080U    /* GA Read Buffer Bus-Error Interrupt Mask                 */
N#define GA_IRQ_MASK_CSLUIM  0xFFFFFF00U    /* Command List User Interrupt Mask 0 – 23                 */
N
N/*======================================
N                Enums
N=======================================*/
N/****************************************
N*         GAIMR Param.Values
N****************************************/
N/* IRQ Mask */
Ntypedef enum tag_ga_irqen_e
N{
N    GA_IRQ_EN  = 0x1u,     /* Enable IRQ */
N    GA_IRQ_DIS = 0x0u      /* Disable IRQ */
N} ga_irqen_e;
N
N/* Bus type */
Ntypedef enum tag_ga_bus_type_e
N{
N    GA_READ_BUF_BUS        = 0x00U,
N    GA_CACHE_BUF_BUS       = 0x01U,
N    GA_WRITE_BUF_READ_BUS  = 0x02U,
N    GA_WRITE_BUF_WRITE_BUS = 0x03U,
N    GA_MAX_TYPE_BUS        = 0x04U
N} ga_bus_type_e;
N
N/* Read / Write Direction */
Ntypedef enum tag_ga_buserr_dir_e
N{
N    GA_BUSERR_READ_TRANSF   = 0x0U,
N    GA_BUSERR_WRITE_TRANSF  = 0x1U
N} ga_buserr_dir_e;
N
N/* Burs error Type */
Ntypedef enum tag_ga_buserr_bursttype
N{
N    GA_BUSERR_BURST_TYPE_FIXED   = 0x0U,
N    GA_BUSERR_BURST_TYPE_INCR    = 0x1U
N} ga_buserr_bursttype;
N
N/* Burst Size */
Ntypedef enum tag_ga_buserr_burstsize
N{
N    GA_BUSERR_BURST_1BYTE     = 0x0U,
N    GA_BUSERR_BURST_2BYTE     = 0x1U,
N    GA_BUSERR_BURST_4BYTE     = 0x2U,
N    GA_BUSERR_BURST_81BYTE    = 0x3U,
N    GA_BUSERR_BURST_16BYTE    = 0x4U,
N    GA_BUSERR_BURST_32BYTE    = 0x5U,
N    GA_BUSERR_BURST_64BYTE    = 0x6U,
N    GA_BUSERR_BURST_128BYTE   = 0x7U
N} ga_buserr_burstsize;
N
N
N/* Response Type */
Ntypedef enum tag_ga_buserr_resptype
N{
N    GA_BUSERR_RESP_OK        = 0x0U,
N    GA_BUSERR_RESP_EXOKAY    = 0x1U,
N    GA_BUSERR_RESP_SLVERR    = 0x2U,
N    GA_BUSERR_RESP_DECERR    = 0x3U
N} ga_buserr_resptype;
N
N/* Memory Protection Region */
Ntypedef enum tag_ga_memory_region_e
N{
N    GA_MEMORY_PROT_REGION_0   = 0x0U,
N    GA_MEMORY_PROT_REGION_1   = 0x1U,
N    GA_MEMORY_PROT_REGION_MAX = 0x2U
N} ga_memory_region_e;
N
N/*======================================
N              Structures
N=======================================*/
N/* GA bus Error Control Signal-Structure */
Ntypedef struct tag_ga_bus_err_ctrl_st
N{
N    ga_buserr_dir_e      eDirection;       /* Read / Write direction */
N    ga_buserr_bursttype  eBurstType;       /* Burst type */
N    ga_buserr_burstsize  eBurstSize;       /* Burst size */
N    ga_buserr_resptype   eRespType;        /* Response Type */
N    uint8_t              u8ByteEnables;    /* Byte-enables for the erroneous transfer. */
N    uint8_t              u8ID;             /* ID tag of the read/write transaction that triggered an error response. */
N    uint8_t              u8BurstLength;    /* Burst length of the read/write transaction that triggered an error response */
N} ga_bus_err_ctrl_st;
N
N/*======================================
N      Exported Function Prototypes
N=======================================*/
N
N/****************************************************************************
N *
N * Function:      vGA_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8CommonRevision - pointer to common header revision string
N *                pau8CommonTag      - pointer to common header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                    uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                    uint8_t** pau8CommonRevision, uint8_t** pau8CommonTag,
N                    uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetMaxUsedBuffSize
N *
N * Purpose:       Resets the counter for used buffer of command list
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ResetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      u32Ga_GetMaxUsedBuffSize
N *
N * Purpose:       To get max. used size of command buffer. This API can be
N *                used to optimize the need size of "GA_CMD_MAX" in ga_list_st
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_GetLastCmdBuffStatus
N *
N * Purpose:       returns the information if there was enough space free for
N *                command over API
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: space status for command list
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_GetLastCmdBuffStatus(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetLastCmdSize
N *
N * Purpose:       returns the uesed buffer size for last API call (in case it
N *                was enough memory in buffer) or it returns needed size of buffer
N *                for last API call (if there was not enough memory in command buffer)
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: sized of used buffer
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetLastCmdSize(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_CheckList
N *
N * Purpose:       To check whether there is enough space in command buffer
N *                to wrote some doble words 
N *
N * Inputs:        pstCmdList  - pointer to command list
N *                u32NeededDW - needed double words 
N *
N * Outputs:       none
N *
N * Return Values: C_FAILED  requested number of commands will not fit into list
N *                C_SUCCESS requested number of commands will fit into list   
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_CheckList(ga_list_st* pstCmdList, uint32_t u32NeededDW);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetList
N *
N * Purpose:       Resets the Command List
N *
N * Inputs:        pstCmdList - Pointer to command list
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   The pointer to current list position will be reset, the
N *                content of the list will remain un-touched.
N *
N ***************************************************************************/
Nvoid vGA_ResetList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CloseList
N *
N * Purpose:       Closes the given list by inserting CSEND command
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CloseList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SyncList
N *
N * Purpose:       Inserts the VSYNC command in the command list in order to
N *                synchronize the execution of the list with vertical (VSYNC)
N *                signal from the GDC or Frame Grabber. When the command
N *                sceduler reaches this command it will stop the list
N *                execution until next VSYNC signal.
N *
N * Inputs:        eModul     - Modul selection to wait on (GDC/FG)
N *                pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SyncList(ga_modul_e eModule, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetUserInt
N *
N * Purpose:       defines Interrupt to CPU
N *
N * Inputs:        u8Number   - Interrupt number
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetUserInt(uint8_t u8Number, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_Enable
N *
N * Purpose:       Enables/Disables the Graphic Accelerator
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_Enable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ReadAheadEnable
N *
N * Purpose:       Enables/Disables ReadBuffer Read Ahead feature
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ReadAheadEnable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_Reset
N *
N * Purpose:       Resets the Graphic Accelerator
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS - Reset successful
N *                C_FAILED  - Reset timeout (Reset was not completted in
N *                            predefined time interval)
N *
N * Limitations:   The function will wait the reset to complete (it can take
N *                until recent bus cycle execution is finished)
N *
N ***************************************************************************/
Nint32_t i32GA_Reset(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetCmdListAddr
N *
N * Purpose:       Sets the physical address of the current command list
N *
N * Inputs:        u32Addr  - Physical address of the command list
N *                           (Must be 64-bit alligned -> uiAddr[2:0] = 0x0)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Make sure that when calling this function command scheduler
N *                is NOT executing a command list !!! Please note, that after
N *                the address is once written, the GA will automatically
N *                start the command list execution.
N *
N ***************************************************************************/
Nvoid vGA_SetCmdListAddr(uint32_t u32Addr);
N
N
N/****************************************************************************
N *
N * Function:      u8GA_GetStatus
N *
N * Purpose:       Reads the Graphic Accelerator Status register
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA Status Register (GASR) value
N *
N * Limitations:   The caller must parse returned status byte. For this
N *                purpose see the description of GASR Register.
N *
N ***************************************************************************/
Nuint8_t u8GA_GetStatus(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListFinished
N *
N * Purpose:       Indicates that the operation of a command list was finished or
N *                the GA was reset. This bit will be set to zero, when a new pointer
N *                is written.
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  command List Finished (ready to get new values)
N *                C_FALSE: command List is not Finished (not ready to get new values)
N *
N * Limitations: 
N *
N ***************************************************************************/
Nbool_t boGA_CmdListFinished(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListError
N *
N * Purpose:       This function shows if the Command Scheduler detects an invalid command
N *                or not. The Graphics Accelerator halts its operation and has to be reset
N *                if error is any detected. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  any Error detected by command list
N *                C_FALSE: no error detected
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdListError(void);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      boGA_CmdReg_IsBusy
N *
N * Purpose:       This function shows when any of the GA engines is currently operating.
N *                Then also the write access to many registers is prohibited.
N *                NOTE:
N *                  This function should be used from user by using direct comamnd 
N *                  registers instead of command list, before writing new commands. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  GA engine is busy.
N *                C_FALSE: GA engine is ready (not busy).
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdReg_IsBusy(void);
N#endif
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetIrqCause
N *
N * Purpose:       Reads the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA IRQ Cause value
N *
N * Limitations:   The calling function must parse returned IRQ cause byte.
N *                For this purpose see the GAICR register description.
N *                Please note that the funtion will automatically clear
N *                the interrupt source !!!
N *
N ***************************************************************************/
Nuint32_t u32GA_GetIrqCause(void);
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCause
N *
N * Purpose:       Clears the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        u32CauseMask: Mask to clear the bits ("1" in the mask means clear Bit)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCause(uint32_t u32CauseMask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetIrqMask
N *
N * Purpose:       Sets all GA Interrupt masks in one shot
N *
N * Inputs:        u32Mask - Interrupt Mask. For this purpose you may use defines:
N *                         GA_IRQ_MASK_CENDIM, GA_IRQ_MASK_CSCEIM, GA_IRQ_MASK_CSLEIM,
N *                         GA_IRQ_MASK_WBWIM, GA_IRQ_MASK_WBRIM, GA_IRQ_MASK_CBIM,
N *                         GA_IRQ_MASK_RBIM, GA_IRQ_MASK_CSLUIM   
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetIrqMask(uint32_t u32Mask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableUserIrq
N *
N * Purpose:       Enables/Disables interrupt to CPU
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *		  u8Number - interrupt line to be enabled/disabled
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableUserIrq(uint8_t u8Number, ga_en_e eEn);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_EnableIrqCmdEnd
N *
N * Purpose:       Enables/Disables GA Command End Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_EnableIrqCmdEnd(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_ClearIrqCmdEnd
N *
N * Purpose:       Clears GA Command End Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_ClearIrqCmdEnd(void);
N
N
N#endif
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSLEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command List
N *                Executed Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSLEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSLEI
N *
N * Purpose:       Clears Command Scheduler Command List Executed Interrupt. 
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSLEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSCEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command Error IRQ
N *                Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSCEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSCEI
N *
N * Purpose:       Clears GA Command Scheduler Command Error IRQ
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSCEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetGADelay
N *
N * Purpose:       Sets the minimum delay in System Clock cycles between two
N *                consecutive memory accesses performed by any Graphics 
N *                Accelerator engine
N *
N * Inputs:        u16Delay: Delay Value (0x0000 .. 0xFFFF)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetGADelay(uint16_t u16Delay);
N
N
N/****************************************************************************/
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBWI
N *
N * Purpose:       Enables/Disables GA Write Buffer Write Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBWI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBWI
N *
N * Purpose:       Clears GA Write Buffer Write Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBWI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBRI
N *
N * Purpose:       Enables/Disables GA Write Buffer Read Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBRI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBRI
N *
N * Purpose:       Clears GA Write Buffer Read Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBRI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGACBIM
N *
N * Purpose:       Enables/Disables GA Cache Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGACBI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGACBI
N *
N * Purpose:       Clears GA Cache Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGACBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGARBI
N *
N * Purpose:       Enables/Disables GA Read Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGARBI(ga_en_e eEn);
N
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGARBI
N *
N * Purpose:       Clears GA Read Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGARBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearUserIrq
N *
N * Purpose:       Clears GA Command List User Interrupt 0 - 23
N *
N * Inputs:        u8CmdListIntr: No. of Interruot (0..23) to be cleared
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearUserIrq(uint8_t u8CmdListIntr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrAddr
N *
N * Purpose:       Returns the address after bus error on GA 
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       pu32BusErrAddr: Pointer to bus error address
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: NULL pointer
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrAddr(ga_bus_type_e eBusType, uint32_t* pu32BusErrAddr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrCtrlStatus
N *
N * Purpose:       Returns the triggering access’s control status after bus error on GA
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       control status structure
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrCtrlStatus(ga_bus_type_e eBusType, ga_bus_err_ctrl_st* pstCtrlStatus);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetMemoryProtRegionAddr
N *
N * Purpose:       Defines the lower and upper address of the memory region
N *                0 or 1 (primary, secondary) GA is allowed to perform write accesses.
N *                Write accesses outside the memory regions are discarded.
N *                NOTE:
N *                   The memory regions are defined with a granularity of 4Kbyte.
N *
N * Inputs:        eRegion  Related Region (0/1)
N *                u32LowAddress: Lower protected address
N *                u32HighAddress: Higher protected address
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_SetMemoryProtRegionAddr(ga_memory_region_e eRegion, uint32_t u32LowAddress, uint32_t u32HighAddress);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecConfigIrq
N *
N * Purpose:       Enables/Disables interrupt, set if a non-privileged access 
N *                tries to write to GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR,
N *                or GAMPIMR.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecConfigIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecAccessIrq
N *
N * Purpose:       Enables/Disables interrupt, set if GA tries to write to 
N *                memory outside the address range defined by GAMR0L-GAMR0H 
N *                and GAMR1L-GAMR1H.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecAccessIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecConfigIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to have a non-privileged access 
N *                tries to write to protection control registers
N *                (GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR, or GAMPIMR)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecConfigIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecAccessIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to write to memory 
N *                outside the address range defined by GAMR0L-GAMR0H and GAMR1L-GAMR1H
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecAccessIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetMemoryProtecErr_CaptAddr
N *
N * Purpose:       Get the address of the first write access performed by the 
N *                Write Buffer’s write interface that caused a memory protection
N *                violation. The register is automatically set by the Graphics 
N *                Accelerator in case of a protection violation, it is reset to
N *                zero automatically if the corresponding interrupt bit GAMPI is
N *                cleared in the Graphics Accelerator Interrupt Cause Register (GAMPICR).
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: Address caused portection error
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMemoryProtecErr_CaptAddr(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetGeneralPurposeRegister
N *
N * Purpose:       Set one of 32 Purpose Registers of GA, which are used to define  
N *                the required parameters for the triggered engine.
N *                Read access is possible all the time, write access is only allowed
N *                if no engine is currently operating (GASR.BUSY=0). Nevertheless, 
N *                it is recommended to configure these registers using Command Lists.
N *
N * Inputs:        u8RegNo      No. of Register (0..31)
N *                u32RegValue: Register value to be written
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo or GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t u32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetGeneralPurposeRegister
N *
N * Purpose:       Get content of one of 32 Purpose Registers of GA, which are used   
N *                to define the required parameters for the triggered engine.
N *
N * Inputs:        u8RegNo       No. of Register (0..31)
N *                pu32RegValue: Pointer to Register value to be read
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo NULL pointer 
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_GetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t* pu32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetCommandRegisterLowHigh
N *
N * Purpose:       Set command register directly (as alternative to command List).
N *                For this mode, user should take care that GA should be ready 
N *                (not busy) before writng in registers. 
N *
N * Inputs:        u32LowValue:  Lower 32 bits of 64 bits command (0..31)
N *                u32HighValue: Higher 32 bits of 64 bits command (32..63)
N *                NOTE:
N *                  1) API should write first Lowe Part and then higher Part. 
N *                    By writing of higehr word thorugh API GA will be trigegred 
N *                    to execute command if it was not busy before.
N *                  2) Related general purpose registers for command should be
N *                     written before, 
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetCommandRegisterLowHigh (uint32_t u32LowValue,  uint32_t u32HighValue);
N
N
N#endif /* _EXTENDED_GA_APIS_DISABLED_ */
N
N#endif /* GA_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 25 "..\..\..\..\lldd\src\transf.c" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1858  /* Rule 17.4 [R] : subscript operator may only be applied to objects declared as an array type */
S  #pragma ghs nowarning 1865  /* Rule 10.1 [R] : conversion from underlying type, "int", to same width underlying type, "uint32_t", not allowed */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to underlying type, "type", changes signedness */
S  #pragma ghs nowarning 1878  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to wider type "type" not allowed */
S  #pragma ghs nowarning 1879  /* Rule 10.3 [R] : Restrict explicit casts for integer type expressions */
S
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */  
S  #pragma ghs nowarning 1737  /* Rule 12.1 [A] :  expression may not depend on operator precedence rules */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S
N#endif
N/*======================================
N    Stat. Var and Func. Prototypes
N=======================================*/
N
N
N/*======================================
N    Glob. Var and Func. Prototypes
N=======================================*/
N
N/*======================================
N                Macros
N=======================================*/
N
N#define LLDD_GA_TRANSF_C_REVISION     "$Revision: 1.13 $"
N#define LLDD_GA_TRANSF_C_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*======================================
N Static variables and forward declarations
N=======================================*/
N
Nstatic uint8_t au8LLDD_GA_TRANSF_C_REVISION[] = LLDD_GA_TRANSF_C_REVISION;
Xstatic uint8_t au8LLDD_GA_TRANSF_C_REVISION[] = "$Revision: 1.13 $";
Nstatic uint8_t au8LLDD_GA_TRANSF_C_TAG[]      = LLDD_GA_TRANSF_C_TAG;
Xstatic uint8_t au8LLDD_GA_TRANSF_C_TAG[]      = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GA_TRANSF_H_REVISION[] = LLDD_GA_TRANSF_H_REVISION;
Xstatic uint8_t au8LLDD_GA_TRANSF_H_REVISION[] = "$Revision: 1.15 $";
Nstatic uint8_t au8LLDD_GA_TRANSF_H_TAG[]      = LLDD_GA_TRANSF_H_TAG;
Xstatic uint8_t au8LLDD_GA_TRANSF_H_TAG[]      = "$Name: LLDD_1_7_GFX $";
N
N/*======================================
N          Function definitions
N=======================================*/
N
Nvoid vTransf_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                        uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag)
N{
N     *pau8ModuleRevision = &au8LLDD_GA_TRANSF_C_REVISION[0];
N     *pau8ModuleTag      = &au8LLDD_GA_TRANSF_C_TAG[0];
N     *pau8HeaderRevision = &au8LLDD_GA_TRANSF_H_REVISION[0];
N     *pau8HeaderTag      = &au8LLDD_GA_TRANSF_H_TAG[0];
N}
N
N/* ....................................................................... */
Nvoid vTransf_SetMemSrc(uint32_t u32Addr, uint32_t u32Width, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 2;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    pu64Curr[0] = TSF_LOAD_SRCWIDTH(u32Width);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((u32Width))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = TSF_LOAD_SOURCEADDR(u32Addr);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((u32Addr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[2];
N    
N    pstCmdList->u32UsedDoubleWords = 2U;
N
N}
N
N/* ....................................................................... */
Nvoid vTransf_SetDstImgSize(uint32_t u32Width, uint32_t u32Lines,
N                          ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 2;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    pu64Curr[0] = TSF_LOAD_DEST_IMAGEWIDTH(u32Width);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((u32Width)& 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = TSF_LOAD_DESTLINECNT(u32Lines);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((u32Lines) & 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[2];
N    pstCmdList->u32UsedDoubleWords = 2U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_SetMemDest(uint32_t u32Addr, uint32_t u32Width, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 2U;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = TSF_LOAD_DESTWIDTH(u32Width);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)(((u32Width))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = TSF_LOAD_DESTADDR(u32Addr);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((u32Addr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[2];
N    pstCmdList->u32UsedDoubleWords = 2U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_ConfigLUT(transf_Lut_st* pstCfg, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW = 3;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = TSF_LOAD_LUTADDR(pstCfg->u32Addr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)(((pstCfg->u32Addr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = TSF_LOAD_LUTWIDTH(pstCfg->u16Width);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstCfg->u16Width)& 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[2] = TSF_LOAD_LUTLINECNT(pstCfg->u16LineCnt);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstCfg->u16LineCnt) & 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[3];
N    pstCmdList->u32UsedDoubleWords = 3U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_SetColorFmt(ga_colFmt_e eSrcColFormat, ga_colFmt_e eDstColFormat, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    /* Color format for Rotation should be redefined to fit to HW implemenation:
N     *  modify color format 0-->1 and 1-->0 
N     *  */
N    pu64Curr[0] = TSF_LOAD_COLORFMT((1 - (uint8_t) eDstColFormat), (1 - (uint8_t) eSrcColFormat));
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((((uint64_t)(((1 - (uint8_t) eDstColFormat))) & (0x1u)) << (1)) | (((uint64_t)(((1 - (uint8_t) eSrcColFormat))) & (0x1u)) << (0))))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N    pstCmdList->u32UsedDoubleWords = 1U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_SetPredefColor(uint32_t u32Color, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1U;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = TSF_LOAD_PRECOLOR(u32Color);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((17)) & (0x1fu)) << (32)) | (((uint64_t)(((u32Color))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N    pstCmdList->u32UsedDoubleWords = 1U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_SetTransfCmd(transf_Mode_e eOpMode, ga_en_e eFilterEn,
N                         ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S    uint32_t u32NeededDW  = 1;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = TSF_TRANSF(eOpMode,eFilterEn);
X    pu64Curr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x4u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x01u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((eOpMode)) & (0x1u)) << (1)) | (((uint64_t)((eFilterEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N    pstCmdList->u32UsedDoubleWords = 1U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_ConfigTransfOp(transf_mem_st* pstMem, transf_Lut_st* pstLutCfg,
N                            transf_Prm_st* pstTsfPrm, ga_list_st* pstCmdList)
N
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S    uint32_t u32NeededDW = 14U;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    /* Source Mem. */
N    pu64Curr[0] = TSF_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u16SrcWidth))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = TSF_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Dest Mem. */
N    pu64Curr[2] = TSF_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u16DstWidth))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = TSF_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Image Size */
N    pu64Curr[4] = TSF_LOAD_DEST_IMAGEWIDTH(pstMem->u16DstImgWidth);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstImgWidth)& 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[5] = TSF_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* LUT Params */
N    pu64Curr[6] = TSF_LOAD_LUTADDR(pstLutCfg->u32Addr);
X    pu64Curr[6] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)(((pstLutCfg->u32Addr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[7] = TSF_LOAD_LUTWIDTH(pstLutCfg->u16Width);
X    pu64Curr[7] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstLutCfg->u16Width)& 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[8] = TSF_LOAD_LUTLINECNT(pstLutCfg->u16LineCnt);
X    pu64Curr[8] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstLutCfg->u16LineCnt) & 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Color Params */
N    /* Color format for Rotation should be redefined to fit to HW implemenation:
N     *  modify color format 0-->1 and 1-->0 
N     *  */
N    pu64Curr[9]  = TSF_LOAD_COLORFMT((1 - (uint8_t)(pstTsfPrm->eDstColFmt)), (1 - (uint8_t)(pstTsfPrm->eSrcColFmt)));
X    pu64Curr[9]  = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((((uint64_t)(((1 - (uint8_t)(pstTsfPrm->eDstColFmt)))) & (0x1u)) << (1)) | (((uint64_t)(((1 - (uint8_t)(pstTsfPrm->eSrcColFmt)))) & (0x1u)) << (0))))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[10] = TSF_LOAD_PRECOLOR(pstTsfPrm->u32Color);
X    pu64Curr[10] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((17)) & (0x1fu)) << (32)) | (((uint64_t)(((pstTsfPrm->u32Color))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* alpha values */
N    pu64Curr[11] = TSF_LOAD_SRCALPHA(pstTsfPrm->u8SrcAlphaVal);
X    pu64Curr[11] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((27)) & (0x1fu)) << (32)) | (((uint64_t)((((pstTsfPrm->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[12] = TSF_LOAD_DESTALPHA(pstTsfPrm->u8DstAlphaVal);
X    pu64Curr[12] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((28)) & (0x1fu)) << (32)) | (((uint64_t)((((pstTsfPrm->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* transformation */
N    pu64Curr[13] = TSF_TRANSF(pstTsfPrm->eTsfMode, pstTsfPrm->eFilterEn);
X    pu64Curr[13] = (((uint64_t)0x0ull | ((((uint64_t)(((0x4u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x01u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstTsfPrm->eTsfMode)) & (0x1u)) << (1)) | (((uint64_t)((pstTsfPrm->eFilterEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N
N    pstCmdList->pu64Current = &pu64Curr[14];
N    
N    pstCmdList->u32UsedDoubleWords = 14U;
N}
N
N/* ....................................................................... */
Nvoid vTransf_ConfigTransfBlendOp(transf_mem_st* pstMem, transf_Lut_st* pstLutCfg,
N                                 transf_PrmBlend_st* pstTsfPrm, ga_list_st* pstCmdList)
N
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S    uint32_t u32NeededDW = 15U;
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N    /* Source Mem. */
N    pu64Curr[0] = TSF_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u16SrcWidth))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = TSF_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Dest Mem. */
N    pu64Curr[2] = TSF_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u16DstWidth))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = TSF_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Image Size */
N    pu64Curr[4] = TSF_LOAD_DEST_IMAGEWIDTH(pstMem->u16DstImgWidth);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstImgWidth)& 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[5] = TSF_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* LUT Params */
N    pu64Curr[6] = TSF_LOAD_LUTADDR(pstLutCfg->u32Addr);
X    pu64Curr[6] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)(((pstLutCfg->u32Addr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[7] = TSF_LOAD_LUTWIDTH(pstLutCfg->u16Width);
X    pu64Curr[7] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstLutCfg->u16Width)& 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[8] = TSF_LOAD_LUTLINECNT(pstLutCfg->u16LineCnt);
X    pu64Curr[8] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstLutCfg->u16LineCnt) & 0x3ffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Color Params */
N    /* Color format for Rotation should be redefined to fit to HW implemenation:
N     *  modify color format 0-->1 and 1-->0 
N     *  */
N    pu64Curr[9]  = TSF_LOAD_COLORFMT((1 - (uint8_t)(pstTsfPrm->eDstColFmt)), (1 - (uint8_t)(pstTsfPrm->eSrcColFmt)));
X    pu64Curr[9]  = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((((uint64_t)(((1 - (uint8_t)(pstTsfPrm->eDstColFmt)))) & (0x1u)) << (1)) | (((uint64_t)(((1 - (uint8_t)(pstTsfPrm->eSrcColFmt)))) & (0x1u)) << (0))))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[10] = TSF_LOAD_PRECOLOR(pstTsfPrm->u32Color);
X    pu64Curr[10] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((17)) & (0x1fu)) << (32)) | (((uint64_t)(((pstTsfPrm->u32Color))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Fading factor values */
N    pu64Curr[11] = TSF_LOAD_SRCFADEFACT(pstTsfPrm->u8FadingFctr);
X    pu64Curr[11] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((26)) & (0x1fu)) << (32)) | (((uint64_t)((((pstTsfPrm->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* alpha values */
N    pu64Curr[12] = TSF_LOAD_SRCALPHA(pstTsfPrm->u8SrcAlphaVal);
X    pu64Curr[12] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((27)) & (0x1fu)) << (32)) | (((uint64_t)((((pstTsfPrm->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[13] = TSF_LOAD_DESTALPHA(pstTsfPrm->u8DstAlphaVal);    
X    pu64Curr[13] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((28)) & (0x1fu)) << (32)) | (((uint64_t)((((pstTsfPrm->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));    
N
N    /* transformation with blend */
N    pu64Curr[14] = TSF_TRANSFB(pstTsfPrm->eTsfMode,
N                               pstTsfPrm->eDstRedProt,
N                               pstTsfPrm->eDstGreenProt,
N                               pstTsfPrm->eDstBlueProt,
N                               pstTsfPrm->eDstAlphaProt,
N                               pstTsfPrm->eSrcRedFad,
N                               pstTsfPrm->eSrcGreenFad,
N                               pstTsfPrm->eSrcBlueFad,
N                               pstTsfPrm->eSrcAlphaFad,
N                               pstTsfPrm->eBldOrd,
N                               pstTsfPrm->eFilterEn);
X    pu64Curr[14] = (((uint64_t)0x0ull | ((((uint64_t)(((0x4u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x00u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstTsfPrm->eDstRedProt)) & (0x1u)) << (15)) | (((uint64_t)((pstTsfPrm->eDstGreenProt)) & (0x1u)) << (14)) | (((uint64_t)((pstTsfPrm->eDstBlueProt)) & (0x1u)) << (13)) | (((uint64_t)((pstTsfPrm->eDstAlphaProt)) & (0x1u)) << (12)) | (((uint64_t)((pstTsfPrm->eSrcRedFad)) & (0x1u)) << (11)) | (((uint64_t)((pstTsfPrm->eSrcGreenFad)) & (0x1u)) << (10)) | (((uint64_t)((pstTsfPrm->eSrcBlueFad)) & (0x1u)) << (9)) | (((uint64_t)((pstTsfPrm->eSrcAlphaFad)) & (0x1u)) << (8)) | (((uint64_t)((pstTsfPrm->eBldOrd)) & (0x3u)) << (3)) | (((uint64_t)((pstTsfPrm->eTsfMode)) & (0x1u)) << (1)) | (((uint64_t)((pstTsfPrm->eFilterEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N
N    pstCmdList->pu64Current = &pu64Curr[15];
N    pstCmdList->u32UsedDoubleWords = 15;
N}
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N/****************************************************************************/
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: transf.c
N**  $Revision: 1.13 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1858 /17.4  - subscript operator may only be applied to objects 
N** |                        declared as an array type
N** | CONS.  : allow
N** | REASON : to handle array of data by usage of pointer 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1865 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to same width underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1866 /10.1  -  implicit conversion from underlying type, "type",  
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1878 /10.3  -   cast of complex integer expression with underlying 
N** |                          type "type" to wider type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as variables in io 
N** |          header file or to allow shift operation
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1879 /10.3  - 	 cast of complex integer expression with underlying
N** |                           type "type" to same width type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as macros in io header file
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices,” or
N  “TOSHIBA Semiconductor Reliability Handbook” etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage”).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCALIMER ****************************/
N
