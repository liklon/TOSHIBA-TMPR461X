L 1 "..\..\..\..\lldd\src\smc.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Stepper motor controler low level driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : 
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.13 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "smc_io.h"                   /* stepper_motor registers, bits and access macros defintion */
L 1 "..\..\..\..\lldd\hdr\smc_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : SMC 
N/  Date of creation (y-m-d:time): 2015-02-17+01:00  :  15:15:33.694+01:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision_: 1.14 $ 
N/  Excel Sheet ver.             : vv2.1
N/  Excel Sheet date             : 2014-Sep-17
N/  Excel Sheet author           : ZUL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : SMC low level driver io-header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : SMC
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.10 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef SMCIO_H
N#define SMCIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */ 
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 40 "..\..\..\..\lldd\hdr\smc_io.h" 2
N
N/* disable following Misra errors for io files */
N#if defined(__GHS__) || defined(__ghs__)  
X#if 0L || 0L  
S  #pragma ghs nowarning 230   /* Rule 6.4  [R] : Bitfields can only have `unsigned int' or `signed int' types */
N#endif
N
N     
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_SMC_IO_H_REVISION     "$Revision: 1.10 $"
N#define LLDD_SMC_IO_H_TAG          "$Name: LLDD_1_6 $"
N     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCCLK_CTRL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300000                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCCLK_CTRL_REG__       0xC0300000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   PRE_SCALE	:4; 	 /* 0..3  bit(s) R/W */ 
N  uint8_t   	:4; 	 /* 4..31  bit(s) R */                    
N} SMCCLK_CTRL_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8SMCCLK_CTRL_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCCLK_CTRL()     ((volatile SMCCLK_CTRL_bit_view_st *)\
N(SMCCLK_CTRL_REG__ ))
X#define pst_bitSMCCLK_CTRL()     ((volatile SMCCLK_CTRL_bit_view_st *)(SMCCLK_CTRL_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8SMCCLK_CTRL()     ((volatile u8SMCCLK_CTRL_byte_view *)\
N(SMCCLK_CTRL_REG__ ))
X#define pu8SMCCLK_CTRL()     ((volatile u8SMCCLK_CTRL_byte_view *)(SMCCLK_CTRL_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCCLK_CTRL_PRE_SCALE() (pst_bitSMCCLK_CTRL() -> PRE_SCALE)
N#define vSetSMCCLK_CTRL_PRE_SCALE(ParValue)  (pst_bitSMCCLK_CTRL() -> PRE_SCALE=(ParValue))
N            
N/* byte access */
N#define vSetSMCCLK_CTRL(ParValue) (*pu8SMCCLK_CTRL() = (ParValue))
N#define u8GetSMCCLK_CTRL() (*pu8SMCCLK_CTRL() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCINT                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300004                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCINT_REG__       0xC0300004U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PPE	:5; 	 /* 0..4  bit(s) R/W1C */
N  uint32_t   	:3; 	 /* 5..7  bit(s) R */
N  uint32_t   MOV_END	:5; 	 /* 8..12  bit(s) R/W1C */
N  uint32_t   	:3; 	 /* 13..15  bit(s) R */
N  uint32_t   ZPDD	:5; 	 /* 16..20  bit(s) R/W1C */
N  uint32_t   	:3; 	 /* 21..23  bit(s) R */
N  uint32_t   CRAUM	:1; 	 /* 24..24  bit(s) R/W1C */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCINT_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCINT_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCINT_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCINT_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCINT()     ((volatile SMCINT_bit_view_st *)\
N(SMCINT_REG__ ))
X#define pst_bitSMCINT()     ((volatile SMCINT_bit_view_st *)(SMCINT_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCINT()     ((volatile SMCINT_byte_view_st *)\
N(SMCINT_REG__ ))
X#define pst_u8SMCINT()     ((volatile SMCINT_byte_view_st *)(SMCINT_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCINT()     ((volatile SMCINT_halfword_view_st *)\
N(SMCINT_REG__ ))
X#define pst_u16SMCINT()     ((volatile SMCINT_halfword_view_st *)(SMCINT_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCINT()     ((volatile u32SMCINT_word_view *)\
N(SMCINT_REG__ ))
X#define pu32SMCINT()     ((volatile u32SMCINT_word_view *)(SMCINT_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCINT_PPE() (pst_bitSMCINT() -> PPE)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..4 for STM 0 to 4: */
N#define vClrSMCINT_PPE(BitNo) (pst_bitSMCINT() -> PPE = ( (0x01U << (BitNo)) & 0x1FU) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple bits 0..4 for STM 0 to 4: */
N#define vClrMultiSMCINT_PPE(Mask) (pst_bitSMCINT() -> PPE = ((Mask) & 0x1FU))
N/*---------------------------------------------------------------------------*/
N
N#define biGetSMCINT_MOV_END() (pst_bitSMCINT() -> MOV_END)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..4 for STM 0 to 4: */
N#define vClrSMCINT_MOV_END(BitNo) (pst_bitSMCINT() -> MOV_END = ( (0x01U << (BitNo)) & 0x1FU) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple bits 0..4 for STM 0 to 4: */
N#define vClrMultiSMCINT_MOV_END(BitNo) (pst_bitSMCINT() -> MOV_END = ((Mask) & 0x1FU))
N/*---------------------------------------------------------------------------*/
N
N#define biGetSMCINT_ZPDD() (pst_bitSMCINT() -> ZPDD)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..4 for STM 0 to 4: */
N#define vClrSMCINT_ZPDD(BitNo) (pst_bitSMCINT() -> ZPDD =( (0x01U << (BitNo)) & 0x1FU) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple bits 0..4 for STM 0 to 4: */
N#define vClrMultiSMCINT_ZPDD(BitNo) (pst_bitSMCINT() -> ZPDD = ((Mask) & 0x1FU))
N/*---------------------------------------------------------------------------*/
N
N#define biGetSMCINT_CRAUM() (pst_bitSMCINT() -> CRAUM)
N#define vClrSMCINT_CRAUM() (pst_bitSMCINT() -> CRAUM = (0x1U))
N            
N/* LL-struct byte access */
N#define vSetSMCINTLL(ParValue) (pst_u8SMCINT() -> u8LL = (ParValue))
N#define u8GetSMCINTLL() (pst_u8SMCINT() -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCINTLH(ParValue) (pst_u8SMCINT() -> u8LH = (ParValue))
N#define u8GetSMCINTLH() (pst_u8SMCINT() -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCINTHL(ParValue) (pst_u8SMCINT() -> u8HL = (ParValue))
N#define u8GetSMCINTHL() (pst_u8SMCINT() -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCINTHH(ParValue) (pst_u8SMCINT() -> u8HH = (ParValue))
N#define u8GetSMCINTHH() (pst_u8SMCINT() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCINTL(ParValue) (pst_u16SMCINT() -> u16L = (ParValue))
N#define u16GetSMCINTL() (pst_u16SMCINT() -> u16L)
N#define vSetSMCINTH(ParValue) (pst_u16SMCINT() -> u16H = (ParValue))
N#define u16GetSMCINTH() (pst_u16SMCINT() -> u16H)
N            
N/* Word access */
N#define vSetSMCINT(ParValue)  (*pu32SMCINT() = (ParValue))
N#define u32GetSMCINT()  (*pu32SMCINT() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCINT_MASK                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300008                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCINT_MASK_REG__       0xC0300008U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MASK_PPE	:5; 	 /* 0..4  bit(s) R/W */
N  uint32_t   	:3; 	 /* 5..7  bit(s) R */
N  uint32_t   MASK_MOV_END	:5; 	 /* 8..12  bit(s) R/W */
N  uint32_t   	:3; 	 /* 13..15  bit(s) R */
N  uint32_t   MASK_ZPDD	:5; 	 /* 16..20  bit(s) R/W */
N  uint32_t   	:3; 	 /* 21..23  bit(s) R */
N  uint32_t   MASK_CRAUM	:1; 	 /* 24..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCINT_MASK_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCINT_MASK_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCINT_MASK_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCINT_MASK_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCINT_MASK()     ((volatile SMCINT_MASK_bit_view_st *)\
N(SMCINT_MASK_REG__ ))
X#define pst_bitSMCINT_MASK()     ((volatile SMCINT_MASK_bit_view_st *)(SMCINT_MASK_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCINT_MASK()     ((volatile SMCINT_MASK_byte_view_st *)\
N(SMCINT_MASK_REG__ ))
X#define pst_u8SMCINT_MASK()     ((volatile SMCINT_MASK_byte_view_st *)(SMCINT_MASK_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCINT_MASK()     ((volatile SMCINT_MASK_halfword_view_st *)\
N(SMCINT_MASK_REG__ ))
X#define pst_u16SMCINT_MASK()     ((volatile SMCINT_MASK_halfword_view_st *)(SMCINT_MASK_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCINT_MASK()     ((volatile u32SMCINT_MASK_word_view *)\
N(SMCINT_MASK_REG__ ))
X#define pu32SMCINT_MASK()     ((volatile u32SMCINT_MASK_word_view *)(SMCINT_MASK_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCINT_MASK_MASK_PPE() (pst_bitSMCINT_MASK() -> MASK_PPE)
N#define vSetSMCINT_MASK_MASK_PPE(ParValue)  (pst_bitSMCINT_MASK() -> MASK_PPE=(ParValue))
N#define biGetSMCINT_MASK_MASK_MOV_END() (pst_bitSMCINT_MASK() -> MASK_MOV_END)
N#define vSetSMCINT_MASK_MASK_MOV_END(ParValue)  (pst_bitSMCINT_MASK() -> MASK_MOV_END=(ParValue))
N#define biGetSMCINT_MASK_MASK_ZPDD() (pst_bitSMCINT_MASK() -> MASK_ZPDD)
N#define vSetSMCINT_MASK_MASK_ZPDD(ParValue)  (pst_bitSMCINT_MASK() -> MASK_ZPDD=(ParValue))
N#define biGetSMCINT_MASK_MASK_CRAUM() (pst_bitSMCINT_MASK() -> MASK_CRAUM)
N#define vSetSMCINT_MASK_MASK_CRAUM(ParValue)  (pst_bitSMCINT_MASK() -> MASK_CRAUM=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCINT_MASKLL(ParValue) (pst_u8SMCINT_MASK() -> u8LL = (ParValue))
N#define u8GetSMCINT_MASKLL() (pst_u8SMCINT_MASK() -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCINT_MASKLH(ParValue) (pst_u8SMCINT_MASK() -> u8LH = (ParValue))
N#define u8GetSMCINT_MASKLH() (pst_u8SMCINT_MASK() -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCINT_MASKHL(ParValue) (pst_u8SMCINT_MASK() -> u8HL = (ParValue))
N#define u8GetSMCINT_MASKHL() (pst_u8SMCINT_MASK() -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCINT_MASKHH(ParValue) (pst_u8SMCINT_MASK() -> u8HH = (ParValue))
N#define u8GetSMCINT_MASKHH() (pst_u8SMCINT_MASK() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCINT_MASKL(ParValue) (pst_u16SMCINT_MASK() -> u16L = (ParValue))
N#define u16GetSMCINT_MASKL() (pst_u16SMCINT_MASK() -> u16L)
N#define vSetSMCINT_MASKH(ParValue) (pst_u16SMCINT_MASK() -> u16H = (ParValue))
N#define u16GetSMCINT_MASKH() (pst_u16SMCINT_MASK() -> u16H)
N            
N/* Word access */
N#define vSetSMCINT_MASK(ParValue)  (*pu32SMCINT_MASK() = (ParValue))
N#define u32GetSMCINT_MASK()  (*pu32SMCINT_MASK() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCCTRL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC030000C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCCTRL_REG__       0xC030000CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MSEL	:2; 	 /* 0..1  bit(s) R/W */
N  uint32_t   OUTEN	:1; 	 /* 2..2  bit(s) R/W */
N  uint32_t   DELAY_CYCLES	:5; 	 /* 3..7  bit(s) R/W */
N  uint32_t   PERIOD_EXT	:7; 	 /* 8..14  bit(s) R/W */
N  uint32_t   	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   SLEW_RATE	:3; 	 /* 16..18  bit(s) R/W */ 
N  uint32_t   	:13; 	 /* 19..31  bit(s) R */                    
N} SMCCTRL_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCCTRL_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCCTRL_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCCTRL_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCCTRL(ch)     ((volatile SMCCTRL_bit_view_st *)\
N(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCCTRL(ch)     ((volatile SMCCTRL_bit_view_st *)(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCCTRL(ch)     ((volatile SMCCTRL_byte_view_st *)\
N(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCCTRL(ch)     ((volatile SMCCTRL_byte_view_st *)(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCCTRL(ch)     ((volatile SMCCTRL_halfword_view_st *)\
N(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCCTRL(ch)     ((volatile SMCCTRL_halfword_view_st *)(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCCTRL(ch)     ((volatile u32SMCCTRL_word_view *)\
N(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCCTRL(ch)     ((volatile u32SMCCTRL_word_view *)(SMCCTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCCTRL_MSEL(ch) (pst_bitSMCCTRL(ch) -> MSEL)
N#define vSetSMCCTRL_MSEL(ch,ParValue)  (pst_bitSMCCTRL(ch) -> MSEL=(ParValue))
N#define biGetSMCCTRL_OUTEN(ch) (pst_bitSMCCTRL(ch) -> OUTEN)
N#define vSetSMCCTRL_OUTEN(ch,ParValue)  (pst_bitSMCCTRL(ch) -> OUTEN=(ParValue))
N#define biGetSMCCTRL_DELAY_CYCLES(ch) (pst_bitSMCCTRL(ch) -> DELAY_CYCLES)
N#define vSetSMCCTRL_DELAY_CYCLES(ch,ParValue)  (pst_bitSMCCTRL(ch) -> DELAY_CYCLES=(ParValue))
N#define biGetSMCCTRL_PERIOD_EXT(ch) (pst_bitSMCCTRL(ch) -> PERIOD_EXT)
N#define vSetSMCCTRL_PERIOD_EXT(ch,ParValue)  (pst_bitSMCCTRL(ch) -> PERIOD_EXT=(ParValue))
N#define biGetSMCCTRL_SLEW_RATE(ch) (pst_bitSMCCTRL(ch) -> SLEW_RATE)
N#define vSetSMCCTRL_SLEW_RATE(ch,ParValue)  (pst_bitSMCCTRL(ch) -> SLEW_RATE=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCCTRLLL(ch,ParValue) (pst_u8SMCCTRL(ch) -> u8LL = (ParValue))
N#define u8GetSMCCTRLLL(ch) (pst_u8SMCCTRL(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCCTRLLH(ch,ParValue) (pst_u8SMCCTRL(ch) -> u8LH = (ParValue))
N#define u8GetSMCCTRLLH(ch) (pst_u8SMCCTRL(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCCTRLHL(ch,ParValue) (pst_u8SMCCTRL(ch) -> u8HL = (ParValue))
N#define u8GetSMCCTRLHL(ch) (pst_u8SMCCTRL(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCCTRLHH(ch,ParValue) (pst_u8SMCCTRL(ch) -> u8HH = (ParValue))
N#define u8GetSMCCTRLHH(ch) (pst_u8SMCCTRL(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCCTRLL(ch,ParValue) (pst_u16SMCCTRL(ch) -> u16L = (ParValue))
N#define u16GetSMCCTRLL(ch) (pst_u16SMCCTRL(ch) -> u16L)
N#define vSetSMCCTRLH(ch,ParValue) (pst_u16SMCCTRL(ch) -> u16H = (ParValue))
N#define u16GetSMCCTRLH(ch) (pst_u16SMCCTRL(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCCTRL(ch,ParValue)  (*pu32SMCCTRL(ch) = (ParValue))
N#define u32GetSMCCTRL(ch)  (*pu32SMCCTRL(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCISM_CTRL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300020                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCISM_CTRL_REG__       0xC0300020U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DAMP_K	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   	:5; 	 /* 3..7  bit(s) R */
N  uint32_t   DAMP_L	:3; 	 /* 8..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   ISM_TABLE_MODE	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   TABLE_IDX	:1; 	 /* 17..17  bit(s) R/W */
N  uint32_t   DIS_DAMP	:1; 	 /* 18..18  bit(s) R/W */
N  uint32_t   	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   RD_REQ	:1; 	 /* 20..20  bit(s) R/W */
N  uint32_t   RD_FLAG	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   	:2; 	 /* 22..23  bit(s) R */
N  uint32_t   FREEZE_REQ	:1; 	 /* 24..24  bit(s) R/W */
N  uint32_t   FREEZE_FLAG	:1; 	 /* 25..25  bit(s) R */ 
N  uint32_t   	:6; 	 /* 26..31  bit(s) R */                    
N} SMCISM_CTRL_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCISM_CTRL_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCISM_CTRL_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCISM_CTRL_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCISM_CTRL(ch)     ((volatile SMCISM_CTRL_bit_view_st *)\
N(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCISM_CTRL(ch)     ((volatile SMCISM_CTRL_bit_view_st *)(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCISM_CTRL(ch)     ((volatile SMCISM_CTRL_byte_view_st *)\
N(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCISM_CTRL(ch)     ((volatile SMCISM_CTRL_byte_view_st *)(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCISM_CTRL(ch)     ((volatile SMCISM_CTRL_halfword_view_st *)\
N(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCISM_CTRL(ch)     ((volatile SMCISM_CTRL_halfword_view_st *)(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCISM_CTRL(ch)     ((volatile u32SMCISM_CTRL_word_view *)\
N(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCISM_CTRL(ch)     ((volatile u32SMCISM_CTRL_word_view *)(SMCISM_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCISM_CTRL_DAMP_K(ch) (pst_bitSMCISM_CTRL(ch) -> DAMP_K)
N#define vSetSMCISM_CTRL_DAMP_K(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> DAMP_K=(ParValue))
N#define biGetSMCISM_CTRL_DAMP_L(ch) (pst_bitSMCISM_CTRL(ch) -> DAMP_L)
N#define vSetSMCISM_CTRL_DAMP_L(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> DAMP_L=(ParValue))
N#define biGetSMCISM_CTRL_ISM_TABLE_MODE(ch) (pst_bitSMCISM_CTRL(ch) -> ISM_TABLE_MODE)
N#define vSetSMCISM_CTRL_ISM_TABLE_MODE(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> ISM_TABLE_MODE=(ParValue))
N#define biGetSMCISM_CTRL_TABLE_IDX(ch) (pst_bitSMCISM_CTRL(ch) -> TABLE_IDX)
N#define vSetSMCISM_CTRL_TABLE_IDX(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> TABLE_IDX=(ParValue))
N#define biGetSMCISM_CTRL_DIS_DAMP(ch) (pst_bitSMCISM_CTRL(ch) -> DIS_DAMP)
N#define vSetSMCISM_CTRL_DIS_DAMP(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> DIS_DAMP=(ParValue))
N#define biGetSMCISM_CTRL_RD_REQ(ch) (pst_bitSMCISM_CTRL(ch) -> RD_REQ)
N#define vSetSMCISM_CTRL_RD_REQ(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> RD_REQ=(ParValue))            
N#define biGetSMCISM_CTRL_RD_FLAG(ch) (pst_bitSMCISM_CTRL(ch) -> RD_FLAG)
N#define biGetSMCISM_CTRL_FREEZE_REQ(ch) (pst_bitSMCISM_CTRL(ch) -> FREEZE_REQ)
N#define vSetSMCISM_CTRL_FREEZE_REQ(ch,ParValue)  (pst_bitSMCISM_CTRL(ch) -> FREEZE_REQ=(ParValue))            
N#define biGetSMCISM_CTRL_FREEZE_FLAG(ch) (pst_bitSMCISM_CTRL(ch) -> FREEZE_FLAG)
N            
N/* LL-struct byte access */
N#define vSetSMCISM_CTRLLL(ch,ParValue) (pst_u8SMCISM_CTRL(ch) -> u8LL = (ParValue))
N#define u8GetSMCISM_CTRLLL(ch) (pst_u8SMCISM_CTRL(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCISM_CTRLLH(ch,ParValue) (pst_u8SMCISM_CTRL(ch) -> u8LH = (ParValue))
N#define u8GetSMCISM_CTRLLH(ch) (pst_u8SMCISM_CTRL(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCISM_CTRLHL(ch,ParValue) (pst_u8SMCISM_CTRL(ch) -> u8HL = (ParValue))
N#define u8GetSMCISM_CTRLHL(ch) (pst_u8SMCISM_CTRL(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCISM_CTRLHH(ch,ParValue) (pst_u8SMCISM_CTRL(ch) -> u8HH = (ParValue))
N#define u8GetSMCISM_CTRLHH(ch) (pst_u8SMCISM_CTRL(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCISM_CTRLL(ch,ParValue) (pst_u16SMCISM_CTRL(ch) -> u16L = (ParValue))
N#define u16GetSMCISM_CTRLL(ch) (pst_u16SMCISM_CTRL(ch) -> u16L)
N#define vSetSMCISM_CTRLH(ch,ParValue) (pst_u16SMCISM_CTRL(ch) -> u16H = (ParValue))
N#define u16GetSMCISM_CTRLH(ch) (pst_u16SMCISM_CTRL(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCISM_CTRL(ch,ParValue)  (*pu32SMCISM_CTRL(ch) = (ParValue))
N#define u32GetSMCISM_CTRL(ch)  (*pu32SMCISM_CTRL(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCPOS_Dest                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300034                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCPOS_Dest_REG__       0xC0300034U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   FRACP	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   INTP	:17; 	 /* 8..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCPOS_Dest_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCPOS_Dest_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCPOS_Dest_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCPOS_Dest_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCPOS_Dest(ch)     ((volatile SMCPOS_Dest_bit_view_st *)\
N(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCPOS_Dest(ch)     ((volatile SMCPOS_Dest_bit_view_st *)(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCPOS_Dest(ch)     ((volatile SMCPOS_Dest_byte_view_st *)\
N(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCPOS_Dest(ch)     ((volatile SMCPOS_Dest_byte_view_st *)(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCPOS_Dest(ch)     ((volatile SMCPOS_Dest_halfword_view_st *)\
N(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCPOS_Dest(ch)     ((volatile SMCPOS_Dest_halfword_view_st *)(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCPOS_Dest(ch)     ((volatile u32SMCPOS_Dest_word_view *)\
N(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCPOS_Dest(ch)     ((volatile u32SMCPOS_Dest_word_view *)(SMCPOS_Dest_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCPOS_Dest_FRACP(ch) (pst_bitSMCPOS_Dest(ch) -> FRACP)
N#define vSetSMCPOS_Dest_FRACP(ch,ParValue)  (pst_bitSMCPOS_Dest(ch) -> FRACP=(ParValue))
N#define biGetSMCPOS_Dest_INTP(ch) (pst_bitSMCPOS_Dest(ch) -> INTP)
N#define vSetSMCPOS_Dest_INTP(ch,ParValue)  (pst_bitSMCPOS_Dest(ch) -> INTP=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCPOS_DestLL(ch,ParValue) (pst_u8SMCPOS_Dest(ch) -> u8LL = (ParValue))
N#define u8GetSMCPOS_DestLL(ch) (pst_u8SMCPOS_Dest(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCPOS_DestLH(ch,ParValue) (pst_u8SMCPOS_Dest(ch) -> u8LH = (ParValue))
N#define u8GetSMCPOS_DestLH(ch) (pst_u8SMCPOS_Dest(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCPOS_DestHL(ch,ParValue) (pst_u8SMCPOS_Dest(ch) -> u8HL = (ParValue))
N#define u8GetSMCPOS_DestHL(ch) (pst_u8SMCPOS_Dest(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCPOS_DestHH(ch,ParValue) (pst_u8SMCPOS_Dest(ch) -> u8HH = (ParValue))
N#define u8GetSMCPOS_DestHH(ch) (pst_u8SMCPOS_Dest(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCPOS_DestL(ch,ParValue) (pst_u16SMCPOS_Dest(ch) -> u16L = (ParValue))
N#define u16GetSMCPOS_DestL(ch) (pst_u16SMCPOS_Dest(ch) -> u16L)
N#define vSetSMCPOS_DestH(ch,ParValue) (pst_u16SMCPOS_Dest(ch) -> u16H = (ParValue))
N#define u16GetSMCPOS_DestH(ch) (pst_u16SMCPOS_Dest(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCPOS_Dest(ch,ParValue)  (*pu32SMCPOS_Dest(ch) = (ParValue))
N#define u32GetSMCPOS_Dest(ch)  (*pu32SMCPOS_Dest(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCPWM                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300048                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCPWM_REG__       0xC0300048U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   COSDUTY	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   SINDUTY	:10; 	 /* 10..19  bit(s) R/W */
N  uint32_t   QUADR	:2; 	 /* 20..21  bit(s) R/W */ 
N  uint32_t   	:10; 	 /* 22..31  bit(s) R */                    
N} SMCPWM_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCPWM_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCPWM_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCPWM_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCPWM(ch)     ((volatile SMCPWM_bit_view_st *)\
N(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCPWM(ch)     ((volatile SMCPWM_bit_view_st *)(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCPWM(ch)     ((volatile SMCPWM_byte_view_st *)\
N(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCPWM(ch)     ((volatile SMCPWM_byte_view_st *)(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCPWM(ch)     ((volatile SMCPWM_halfword_view_st *)\
N(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCPWM(ch)     ((volatile SMCPWM_halfword_view_st *)(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCPWM(ch)     ((volatile u32SMCPWM_word_view *)\
N(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCPWM(ch)     ((volatile u32SMCPWM_word_view *)(SMCPWM_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCPWM_COSDUTY(ch) (pst_bitSMCPWM(ch) -> COSDUTY)
N#define vSetSMCPWM_COSDUTY(ch,ParValue)  (pst_bitSMCPWM(ch) -> COSDUTY=(ParValue))
N#define biGetSMCPWM_SINDUTY(ch) (pst_bitSMCPWM(ch) -> SINDUTY)
N#define vSetSMCPWM_SINDUTY(ch,ParValue)  (pst_bitSMCPWM(ch) -> SINDUTY=(ParValue))
N#define biGetSMCPWM_QUADR(ch) (pst_bitSMCPWM(ch) -> QUADR)
N#define vSetSMCPWM_QUADR(ch,ParValue)  (pst_bitSMCPWM(ch) -> QUADR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCPWMLL(ch,ParValue) (pst_u8SMCPWM(ch) -> u8LL = (ParValue))
N#define u8GetSMCPWMLL(ch) (pst_u8SMCPWM(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCPWMLH(ch,ParValue) (pst_u8SMCPWM(ch) -> u8LH = (ParValue))
N#define u8GetSMCPWMLH(ch) (pst_u8SMCPWM(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCPWMHL(ch,ParValue) (pst_u8SMCPWM(ch) -> u8HL = (ParValue))
N#define u8GetSMCPWMHL(ch) (pst_u8SMCPWM(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCPWMHH(ch,ParValue) (pst_u8SMCPWM(ch) -> u8HH = (ParValue))
N#define u8GetSMCPWMHH(ch) (pst_u8SMCPWM(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCPWML(ch,ParValue) (pst_u16SMCPWM(ch) -> u16L = (ParValue))
N#define u16GetSMCPWML(ch) (pst_u16SMCPWM(ch) -> u16L)
N#define vSetSMCPWMH(ch,ParValue) (pst_u16SMCPWM(ch) -> u16H = (ParValue))
N#define u16GetSMCPWMH(ch) (pst_u16SMCPWM(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCPWM(ch,ParValue)  (*pu32SMCPWM(ch) = (ParValue))
N#define u32GetSMCPWM(ch)  (*pu32SMCPWM(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_PT1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC030005C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_PT1_REG__       0xC030005CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PT1	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_PT1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_PT1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_PT1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_PT1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_PT1(ch)     ((volatile SMCDCA_PT1_bit_view_st *)\
N(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_PT1(ch)     ((volatile SMCDCA_PT1_bit_view_st *)(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_PT1(ch)     ((volatile SMCDCA_PT1_byte_view_st *)\
N(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_PT1(ch)     ((volatile SMCDCA_PT1_byte_view_st *)(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_PT1(ch)     ((volatile SMCDCA_PT1_halfword_view_st *)\
N(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_PT1(ch)     ((volatile SMCDCA_PT1_halfword_view_st *)(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_PT1(ch)     ((volatile u32SMCDCA_PT1_word_view *)\
N(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_PT1(ch)     ((volatile u32SMCDCA_PT1_word_view *)(SMCDCA_PT1_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_PT1_PT1(ch) (pst_bitSMCDCA_PT1(ch) -> PT1)
N#define vSetSMCDCA_PT1_PT1(ch,ParValue)  (pst_bitSMCDCA_PT1(ch) -> PT1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_PT1LL(ch,ParValue) (pst_u8SMCDCA_PT1(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_PT1LL(ch) (pst_u8SMCDCA_PT1(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_PT1LH(ch,ParValue) (pst_u8SMCDCA_PT1(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_PT1LH(ch) (pst_u8SMCDCA_PT1(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_PT1HL(ch,ParValue) (pst_u8SMCDCA_PT1(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_PT1HL(ch) (pst_u8SMCDCA_PT1(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_PT1HH(ch,ParValue) (pst_u8SMCDCA_PT1(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_PT1HH(ch) (pst_u8SMCDCA_PT1(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_PT1L(ch,ParValue) (pst_u16SMCDCA_PT1(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_PT1L(ch) (pst_u16SMCDCA_PT1(ch) -> u16L)
N#define vSetSMCDCA_PT1H(ch,ParValue) (pst_u16SMCDCA_PT1(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_PT1H(ch) (pst_u16SMCDCA_PT1(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_PT1(ch,ParValue)  (*pu32SMCDCA_PT1(ch) = (ParValue))
N#define u32GetSMCDCA_PT1(ch)  (*pu32SMCDCA_PT1(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_PT2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300070                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_PT2_REG__       0xC0300070U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PT2	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_PT2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_PT2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_PT2_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_PT2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_PT2(ch)     ((volatile SMCDCA_PT2_bit_view_st *)\
N(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_PT2(ch)     ((volatile SMCDCA_PT2_bit_view_st *)(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_PT2(ch)     ((volatile SMCDCA_PT2_byte_view_st *)\
N(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_PT2(ch)     ((volatile SMCDCA_PT2_byte_view_st *)(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_PT2(ch)     ((volatile SMCDCA_PT2_halfword_view_st *)\
N(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_PT2(ch)     ((volatile SMCDCA_PT2_halfword_view_st *)(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_PT2(ch)     ((volatile u32SMCDCA_PT2_word_view *)\
N(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_PT2(ch)     ((volatile u32SMCDCA_PT2_word_view *)(SMCDCA_PT2_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_PT2_PT2(ch) (pst_bitSMCDCA_PT2(ch) -> PT2)
N#define vSetSMCDCA_PT2_PT2(ch,ParValue)  (pst_bitSMCDCA_PT2(ch) -> PT2=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_PT2LL(ch,ParValue) (pst_u8SMCDCA_PT2(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_PT2LL(ch) (pst_u8SMCDCA_PT2(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_PT2LH(ch,ParValue) (pst_u8SMCDCA_PT2(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_PT2LH(ch) (pst_u8SMCDCA_PT2(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_PT2HL(ch,ParValue) (pst_u8SMCDCA_PT2(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_PT2HL(ch) (pst_u8SMCDCA_PT2(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_PT2HH(ch,ParValue) (pst_u8SMCDCA_PT2(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_PT2HH(ch) (pst_u8SMCDCA_PT2(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_PT2L(ch,ParValue) (pst_u16SMCDCA_PT2(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_PT2L(ch) (pst_u16SMCDCA_PT2(ch) -> u16L)
N#define vSetSMCDCA_PT2H(ch,ParValue) (pst_u16SMCDCA_PT2(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_PT2H(ch) (pst_u16SMCDCA_PT2(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_PT2(ch,ParValue)  (*pu32SMCDCA_PT2(ch) = (ParValue))
N#define u32GetSMCDCA_PT2(ch)  (*pu32SMCDCA_PT2(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_V_OLD                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300084                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_V_OLD_REG__       0xC0300084U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   V_OLD	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_V_OLD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_V_OLD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_V_OLD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_V_OLD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_V_OLD(ch)     ((volatile SMCDCA_V_OLD_bit_view_st *)\
N(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_V_OLD(ch)     ((volatile SMCDCA_V_OLD_bit_view_st *)(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_V_OLD(ch)     ((volatile SMCDCA_V_OLD_byte_view_st *)\
N(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_V_OLD(ch)     ((volatile SMCDCA_V_OLD_byte_view_st *)(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_V_OLD(ch)     ((volatile SMCDCA_V_OLD_halfword_view_st *)\
N(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_V_OLD(ch)     ((volatile SMCDCA_V_OLD_halfword_view_st *)(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_V_OLD(ch)     ((volatile u32SMCDCA_V_OLD_word_view *)\
N(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_V_OLD(ch)     ((volatile u32SMCDCA_V_OLD_word_view *)(SMCDCA_V_OLD_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_V_OLD_V_OLD(ch) (pst_bitSMCDCA_V_OLD(ch) -> V_OLD)
N#define vSetSMCDCA_V_OLD_V_OLD(ch,ParValue)  (pst_bitSMCDCA_V_OLD(ch) -> V_OLD=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_V_OLDLL(ch,ParValue) (pst_u8SMCDCA_V_OLD(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_V_OLDLL(ch) (pst_u8SMCDCA_V_OLD(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_V_OLDLH(ch,ParValue) (pst_u8SMCDCA_V_OLD(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_V_OLDLH(ch) (pst_u8SMCDCA_V_OLD(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_V_OLDHL(ch,ParValue) (pst_u8SMCDCA_V_OLD(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_V_OLDHL(ch) (pst_u8SMCDCA_V_OLD(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_V_OLDHH(ch,ParValue) (pst_u8SMCDCA_V_OLD(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_V_OLDHH(ch) (pst_u8SMCDCA_V_OLD(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_V_OLDL(ch,ParValue) (pst_u16SMCDCA_V_OLD(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_V_OLDL(ch) (pst_u16SMCDCA_V_OLD(ch) -> u16L)
N#define vSetSMCDCA_V_OLDH(ch,ParValue) (pst_u16SMCDCA_V_OLD(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_V_OLDH(ch) (pst_u16SMCDCA_V_OLD(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_V_OLD(ch,ParValue)  (*pu32SMCDCA_V_OLD(ch) = (ParValue))
N#define u32GetSMCDCA_V_OLD(ch)  (*pu32SMCDCA_V_OLD(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_V_MAX                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300098                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_V_MAX_REG__       0xC0300098U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   V_MAX	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_V_MAX_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_V_MAX_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_V_MAX_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_V_MAX_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_V_MAX(ch)     ((volatile SMCDCA_V_MAX_bit_view_st *)\
N(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_V_MAX(ch)     ((volatile SMCDCA_V_MAX_bit_view_st *)(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_V_MAX(ch)     ((volatile SMCDCA_V_MAX_byte_view_st *)\
N(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_V_MAX(ch)     ((volatile SMCDCA_V_MAX_byte_view_st *)(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_V_MAX(ch)     ((volatile SMCDCA_V_MAX_halfword_view_st *)\
N(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_V_MAX(ch)     ((volatile SMCDCA_V_MAX_halfword_view_st *)(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_V_MAX(ch)     ((volatile u32SMCDCA_V_MAX_word_view *)\
N(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_V_MAX(ch)     ((volatile u32SMCDCA_V_MAX_word_view *)(SMCDCA_V_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_V_MAX_V_MAX(ch) (pst_bitSMCDCA_V_MAX(ch) -> V_MAX)
N#define vSetSMCDCA_V_MAX_V_MAX(ch,ParValue)  (pst_bitSMCDCA_V_MAX(ch) -> V_MAX=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_V_MAXLL(ch,ParValue) (pst_u8SMCDCA_V_MAX(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_V_MAXLL(ch) (pst_u8SMCDCA_V_MAX(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_V_MAXLH(ch,ParValue) (pst_u8SMCDCA_V_MAX(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_V_MAXLH(ch) (pst_u8SMCDCA_V_MAX(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_V_MAXHL(ch,ParValue) (pst_u8SMCDCA_V_MAX(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_V_MAXHL(ch) (pst_u8SMCDCA_V_MAX(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_V_MAXHH(ch,ParValue) (pst_u8SMCDCA_V_MAX(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_V_MAXHH(ch) (pst_u8SMCDCA_V_MAX(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_V_MAXL(ch,ParValue) (pst_u16SMCDCA_V_MAX(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_V_MAXL(ch) (pst_u16SMCDCA_V_MAX(ch) -> u16L)
N#define vSetSMCDCA_V_MAXH(ch,ParValue) (pst_u16SMCDCA_V_MAX(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_V_MAXH(ch) (pst_u16SMCDCA_V_MAX(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_V_MAX(ch,ParValue)  (*pu32SMCDCA_V_MAX(ch) = (ParValue))
N#define u32GetSMCDCA_V_MAX(ch)  (*pu32SMCDCA_V_MAX(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_ACC                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC03000AC                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_ACC_REG__       0xC03000ACU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ACC	:25; 	 /* 0..24  bit(s) R */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_ACC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_ACC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_ACC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_ACC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_ACC(ch)     ((volatile SMCDCA_ACC_bit_view_st *)\
N(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_ACC(ch)     ((volatile SMCDCA_ACC_bit_view_st *)(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_ACC(ch)     ((volatile SMCDCA_ACC_byte_view_st *)\
N(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_ACC(ch)     ((volatile SMCDCA_ACC_byte_view_st *)(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_ACC(ch)     ((volatile SMCDCA_ACC_halfword_view_st *)\
N(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_ACC(ch)     ((volatile SMCDCA_ACC_halfword_view_st *)(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_ACC(ch)     ((volatile u32SMCDCA_ACC_word_view *)\
N(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_ACC(ch)     ((volatile u32SMCDCA_ACC_word_view *)(SMCDCA_ACC_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetSMCDCA_ACC_ACC(ch) (pst_bitSMCDCA_ACC(ch) -> ACC)
N            
N/* LL-struct byte access */
N
N#define u8GetSMCDCA_ACCLL(ch) (pst_u8SMCDCA_ACC(ch) -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetSMCDCA_ACCLH(ch) (pst_u8SMCDCA_ACC(ch) -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetSMCDCA_ACCHL(ch) (pst_u8SMCDCA_ACC(ch) -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetSMCDCA_ACCHH(ch) (pst_u8SMCDCA_ACC(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N
N#define u16GetSMCDCA_ACCL(ch) (pst_u16SMCDCA_ACC(ch) -> u16L)
N
N#define u16GetSMCDCA_ACCH(ch) (pst_u16SMCDCA_ACC(ch) -> u16H)
N            
N/* Word access */
N
N#define u32GetSMCDCA_ACC(ch)  (*pu32SMCDCA_ACC(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_A_MAX                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC03000C0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_A_MAX_REG__       0xC03000C0U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   A_MAX	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_A_MAX_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_A_MAX_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_A_MAX_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_A_MAX_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_A_MAX(ch)     ((volatile SMCDCA_A_MAX_bit_view_st *)\
N(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_A_MAX(ch)     ((volatile SMCDCA_A_MAX_bit_view_st *)(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_A_MAX(ch)     ((volatile SMCDCA_A_MAX_byte_view_st *)\
N(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_A_MAX(ch)     ((volatile SMCDCA_A_MAX_byte_view_st *)(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_A_MAX(ch)     ((volatile SMCDCA_A_MAX_halfword_view_st *)\
N(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_A_MAX(ch)     ((volatile SMCDCA_A_MAX_halfword_view_st *)(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_A_MAX(ch)     ((volatile u32SMCDCA_A_MAX_word_view *)\
N(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_A_MAX(ch)     ((volatile u32SMCDCA_A_MAX_word_view *)(SMCDCA_A_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_A_MAX_A_MAX(ch) (pst_bitSMCDCA_A_MAX(ch) -> A_MAX)
N#define vSetSMCDCA_A_MAX_A_MAX(ch,ParValue)  (pst_bitSMCDCA_A_MAX(ch) -> A_MAX=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_A_MAXLL(ch,ParValue) (pst_u8SMCDCA_A_MAX(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_A_MAXLL(ch) (pst_u8SMCDCA_A_MAX(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_A_MAXLH(ch,ParValue) (pst_u8SMCDCA_A_MAX(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_A_MAXLH(ch) (pst_u8SMCDCA_A_MAX(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_A_MAXHL(ch,ParValue) (pst_u8SMCDCA_A_MAX(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_A_MAXHL(ch) (pst_u8SMCDCA_A_MAX(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_A_MAXHH(ch,ParValue) (pst_u8SMCDCA_A_MAX(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_A_MAXHH(ch) (pst_u8SMCDCA_A_MAX(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_A_MAXL(ch,ParValue) (pst_u16SMCDCA_A_MAX(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_A_MAXL(ch) (pst_u16SMCDCA_A_MAX(ch) -> u16L)
N#define vSetSMCDCA_A_MAXH(ch,ParValue) (pst_u16SMCDCA_A_MAX(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_A_MAXH(ch) (pst_u16SMCDCA_A_MAX(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_A_MAX(ch,ParValue)  (*pu32SMCDCA_A_MAX(ch) = (ParValue))
N#define u32GetSMCDCA_A_MAX(ch)  (*pu32SMCDCA_A_MAX(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_D_MAX                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC03000D4                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_D_MAX_REG__       0xC03000D4U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   D_MAX	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_D_MAX_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_D_MAX_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_D_MAX_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_D_MAX_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_D_MAX(ch)     ((volatile SMCDCA_D_MAX_bit_view_st *)\
N(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_D_MAX(ch)     ((volatile SMCDCA_D_MAX_bit_view_st *)(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_D_MAX(ch)     ((volatile SMCDCA_D_MAX_byte_view_st *)\
N(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_D_MAX(ch)     ((volatile SMCDCA_D_MAX_byte_view_st *)(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_D_MAX(ch)     ((volatile SMCDCA_D_MAX_halfword_view_st *)\
N(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_D_MAX(ch)     ((volatile SMCDCA_D_MAX_halfword_view_st *)(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_D_MAX(ch)     ((volatile u32SMCDCA_D_MAX_word_view *)\
N(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_D_MAX(ch)     ((volatile u32SMCDCA_D_MAX_word_view *)(SMCDCA_D_MAX_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_D_MAX_D_MAX(ch) (pst_bitSMCDCA_D_MAX(ch) -> D_MAX)
N#define vSetSMCDCA_D_MAX_D_MAX(ch,ParValue)  (pst_bitSMCDCA_D_MAX(ch) -> D_MAX=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_D_MAXLL(ch,ParValue) (pst_u8SMCDCA_D_MAX(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_D_MAXLL(ch) (pst_u8SMCDCA_D_MAX(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_D_MAXLH(ch,ParValue) (pst_u8SMCDCA_D_MAX(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_D_MAXLH(ch) (pst_u8SMCDCA_D_MAX(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_D_MAXHL(ch,ParValue) (pst_u8SMCDCA_D_MAX(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_D_MAXHL(ch) (pst_u8SMCDCA_D_MAX(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_D_MAXHH(ch,ParValue) (pst_u8SMCDCA_D_MAX(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_D_MAXHH(ch) (pst_u8SMCDCA_D_MAX(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_D_MAXL(ch,ParValue) (pst_u16SMCDCA_D_MAX(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_D_MAXL(ch) (pst_u16SMCDCA_D_MAX(ch) -> u16L)
N#define vSetSMCDCA_D_MAXH(ch,ParValue) (pst_u16SMCDCA_D_MAX(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_D_MAXH(ch) (pst_u16SMCDCA_D_MAX(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_D_MAX(ch,ParValue)  (*pu32SMCDCA_D_MAX(ch) = (ParValue))
N#define u32GetSMCDCA_D_MAX(ch)  (*pu32SMCDCA_D_MAX(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_V1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC03000E8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_V1_REG__       0xC03000E8U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   V1TH	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_V1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_V1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_V1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_V1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_V1(ch)     ((volatile SMCDCA_V1_bit_view_st *)\
N(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_V1(ch)     ((volatile SMCDCA_V1_bit_view_st *)(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_V1(ch)     ((volatile SMCDCA_V1_byte_view_st *)\
N(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_V1(ch)     ((volatile SMCDCA_V1_byte_view_st *)(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_V1(ch)     ((volatile SMCDCA_V1_halfword_view_st *)\
N(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_V1(ch)     ((volatile SMCDCA_V1_halfword_view_st *)(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_V1(ch)     ((volatile u32SMCDCA_V1_word_view *)\
N(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_V1(ch)     ((volatile u32SMCDCA_V1_word_view *)(SMCDCA_V1_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_V1_V1TH(ch) (pst_bitSMCDCA_V1(ch) -> V1TH)
N#define vSetSMCDCA_V1_V1TH(ch,ParValue)  (pst_bitSMCDCA_V1(ch) -> V1TH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_V1LL(ch,ParValue) (pst_u8SMCDCA_V1(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_V1LL(ch) (pst_u8SMCDCA_V1(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_V1LH(ch,ParValue) (pst_u8SMCDCA_V1(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_V1LH(ch) (pst_u8SMCDCA_V1(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_V1HL(ch,ParValue) (pst_u8SMCDCA_V1(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_V1HL(ch) (pst_u8SMCDCA_V1(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_V1HH(ch,ParValue) (pst_u8SMCDCA_V1(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_V1HH(ch) (pst_u8SMCDCA_V1(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_V1L(ch,ParValue) (pst_u16SMCDCA_V1(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_V1L(ch) (pst_u16SMCDCA_V1(ch) -> u16L)
N#define vSetSMCDCA_V1H(ch,ParValue) (pst_u16SMCDCA_V1(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_V1H(ch) (pst_u16SMCDCA_V1(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_V1(ch,ParValue)  (*pu32SMCDCA_V1(ch) = (ParValue))
N#define u32GetSMCDCA_V1(ch)  (*pu32SMCDCA_V1(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_V2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC03000FC                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_V2_REG__       0xC03000FCU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   V2TH	:25; 	 /* 0..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} SMCDCA_V2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCDCA_V2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCDCA_V2_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCDCA_V2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_V2(ch)     ((volatile SMCDCA_V2_bit_view_st *)\
N(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_V2(ch)     ((volatile SMCDCA_V2_bit_view_st *)(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_V2(ch)     ((volatile SMCDCA_V2_byte_view_st *)\
N(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_V2(ch)     ((volatile SMCDCA_V2_byte_view_st *)(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCDCA_V2(ch)     ((volatile SMCDCA_V2_halfword_view_st *)\
N(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCDCA_V2(ch)     ((volatile SMCDCA_V2_halfword_view_st *)(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCDCA_V2(ch)     ((volatile u32SMCDCA_V2_word_view *)\
N(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCDCA_V2(ch)     ((volatile u32SMCDCA_V2_word_view *)(SMCDCA_V2_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_V2_V2TH(ch) (pst_bitSMCDCA_V2(ch) -> V2TH)
N#define vSetSMCDCA_V2_V2TH(ch,ParValue)  (pst_bitSMCDCA_V2(ch) -> V2TH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCDCA_V2LL(ch,ParValue) (pst_u8SMCDCA_V2(ch) -> u8LL = (ParValue))
N#define u8GetSMCDCA_V2LL(ch) (pst_u8SMCDCA_V2(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCDCA_V2LH(ch,ParValue) (pst_u8SMCDCA_V2(ch) -> u8LH = (ParValue))
N#define u8GetSMCDCA_V2LH(ch) (pst_u8SMCDCA_V2(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCDCA_V2HL(ch,ParValue) (pst_u8SMCDCA_V2(ch) -> u8HL = (ParValue))
N#define u8GetSMCDCA_V2HL(ch) (pst_u8SMCDCA_V2(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCDCA_V2HH(ch,ParValue) (pst_u8SMCDCA_V2(ch) -> u8HH = (ParValue))
N#define u8GetSMCDCA_V2HH(ch) (pst_u8SMCDCA_V2(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCDCA_V2L(ch,ParValue) (pst_u16SMCDCA_V2(ch) -> u16L = (ParValue))
N#define u16GetSMCDCA_V2L(ch) (pst_u16SMCDCA_V2(ch) -> u16L)
N#define vSetSMCDCA_V2H(ch,ParValue) (pst_u16SMCDCA_V2(ch) -> u16H = (ParValue))
N#define u16GetSMCDCA_V2H(ch) (pst_u16SMCDCA_V2(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCDCA_V2(ch,ParValue)  (*pu32SMCDCA_V2(ch) = (ParValue))
N#define u32GetSMCDCA_V2(ch)  (*pu32SMCDCA_V2(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCDCA_TS                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300110                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCDCA_TS_REG__       0xC0300110U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   TS_SEL	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   	:7; 	 /* 1..7  bit(s) R */
N  uint16_t   TD_SEL	:1; 	 /* 8..8  bit(s) R/W */ 
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */                    
N} SMCDCA_TS_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} SMCDCA_TS_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16SMCDCA_TS_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCDCA_TS(ch)     ((volatile SMCDCA_TS_bit_view_st *)\
N(SMCDCA_TS_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCDCA_TS(ch)     ((volatile SMCDCA_TS_bit_view_st *)(SMCDCA_TS_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCDCA_TS(ch)     ((volatile SMCDCA_TS_byte_view_st *)\
N(SMCDCA_TS_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCDCA_TS(ch)     ((volatile SMCDCA_TS_byte_view_st *)(SMCDCA_TS_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD */
N#define pu16SMCDCA_TS(ch)     ((volatile u16SMCDCA_TS_halfword_view *)\
N(SMCDCA_TS_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu16SMCDCA_TS(ch)     ((volatile u16SMCDCA_TS_halfword_view *)(SMCDCA_TS_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCDCA_TS_TS_SEL(ch) (pst_bitSMCDCA_TS(ch) -> TS_SEL)
N#define vSetSMCDCA_TS_TS_SEL(ch,ParValue)  (pst_bitSMCDCA_TS(ch) -> TS_SEL=(ParValue))            
N#define biGetSMCDCA_TS_TD_SEL(ch) (pst_bitSMCDCA_TS(ch) -> TD_SEL)
N#define vSetSMCDCA_TS_TD_SEL(ch,ParValue)  (pst_bitSMCDCA_TS(ch) -> TD_SEL=(ParValue))
N            
N/* L-struct byte access */
N#define vSetSMCDCA_TSL(ch,ParValue) (pst_u8SMCDCA_TS(ch) -> u8L = (ParValue))
N#define u8GetSMCDCA_TSL(ch) (pst_u8SMCDCA_TS(ch) -> u8L)
N/* H-struct byte access */
N#define vSetSMCDCA_TSH(ch,ParValue) (pst_u8SMCDCA_TS(ch) -> u8H = (ParValue))
N#define u8GetSMCDCA_TSH(ch) (pst_u8SMCDCA_TS(ch) -> u8H)
N            
N/* Half-word access */ 
N#define vSetSMCDCA_TS(ch,ParValue) (*pu16SMCDCA_TS(ch)  = (ParValue))
N#define u16GetSMCDCA_TS(ch) (*pu16SMCDCA_TS(ch) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCZPD_CTRL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300124                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCZPD_CTRL_REG__       0xC0300124U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   IDX_INC_N	:7; 	 /* 0..6  bit(s) R/W */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   QUAD	:2; 	 /* 8..9  bit(s) R */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   FREQ_N	:4; 	 /* 16..19  bit(s) R/W */
N  uint32_t   	:4; 	 /* 20..23  bit(s) R */
N  uint32_t   VOLT_REF	:6; 	 /* 24..29  bit(s) R/W */ 
N  uint32_t   	:2; 	 /* 30..31  bit(s) R */                    
N} SMCZPD_CTRL_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCZPD_CTRL_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCZPD_CTRL_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCZPD_CTRL_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCZPD_CTRL(ch)     ((volatile SMCZPD_CTRL_bit_view_st *)\
N(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCZPD_CTRL(ch)     ((volatile SMCZPD_CTRL_bit_view_st *)(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCZPD_CTRL(ch)     ((volatile SMCZPD_CTRL_byte_view_st *)\
N(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCZPD_CTRL(ch)     ((volatile SMCZPD_CTRL_byte_view_st *)(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCZPD_CTRL(ch)     ((volatile SMCZPD_CTRL_halfword_view_st *)\
N(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCZPD_CTRL(ch)     ((volatile SMCZPD_CTRL_halfword_view_st *)(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCZPD_CTRL(ch)     ((volatile u32SMCZPD_CTRL_word_view *)\
N(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCZPD_CTRL(ch)     ((volatile u32SMCZPD_CTRL_word_view *)(SMCZPD_CTRL_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCZPD_CTRL_IDX_INC_N(ch) (pst_bitSMCZPD_CTRL(ch) -> IDX_INC_N)
N#define vSetSMCZPD_CTRL_IDX_INC_N(ch,ParValue)  (pst_bitSMCZPD_CTRL(ch) -> IDX_INC_N=(ParValue))            
N#define biGetSMCZPD_CTRL_QUAD(ch) (pst_bitSMCZPD_CTRL(ch) -> QUAD)
N#define biGetSMCZPD_CTRL_FREQ_N(ch) (pst_bitSMCZPD_CTRL(ch) -> FREQ_N)
N#define vSetSMCZPD_CTRL_FREQ_N(ch,ParValue)  (pst_bitSMCZPD_CTRL(ch) -> FREQ_N=(ParValue))
N#define biGetSMCZPD_CTRL_VOLT_REF(ch) (pst_bitSMCZPD_CTRL(ch) -> VOLT_REF)
N#define vSetSMCZPD_CTRL_VOLT_REF(ch,ParValue)  (pst_bitSMCZPD_CTRL(ch) -> VOLT_REF=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCZPD_CTRLLL(ch,ParValue) (pst_u8SMCZPD_CTRL(ch) -> u8LL = (ParValue))
N#define u8GetSMCZPD_CTRLLL(ch) (pst_u8SMCZPD_CTRL(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCZPD_CTRLLH(ch,ParValue) (pst_u8SMCZPD_CTRL(ch) -> u8LH = (ParValue))
N#define u8GetSMCZPD_CTRLLH(ch) (pst_u8SMCZPD_CTRL(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCZPD_CTRLHL(ch,ParValue) (pst_u8SMCZPD_CTRL(ch) -> u8HL = (ParValue))
N#define u8GetSMCZPD_CTRLHL(ch) (pst_u8SMCZPD_CTRL(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCZPD_CTRLHH(ch,ParValue) (pst_u8SMCZPD_CTRL(ch) -> u8HH = (ParValue))
N#define u8GetSMCZPD_CTRLHH(ch) (pst_u8SMCZPD_CTRL(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCZPD_CTRLL(ch,ParValue) (pst_u16SMCZPD_CTRL(ch) -> u16L = (ParValue))
N#define u16GetSMCZPD_CTRLL(ch) (pst_u16SMCZPD_CTRL(ch) -> u16L)
N#define vSetSMCZPD_CTRLH(ch,ParValue) (pst_u16SMCZPD_CTRL(ch) -> u16H = (ParValue))
N#define u16GetSMCZPD_CTRLH(ch) (pst_u16SMCZPD_CTRL(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCZPD_CTRL(ch,ParValue)  (*pu32SMCZPD_CTRL(ch) = (ParValue))
N#define u32GetSMCZPD_CTRL(ch)  (*pu32SMCZPD_CTRL(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCZPD_TABLE                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0300C00                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCZPD_TABLE_REG__       0xC0300C00U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PORT_CTRL	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   INPUT_SEL	:2; 	 /* 8..9  bit(s) R/W */
N  uint32_t   DLY_CNT	:10; 	 /* 10..19  bit(s) R/W */
N  uint32_t   NOT_USED	:2; 	 /* 20..21  bit(s) R/W */
N  uint32_t   LAST_ENTRY	:1; 	 /* 22..22  bit(s) R/W */
N  uint32_t   MEASURE	:1; 	 /* 23..23  bit(s) R/W */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} SMCZPD_TABLE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCZPD_TABLE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCZPD_TABLE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCZPD_TABLE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCZPD_TABLE(ch)     ((volatile SMCZPD_TABLE_bit_view_st *)\
N(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCZPD_TABLE(ch)     ((volatile SMCZPD_TABLE_bit_view_st *)(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCZPD_TABLE(ch)     ((volatile SMCZPD_TABLE_byte_view_st *)\
N(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCZPD_TABLE(ch)     ((volatile SMCZPD_TABLE_byte_view_st *)(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCZPD_TABLE(ch)     ((volatile SMCZPD_TABLE_halfword_view_st *)\
N(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCZPD_TABLE(ch)     ((volatile SMCZPD_TABLE_halfword_view_st *)(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCZPD_TABLE(ch)     ((volatile u32SMCZPD_TABLE_word_view *)\
N(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCZPD_TABLE(ch)     ((volatile u32SMCZPD_TABLE_word_view *)(SMCZPD_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCZPD_TABLE_PORT_CTRL(ch) (pst_bitSMCZPD_TABLE(ch) -> PORT_CTRL)
N#define vSetSMCZPD_TABLE_PORT_CTRL(ch,ParValue)  (pst_bitSMCZPD_TABLE(ch) -> PORT_CTRL=(ParValue))
N#define biGetSMCZPD_TABLE_INPUT_SEL(ch) (pst_bitSMCZPD_TABLE(ch) -> INPUT_SEL)
N#define vSetSMCZPD_TABLE_INPUT_SEL(ch,ParValue)  (pst_bitSMCZPD_TABLE(ch) -> INPUT_SEL=(ParValue))
N#define biGetSMCZPD_TABLE_DLY_CNT(ch) (pst_bitSMCZPD_TABLE(ch) -> DLY_CNT)
N#define vSetSMCZPD_TABLE_DLY_CNT(ch,ParValue)  (pst_bitSMCZPD_TABLE(ch) -> DLY_CNT=(ParValue))
N#define biGetSMCZPD_TABLE_NOT_USED(ch) (pst_bitSMCZPD_TABLE(ch) -> NOT_USED)
N#define vSetSMCZPD_TABLE_NOT_USED(ch,ParValue)  (pst_bitSMCZPD_TABLE(ch) -> NOT_USED=(ParValue))
N#define biGetSMCZPD_TABLE_LAST_ENTRY(ch) (pst_bitSMCZPD_TABLE(ch) -> LAST_ENTRY)
N#define vSetSMCZPD_TABLE_LAST_ENTRY(ch,ParValue)  (pst_bitSMCZPD_TABLE(ch) -> LAST_ENTRY=(ParValue))
N#define biGetSMCZPD_TABLE_MEASURE(ch) (pst_bitSMCZPD_TABLE(ch) -> MEASURE)
N#define vSetSMCZPD_TABLE_MEASURE(ch,ParValue)  (pst_bitSMCZPD_TABLE(ch) -> MEASURE=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCZPD_TABLELL(ch,ParValue) (pst_u8SMCZPD_TABLE(ch) -> u8LL = (ParValue))
N#define u8GetSMCZPD_TABLELL(ch) (pst_u8SMCZPD_TABLE(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCZPD_TABLELH(ch,ParValue) (pst_u8SMCZPD_TABLE(ch) -> u8LH = (ParValue))
N#define u8GetSMCZPD_TABLELH(ch) (pst_u8SMCZPD_TABLE(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCZPD_TABLEHL(ch,ParValue) (pst_u8SMCZPD_TABLE(ch) -> u8HL = (ParValue))
N#define u8GetSMCZPD_TABLEHL(ch) (pst_u8SMCZPD_TABLE(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCZPD_TABLEHH(ch,ParValue) (pst_u8SMCZPD_TABLE(ch) -> u8HH = (ParValue))
N#define u8GetSMCZPD_TABLEHH(ch) (pst_u8SMCZPD_TABLE(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCZPD_TABLEL(ch,ParValue) (pst_u16SMCZPD_TABLE(ch) -> u16L = (ParValue))
N#define u16GetSMCZPD_TABLEL(ch) (pst_u16SMCZPD_TABLE(ch) -> u16L)
N#define vSetSMCZPD_TABLEH(ch,ParValue) (pst_u16SMCZPD_TABLE(ch) -> u16H = (ParValue))
N#define u16GetSMCZPD_TABLEH(ch) (pst_u16SMCZPD_TABLE(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCZPD_TABLE(ch,ParValue)  (*pu32SMCZPD_TABLE(ch) = (ParValue))
N#define u32GetSMCZPD_TABLE(ch)  (*pu32SMCZPD_TABLE(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: SMCISM_TABLE                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0301000                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define SMCISM_TABLE_REG__       0xC0301000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   COS_ISM	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   SIN_ISM	:10; 	 /* 10..19  bit(s) R/W */
N  uint32_t   QUAD_ISM	:2; 	 /* 20..21  bit(s) R/W */ 
N  uint32_t   	:10; 	 /* 22..31  bit(s) R */                    
N} SMCISM_TABLE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} SMCISM_TABLE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} SMCISM_TABLE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32SMCISM_TABLE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitSMCISM_TABLE(ch)     ((volatile SMCISM_TABLE_bit_view_st *)\
N(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitSMCISM_TABLE(ch)     ((volatile SMCISM_TABLE_bit_view_st *)(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8SMCISM_TABLE(ch)     ((volatile SMCISM_TABLE_byte_view_st *)\
N(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u8SMCISM_TABLE(ch)     ((volatile SMCISM_TABLE_byte_view_st *)(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16SMCISM_TABLE(ch)     ((volatile SMCISM_TABLE_halfword_view_st *)\
N(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pst_u16SMCISM_TABLE(ch)     ((volatile SMCISM_TABLE_halfword_view_st *)(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N            
N/* Pointer to WORD  */ 
N#define pu32SMCISM_TABLE(ch)     ((volatile u32SMCISM_TABLE_word_view *)\
N(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
X#define pu32SMCISM_TABLE(ch)     ((volatile u32SMCISM_TABLE_word_view *)(SMCISM_TABLE_REG__  + ((uint16_t)(ch) * 0x4U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetSMCISM_TABLE_COS_ISM(ch) (pst_bitSMCISM_TABLE(ch) -> COS_ISM)
N#define vSetSMCISM_TABLE_COS_ISM(ch,ParValue)  (pst_bitSMCISM_TABLE(ch) -> COS_ISM=(ParValue))
N#define biGetSMCISM_TABLE_SIN_ISM(ch) (pst_bitSMCISM_TABLE(ch) -> SIN_ISM)
N#define vSetSMCISM_TABLE_SIN_ISM(ch,ParValue)  (pst_bitSMCISM_TABLE(ch) -> SIN_ISM=(ParValue))
N#define biGetSMCISM_TABLE_QUAD_ISM(ch) (pst_bitSMCISM_TABLE(ch) -> QUAD_ISM)
N#define vSetSMCISM_TABLE_QUAD_ISM(ch,ParValue)  (pst_bitSMCISM_TABLE(ch) -> QUAD_ISM=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetSMCISM_TABLELL(ch,ParValue) (pst_u8SMCISM_TABLE(ch) -> u8LL = (ParValue))
N#define u8GetSMCISM_TABLELL(ch) (pst_u8SMCISM_TABLE(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetSMCISM_TABLELH(ch,ParValue) (pst_u8SMCISM_TABLE(ch) -> u8LH = (ParValue))
N#define u8GetSMCISM_TABLELH(ch) (pst_u8SMCISM_TABLE(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetSMCISM_TABLEHL(ch,ParValue) (pst_u8SMCISM_TABLE(ch) -> u8HL = (ParValue))
N#define u8GetSMCISM_TABLEHL(ch) (pst_u8SMCISM_TABLE(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetSMCISM_TABLEHH(ch,ParValue) (pst_u8SMCISM_TABLE(ch) -> u8HH = (ParValue))
N#define u8GetSMCISM_TABLEHH(ch) (pst_u8SMCISM_TABLE(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetSMCISM_TABLEL(ch,ParValue) (pst_u16SMCISM_TABLE(ch) -> u16L = (ParValue))
N#define u16GetSMCISM_TABLEL(ch) (pst_u16SMCISM_TABLE(ch) -> u16L)
N#define vSetSMCISM_TABLEH(ch,ParValue) (pst_u16SMCISM_TABLE(ch) -> u16H = (ParValue))
N#define u16GetSMCISM_TABLEH(ch) (pst_u16SMCISM_TABLE(ch) -> u16H)
N            
N/* Word access */
N#define vSetSMCISM_TABLE(ch,ParValue)  (*pu32SMCISM_TABLE(ch) = (ParValue))
N#define u32GetSMCISM_TABLE(ch)  (*pu32SMCISM_TABLE(ch) )
N            
N/******************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */ 
N/******************************************************************************/
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :   Deactivated:
N** |
N** |     Requested Rules:
N** |         Rule 6.4  [R] : Bitfields can only have `unsigned int' or `signed int' types
N** |                         Used for bit definitons generated by converter tool
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************/
N
N   
N
N#endif /* SMCIO_H */ 
N    
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 23 "..\..\..\..\lldd\src\smc.c" 2
N#include "smc.h"                      /* Own definitions */
L 1 "..\..\..\..\lldd\inc\smc.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Stepper motor controler low level driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : SMC
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef SMC_H
N#define SMC_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_SMC_H_REVISION     "$Revision: 1.14 $"
N#define LLDD_SMC_H_TAG          "$Name: LLDD_1_6 $"
N
N
N#define SMC_SCLFAK_MIN  1
N#define SMC_SCLFAK_MAX  10
N
N/*********************************************/
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N/* smc device no. */
Ntypedef enum tag_smc_dev_e
N{
N   SMC0 = 0,                              /* smc device #0 */
N   SMC1 = 1,                              /* smc device #1 */
N   SMC2 = 2,                              /* smc device #2 */
N   SMC3 = 3,                              /* smc device #3 */
N   SMC4 = 4                               /* smc device #4 */
N} smc_dev_e;
N
N/* device modes */
Ntypedef enum tag_smc_channel_mode_e
N{
N   SMC_ISM_MODE = 0,                      /* ISM mode */
N   SMC_PWM_MODE = 1,                      /* direct PWM mode */
N   SMC_ZPD_MODE = 2                       /* zero point detection */
N} smc_channel_mode_e;
N
N/* enable/disable */
Ntypedef enum tag_smc_enable_e
N{
N   SMC_DISABLE = 0,                       /* disable */
N   SMC_ENABLE  = 1                        /* enable  */
N} smc_enable_e;
N
N/* Interrupt types */
Ntypedef enum tag_smc_motint_types_e
N{
N   SMC_INT_PPE     = 0,                   /* PPE */
N   SMC_INT_MOW_END = 1,                   /* MOV_END */
N   SMC_INT_ZPD     = 2                    /* ZPD */
N} smc_motint_types_e;
N
N/* ISM table mode */
Ntypedef enum tag_smc_ism_table_mode_e
N{
N   SMC_ISM_TABLE_MODE_NORMAL  = 0,        /* normal table mode */
N   SMC_ISM_TABLE_MODE_PRECISE = 1         /* precise table mode  */
N} smc_ism_table_mode_e;
N
N/* table index */
Ntypedef enum tag_smc_table_index_e
N{
N   SMC_TABLE_INDEX_0 = 0,                 /* table index 0 */
N   SMC_TABLE_INDEX_1 = 1                  /* table index 1  */
N} smc_table_index_e;
N
N/* PWM quadrant */
Ntypedef enum tag_smc_quadrant_e
N{
N   SMC_PWM_QUADRANT_1 = 0,                /* quadrant 1 */
N   SMC_PWM_QUADRANT_2 = 1,                /* quadrant 2 */
N   SMC_PWM_QUADRANT_3 = 2,                /* quadrant 3 */
N   SMC_PWM_QUADRANT_4 = 3                 /* quadrant 4 */
N} smc_quadrant_e;
N
N/* table data selection */
Ntypedef enum tag_smc_table_data_selection_e
N{
N   SMC_TABLE_SLOW = 0,                    /* table data slow */
N   SMC_TABLE_FAST = 1                     /* table data fast */
N} smc_table_data_selection_e;
N
N/* table data direction */
Ntypedef enum tag_smc_table_data_direction_e
N{
N   SMC_TABLE_CCW = 0,                     /* table ccw */
N   SMC_TABLE_CW = 1                       /* table cw */
N} smc_table_data_direction_e;
N
N/*********************************************/
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
Ntypedef struct tag_smc_generalconfig_st
N{
N    uint8_t      u8DelayCycleCount;                      /* number of delay cycles */
N    uint8_t      u8PeriodExtension;                      /* number of cycles for period extension */
N    uint8_t      u8SlewRate;                             /* slew rate */
N} smc_generalconfig_st;
N
Ntypedef struct tag_smc_ismconfig_st
N{
N    float32_t                  f32IntermediateAngle;     /* (PT1) intermediate angle */
N    float32_t                  f32ActualAngle;           /* (PT2) actual angle */
N    uint32_t                   u32Velocity;              /* (V) velocity */
N    uint32_t                   u32VelocityLimit;         /* (Vmax) velocity limit */
N    uint32_t                   u32AccelerationLimit;     /* (amax) acceleration limit */
N    uint32_t                   u32DecelerationLimit;     /* (dmax) deceleration limit */
N    uint32_t                   u32SpeedThreshold1;       /* (V1th) speed threshold 1 */
N    uint32_t                   u32SpeedThreshold2;       /* (V2th) speed threshold 2 */
N    uint8_t                    u8DampingFactorK;         /* (k) damping factor K */
N    uint8_t                    u8DampingFactorL;         /* (l) damping factor L */
N    float32_t                  f32DegreePerFullstep;     /* rotation angle in degree per one full step */
N    smc_ism_table_mode_e       eTableMode;               /* number of cycles for period extension */
N    smc_table_index_e          eTableIndex;              /* starting table index */
N    smc_table_data_selection_e eTableData;               /* table data */
N    smc_enable_e               eUseDampingCurveHardware; /* use damping curve hardware */
N} smc_ismconfig_st;
N
Ntypedef struct tag_smc_pwmvalue_st
N{
N    smc_quadrant_e eQuadrant;                            /* quadrant used */
N    uint16_t       u16SinDuty;                           /* PWM duty cycle for sin */
N    uint16_t       u16CosDuty;                           /* PWM duty cycle for cos */
N} smc_pwmvalue_st;
N
Ntypedef struct tag_smc_zpdconfig_st
N{
N    uint8_t u8IndexIncrement;                            /* index increment */
N    uint8_t u8ScanningFrequency;                         /* scanning frequency */
N    uint8_t u8VoltageThreshold;                          /* voltage threshold */
N} smc_zpdconfig_st;
N
N/*********************************************/
N
N/**********************************************
N*            Forward declarations             *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      vSMC_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                     uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N/****************************************************************************
N *
N * Function:      boSMC_SetPrescaler
N *
N * Purpose:       write prescaler value to register
N *
N * Inputs:        u8Value - prescaler value
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE: OK
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boSMC_SetPrescaler(uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetPrescaler
N *
N * Purpose:       read prescaler value from register
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: prescaler value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetPrescaler(void);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetIntConfigReg
N *
N * Purpose:       reads configuration register access in user mode
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: SMC_ENABLE/SMC_DISABLE 
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_GetIntConfigReg(void);
N
N/****************************************************************************
N *
N * Function:      boSMC_GetIntSingle
N *
N * Purpose:       read interrupt for single motor
N *
N * Inputs:        eDevice  - SMC device
N *                eIntMask - Interrupt mask
N *
N * Outputs:       peEnable: pointer to get enabled or disabled
N *
N * Return Values: C_TRUE on success
N *                C_FALSE on invalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boSMC_GetIntSingle(smc_dev_e eDevice, smc_motint_types_e eIntMask, smc_enable_e* peEnable);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetIntAll
N *
N * Purpose:       read all interrupts
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: interrupt vector
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetIntAll(void);
N
N/****************************************************************************
N *
N * Function:      vSMC_ClearIntConfigReg
N *
N * Purpose:       clear configuraion register by user mode
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_ClearIntConfigReg(void);
N
N/****************************************************************************
N *
N * Function:      boSMC_ClearIntSingle
N *
N * Purpose:       clear single interrupt
N *
N * Inputs:        eDevice  - SMC device
N *                eIntType - Interrupt mask
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE on success
N *                C_FALSE on invalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boSMC_ClearIntSingle(smc_dev_e eDevice, smc_motint_types_e eIntType);
N
N/****************************************************************************
N *
N * Function:      vSMC_ClearIntAll
N *
N * Purpose:       clear all interrupts
N *
N * Inputs:        u32Value - clear value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_ClearIntAll(uint32_t u32Value);
N
N
N/****************************************************************************
N *
N * Function:      vSetIntConfReg
N *
N * Purpose:       set interrupt mask for config register by user mode
N *
N * Inputs:        eEnable  - Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSetIntConfReg(smc_enable_e eEnable);
N
N/****************************************************************************
N *
N * Function:      boSMC_SetIntMaskSingle
N *
N * Purpose:       set interrupt mask for single interrupt
N *
N * Inputs:        eDevice  - SMC device
N *                eIntType - Interrupt type
N *                eEnable  - Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE on success
N *                C_FALSE on invalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boSMC_SetIntMaskSingle(smc_dev_e eDevice, smc_motint_types_e eIntType, smc_enable_e eEnable);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetIntMaskAll
N *
N * Purpose:       set interrupt mask for all interrupts
N *
N * Inputs:        u32Mask - interrupt mask
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetIntMaskAll(uint32_t u32Mask);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetIntMaskAll
N *
N * Purpose:       get interrupt mask for all interrupts
N *
N * Inputs:        void 
N *
N * Outputs:       interrupt mask
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetIntMaskAll(void);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetChannelMode
N *
N * Purpose:       read operation mode type
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: channel mode
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_channel_mode_e eSMC_GetChannelMode(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetChannelMode
N *
N * Purpose:       set operation mode type
N *
N * Inputs:        eDevice - SMC device
N *                eMode   - channel mode
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetChannelMode(smc_dev_e eDevice, smc_channel_mode_e eMode);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetPinStatus
N *
N * Purpose:       read configuration for PWM-pin behavior
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: status of pins
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_GetPinStatus(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetPinStatus
N *
N * Purpose:       set configuration for PWM-pin behavior
N *
N * Inputs:        eDevice - SMC device
N *                eEnable - status
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetPinStatus(smc_dev_e eDevice, smc_enable_e eEnable);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetOutputDelayCycleCount
N *
N * Purpose:       read delay cycles on PWM-lines of different stepper motors 
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: number of delay cycles
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetOutputDelayCycleCount(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetOutputDelayCycleCount
N *
N * Purpose:       set delay cycle count on PWM-lines of different stepper
N *                motors 
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - number of delay cycles
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetOutputDelayCycleCount(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetPeriodExtension
N *
N * Purpose:       read period extension value
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: period extension value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetPeriodExtension(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetPeriodExtension
N *
N * Purpose:       set period extension value 
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - number extension cycles
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetPeriodExtension(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetSlewRate
N *
N * Purpose:       read slew rate value
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: slew rate value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetSlewRate(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetSlewRate
N *
N * Purpose:       set slew rate value
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - slew rate value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetSlewRate(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetISMDampingFactorK
N *
N * Purpose:       read damping factor K
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: damping factor K
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetISMDampingFactorK(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMDampingFactorK
N *
N * Purpose:       set damping factor K
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - damping factor K
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMDampingFactorK(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      vSMC_GetISMDampingFactorL
N *
N * Purpose:       read damping factor L
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: damping factor L
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetISMDampingFactorL(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMDampingFactorL
N *
N * Purpose:       set damping factor L
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - damping factor L
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMDampingFactorL(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetISMTableMode
N *
N * Purpose:       read table mode
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: table mode
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_ism_table_mode_e eSMC_GetISMTableMode(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMTableMode
N *
N * Purpose:       set table mode
N *
N * Inputs:        eDevice - SMC device
N *                eValue  - table mode
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMTableMode(smc_dev_e eDevice, smc_ism_table_mode_e eValue);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetISMTableIndex
N *
N * Purpose:       read table index
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: table index
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_table_index_e eSMC_GetISMTableIndex(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMTableIndex
N *
N * Purpose:       set table mode
N *
N * Inputs:        eDevice - SMC device
N *                eValue  - table index
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMTableIndex(smc_dev_e eDevice, smc_table_index_e eValue);
N
N/****************************************************************************
N *
N * Function:      eSMC_IsISMDampingCurveHardwareEnabled
N *
N * Purpose:       read status if damping curve hardware is enabled
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: status if damping curve hardware is enabled
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_IsISMDampingCurveHardwareEnabled(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_EnableISMDampingCurveHardware
N *
N * Purpose:       enable or disable damping curve hardware
N *
N * Inputs:        eDevice - SMC device
N *                eValue  - enable/disable damping curve hardware
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_EnableISMDampingCurveHardware(smc_dev_e eDevice, smc_enable_e eValue);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetISMReadRequestStatus
N *
N * Purpose:       read status of read request
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: read request status
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_GetISMReadRequestStatus(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMReadRequest
N *
N * Purpose:       enable or disable read request
N *
N * Inputs:        eDevice - SMC device
N *                eValue  - enable/disable read request
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMReadRequest(smc_dev_e eDevice, smc_enable_e eValue);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMReadRequest
N *
N * Purpose:       read flag, if read access is performed
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: status of read access flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_GetISMReadRequestFlagStatus(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetISMFreezeRequestStatus
N *
N * Purpose:       read status of freeze request
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: freeze request status
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_GetISMFreezeRequestStatus(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMFreezeRequest
N *
N * Purpose:       enable or disable freeze request
N *
N * Inputs:        eDevice - SMC device
N *                eValue  - enable/disable freeze request
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMFreezeRequest(smc_dev_e eDevice, smc_enable_e eValue);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetISMFreezeRequestFlagStatus
N *
N * Purpose:       read flag, if channel is frozen
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: status of freeze flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_enable_e eSMC_GetISMFreezeRequestFlagStatus(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      fSMC_GetISMPosition
N *
N * Purpose:       read current position value
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: position value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nfloat32_t fSMC_GetISMPosition(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetISMPosition
N *
N * Purpose:       write position value
N *
N * Inputs:        eDevice  - SMC device
N *                f32Value - position value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetISMPosition(smc_dev_e eDevice, float32_t f32Value);
N
N/****************************************************************************
N *
N * Function:      u16SMC_GetPWMCosDuty
N *
N * Purpose:       read PWM duty cycle for cos
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: PWM duty cycle for cos
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16SMC_GetPWMCosDuty(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetPWMCosDuty
N *
N * Purpose:       write PWM duty cycle for cos
N *
N * Inputs:        eDevice  - SMC device
N *                u16Value - PWM duty cycle for cos
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetPWMCosDuty(smc_dev_e eDevice, uint16_t u16Value);
N
N/****************************************************************************
N *
N * Function:      u16SMC_GetPWMSinDuty
N *
N * Purpose:       read PWM duty cycle for sin
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: PWM duty cycle for sin
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16SMC_GetPWMSinDuty(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetPWMSinDuty
N *
N * Purpose:       write PWM duty cycle for sin
N *
N * Inputs:        eDevice  - SMC device
N *                u16Value - PWM duty cycle for sin
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetPWMSinDuty(smc_dev_e eDevice, uint16_t u16Value);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetPWMQuadrant
N *
N * Purpose:       read quadrant used in PWM mode
N *
N * Inputs:        eDevice  - SMC device
N *
N * Outputs:       quadrant used in PWM mode
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_quadrant_e eSMC_GetPWMQuadrant(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetPWM32BitData
N *
N * Purpose:       sets quadrant, Sin and cos part of pwm value in one step
N *                NOTE: this API can be used to ensure all 3 parameters will
N *                       be set together, to avoid side effects by setting
N *                       separately.   
N *
N * Inputs:        eDevice  - SMC device
N *                wQuadr:  Selected Quandrant
N *                u16Sin:  Sinus part
N *                u16Cos:  Cosinus part                
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetPWM32BitData(smc_dev_e eDevice, smc_quadrant_e wQuadr, 
N                          uint16_t u16Sin, uint16_t u16Cos);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetPWMQuadrant
N *
N * Purpose:       write quadrant used in PWM mode
N *
N * Inputs:        eDevice - SMC device
N *                eValue  - quadrant used in PWM mode
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetPWMQuadrant(smc_dev_e eDevice, smc_quadrant_e eValue);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCAIntermediateAngle
N *
N * Purpose:       read intermediate angle
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: intermediate angle
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCAIntermediateAngle(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCAIntermediateAngle
N *
N * Purpose:       write intermediate angle
N *
N * Inputs:        eDevice  - SMC device
N *                f32Value - intermediate angle
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCAIntermediateAngle(smc_dev_e eDevice, float32_t f32Value);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCAActualAngle
N *
N * Purpose:       write actual angle
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: actual angle
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCAActualAngle(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCAActualAngle
N *
N * Purpose:       write actual angle
N *
N * Inputs:        eDevice  - SMC device
N *                f32Value - actual angle
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCAActualAngle(smc_dev_e eDevice, float32_t f32Value);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCAVelocity
N *
N * Purpose:       read velocity
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: velocity
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCAVelocity(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCAVelocity
N *
N * Purpose:       write velocity
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - velocity
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCAVelocity(smc_dev_e eDevice, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCAVelocityLimit
N *
N * Purpose:       read velocity linit
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: velocity linit
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCAVelocityLimit(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCAVelocityLimit
N *
N * Purpose:       write velocity
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - velocity limit
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCAVelocityLimit(smc_dev_e eDevice, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      f32SMC_GetDCAAcceleration
N *
N * Purpose:       read acceleration
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       acceleration
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nfloat32_t f32SMC_GetDCAAcceleration(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCAAccelerationLimit
N *
N * Purpose:       read acceleration limit
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: acceleration limit value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCAAccelerationLimit(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCAAcceleration
N *
N * Purpose:       read acceleration
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: acceleration value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCAAcceleration(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCAAccelerationLimit
N *
N * Purpose:       write acceleration limit
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - scceleration limit
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCAAccelerationLimit(smc_dev_e eDevice, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCADecelerationLimit
N *
N * Purpose:       read deceleration limit
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: deceleration limit
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCADecelerationLimit(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCADecelerationLimit
N *
N * Purpose:       write deceleration limit
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - deceleration limit
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCADecelerationLimit(smc_dev_e eDevice, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCASpeedThreshold1
N *
N * Purpose:       read speed threshold 1
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: speed threshold 1
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCASpeedThreshold1(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCASpeedThreshold1
N *
N * Purpose:       write speed threshold 1
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - speed threshold 1
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCASpeedThreshold1(smc_dev_e eDevice, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      u32SMC_GetDCASpeedThreshold2
N *
N * Purpose:       read speed threshold 2
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: speed threshold 2
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_GetDCASpeedThreshold2(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCASpeedThreshold2
N *
N * Purpose:       write speed threshold 2
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - speed threshold 2
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCASpeedThreshold2(smc_dev_e eDevice, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetDCATableDataSelection
N *
N * Purpose:       read table data selection value
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: table data selection value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_table_data_selection_e eSMC_GetDCATableDataSelection(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCATableDataSelection
N *
N * Purpose:       write table data selection value
N *
N * Inputs:        eDevice  - SMC device
N *                u32Value - table data selection value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCATableDataSelection(smc_dev_e eDevice, smc_table_data_selection_e eValue);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetDCATableDataDirection
N *
N * Purpose:       read table data direction value
N *
N * Inputs:        eDevice  - SMC device
N *
N * Outputs:       none
N *
N * Return Values: table data direction value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_table_data_direction_e eSMC_GetDCATableDataDirection(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDCATableDataDirection
N *
N * Purpose:       write table data direction value
N *
N * Inputs:        eDevice  - SMC device
N *                eValue   - Value 
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDCATableDataDirection(smc_dev_e eDevice, smc_table_data_direction_e eValue);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetZPDIndexIncrement
N *
N * Purpose:       read index increment to subdivide measurement period
N *
N * Inputs:        eDevice  - SMC device
N *
N * Outputs:       none
N *
N * Return Values: index increment
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetZPDIndexIncrement(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetZPDIndexIncrement
N *
N * Purpose:       write index increment to subdivide measurement period
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - index increment value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetZPDIndexIncrement(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      eSMC_GetZPDQuadrantZPDIsIn
N *
N * Purpose:       read quadrant where the zero point is in
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: quadrant where the zero point is in
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nsmc_quadrant_e eSMC_GetZPDQuadrantZPDIsIn(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetZPDScanningFrequency
N *
N * Purpose:       read scanning frequency for scan fscan
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: scanning frequency
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetZPDScanningFrequency(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetZPDScanningFrequency
N *
N * Purpose:       write scanning frequency for scan fscan
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - scanning frequency value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetZPDScanningFrequency(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u8SMC_GetZPDVoltageThreshold
N *
N * Purpose:       read voltage reference value
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: voltage reference value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8SMC_GetZPDVoltageThreshold(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetZPDVoltageThreshold
N *
N * Purpose:       write voltage reference value
N *
N * Inputs:        eDevice - SMC device
N *                u8Value - voltage reference value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetZPDVoltageThreshold(smc_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      vSMC_WriteZPDTable
N *
N * Purpose:       write ZPD-table values
N *
N * Inputs:        eDevice        - SMC device
N *                u8Length       - length of table
N *                u32TableValues - pointer to ZPD-table values
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_WriteZPDTable(smc_dev_e eDevice, uint8_t u8Length, const uint32_t * u32TableValues);
N
N/****************************************************************************
N *
N * Function:      vSMC_WriteISMTable
N *
N * Purpose:       write ISM-table values
N *
N * Inputs:        u32TableValues - pointer to ZPD-table values
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_WriteISMTable(const uint32_t * u32TableValues);
N
N/****************************************************************************
N *
N * Function:      f32SMC_GetDegreePerFullstep
N *
N * Purpose:       Get internal value for rotation angle in degree for one
N *                full step
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: rotation angle in degree for one full step
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nfloat32_t f32SMC_GetDegreePerFullstep(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SetDegreePerFullstep
N *
N * Purpose:       set internal value for rotation angle in degree for one
N *                full step
N *
N * Inputs:        eDevice  - SMC device
N *                f32Value - rotation angle in degree for one full step
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SetDegreePerFullstep(smc_dev_e eDevice, float32_t f32Value);
N
N/****************************************************************************
N *
N * Function:      vSMC_GeneralConfig
N *
N * Purpose:       configure general settings of SMC IP
N *
N * Inputs:        eDevice         - SMC device
N *                pstGeneralConfig - pointer to configuration structure
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_GeneralConfig(smc_dev_e eDevice, const smc_generalconfig_st * pstGeneralConfig);
N
N/****************************************************************************
N *
N * Function:      vSMC_IsmConfig
N *
N * Purpose:       configure ISM mode of SMC IP
N *
N * Inputs:        eDevice     - SMC device
N *                pstIsmConfig - pointer to configuration structure
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_IsmConfig(smc_dev_e eDevice, const smc_ismconfig_st * pstIsmConfig);
N
N/****************************************************************************
N *
N * Function:      vSMC_PwmConfig
N *
N * Purpose:       configure PWM mode of SMC IP
N *
N * Inputs:        eDevice     - SMC device
N *                pstPwmConfig - pointer to configuration structure
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_PwmConfig(smc_dev_e eDevice, const smc_pwmvalue_st * pstPwmConfig);
N
N/****************************************************************************
N *
N * Function:      vSMC_ZPDConfig
N *
N * Purpose:       configure ZPD mode of SMC IP
N *
N * Inputs:        eDevice     - SMC device
N *                pstZpdConfig - pointer to configuration structure
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_ZPDConfig(smc_dev_e eDevice, const smc_zpdconfig_st * pstZpdConfig);
N
N/****************************************************************************
N *
N * Function:      boSMC_WaitForZPDEnd
N *
N * Purpose:       wait for ZPD interrupt
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE on success
N *                C_FALSE on invalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boSMC_WaitForZPDEnd(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      boSMC_MoveToZeroPosition
N *
N * Purpose:       rotate motor to zero position
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE on success
N *                C_FALSE on invalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boSMC_MoveToZeroPosition(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_ISMUpdateVariablesBeforeRead
N *
N * Purpose:       Update ISM-variables before read access
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_ISMUpdateVariablesBeforeRead(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      vSMC_SwitchFromZPDToISM
N *
N * Purpose:       switch from ZPD to ISM mode
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSMC_SwitchFromZPDToISM(smc_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      u32SMC_SwitchFromZPDToPWM
N *
N * Purpose:       switch from ZPD to PWM mode
N *
N * Inputs:        eDevice - SMC device
N *
N * Outputs:       none
N *
N * Return Values: quadrant
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32SMC_SwitchFromZPDToPWM(smc_dev_e eDevice);
N
N/****************************************************************************/
N
N
N#endif /* SMC_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\smc.c" 2
N
N/*********************************************/
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */  
S  #pragma ghs nowarning 1834  /* Rule 11.3 [A] : disable casting error (used for result of i/o header amcros) */
S  #pragma ghs nowarning 1835  /* Rule 11.4 [A] : allow cast from type "type" to type "type" */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S  #pragma ghs nowarning 1877  /* Rule 11-3 [A] : cast of 0 from type "type" to type "type" not allowed */
S  #pragma ghs nowarning 1853  /* Rule 12.6 [A] : effectively boolean expression required */
S  #pragma ghs nowarning 1855  /* Rule 13.2 [A] : Explicit test of a value against zero unless the expression is Boolean */
S  
S  #pragma ghs nowarning 1752  /* Rule 17.4 [R] : disable "pointer arithmetic not allowed"  for usage of io header files */
S  #pragma ghs nowarning 1847  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to non-integer type "type" not allowed */
S  #pragma ghs nowarning 1848  /* Rule 10.4 [R] : cast of complex floating point expression from type "type" to type "type" not allowed */
S  #pragma ghs nowarning 1849  /* Rule 8.1  [R] : bitwise ~ or << expression must be immediately cast back to  underlying type, "unsigned char" */
S  #pragma ghs nowarning 1867  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
N#endif
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_SMC_C_REVISION     "$Revision: 1.13 $"
N#define LLDD_SMC_C_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/ 
N
Nstatic uint8_t au8LLDD_SMC_C_REVISION[]    = LLDD_SMC_C_REVISION;
Xstatic uint8_t au8LLDD_SMC_C_REVISION[]    = "$Revision: 1.13 $";
Nstatic uint8_t au8LLDD_SMC_C_TAG[]         = LLDD_SMC_C_TAG;
Xstatic uint8_t au8LLDD_SMC_C_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_SMC_H_REVISION[]    = LLDD_SMC_H_REVISION;
Xstatic uint8_t au8LLDD_SMC_H_REVISION[]    = "$Revision: 1.14 $";
Nstatic uint8_t au8LLDD_SMC_H_TAG[]         = LLDD_SMC_H_TAG;
Xstatic uint8_t au8LLDD_SMC_H_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_SMC_IO_H_REVISION[] = LLDD_SMC_IO_H_REVISION;
Xstatic uint8_t au8LLDD_SMC_IO_H_REVISION[] = "$Revision: 1.10 $";
Nstatic uint8_t au8LLDD_SMC_IO_H_TAG[]      = LLDD_SMC_IO_H_TAG;
Xstatic uint8_t au8LLDD_SMC_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N/*********************************************/
Nstatic float32_t f32DegreePerFullstepVal[5];
Nstatic smc_ism_table_mode_e eTableModeVal[5];
N
Nstatic float32_t f32ISMQuadrantOffset[5] = {(float32_t)0.0, (float32_t)0.0, (float32_t)0.0, (float32_t)0.0, (float32_t)0.0};
N
Nstatic float32_t f32RegToFloat(uint32_t u32Value, float32_t f32DegreePerFullstepLocal, smc_ism_table_mode_e eTableModeLocal);
Nstatic uint32_t u32SMC_FloatToReg(float32_t f32Value, float32_t f32DegreePerFullstepLocal, smc_ism_table_mode_e eTableModeLocal);
N
N/**********************************************
N*             Function definition             *
N**********************************************/
N
Nvoid vSMC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                     uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N   *pau8ModuleRevision = &au8LLDD_SMC_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_SMC_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_SMC_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_SMC_H_TAG[0];
N   *pau8IORevision     = &au8LLDD_SMC_IO_H_REVISION[0];
N   *pau8IOTag          = &au8LLDD_SMC_IO_H_TAG[0];
N}
N
N/****************************************************************************/
N
Nbool_t boSMC_SetPrescaler(uint8_t u8Value)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    if ( (u8Value >= ((uint8_t)SMC_SCLFAK_MIN)) && (u8Value <= ((uint8_t)SMC_SCLFAK_MAX)) )
X    if ( (u8Value >= ((uint8_t)1)) && (u8Value <= ((uint8_t)10)) )
N    {
N        vSetSMCCLK_CTRL_PRE_SCALE(u8Value);
X        (((volatile SMCCLK_CTRL_bit_view_st *)(0xC0300000U )) -> PRE_SCALE=(u8Value));
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    return boRes;
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetPrescaler(void)
N{
N   return biGetSMCCLK_CTRL_PRE_SCALE();
X   return (((volatile SMCCLK_CTRL_bit_view_st *)(0xC0300000U )) -> PRE_SCALE);
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_GetIntConfigReg(void)
N{
N    smc_enable_e eResult;
N    
N    eResult = ( 0x01U == biGetSMCINT_CRAUM() ) ? SMC_ENABLE : SMC_DISABLE;
X    eResult = ( 0x01U == (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> CRAUM) ) ? SMC_ENABLE : SMC_DISABLE;
N    
N    return eResult;
N}
N
N/****************************************************************************/
N
Nbool_t boSMC_GetIntSingle(smc_dev_e eDevice, smc_motint_types_e eIntMask, smc_enable_e* peEnable)
N{
N    bool_t  boResult = C_TRUE;
X    bool_t  boResult = (1);
N    uint8_t u8Value;
N   
N    if (( C_NULL != peEnable) && (eDevice <= SMC4) )
X    if (( ((void*)0) != peEnable) && (eDevice <= SMC4) )
N    {
N        switch(eIntMask)
N        {
N            case SMC_INT_PPE:
N                {
N                    u8Value = (uint8_t) biGetSMCINT_PPE();
X                    u8Value = (uint8_t) (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> PPE);
N                }
N                break;
N            case SMC_INT_MOW_END:
N                {
N                    u8Value = (uint8_t) biGetSMCINT_MOV_END(); 
X                    u8Value = (uint8_t) (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> MOV_END); 
N                }
N                break;
N            case SMC_INT_ZPD:
N                {
N                    u8Value = (uint8_t) biGetSMCINT_ZPDD();
X                    u8Value = (uint8_t) (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> ZPDD);
N                }
N                break;
N            default:
N                {
N                    boResult = C_FALSE;
X                    boResult = (0);
N                }
N		            break;
N        }
N   }
N
N   if (C_TRUE == boResult)
X   if ((1) == boResult)
N   {
N       *peEnable = ( (0x01U<<eDevice)& u8Value) ? SMC_ENABLE : SMC_DISABLE;
N   }
N   return boResult;
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetIntAll(void)
N{
N    return u32GetSMCINT();
X    return (*((volatile u32SMCINT_word_view *)(0xC0300004U )) );
N}
N
N/****************************************************************************/
Nvoid vSMC_ClearIntConfigReg(void)
N{
N    vClrSMCINT_CRAUM();
X    (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> CRAUM = (0x1U));
N}
N
N/****************************************************************************/
Nbool_t boSMC_ClearIntSingle(smc_dev_e eDevice, smc_motint_types_e eIntType)
N{
N    bool_t  boResult = C_TRUE;
X    bool_t  boResult = (1);
N    
N    if (eDevice <= SMC4)
N    {
N        switch(eIntType)
N        {
N            case SMC_INT_PPE:
N                vClrSMCINT_PPE((uint8_t)eDevice);
X                (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> PPE = ( (0x01U << ((uint8_t)eDevice)) & 0x1FU) );
N                break;
N
N            case SMC_INT_MOW_END:
N                vClrSMCINT_MOV_END((uint8_t)eDevice);
X                (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> MOV_END = ( (0x01U << ((uint8_t)eDevice)) & 0x1FU) );
N                break;
N
N            case SMC_INT_ZPD:
N                vClrSMCINT_ZPDD((uint8_t)eDevice);
X                (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> ZPDD =( (0x01U << ((uint8_t)eDevice)) & 0x1FU) );
N                break;
N
N            default:
N                boResult = C_FALSE;
X                boResult = (0);
N		            break;
N        }
N    }
N    else
N    {
N        boResult = C_FALSE;
X        boResult = (0);
N    }
N     return boResult;
N}
N 
N/****************************************************************************/
N 
Nvoid vSMC_ClearIntAll(uint32_t u32Value)
N{
N    vSetSMCINT(u32Value);
X    (*((volatile u32SMCINT_word_view *)(0xC0300004U )) = (u32Value));
N}
N
N/****************************************************************************/
Nvoid vSetIntConfReg(smc_enable_e eEnable)
N{
N    vSetSMCINT_MASK_MASK_CRAUM((uint32_t)eEnable);
X    (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_CRAUM=((uint32_t)eEnable));
N}
N
N/****************************************************************************/
N
Nbool_t boSMC_SetIntMaskSingle(smc_dev_e eDevice, smc_motint_types_e eIntType, smc_enable_e eEnable)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    uint32_t u32Mask;
N    if (eDevice <= SMC4 )
N    {
N        switch(eIntType)
N        {
N            case SMC_INT_PPE:
N                /* read bit fields: */
N                u32Mask = (uint32_t)biGetSMCINT_MASK_MASK_PPE();
X                u32Mask = (uint32_t)(((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_PPE);
N                if (SMC_ENABLE == eEnable)
N                {
N                    /* set related bit: */
N                    u32Mask |= ((uint32_t)0x01U << (uint8_t)eDevice);
N                }
N                else
N                {
N                    /* reset related bit: */
N                    u32Mask &= (~((uint32_t)0x01U << (uint8_t)eDevice));
N                }
N                /* write back bit fields: */
N                vSetSMCINT_MASK_MASK_PPE(u32Mask);
X                (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_PPE=(u32Mask));
N                break;
N                
N            case SMC_INT_MOW_END:
N                u32Mask = biGetSMCINT_MASK_MASK_MOV_END();
X                u32Mask = (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_MOV_END);
N                if (SMC_ENABLE == eEnable)
N                {
N                    /* set related bit: */
N                    u32Mask |= ((uint32_t)0x01U << (uint8_t)eDevice);
N                }
N                else
N                {
N                    /* reset related bit: */
N                    u32Mask &= (~((uint32_t)0x01U << (uint8_t)eDevice));
N                }
N                vSetSMCINT_MASK_MASK_MOV_END(u32Mask);
X                (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_MOV_END=(u32Mask));
N                break;
N                
N            case SMC_INT_ZPD:
N                u32Mask = biGetSMCINT_MASK_MASK_ZPDD();
X                u32Mask = (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_ZPDD);
N                if (SMC_ENABLE == eEnable)
N                {
N                    /* set related bit: */
N                    u32Mask |= ((uint32_t)0x01U << (uint8_t)eDevice);
N                }
N                else
N                {
N                    /* reset related bit: */
N                    u32Mask &= (~((uint32_t)0x01U << (uint8_t)eDevice));
N                }
N               vSetSMCINT_MASK_MASK_ZPDD(u32Mask);
X               (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_ZPDD=(u32Mask));
N                break;
N
N            default:
N                boRes = C_FALSE;
X                boRes = (0);
N		            break;
N        }
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N
N
N    return boRes;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetIntMaskAll(uint32_t u32Mask)
N{
N   vSetSMCINT_MASK(u32Mask);
X   (*((volatile u32SMCINT_MASK_word_view *)(0xC0300008U )) = (u32Mask));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetIntMaskAll(void)
N{
N    return u32GetSMCINT_MASK();
X    return (*((volatile u32SMCINT_MASK_word_view *)(0xC0300008U )) );
N}
N
N/****************************************************************************/
N
Nsmc_channel_mode_e eSMC_GetChannelMode(smc_dev_e eDevice)
N{
N   return (smc_channel_mode_e)biGetSMCCTRL_MSEL(eDevice);
X   return (smc_channel_mode_e)(((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> MSEL);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetChannelMode(smc_dev_e eDevice, smc_channel_mode_e eMode)
N{
N   vSetSMCCTRL_MSEL(eDevice, (uint32_t)eMode);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> MSEL=((uint32_t)eMode));
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_GetPinStatus(smc_dev_e eDevice)
N{
N   return (smc_enable_e)biGetSMCCTRL_OUTEN(eDevice);
X   return (smc_enable_e)(((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> OUTEN);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetPinStatus(smc_dev_e eDevice, smc_enable_e eEnable)
N{
N   vSetSMCCTRL_OUTEN(eDevice, (uint32_t)eEnable);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> OUTEN=((uint32_t)eEnable));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetOutputDelayCycleCount(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCCTRL_DELAY_CYCLES(eDevice));
X   return ((uint8_t)(((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> DELAY_CYCLES));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetOutputDelayCycleCount(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCCTRL_DELAY_CYCLES(eDevice, u8Value);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> DELAY_CYCLES=(u8Value));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetPeriodExtension(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCCTRL_PERIOD_EXT(eDevice));
X   return ((uint8_t)(((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> PERIOD_EXT));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetPeriodExtension(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCCTRL_PERIOD_EXT(eDevice, u8Value);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> PERIOD_EXT=(u8Value));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetSlewRate(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCCTRL_SLEW_RATE(eDevice));
X   return ((uint8_t)(((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> SLEW_RATE));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetSlewRate(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCCTRL_SLEW_RATE(eDevice, u8Value);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> SLEW_RATE=(u8Value));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetISMDampingFactorK(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCISM_CTRL_DAMP_K(eDevice));
X   return ((uint8_t)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DAMP_K));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMDampingFactorK(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCISM_CTRL_DAMP_K(eDevice, u8Value);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DAMP_K=(u8Value));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetISMDampingFactorL(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCISM_CTRL_DAMP_L(eDevice));
X   return ((uint8_t)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DAMP_L));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMDampingFactorL(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCISM_CTRL_DAMP_L(eDevice, u8Value);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DAMP_L=(u8Value));
N}
N
N/****************************************************************************/
N
Nsmc_ism_table_mode_e eSMC_GetISMTableMode(smc_dev_e eDevice)
N{
N   return (smc_ism_table_mode_e)biGetSMCISM_CTRL_ISM_TABLE_MODE(eDevice);
X   return (smc_ism_table_mode_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> ISM_TABLE_MODE);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMTableMode(smc_dev_e eDevice, smc_ism_table_mode_e eValue)
N{
N   eTableModeVal[eDevice] = eValue;
N   vSetSMCISM_CTRL_ISM_TABLE_MODE(eDevice, (uint32_t)eValue);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> ISM_TABLE_MODE=((uint32_t)eValue));
N}
N
N/****************************************************************************/
N
Nsmc_table_index_e eSMC_GetISMTableIndex(smc_dev_e eDevice)
N{
N   return (smc_table_index_e)biGetSMCISM_CTRL_TABLE_IDX(eDevice);
X   return (smc_table_index_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> TABLE_IDX);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMTableIndex(smc_dev_e eDevice, smc_table_index_e eValue)
N{
N   vSetSMCISM_CTRL_TABLE_IDX(eDevice, (uint32_t)eValue);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> TABLE_IDX=((uint32_t)eValue));
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_IsISMDampingCurveHardwareEnabled(smc_dev_e eDevice)
N{
N   /*return (smc_enable_e)(1-biGetSMCISM_CTRL_DIS_DAMP(eDevice));*/
N   return ( SMC_ENABLE==((smc_enable_e)biGetSMCISM_CTRL_DIS_DAMP(eDevice)) ) ? SMC_DISABLE : SMC_ENABLE;
X   return ( SMC_ENABLE==((smc_enable_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DIS_DAMP)) ) ? SMC_DISABLE : SMC_ENABLE;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_EnableISMDampingCurveHardware(smc_dev_e eDevice, smc_enable_e eValue)
N{
N   vSetSMCISM_CTRL_DIS_DAMP(eDevice, ((eValue == SMC_ENABLE)? (uint32_t)SMC_DISABLE : (uint32_t)SMC_ENABLE));
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DIS_DAMP=(((eValue == SMC_ENABLE)? (uint32_t)SMC_DISABLE : (uint32_t)SMC_ENABLE)));
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_GetISMReadRequestStatus(smc_dev_e eDevice)
N{
N   return (smc_enable_e)biGetSMCISM_CTRL_RD_REQ(eDevice);
X   return (smc_enable_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> RD_REQ);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMReadRequest(smc_dev_e eDevice, smc_enable_e eValue)
N{
N   vSetSMCISM_CTRL_RD_REQ(eDevice, (uint32_t)eValue);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> RD_REQ=((uint32_t)eValue));
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_GetISMReadRequestFlagStatus(smc_dev_e eDevice)
N{
N   return (smc_enable_e)biGetSMCISM_CTRL_RD_FLAG(eDevice);
X   return (smc_enable_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> RD_FLAG);
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_GetISMFreezeRequestStatus(smc_dev_e eDevice)
N{
N   return (smc_enable_e)biGetSMCISM_CTRL_FREEZE_REQ(eDevice);
X   return (smc_enable_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> FREEZE_REQ);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMFreezeRequest(smc_dev_e eDevice, smc_enable_e eValue)
N{
N   vSetSMCISM_CTRL_FREEZE_REQ(eDevice, (uint32_t)eValue);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> FREEZE_REQ=((uint32_t)eValue));
N}
N
N/****************************************************************************/
N
Nsmc_enable_e eSMC_GetISMFreezeRequestFlagStatus(smc_dev_e eDevice)
N{
N   return (smc_enable_e)biGetSMCISM_CTRL_FREEZE_FLAG(eDevice);
X   return (smc_enable_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> FREEZE_FLAG);
N}
N
N/****************************************************************************/
N
Nstatic float32_t f32RegToFloat(uint32_t u32Value, float32_t f32DegreePerFullstepLocal, smc_ism_table_mode_e eTableModeLocal)
N{
N    float32_t fInteger;
N    float32_t fFraction;
N    float32_t fValue;
N    uint32_t  u32MoveIntegerPart = 13U;
N    float32_t f32ScaleFractionalPart = (float32_t)8192.0;
N    uint32_t  u32IntMask = 0x3FFU;
N    uint32_t  u32FracMask = 0x1FFFU;
N
N    if (eTableModeLocal == SMC_ISM_TABLE_MODE_PRECISE)
N    {
N        u32MoveIntegerPart = 15U;
N        f32ScaleFractionalPart = (float32_t)32768.0;
N        u32IntMask = 0xFFU;
N        u32FracMask = 0x7FFFU;
N    }
N
N    fInteger = (float32_t)((u32Value >> u32MoveIntegerPart) & u32IntMask);
N    fFraction = (float32_t)(u32Value & u32FracMask);
N    fValue = fInteger + (fFraction/f32ScaleFractionalPart);
N    if ((u32Value & 0x01000000U) > 0U)
N    {
N        fValue = (float32_t)(-1.0) * fValue;
N    }
N
N    return (f32DegreePerFullstepLocal * fValue);
N}
N
N/****************************************************************************/
N
Nstatic uint32_t u32SMC_FloatToReg(float32_t f32Value, float32_t f32DegreePerFullstepLocal, smc_ism_table_mode_e eTableModeLocal)
N{
N    uint32_t  u32Sign = 0U;
N    uint32_t  u32IntegerPart;
N    uint32_t  u32FractionalPart;
N    uint32_t  u32Value;
N    uint32_t  u32MoveIntegerPart = 13U;
N    float32_t f32ScaleFractionalPart = (float32_t)8192.0;
N
N    if (eTableModeLocal == SMC_ISM_TABLE_MODE_PRECISE)
N    {
N        u32MoveIntegerPart = 15U;
N        f32ScaleFractionalPart = (float32_t)32768.0;
N    }
N    if (f32Value < 0.0)
N    {
N        u32Sign  = 1U;
N        f32Value = (float32_t)-1.0 * f32Value;
N    }
N    f32Value          = f32Value / f32DegreePerFullstepLocal;
N    u32IntegerPart    = (uint32_t)f32Value;
N    u32FractionalPart = (uint32_t)(f32ScaleFractionalPart * (f32Value - (float32_t)u32IntegerPart));
N    u32Value          = (u32Sign << 24) + (u32IntegerPart << u32MoveIntegerPart) + u32FractionalPart;
N
N    return u32Value;
N}
N
N/****************************************************************************/
N
Nfloat32_t fSMC_GetISMPosition(smc_dev_e eDevice)
N{
N    float32_t fValue;
N    uint32_t u32Value;
N
N    u32Value = u32GetSMCPOS_Dest(eDevice);
X    u32Value = (*((volatile u32SMCPOS_Dest_word_view *)(0xC0300034U + ((uint16_t)(eDevice) * 0x4U))) );
N
N    fValue = f32RegToFloat((uint32_t)((float32_t)u32Value - f32ISMQuadrantOffset[eDevice]), f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
N
N    return fValue;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetISMPosition(smc_dev_e eDevice, float32_t f32Value)
N{
N    uint32_t u32Value;
N
N    u32Value = u32SMC_FloatToReg(f32Value + f32ISMQuadrantOffset[eDevice], f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
N
N    vSetSMCPOS_Dest(eDevice, u32Value);
X    (*((volatile u32SMCPOS_Dest_word_view *)(0xC0300034U + ((uint16_t)(eDevice) * 0x4U))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nuint16_t u16SMC_GetPWMCosDuty(smc_dev_e eDevice)
N{
N    return ((uint16_t)biGetSMCPWM_COSDUTY(eDevice));
X    return ((uint16_t)(((volatile SMCPWM_bit_view_st *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) -> COSDUTY));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetPWMCosDuty(smc_dev_e eDevice, uint16_t u16Value)
N{
N    vSetSMCPWM_COSDUTY(eDevice, u16Value);
X    (((volatile SMCPWM_bit_view_st *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) -> COSDUTY=(u16Value));
N}
N
N/****************************************************************************/
N
Nuint16_t u16SMC_GetPWMSinDuty(smc_dev_e eDevice)
N{
N    return ((uint16_t)biGetSMCPWM_SINDUTY(eDevice));
X    return ((uint16_t)(((volatile SMCPWM_bit_view_st *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) -> SINDUTY));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetPWMSinDuty(smc_dev_e eDevice, uint16_t u16Value)
N{
N    vSetSMCPWM_SINDUTY(eDevice, u16Value);
X    (((volatile SMCPWM_bit_view_st *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) -> SINDUTY=(u16Value));
N}
N
N/****************************************************************************/
N
Nsmc_quadrant_e eSMC_GetPWMQuadrant(smc_dev_e eDevice)
N{
N    return (smc_quadrant_e)biGetSMCPWM_QUADR(eDevice);
X    return (smc_quadrant_e)(((volatile SMCPWM_bit_view_st *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) -> QUADR);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetPWM32BitData(smc_dev_e eDevice, smc_quadrant_e wQuadr, 
N                          uint16_t u16Sin, uint16_t u16Cos)
N{
N   uint32_t u32Value;
N
N   u32Value = ((uint32_t) wQuadr << 20) | (u16Sin<<10) | u16Cos;
N   vSetSMCPWM(eDevice, u32Value);
X   (*((volatile u32SMCPWM_word_view *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetPWMQuadrant(smc_dev_e eDevice, smc_quadrant_e eValue)
N{
N   vSetSMCPWM_QUADR(eDevice, (uint32_t)eValue);
X   (((volatile SMCPWM_bit_view_st *)(0xC0300048U + ((uint16_t)(eDevice) * 0x4U))) -> QUADR=((uint32_t)eValue));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCAIntermediateAngle(smc_dev_e eDevice)
N{
N    float32_t fValue;
N    uint32_t u32Value;
N
N    u32Value = biGetSMCDCA_PT1_PT1(eDevice);
X    u32Value = (((volatile SMCDCA_PT1_bit_view_st *)(0xC030005CU + ((uint16_t)(eDevice) * 0x4U))) -> PT1);
N
N    fValue = f32RegToFloat(u32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
N
N    return (uint32_t)fValue;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCAIntermediateAngle(smc_dev_e eDevice, float32_t f32Value)
N{
N    uint32_t u32Value;
N
N    u32Value = u32SMC_FloatToReg(f32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
N
N    vSetSMCDCA_PT1_PT1(eDevice, u32Value);
X    (((volatile SMCDCA_PT1_bit_view_st *)(0xC030005CU + ((uint16_t)(eDevice) * 0x4U))) -> PT1=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCAActualAngle(smc_dev_e eDevice)
N{
N    float32_t fValue;
N    uint32_t u32Value;
N
N    u32Value = biGetSMCDCA_PT2_PT2(eDevice);
X    u32Value = (((volatile SMCDCA_PT2_bit_view_st *)(0xC0300070U + ((uint16_t)(eDevice) * 0x4U))) -> PT2);
N
N    fValue = f32RegToFloat(u32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
N
N    return (uint32_t)fValue;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCAActualAngle(smc_dev_e eDevice, float32_t f32Value)
N{
N    uint32_t u32Value;
N
N    u32Value = u32SMC_FloatToReg(f32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
N
N    vSetSMCDCA_PT2_PT2(eDevice, u32Value);
X    (((volatile SMCDCA_PT2_bit_view_st *)(0xC0300070U + ((uint16_t)(eDevice) * 0x4U))) -> PT2=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCAVelocity(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_V_OLD_V_OLD(eDevice);
X    return (((volatile SMCDCA_V_OLD_bit_view_st *)(0xC0300084U + ((uint16_t)(eDevice) * 0x4U))) -> V_OLD);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCAVelocity(smc_dev_e eDevice, uint32_t u32Value)
N{
N    vSetSMCDCA_V_OLD_V_OLD(eDevice, u32Value);
X    (((volatile SMCDCA_V_OLD_bit_view_st *)(0xC0300084U + ((uint16_t)(eDevice) * 0x4U))) -> V_OLD=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCAVelocityLimit(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_V_MAX_V_MAX(eDevice);
X    return (((volatile SMCDCA_V_MAX_bit_view_st *)(0xC0300098U + ((uint16_t)(eDevice) * 0x4U))) -> V_MAX);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCAVelocityLimit(smc_dev_e eDevice, uint32_t u32Value)
N{
N    vSetSMCDCA_V_MAX_V_MAX(eDevice, u32Value);
X    (((volatile SMCDCA_V_MAX_bit_view_st *)(0xC0300098U + ((uint16_t)(eDevice) * 0x4U))) -> V_MAX=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCAAcceleration(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_ACC_ACC(eDevice);
X    return (((volatile SMCDCA_ACC_bit_view_st *)(0xC03000ACU + ((uint16_t)(eDevice) * 0x4U))) -> ACC);
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCAAccelerationLimit(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_A_MAX_A_MAX(eDevice);
X    return (((volatile SMCDCA_A_MAX_bit_view_st *)(0xC03000C0U + ((uint16_t)(eDevice) * 0x4U))) -> A_MAX);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCAAccelerationLimit(smc_dev_e eDevice, uint32_t u32Value)
N{
N    vSetSMCDCA_A_MAX_A_MAX(eDevice, u32Value);
X    (((volatile SMCDCA_A_MAX_bit_view_st *)(0xC03000C0U + ((uint16_t)(eDevice) * 0x4U))) -> A_MAX=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCADecelerationLimit(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_D_MAX_D_MAX(eDevice);
X    return (((volatile SMCDCA_D_MAX_bit_view_st *)(0xC03000D4U + ((uint16_t)(eDevice) * 0x4U))) -> D_MAX);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCADecelerationLimit(smc_dev_e eDevice, uint32_t u32Value)
N{
N    vSetSMCDCA_D_MAX_D_MAX(eDevice, u32Value);
X    (((volatile SMCDCA_D_MAX_bit_view_st *)(0xC03000D4U + ((uint16_t)(eDevice) * 0x4U))) -> D_MAX=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCASpeedThreshold1(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_V1_V1TH(eDevice);
X    return (((volatile SMCDCA_V1_bit_view_st *)(0xC03000E8U + ((uint16_t)(eDevice) * 0x4U))) -> V1TH);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCASpeedThreshold1(smc_dev_e eDevice, uint32_t u32Value)
N{
N    vSetSMCDCA_V1_V1TH(eDevice, u32Value);
X    (((volatile SMCDCA_V1_bit_view_st *)(0xC03000E8U + ((uint16_t)(eDevice) * 0x4U))) -> V1TH=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_GetDCASpeedThreshold2(smc_dev_e eDevice)
N{
N    return biGetSMCDCA_V2_V2TH(eDevice);
X    return (((volatile SMCDCA_V2_bit_view_st *)(0xC03000FCU + ((uint16_t)(eDevice) * 0x4U))) -> V2TH);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCASpeedThreshold2(smc_dev_e eDevice, uint32_t u32Value)
N{
N    vSetSMCDCA_V2_V2TH(eDevice, u32Value);
X    (((volatile SMCDCA_V2_bit_view_st *)(0xC03000FCU + ((uint16_t)(eDevice) * 0x4U))) -> V2TH=(u32Value));
N}
N
N/****************************************************************************/
N
Nsmc_table_data_selection_e eSMC_GetDCATableDataSelection(smc_dev_e eDevice)
N{
N   return (smc_table_data_selection_e)biGetSMCDCA_TS_TS_SEL(eDevice);
X   return (smc_table_data_selection_e)(((volatile SMCDCA_TS_bit_view_st *)(0xC0300110U + ((uint16_t)(eDevice) * 0x4U))) -> TS_SEL);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCATableDataSelection(smc_dev_e eDevice, smc_table_data_selection_e eValue)
N{
N   vSetSMCDCA_TS_TS_SEL(eDevice, (uint16_t)eValue);
X   (((volatile SMCDCA_TS_bit_view_st *)(0xC0300110U + ((uint16_t)(eDevice) * 0x4U))) -> TS_SEL=((uint16_t)eValue));
N}
N
N/****************************************************************************/
N
Nsmc_table_data_direction_e eSMC_GetDCATableDataDirection(smc_dev_e eDevice)
N{
N   return (smc_table_data_direction_e)biGetSMCDCA_TS_TD_SEL(eDevice);
X   return (smc_table_data_direction_e)(((volatile SMCDCA_TS_bit_view_st *)(0xC0300110U + ((uint16_t)(eDevice) * 0x4U))) -> TD_SEL);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetDCATableDataDirection(smc_dev_e eDevice, smc_table_data_direction_e eValue)
N{
N   vSetSMCDCA_TS_TD_SEL(eDevice, (uint16_t)eValue);
X   (((volatile SMCDCA_TS_bit_view_st *)(0xC0300110U + ((uint16_t)(eDevice) * 0x4U))) -> TD_SEL=((uint16_t)eValue));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetZPDIndexIncrement(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCZPD_CTRL_IDX_INC_N(eDevice));
X   return ((uint8_t)(((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> IDX_INC_N));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetZPDIndexIncrement(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCZPD_CTRL_IDX_INC_N(eDevice, u8Value);
X   (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> IDX_INC_N=(u8Value));
N}
N
N/****************************************************************************/
N
Nsmc_quadrant_e eSMC_GetZPDQuadrantZPDIsIn(smc_dev_e eDevice)
N{
N   return (smc_quadrant_e)biGetSMCZPD_CTRL_QUAD(eDevice);
X   return (smc_quadrant_e)(((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> QUAD);
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetZPDScanningFrequency(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCZPD_CTRL_FREQ_N(eDevice));
X   return ((uint8_t)(((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> FREQ_N));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetZPDScanningFrequency(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCZPD_CTRL_FREQ_N(eDevice, u8Value);
X   (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> FREQ_N=(u8Value));
N}
N
N/****************************************************************************/
N
Nuint8_t u8SMC_GetZPDVoltageThreshold(smc_dev_e eDevice)
N{
N   return ((uint8_t)biGetSMCZPD_CTRL_VOLT_REF(eDevice));
X   return ((uint8_t)(((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> VOLT_REF));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SetZPDVoltageThreshold(smc_dev_e eDevice, uint8_t u8Value)
N{
N   vSetSMCZPD_CTRL_VOLT_REF(eDevice, u8Value);
X   (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> VOLT_REF=(u8Value));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_WriteZPDTable(smc_dev_e eDevice, uint8_t u8Length, const uint32_t * u32TableValues)
N{
N   uint32_t u32Counter;
N   
N   for (u32Counter=0U; u32Counter<(uint32_t)u8Length; u32Counter++)
N   {
N      vSetSMCZPD_TABLE( (32U*(uint32_t)eDevice) + u32Counter, *(u32TableValues+u32Counter));
X      (*((volatile u32SMCZPD_TABLE_word_view *)(0xC0300C00U + ((uint16_t)((32U*(uint32_t)eDevice) + u32Counter) * 0x4U))) = (*(u32TableValues+u32Counter)));
N   }
N}
N
N/****************************************************************************/
N
Nvoid vSMC_WriteISMTable(const uint32_t * u32TableValues)
N{
N   uint32_t u32Counter;
N   
N   for (u32Counter=0U; u32Counter<1024U; u32Counter++)
N   {
N      vSetSMCISM_TABLE(u32Counter, *(u32TableValues+u32Counter));
X      (*((volatile u32SMCISM_TABLE_word_view *)(0xC0301000U + ((uint16_t)(u32Counter) * 0x4U))) = (*(u32TableValues+u32Counter)));
N   }
N}
N
N/****************************************************************************/
Nfloat32_t f32SMC_GetDegreePerFullstep(smc_dev_e eDevice)
N{
N    return f32DegreePerFullstepVal[eDevice];
N}
N
N/****************************************************************************/
Nvoid vSMC_SetDegreePerFullstep(smc_dev_e eDevice, float32_t f32Value)
N{
N    f32DegreePerFullstepVal[eDevice] = f32Value;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_GeneralConfig(smc_dev_e eDevice, const smc_generalconfig_st * pstGeneralConfig)
N{
N   vSetSMCCTRL_DELAY_CYCLES(eDevice, pstGeneralConfig->u8DelayCycleCount);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> DELAY_CYCLES=(pstGeneralConfig->u8DelayCycleCount));
N   vSetSMCCTRL_PERIOD_EXT(eDevice, pstGeneralConfig->u8PeriodExtension);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> PERIOD_EXT=(pstGeneralConfig->u8PeriodExtension));
N   vSetSMCCTRL_SLEW_RATE(eDevice, pstGeneralConfig->u8SlewRate);
X   (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> SLEW_RATE=(pstGeneralConfig->u8SlewRate));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_IsmConfig(smc_dev_e eDevice, const smc_ismconfig_st * pstIsmConfig)
N{
N   /* internal parameter */
N   f32DegreePerFullstepVal[eDevice] = pstIsmConfig->f32DegreePerFullstep;
N   eTableModeVal[eDevice] = pstIsmConfig->eTableMode;
N
N   /* DCA config */
N   vSMC_SetDCAIntermediateAngle(eDevice, pstIsmConfig->f32IntermediateAngle);
N   vSMC_SetDCAActualAngle(eDevice, pstIsmConfig->f32ActualAngle);
N   vSetSMCDCA_V_OLD_V_OLD(eDevice, pstIsmConfig->u32Velocity);
X   (((volatile SMCDCA_V_OLD_bit_view_st *)(0xC0300084U + ((uint16_t)(eDevice) * 0x4U))) -> V_OLD=(pstIsmConfig->u32Velocity));
N   vSetSMCDCA_V_MAX_V_MAX(eDevice, pstIsmConfig->u32VelocityLimit);
X   (((volatile SMCDCA_V_MAX_bit_view_st *)(0xC0300098U + ((uint16_t)(eDevice) * 0x4U))) -> V_MAX=(pstIsmConfig->u32VelocityLimit));
N   vSetSMCDCA_A_MAX_A_MAX(eDevice, pstIsmConfig->u32AccelerationLimit);
X   (((volatile SMCDCA_A_MAX_bit_view_st *)(0xC03000C0U + ((uint16_t)(eDevice) * 0x4U))) -> A_MAX=(pstIsmConfig->u32AccelerationLimit));
N   vSetSMCDCA_D_MAX_D_MAX(eDevice, pstIsmConfig->u32DecelerationLimit);
X   (((volatile SMCDCA_D_MAX_bit_view_st *)(0xC03000D4U + ((uint16_t)(eDevice) * 0x4U))) -> D_MAX=(pstIsmConfig->u32DecelerationLimit));
N   vSetSMCDCA_V1_V1TH(eDevice,     pstIsmConfig->u32SpeedThreshold1);
X   (((volatile SMCDCA_V1_bit_view_st *)(0xC03000E8U + ((uint16_t)(eDevice) * 0x4U))) -> V1TH=(pstIsmConfig->u32SpeedThreshold1));
N   vSetSMCDCA_V2_V2TH(eDevice,     pstIsmConfig->u32SpeedThreshold2);
X   (((volatile SMCDCA_V2_bit_view_st *)(0xC03000FCU + ((uint16_t)(eDevice) * 0x4U))) -> V2TH=(pstIsmConfig->u32SpeedThreshold2));
N
N   /* ISM config */
N   vSetSMCISM_CTRL_DAMP_K(eDevice, pstIsmConfig->u8DampingFactorK);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DAMP_K=(pstIsmConfig->u8DampingFactorK));
N   vSetSMCISM_CTRL_DAMP_L(eDevice, pstIsmConfig->u8DampingFactorL);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DAMP_L=(pstIsmConfig->u8DampingFactorL));
N   vSetSMCISM_CTRL_ISM_TABLE_MODE(eDevice, (uint32_t) pstIsmConfig->eTableMode);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> ISM_TABLE_MODE=((uint32_t) pstIsmConfig->eTableMode));
N   vSetSMCISM_CTRL_TABLE_IDX     (eDevice, (uint32_t) pstIsmConfig->eTableIndex);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> TABLE_IDX=((uint32_t) pstIsmConfig->eTableIndex));
N   vSetSMCDCA_TS_TS_SEL          (eDevice, (uint16_t) pstIsmConfig->eTableData);
X   (((volatile SMCDCA_TS_bit_view_st *)(0xC0300110U + ((uint16_t)(eDevice) * 0x4U))) -> TS_SEL=((uint16_t) pstIsmConfig->eTableData));
N   vSetSMCISM_CTRL_DIS_DAMP      (eDevice, ((SMC_ENABLE== pstIsmConfig->eUseDampingCurveHardware)? (uint32_t)SMC_DISABLE : (uint32_t)SMC_ENABLE) );
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> DIS_DAMP=(((SMC_ENABLE== pstIsmConfig->eUseDampingCurveHardware)? (uint32_t)SMC_DISABLE : (uint32_t)SMC_ENABLE)));
N}
N
N/****************************************************************************/
N
Nvoid vSMC_PwmConfig(smc_dev_e eDevice, const smc_pwmvalue_st * pstPwmConfig)
N{
N   vSMC_SetPWM32BitData(eDevice, pstPwmConfig->eQuadrant, pstPwmConfig->u16SinDuty, pstPwmConfig->u16CosDuty);
N}
N
N/****************************************************************************/
N
Nvoid vSMC_ZPDConfig(smc_dev_e eDevice, const smc_zpdconfig_st * pstZpdConfig)
N{
N   vSetSMCZPD_CTRL_IDX_INC_N(eDevice, pstZpdConfig->u8IndexIncrement);
X   (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> IDX_INC_N=(pstZpdConfig->u8IndexIncrement));
N   vSetSMCZPD_CTRL_FREQ_N(eDevice, pstZpdConfig->u8ScanningFrequency);
X   (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> FREQ_N=(pstZpdConfig->u8ScanningFrequency));
N   vSetSMCZPD_CTRL_VOLT_REF(eDevice, pstZpdConfig->u8VoltageThreshold);
X   (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> VOLT_REF=(pstZpdConfig->u8VoltageThreshold));
N}
N
N/****************************************************************************/
N
Nbool_t boSMC_WaitForZPDEnd(smc_dev_e eDevice)
N{
N    bool_t   boResult = C_TRUE;
X    bool_t   boResult = (1);
N    uint32_t u32Mask;
N    
N    if (eDevice <= SMC4)
N    {
N        u32Mask = (0x01U<<eDevice);
N        while((u32Mask & biGetSMCINT_ZPDD()) == 0U)
X        while((u32Mask & (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> ZPDD)) == 0U)
N        {
N            ;
N        }
N    }
N    else
N    {
N        boResult = C_FALSE;
X        boResult = (0);
N    }
N    return boResult;
N}
N
N/****************************************************************************/
N
Nbool_t boSMC_MoveToZeroPosition(smc_dev_e eDevice)
N{
N    bool_t   boResult = C_TRUE;
X    bool_t   boResult = (1);
N    uint32_t u32Mask;
N
N    if (eDevice <= SMC4)
N    {
N        u32Mask = (0x01U<<eDevice);
N        /* set mode of channel */
N        vSetSMCCTRL_MSEL(eDevice, (uint32_t)SMC_ZPD_MODE);
X        (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> MSEL=((uint32_t)SMC_ZPD_MODE));
N        
N        /* clear interrupt */
N        vClrSMCINT_ZPDD(eDevice);
X        (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> ZPDD =( (0x01U << (eDevice)) & 0x1FU) );
N        
N        /* set interrupt mask */
N        vSetSMCINT_MASK_MASK_ZPDD(u32Mask & (uint32_t)SMC_ENABLE);
X        (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_ZPDD=(u32Mask & (uint32_t)SMC_ENABLE));
N        
N        /* enable pins */
N        vSetSMCCTRL_OUTEN(eDevice, (uint32_t)SMC_ENABLE);
X        (((volatile SMCCTRL_bit_view_st *)(0xC030000CU + ((uint16_t)(eDevice) * 0x4U))) -> OUTEN=((uint32_t)SMC_ENABLE));
N        
N        /* wait for end of movement */
N        while((u32Mask & biGetSMCINT_ZPDD()) > 0U){}
X        while((u32Mask & (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> ZPDD)) > 0U){}
N        
N        /* set interrupt mask */
N        vSetSMCINT_MASK_MASK_ZPDD(u32Mask & (uint32_t)SMC_DISABLE);
X        (((volatile SMCINT_MASK_bit_view_st *)(0xC0300008U )) -> MASK_ZPDD=(u32Mask & (uint32_t)SMC_DISABLE));
N        
N        /* clear interrupt */
N        vClrSMCINT_ZPDD(eDevice);
X        (((volatile SMCINT_bit_view_st *)(0xC0300004U )) -> ZPDD =( (0x01U << (eDevice)) & 0x1FU) );
N    }
N   else
N   {
N       boResult = C_FALSE;
X       boResult = (0);
N   }
N   return boResult;
N}
N
N/****************************************************************************/
N
Nvoid vSMC_ISMUpdateVariablesBeforeRead(smc_dev_e eDevice)
N{
N   vSetSMCISM_CTRL_RD_REQ(eDevice, (uint32_t)SMC_ENABLE);
X   (((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> RD_REQ=((uint32_t)SMC_ENABLE));
N   while(SMC_ENABLE != (smc_enable_e)biGetSMCISM_CTRL_RD_FLAG(eDevice)) {}
X   while(SMC_ENABLE != (smc_enable_e)(((volatile SMCISM_CTRL_bit_view_st *)(0xC0300020U + ((uint16_t)(eDevice) * 0x4U))) -> RD_FLAG)) {}
N}
N
N/****************************************************************************/
N
Nvoid vSMC_SwitchFromZPDToISM(smc_dev_e eDevice)
N{
N    uint32_t u32Quadrant;
N
N    vSMC_SetISMFreezeRequest(eDevice, SMC_ENABLE);
N    while (SMC_DISABLE == eSMC_GetISMFreezeRequestFlagStatus(eDevice)) {}
N
N    u32Quadrant = biGetSMCZPD_CTRL_QUAD(eDevice);
X    u32Quadrant = (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> QUAD);
N    f32ISMQuadrantOffset[eDevice] = f32DegreePerFullstepVal[eDevice] * (float32_t)(4U - u32Quadrant);
N
N    vSMC_SetISMPosition(eDevice, (float32_t)0.0);
N
N    vSMC_SetChannelMode(eDevice, SMC_ISM_MODE);
N    vSMC_SetISMFreezeRequest(eDevice, SMC_DISABLE);
N}
N
N/****************************************************************************/
N
Nuint32_t u32SMC_SwitchFromZPDToPWM(smc_dev_e eDevice)
N{
N    uint32_t u32Quadrant;
N
N    u32Quadrant = biGetSMCZPD_CTRL_QUAD(eDevice);
X    u32Quadrant = (((volatile SMCZPD_CTRL_bit_view_st *)(0xC0300124U + ((uint16_t)(eDevice) * 0x4U))) -> QUAD);
N
N    vSMC_SetChannelMode(eDevice, SMC_PWM_MODE);
N
N    return u32Quadrant;
N}
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: smc.c
N**  $Revision: 1.13 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :  5 (0286) String literal contains character which is not a
N** |                    member of the basic source character set.
N** |
N** | REASON : This is neccessary because of driver version control.
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1752 / 17.4 - pointer arithmetic not allowed
N** | CONS.  : allow
N** | REASON : this is necessary to have access to the hw resources 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1847 / 10.3 - cast of complex integer expression with underlying type
N** |                        "type" to non-integer type "type" not allowed 
N** | CONS.  : disable
N** | REASON : to use macros from i/o header files, unavoidable when addressing 
N** |          memory mapped registers 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1849 / 8.1 - bitwise ~ or << expression must be immediately cast 
N** |                       back to  underlying type, "unsigned char" 
N** | CONS.  : allow
N** | REASON : necessary for shift oeprations, which we know it will not over run 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1848 / 10.4 : cast of complex floating point expression from type 
N** |                        "type" to type "type" not allowed
N** | CONS.  : allow
N** | REASON : necessary to allow to write integer value of a float data. 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1867 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N/****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
