; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\draw.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\draw.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\draw.crf ..\..\..\..\lldd\src\draw.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vDrw_GetVersion PROC
;;;81     **********************************************/
;;;82     void vDrw_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
000000  e92d4010          PUSH     {r4,lr}
;;;83                          uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag)
;;;84     {
;;;85         *pau8ModuleRevision = &au8LLDD_GA_DRAW_C_REVISION[0];
000004  e59f4fb4          LDR      r4,|L1.4032|
000008  e5804000          STR      r4,[r0,#0]
;;;86         *pau8ModuleTag      = &au8LLDD_GA_DRAW_C_TAG[0];
00000c  e59f4fb0          LDR      r4,|L1.4036|
000010  e5814000          STR      r4,[r1,#0]
;;;87         *pau8HeaderRevision = &au8LLDD_GA_DRAW_H_REVISION[0];
000014  e59f4fac          LDR      r4,|L1.4040|
000018  e5824000          STR      r4,[r2,#0]
;;;88         *pau8HeaderTag      = &au8LLDD_GA_DRAW_H_TAG[0];
00001c  e59f4fa8          LDR      r4,|L1.4044|
000020  e5834000          STR      r4,[r3,#0]
;;;89     }
000024  e8bd8010          POP      {r4,pc}
;;;90     
                          ENDP

                  vDrw_SetMemDest PROC
;;;91     /* ....................................................................... */
;;;92     void vDrw_SetMemDest(const void* pvAddr, ga_list_st* pstCmdList)
000028  e92d40f0          PUSH     {r4-r7,lr}
;;;93     {
;;;94         uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
00002c  e3043000          MOVW     r3,#0x4000
000030  e7932001          LDR      r2,[r3,r1]
;;;95         
;;;96     #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;97         uint32_t u32NeededDW  = 1;
;;;98        
;;;99         u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;100        
;;;101        /* check if there is enough space in command list: */
;;;102        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;103        {
;;;104          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;105          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;106          return;
;;;107        }
;;;108        else 
;;;109        {
;;;110          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;111        }
;;;112    #endif
;;;113        
;;;114        pu64Curr[0] = DRW_LOAD_DESTADDR((uint64_t) pvAddr);
000034  e3a04000          MOV      r4,#0
000038  e0043004          AND      r3,r4,r4
00003c  e1805004          ORR      r5,r0,r4
000040  e1a04005          MOV      r4,r5
000044  e3837004          ORR      r7,r3,#4
000048  e59f5f80          LDR      r5,|L1.4048|
00004c  e1a03004          MOV      r3,r4
000050  e1874005          ORR      r4,r7,r5
000054  e8820018          STM      r2,{r3,r4}
;;;115    
;;;116        pstCmdList->pu64Current = &pu64Curr[1];
000058  e2823008          ADD      r3,r2,#8
00005c  e3044000          MOVW     r4,#0x4000
000060  e7843001          STR      r3,[r4,r1]
;;;117    }
000064  e8bd80f0          POP      {r4-r7,pc}
;;;118    
                          ENDP

                  vDrw_SetMemDim PROC
;;;119    /* ....................................................................... */
;;;120    void vDrw_SetMemDim(uint16_t u16Width, uint16_t u16Height, ga_list_st* pstCmdList)
000068  e92d40f0          PUSH     {r4-r7,lr}
;;;121    {
;;;122        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
00006c  e3044000          MOVW     r4,#0x4000
000070  e7943002          LDR      r3,[r4,r2]
;;;123        
;;;124    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;125    
;;;126        uint32_t u32NeededDW  = 1;
;;;127       
;;;128        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;129        
;;;130        /* check if there is enough space in command list: */
;;;131        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;132        {
;;;133          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;134          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;135          return;
;;;136        }
;;;137        else 
;;;138        {
;;;139          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;140        }
;;;141    #endif
;;;142        
;;;143        pu64Curr[0] = DRW_LOAD_DESTDIM(u16Width, u16Height);
000074  e3a06000          MOV      r6,#0
000078  e3005fff          MOV      r5,#0xfff
00007c  e0055001          AND      r5,r5,r1
000080  e0064006          AND      r4,r6,r6
000084  e1a04804          LSL      r4,r4,#16
000088  e1844825          ORR      r4,r4,r5,LSR #16
00008c  e3007fff          MOV      r7,#0xfff
000090  e0077000          AND      r7,r7,r0
000094  e0066006          AND      r6,r6,r6
000098  e1875805          ORR      r5,r7,r5,LSL #16
00009c  e184c006          ORR      r12,r4,r6
0000a0  e3a04000          MOV      r4,#0
0000a4  e1a06005          MOV      r6,r5
0000a8  e1a0500c          MOV      r5,r12
0000ac  e1a0c004          MOV      r12,r4
0000b0  e1a04006          MOV      r4,r6
0000b4  e00cc005          AND      r12,r12,r5
0000b8  e6ff607c          UXTH     r6,r12
0000bc  e3865005          ORR      r5,r6,#5
0000c0  e59f7f08          LDR      r7,|L1.4048|
0000c4  e1855007          ORR      r5,r5,r7
0000c8  e1c340f0          STRD     r4,r5,[r3,#0]
;;;144    
;;;145        pstCmdList->pu64Current = &pu64Curr[1];
0000cc  e2834008          ADD      r4,r3,#8
0000d0  e3045000          MOVW     r5,#0x4000
0000d4  e7854002          STR      r4,[r5,r2]
;;;146    }
0000d8  e8bd80f0          POP      {r4-r7,pc}
;;;147    
                          ENDP

                  vDrw_SetColorRGB16 PROC
;;;148    /* ....................................................................... */
;;;149    void vDrw_SetColorRGB16(uint16_t u16Color, uint8_t u8Alpha, ga_list_st* pstCmdList)
0000dc  e92d40f0          PUSH     {r4-r7,lr}
;;;150    {
;;;151        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
0000e0  e3044000          MOVW     r4,#0x4000
0000e4  e7943002          LDR      r3,[r4,r2]
;;;152    
;;;153    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;154    
;;;155        uint32_t u32NeededDW  = 1;
;;;156       
;;;157        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;158        
;;;159        /* check if there is enough space in command list: */
;;;160        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;161        {
;;;162          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;163          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;164          return;
;;;165        }
;;;166        else 
;;;167        {
;;;168          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;169        }
;;;170    #endif
;;;171    
;;;172        pu64Curr[0] = DRW_LOAD_RGB16(u16Color,u8Alpha);
0000e8  e3a06000          MOV      r6,#0
0000ec  e20150ff          AND      r5,r1,#0xff
0000f0  e0064006          AND      r4,r6,r6
0000f4  e1a04804          LSL      r4,r4,#16
0000f8  e1844825          ORR      r4,r4,r5,LSR #16
0000fc  e6ff7070          UXTH     r7,r0
000100  e0066006          AND      r6,r6,r6
000104  e1875805          ORR      r5,r7,r5,LSL #16
000108  e184c006          ORR      r12,r4,r6
00010c  e3a04000          MOV      r4,#0
000110  e1a06005          MOV      r6,r5
000114  e1a0500c          MOV      r5,r12
000118  e1a0c004          MOV      r12,r4
00011c  e1a04006          MOV      r4,r6
000120  e00cc005          AND      r12,r12,r5
000124  e6ff607c          UXTH     r6,r12
000128  e386500a          ORR      r5,r6,#0xa
00012c  e59f7e9c          LDR      r7,|L1.4048|
000130  e1855007          ORR      r5,r5,r7
000134  e1c340f0          STRD     r4,r5,[r3,#0]
;;;173    
;;;174        pstCmdList->pu64Current = &pu64Curr[1];
000138  e2834008          ADD      r4,r3,#8
00013c  e3045000          MOVW     r5,#0x4000
000140  e7854002          STR      r4,[r5,r2]
;;;175    }
000144  e8bd80f0          POP      {r4-r7,pc}
;;;176    
                          ENDP

                  vDrw_SetColorRGBA32 PROC
;;;177    /* ....................................................................... */
;;;178    void vDrw_SetColorRGBA32(uint32_t u32Color, ga_list_st* pstCmdList)
000148  e92d40f0          PUSH     {r4-r7,lr}
;;;179    {
;;;180        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
00014c  e3043000          MOVW     r3,#0x4000
000150  e7932001          LDR      r2,[r3,r1]
;;;181    
;;;182    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;183    
;;;184        uint32_t u32NeededDW  = 1;
;;;185       
;;;186        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;187        
;;;188        /* check if there is enough space in command list: */
;;;189        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;190        {
;;;191          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;192          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;193          return;
;;;194        }
;;;195        else 
;;;196        {
;;;197          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;198        }
;;;199    #endif
;;;200    
;;;201        pu64Curr[0] = DRW_LOAD_RGBA32(u32Color);
000154  e3a05000          MOV      r5,#0
000158  e0055005          AND      r5,r5,r5
00015c  e3a05000          MOV      r5,#0
000160  e1806005          ORR      r6,r0,r5
000164  e3a0300a          MOV      r3,#0xa
000168  e1a05003          MOV      r5,r3
00016c  e59f4e5c          LDR      r4,|L1.4048|
000170  e1844005          ORR      r4,r4,r5
000174  e5824004          STR      r4,[r2,#4]
000178  e5826000          STR      r6,[r2,#0]
;;;202    
;;;203        pstCmdList->pu64Current = &pu64Curr[1];
00017c  e2823008          ADD      r3,r2,#8
000180  e3044000          MOVW     r4,#0x4000
000184  e7843001          STR      r3,[r4,r1]
;;;204    }
000188  e8bd80f0          POP      {r4-r7,pc}
;;;205    
                          ENDP

                  vDrw_SetBgColorRGBA32 PROC
;;;206    /* ....................................................................... */
;;;207    void vDrw_SetBgColorRGBA32(uint32_t u32Color, ga_list_st* pstCmdList)
00018c  e92d40f0          PUSH     {r4-r7,lr}
;;;208    {
;;;209        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000190  e3043000          MOVW     r3,#0x4000
000194  e7932001          LDR      r2,[r3,r1]
;;;210    
;;;211    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;212    
;;;213        uint32_t u32NeededDW  = 1;
;;;214       
;;;215        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;216        
;;;217        /* check if there is enough space in command list: */
;;;218        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;219        {
;;;220          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;221          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;222          return;
;;;223        }
;;;224        else 
;;;225        {
;;;226          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;227        }
;;;228    #endif
;;;229    
;;;230        pu64Curr[0] = DRW_LOAD_RGBA32BGRND(u32Color);
000198  e3a05000          MOV      r5,#0
00019c  e0055005          AND      r5,r5,r5
0001a0  e3a05000          MOV      r5,#0
0001a4  e1806005          ORR      r6,r0,r5
0001a8  e3a0300b          MOV      r3,#0xb
0001ac  e1a05003          MOV      r5,r3
0001b0  e59f4e18          LDR      r4,|L1.4048|
0001b4  e1844005          ORR      r4,r4,r5
0001b8  e5824004          STR      r4,[r2,#4]
0001bc  e5826000          STR      r6,[r2,#0]
;;;231    
;;;232        pstCmdList->pu64Current = &pu64Curr[1];
0001c0  e2823008          ADD      r3,r2,#8
0001c4  e3044000          MOVW     r4,#0x4000
0001c8  e7843001          STR      r3,[r4,r1]
;;;233    }
0001cc  e8bd80f0          POP      {r4-r7,pc}
;;;234    
                          ENDP

                  vDrw_SetBgColorRGB16 PROC
;;;235    /* ....................................................................... */
;;;236    void vDrw_SetBgColorRGB16(uint16_t u16Color, ga_list_st* pstCmdList)
0001d0  e92d40f0          PUSH     {r4-r7,lr}
;;;237    {
;;;238        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
0001d4  e3043000          MOVW     r3,#0x4000
0001d8  e7932001          LDR      r2,[r3,r1]
;;;239    
;;;240    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;241    
;;;242        uint32_t u32NeededDW  = 1;
;;;243       
;;;244        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;245        
;;;246        /* check if there is enough space in command list: */
;;;247        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;248        {
;;;249          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;250          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;251          return;
;;;252        }
;;;253        else 
;;;254        {
;;;255          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;256        }
;;;257    #endif
;;;258    
;;;259        pu64Curr[0] = DRW_LOAD_RGB16BGRND(u16Color);
0001dc  e3a05000          MOV      r5,#0
0001e0  e6ff3070          UXTH     r3,r0
0001e4  e0055005          AND      r5,r5,r5
0001e8  e3a05000          MOV      r5,#0
0001ec  e1836005          ORR      r6,r3,r5
0001f0  e3a0300b          MOV      r3,#0xb
0001f4  e1a05003          MOV      r5,r3
0001f8  e59f4dd0          LDR      r4,|L1.4048|
0001fc  e1844005          ORR      r4,r4,r5
000200  e5824004          STR      r4,[r2,#4]
000204  e5826000          STR      r6,[r2,#0]
;;;260    
;;;261        pstCmdList->pu64Current = &pu64Curr[1];
000208  e2823008          ADD      r3,r2,#8
00020c  e3044000          MOVW     r4,#0x4000
000210  e7843001          STR      r3,[r4,r1]
;;;262    }
000214  e8bd80f0          POP      {r4-r7,pc}
;;;263    
                          ENDP

                  vDrw_SetLineStart PROC
;;;264    /* ....................................................................... */
;;;265    void vDrw_SetLineStart(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
000218  e92d40f0          PUSH     {r4-r7,lr}
;;;266    {
;;;267        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
00021c  e3044000          MOVW     r4,#0x4000
000220  e7943002          LDR      r3,[r4,r2]
;;;268    
;;;269    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;270    
;;;271        uint32_t u32NeededDW  = 1;
;;;272       
;;;273        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;274        
;;;275        /* check if there is enough space in command list: */
;;;276        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;277        {
;;;278          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;279          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;280          return;
;;;281        }
;;;282        else 
;;;283        {
;;;284          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;285        }
;;;286    #endif
;;;287    
;;;288        pu64Curr[0] = DRW_LOAD_LINESTART( u16X, u16Y);
000224  e3a06000          MOV      r6,#0
000228  e6ff5071          UXTH     r5,r1
00022c  e0064006          AND      r4,r6,r6
000230  e1a04804          LSL      r4,r4,#16
000234  e1844825          ORR      r4,r4,r5,LSR #16
000238  e6ff7070          UXTH     r7,r0
00023c  e0066006          AND      r6,r6,r6
000240  e1875805          ORR      r5,r7,r5,LSL #16
000244  e184c006          ORR      r12,r4,r6
000248  e3a04000          MOV      r4,#0
00024c  e1a06005          MOV      r6,r5
000250  e1a0500c          MOV      r5,r12
000254  e1a0c004          MOV      r12,r4
000258  e1a04006          MOV      r4,r6
00025c  e00cc005          AND      r12,r12,r5
000260  e6ff607c          UXTH     r6,r12
000264  e3865006          ORR      r5,r6,#6
000268  e59f7d60          LDR      r7,|L1.4048|
00026c  e1855007          ORR      r5,r5,r7
000270  e1c340f0          STRD     r4,r5,[r3,#0]
;;;289        pstCmdList->pu64Current = &pu64Curr[1];
000274  e2834008          ADD      r4,r3,#8
000278  e3045000          MOVW     r5,#0x4000
00027c  e7854002          STR      r4,[r5,r2]
;;;290    }
000280  e8bd80f0          POP      {r4-r7,pc}
;;;291    
                          ENDP

                  vDrw_SetLineEnd PROC
;;;292    /* ....................................................................... */
;;;293    void vDrw_SetLineEnd(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
000284  e92d40f0          PUSH     {r4-r7,lr}
;;;294    {
;;;295        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000288  e3044000          MOVW     r4,#0x4000
00028c  e7943002          LDR      r3,[r4,r2]
;;;296    
;;;297    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;298    
;;;299        uint32_t u32NeededDW  = 1;
;;;300       
;;;301        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;302        
;;;303        /* check if there is enough space in command list: */
;;;304        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;305        {
;;;306          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;307          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;308          return;
;;;309        }
;;;310        else 
;;;311        {
;;;312          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;313        }
;;;314    #endif
;;;315    
;;;316        pu64Curr[0] = DRW_LOAD_LINEEND( u16X, u16Y);
000290  e3a06000          MOV      r6,#0
000294  e6ff5071          UXTH     r5,r1
000298  e0064006          AND      r4,r6,r6
00029c  e1a04804          LSL      r4,r4,#16
0002a0  e1844825          ORR      r4,r4,r5,LSR #16
0002a4  e6ff7070          UXTH     r7,r0
0002a8  e0066006          AND      r6,r6,r6
0002ac  e1875805          ORR      r5,r7,r5,LSL #16
0002b0  e184c006          ORR      r12,r4,r6
0002b4  e3a04000          MOV      r4,#0
0002b8  e1a06005          MOV      r6,r5
0002bc  e1a0500c          MOV      r5,r12
0002c0  e1a0c004          MOV      r12,r4
0002c4  e1a04006          MOV      r4,r6
0002c8  e00cc005          AND      r12,r12,r5
0002cc  e6ff607c          UXTH     r6,r12
0002d0  e3865007          ORR      r5,r6,#7
0002d4  e59f7cf4          LDR      r7,|L1.4048|
0002d8  e1855007          ORR      r5,r5,r7
0002dc  e1c340f0          STRD     r4,r5,[r3,#0]
;;;317    
;;;318        pstCmdList->pu64Current = &pu64Curr[1];
0002e0  e2834008          ADD      r4,r3,#8
0002e4  e3045000          MOVW     r5,#0x4000
0002e8  e7854002          STR      r4,[r5,r2]
;;;319    }
0002ec  e8bd80f0          POP      {r4-r7,pc}
;;;320    
                          ENDP

                  vDrw_SetLineThickness PROC
;;;322    
;;;323    void vDrw_SetLineThickness(uint16_t u16Val, ga_list_st* pstCmdList)
0002f0  e92d40f0          PUSH     {r4-r7,lr}
;;;324    {
;;;325        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
0002f4  e3043000          MOVW     r3,#0x4000
0002f8  e7932001          LDR      r2,[r3,r1]
;;;326    
;;;327    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;328    
;;;329        uint32_t u32NeededDW  = 1;
;;;330       
;;;331        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;332        
;;;333        /* check if there is enough space in command list: */
;;;334        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;335        {
;;;336          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;337          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;338          return;
;;;339        }
;;;340        else 
;;;341        {
;;;342          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;343        }
;;;344    #endif
;;;345    
;;;346        pu64Curr[0] = DRW_LOAD_THICKNESS(u16Val);
0002fc  e3a05000          MOV      r5,#0
000300  e30041ff          MOV      r4,#0x1ff
000304  e0003004          AND      r3,r0,r4
000308  e0055005          AND      r5,r5,r5
00030c  e3a05000          MOV      r5,#0
000310  e1836005          ORR      r6,r3,r5
000314  e3a03009          MOV      r3,#9
000318  e1a05003          MOV      r5,r3
00031c  e59f4cac          LDR      r4,|L1.4048|
000320  e1844005          ORR      r4,r4,r5
000324  e5824004          STR      r4,[r2,#4]
000328  e5826000          STR      r6,[r2,#0]
;;;347    
;;;348        pstCmdList->pu64Current = &pu64Curr[1];
00032c  e2823008          ADD      r3,r2,#8
000330  e3044000          MOVW     r4,#0x4000
000334  e7843001          STR      r3,[r4,r1]
;;;349    }
000338  e8bd80f0          POP      {r4-r7,pc}
;;;350    
                          ENDP

                  vDrw_SetTriangle1 PROC
;;;351    /* ....................................................................... */
;;;352    void vDrw_SetTriangle1(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
00033c  e92d40f0          PUSH     {r4-r7,lr}
;;;353    {
;;;354        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000340  e3044000          MOVW     r4,#0x4000
000344  e7943002          LDR      r3,[r4,r2]
;;;355    
;;;356    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;357    
;;;358        uint32_t u32NeededDW  = 1;
;;;359       
;;;360        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;361        
;;;362        /* check if there is enough space in command list: */
;;;363        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;364        {
;;;365          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;366          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;367          return;
;;;368        }
;;;369        else 
;;;370        {
;;;371          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;372        }
;;;373    #endif
;;;374    
;;;375        pu64Curr[0] = DRW_LOAD_TRNGLE1(u16X, u16Y);
000348  e3a06000          MOV      r6,#0
00034c  e6ff5071          UXTH     r5,r1
000350  e0064006          AND      r4,r6,r6
000354  e1a04804          LSL      r4,r4,#16
000358  e1844825          ORR      r4,r4,r5,LSR #16
00035c  e6ff7070          UXTH     r7,r0
000360  e0066006          AND      r6,r6,r6
000364  e1875805          ORR      r5,r7,r5,LSL #16
000368  e184c006          ORR      r12,r4,r6
00036c  e3a04000          MOV      r4,#0
000370  e1a06005          MOV      r6,r5
000374  e1a0500c          MOV      r5,r12
000378  e1a0c004          MOV      r12,r4
00037c  e1a04006          MOV      r4,r6
000380  e00cc005          AND      r12,r12,r5
000384  e6ff607c          UXTH     r6,r12
000388  e3865006          ORR      r5,r6,#6
00038c  e59f7c3c          LDR      r7,|L1.4048|
000390  e1855007          ORR      r5,r5,r7
000394  e1c340f0          STRD     r4,r5,[r3,#0]
;;;376    
;;;377        pstCmdList->pu64Current = &pu64Curr[1];
000398  e2834008          ADD      r4,r3,#8
00039c  e3045000          MOVW     r5,#0x4000
0003a0  e7854002          STR      r4,[r5,r2]
;;;378    }
0003a4  e8bd80f0          POP      {r4-r7,pc}
;;;379    
                          ENDP

                  vDrw_SetTriangle2 PROC
;;;380    /* ....................................................................... */
;;;381    void vDrw_SetTriangle2(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
0003a8  e92d40f0          PUSH     {r4-r7,lr}
;;;382    {
;;;383        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
0003ac  e3044000          MOVW     r4,#0x4000
0003b0  e7943002          LDR      r3,[r4,r2]
;;;384    
;;;385    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;386    
;;;387        uint32_t u32NeededDW  = 1;
;;;388       
;;;389        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;390        
;;;391        /* check if there is enough space in command list: */
;;;392        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;393        {
;;;394          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;395          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;396          return;
;;;397        }
;;;398        else 
;;;399        {
;;;400          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;401        }
;;;402    #endif
;;;403    
;;;404        pu64Curr[0] = DRW_LOAD_TRNGLE2(u16X, u16Y);
0003b4  e3a06000          MOV      r6,#0
0003b8  e6ff5071          UXTH     r5,r1
0003bc  e0064006          AND      r4,r6,r6
0003c0  e1a04804          LSL      r4,r4,#16
0003c4  e1844825          ORR      r4,r4,r5,LSR #16
0003c8  e6ff7070          UXTH     r7,r0
0003cc  e0066006          AND      r6,r6,r6
0003d0  e1875805          ORR      r5,r7,r5,LSL #16
0003d4  e184c006          ORR      r12,r4,r6
0003d8  e3a04000          MOV      r4,#0
0003dc  e1a06005          MOV      r6,r5
0003e0  e1a0500c          MOV      r5,r12
0003e4  e1a0c004          MOV      r12,r4
0003e8  e1a04006          MOV      r4,r6
0003ec  e00cc005          AND      r12,r12,r5
0003f0  e6ff607c          UXTH     r6,r12
0003f4  e3865007          ORR      r5,r6,#7
0003f8  e59f7bd0          LDR      r7,|L1.4048|
0003fc  e1855007          ORR      r5,r5,r7
000400  e1c340f0          STRD     r4,r5,[r3,#0]
;;;405    
;;;406        pstCmdList->pu64Current = &pu64Curr[1];
000404  e2834008          ADD      r4,r3,#8
000408  e3045000          MOVW     r5,#0x4000
00040c  e7854002          STR      r4,[r5,r2]
;;;407    }
000410  e8bd80f0          POP      {r4-r7,pc}
;;;408    
                          ENDP

                  vDrw_SetTriangle3 PROC
;;;409    /* ....................................................................... */
;;;410    void vDrw_SetTriangle3(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
000414  e92d40f0          PUSH     {r4-r7,lr}
;;;411    {
;;;412        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000418  e3044000          MOVW     r4,#0x4000
00041c  e7943002          LDR      r3,[r4,r2]
;;;413    
;;;414    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;415    
;;;416        uint32_t u32NeededDW  = 1;
;;;417       
;;;418        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;419        
;;;420        /* check if there is enough space in command list: */
;;;421        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;422        {
;;;423          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;424          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;425          return;
;;;426        }
;;;427        else 
;;;428        {
;;;429          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;430        }
;;;431    #endif
;;;432    
;;;433        pu64Curr[0] = DRW_LOAD_TRNGLE3(u16X, u16Y);
000420  e3a06000          MOV      r6,#0
000424  e6ff5071          UXTH     r5,r1
000428  e0064006          AND      r4,r6,r6
00042c  e1a04804          LSL      r4,r4,#16
000430  e1844825          ORR      r4,r4,r5,LSR #16
000434  e6ff7070          UXTH     r7,r0
000438  e0066006          AND      r6,r6,r6
00043c  e1875805          ORR      r5,r7,r5,LSL #16
000440  e184c006          ORR      r12,r4,r6
000444  e3a04000          MOV      r4,#0
000448  e1a06005          MOV      r6,r5
00044c  e1a0500c          MOV      r5,r12
000450  e1a0c004          MOV      r12,r4
000454  e1a04006          MOV      r4,r6
000458  e00cc005          AND      r12,r12,r5
00045c  e6ff607c          UXTH     r6,r12
000460  e3865008          ORR      r5,r6,#8
000464  e59f7b64          LDR      r7,|L1.4048|
000468  e1855007          ORR      r5,r5,r7
00046c  e1c340f0          STRD     r4,r5,[r3,#0]
;;;434    
;;;435        pstCmdList->pu64Current = &pu64Curr[1];
000470  e2834008          ADD      r4,r3,#8
000474  e3045000          MOVW     r5,#0x4000
000478  e7854002          STR      r4,[r5,r2]
;;;436    }
00047c  e8bd80f0          POP      {r4-r7,pc}
;;;437    
                          ENDP

                  vDrw_SetClippWnd PROC
;;;438    /* ....................................................................... */
;;;439    void vDrw_SetClippWnd(drw_clipWnd_st* pstClipWnd, ga_list_st* pstCmdList)
000480  e92d40f0          PUSH     {r4-r7,lr}
;;;440    {
;;;441        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000484  e3043000          MOVW     r3,#0x4000
000488  e7932001          LDR      r2,[r3,r1]
;;;442    
;;;443    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;444    
;;;445        uint32_t u32NeededDW  = 2;
;;;446       
;;;447        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;448        
;;;449        /* check if there is enough space in command list: */
;;;450        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;451        {
;;;452          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;453          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;454          return;
;;;455        }
;;;456        else 
;;;457        {
;;;458          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;459        }
;;;460    #endif
;;;461    
;;;462        pu64Curr[0] = DRW_LOAD_CLIPWNDSTART(pstClipWnd->u16UlX, pstClipWnd->u16UlY);
00048c  e1d030b2          LDRH     r3,[r0,#2]
000490  e3a05000          MOV      r5,#0
000494  e3006fff          MOV      r6,#0xfff
000498  e0033006          AND      r3,r3,r6
00049c  e0054005          AND      r4,r5,r5
0004a0  e1a04804          LSL      r4,r4,#16
0004a4  e1844823          ORR      r4,r4,r3,LSR #16
0004a8  e1a05803          LSL      r5,r3,#16
0004ac  e1d030b0          LDRH     r3,[r0,#0]
0004b0  e3a0c000          MOV      r12,#0
0004b4  e1a07006          MOV      r7,r6
0004b8  e0033007          AND      r3,r3,r7
0004bc  e00c600c          AND      r6,r12,r12
0004c0  e1833005          ORR      r3,r3,r5
0004c4  e1866004          ORR      r6,r6,r4
0004c8  e1a05003          MOV      r5,r3
0004cc  e006600c          AND      r6,r6,r12
0004d0  e185500c          ORR      r5,r5,r12
0004d4  e6ff6076          UXTH     r6,r6
0004d8  e3866001          ORR      r6,r6,#1
0004dc  e59f3aec          LDR      r3,|L1.4048|
0004e0  e1833006          ORR      r3,r3,r6
0004e4  e5823004          STR      r3,[r2,#4]
0004e8  e5825000          STR      r5,[r2,#0]
;;;463        pu64Curr[1] = DRW_LOAD_CLIPWNDEND(pstClipWnd->u16LrX, pstClipWnd->u16LrY);
0004ec  e1d030b6          LDRH     r3,[r0,#6]
0004f0  e3a04000          MOV      r4,#0
0004f4  e3006fff          MOV      r6,#0xfff
0004f8  e0033006          AND      r3,r3,r6
0004fc  e0044004          AND      r4,r4,r4
000500  e1a04804          LSL      r4,r4,#16
000504  e1845823          ORR      r5,r4,r3,LSR #16
000508  e1a06803          LSL      r6,r3,#16
00050c  e1d030b4          LDRH     r3,[r0,#4]
000510  e3a04000          MOV      r4,#0
000514  e300cfff          MOV      r12,#0xfff
000518  e003300c          AND      r3,r3,r12
00051c  e0044004          AND      r4,r4,r4
000520  e1833006          ORR      r3,r3,r6
000524  e1844005          ORR      r4,r4,r5
000528  e3a04000          MOV      r4,#0
00052c  e1836004          ORR      r6,r3,r4
000530  e3a03002          MOV      r3,#2
000534  e1a04003          MOV      r4,r3
000538  e59f3a90          LDR      r3,|L1.4048|
00053c  e1833004          ORR      r3,r3,r4
000540  e582300c          STR      r3,[r2,#0xc]
000544  e5826008          STR      r6,[r2,#8]
;;;464    
;;;465        pstCmdList->pu64Current = &pu64Curr[2];
000548  e2823010          ADD      r3,r2,#0x10
00054c  e3044000          MOVW     r4,#0x4000
000550  e7843001          STR      r3,[r4,r1]
;;;466    }
000554  e8bd80f0          POP      {r4-r7,pc}
;;;467    
                          ENDP

                  vDrw_SetLineCmd PROC
;;;468    /* ....................................................................... */
;;;469    void vDrw_SetLineCmd(drw_LnOpCfg_st* pstParam, ga_list_st* pstCmdList)
000558  e92d40f0          PUSH     {r4-r7,lr}
;;;470    {
;;;471        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
00055c  e3043000          MOVW     r3,#0x4000
000560  e7932001          LDR      r2,[r3,r1]
;;;472    
;;;473    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;474    
;;;475        uint32_t u32NeededDW  = 1;
;;;476       
;;;477        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;478        
;;;479        /* check if there is enough space in command list: */
;;;480        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;481        {
;;;482          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;483          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;484          return;
;;;485        }
;;;486        else 
;;;487        {
;;;488          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;489        }
;;;490    #endif
;;;491    
;;;492        if(pstParam->eColFmt == GA_RGB16)
000564  e5d03000          LDRB     r3,[r0,#0]
000568  e3530000          CMP      r3,#0
00056c  1a000020          BNE      |L1.1524|
;;;493        {
;;;494            pu64Curr[0] = DRW_LINERGB16(pstParam->eStartCap,
000570  e5d03002          LDRB     r3,[r0,#2]
000574  e3a04000          MOV      r4,#0
000578  e203300f          AND      r3,r3,#0xf
00057c  e0044004          AND      r4,r4,r4
000580  e1a04404          LSL      r4,r4,#8
000584  e1844c23          ORR      r4,r4,r3,LSR #24
000588  e1a05403          LSL      r5,r3,#8
00058c  e5d03003          LDRB     r3,[r0,#3]
000590  e3a0c000          MOV      r12,#0
000594  e203700f          AND      r7,r3,#0xf
000598  e00c600c          AND      r6,r12,r12
00059c  e1a06206          LSL      r6,r6,#4
0005a0  e1863e27          ORR      r3,r6,r7,LSR #28
0005a4  e1855207          ORR      r5,r5,r7,LSL #4
0005a8  e1844003          ORR      r4,r4,r3
0005ac  e5d03001          LDRB     r3,[r0,#1]
0005b0  e2037007          AND      r7,r3,#7
0005b4  e00c300c          AND      r3,r12,r12
0005b8  e0976007          ADDS     r6,r7,r7
0005bc  e0a33003          ADC      r3,r3,r3
0005c0  e1855006          ORR      r5,r5,r6
0005c4  e1844003          ORR      r4,r4,r3
0005c8  e5d03004          LDRB     r3,[r0,#4]
0005cc  e2033001          AND      r3,r3,#1
0005d0  e00c600c          AND      r6,r12,r12
0005d4  e1833005          ORR      r3,r3,r5
0005d8  e1866004          ORR      r6,r6,r4
0005dc  e6ff6076          UXTH     r6,r6
0005e0  e59f59ec          LDR      r5,|L1.4052|
0005e4  e183300c          ORR      r3,r3,r12
0005e8  e1864005          ORR      r4,r6,r5
0005ec  e8820018          STM      r2,{r3,r4}
0005f0  ea00001f          B        |L1.1652|
                  |L1.1524|
;;;495                                        pstParam->eEndCap,
;;;496                                        pstParam->eBlndMode,
;;;497                                        pstParam->eClipWndEn);
;;;498        }
;;;499        else
;;;500        {
;;;501            pu64Curr[0] = DRW_LINERGBA32(pstParam->eStartCap,
0005f4  e5d03002          LDRB     r3,[r0,#2]
0005f8  e3a04000          MOV      r4,#0
0005fc  e203300f          AND      r3,r3,#0xf
000600  e0044004          AND      r4,r4,r4
000604  e1a04404          LSL      r4,r4,#8
000608  e1846c23          ORR      r6,r4,r3,LSR #24
00060c  e1a07403          LSL      r7,r3,#8
000610  e5d03003          LDRB     r3,[r0,#3]
000614  e3a0c000          MOV      r12,#0
000618  e203300f          AND      r3,r3,#0xf
00061c  e00c400c          AND      r4,r12,r12
000620  e1a04204          LSL      r4,r4,#4
000624  e1845e23          ORR      r5,r4,r3,LSR #28
000628  e1874203          ORR      r4,r7,r3,LSL #4
00062c  e1866005          ORR      r6,r6,r5
000630  e5d03001          LDRB     r3,[r0,#1]
000634  e2033007          AND      r3,r3,#7
000638  e00c500c          AND      r5,r12,r12
00063c  e0933003          ADDS     r3,r3,r3
000640  e0a55005          ADC      r5,r5,r5
000644  e1844003          ORR      r4,r4,r3
000648  e1866005          ORR      r6,r6,r5
00064c  e5d03004          LDRB     r3,[r0,#4]
000650  e3a05000          MOV      r5,#0
000654  e2033001          AND      r3,r3,#1
000658  e0055005          AND      r5,r5,r5
00065c  e1833004          ORR      r3,r3,r4
000660  e1864005          ORR      r4,r6,r5
000664  e6ff4074          UXTH     r4,r4
000668  e59f5968          LDR      r5,|L1.4056|
00066c  e1844005          ORR      r4,r4,r5
000670  e8820018          STM      r2,{r3,r4}
                  |L1.1652|
;;;502                                         pstParam->eEndCap,
;;;503                                         pstParam->eBlndMode,
;;;504                                         pstParam->eClipWndEn);
;;;505            
;;;506        }
;;;507        pstCmdList->pu64Current = &pu64Curr[1];
000674  e2823008          ADD      r3,r2,#8
000678  e3044000          MOVW     r4,#0x4000
00067c  e7843001          STR      r3,[r4,r1]
;;;508    }
000680  e8bd80f0          POP      {r4-r7,pc}
;;;509    
                          ENDP

                  vDrw_SetTriangleCmd PROC
;;;510    /* ....................................................................... */
;;;511    void vDrw_SetTriangleCmd(drw_TriOpCfg_st* pstParam, ga_list_st* pstCmdList)
000684  e92d40f0          PUSH     {r4-r7,lr}
;;;512    {
;;;513        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000688  e3043000          MOVW     r3,#0x4000
00068c  e7932001          LDR      r2,[r3,r1]
;;;514    
;;;515    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;516    
;;;517        uint32_t u32NeededDW  = 1;
;;;518       
;;;519        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;520        
;;;521        /* check if there is enough space in command list: */
;;;522        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;523        {
;;;524          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;525          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;526          return;
;;;527        }
;;;528        else 
;;;529        {
;;;530          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;531        }
;;;532    #endif
;;;533    
;;;534        if(pstParam->eColFmt == GA_RGB16)
000690  e5d03000          LDRB     r3,[r0,#0]
000694  e3530000          CMP      r3,#0
000698  1a000029          BNE      |L1.1860|
;;;535        {
;;;536            pu64Curr[0] = DRW_TRIANGLE_RGB16(pstParam->eAntialEn3,
00069c  e5d03005          LDRB     r3,[r0,#5]
0006a0  e3a04000          MOV      r4,#0
0006a4  e2033001          AND      r3,r3,#1
0006a8  e0044004          AND      r4,r4,r4
0006ac  e1a04304          LSL      r4,r4,#6
0006b0  e1844d23          ORR      r4,r4,r3,LSR #26
0006b4  e1a05303          LSL      r5,r3,#6
0006b8  e5d03004          LDRB     r3,[r0,#4]
0006bc  e3a0c000          MOV      r12,#0
0006c0  e2036001          AND      r6,r3,#1
0006c4  e00c700c          AND      r7,r12,r12
0006c8  e1a07287          LSL      r7,r7,#5
0006cc  e1873da6          ORR      r3,r7,r6,LSR #27
0006d0  e1855286          ORR      r5,r5,r6,LSL #5
0006d4  e1844003          ORR      r4,r4,r3
0006d8  e5d03003          LDRB     r3,[r0,#3]
0006dc  e2036001          AND      r6,r3,#1
0006e0  e1a0720c          LSL      r7,r12,#4
0006e4  e1873e26          ORR      r3,r7,r6,LSR #28
0006e8  e1856206          ORR      r6,r5,r6,LSL #4
0006ec  e1845003          ORR      r5,r4,r3
0006f0  e5d03001          LDRB     r3,[r0,#1]
0006f4  e3a04000          MOV      r4,#0
0006f8  e2037007          AND      r7,r3,#7
0006fc  e0043004          AND      r3,r4,r4
000700  e0974007          ADDS     r4,r7,r7
000704  e0a33003          ADC      r3,r3,r3
000708  e1844006          ORR      r4,r4,r6
00070c  e1856003          ORR      r6,r5,r3
000710  e5d03002          LDRB     r3,[r0,#2]
000714  e2033001          AND      r3,r3,#1
000718  e00c500c          AND      r5,r12,r12
00071c  e1833004          ORR      r3,r3,r4
000720  e1864005          ORR      r4,r6,r5
000724  e6ff7074          UXTH     r7,r4
000728  e59f58ac          LDR      r5,|L1.4060|
00072c  e1a04003          MOV      r4,r3
000730  e184400c          ORR      r4,r4,r12
000734  e1873005          ORR      r3,r7,r5
000738  e5823004          STR      r3,[r2,#4]
00073c  e5824000          STR      r4,[r2,#0]
000740  ea00002a          B        |L1.2032|
                  |L1.1860|
;;;537                                             pstParam->eAntialEn2,
;;;538                                             pstParam->eAntialEn1,
;;;539                                             pstParam->eBlndMode,
;;;540                                             pstParam->eClipWndEn);
;;;541        }
;;;542        else
;;;543        {
;;;544            pu64Curr[0] = DRW_TRIANGLE_RGBA32(pstParam->eAntialEn3,
000744  e5d03005          LDRB     r3,[r0,#5]
000748  e3a06000          MOV      r6,#0
00074c  e2033001          AND      r3,r3,#1
000750  e0064006          AND      r4,r6,r6
000754  e1a04304          LSL      r4,r4,#6
000758  e1844d23          ORR      r4,r4,r3,LSR #26
00075c  e1a06303          LSL      r6,r3,#6
000760  e5d03004          LDRB     r3,[r0,#4]
000764  e3a07000          MOV      r7,#0
000768  e2033001          AND      r3,r3,#1
00076c  e0075007          AND      r5,r7,r7
000770  e1a05285          LSL      r5,r5,#5
000774  e1855da3          ORR      r5,r5,r3,LSR #27
000778  e1a07004          MOV      r7,r4
00077c  e1864283          ORR      r4,r6,r3,LSL #5
000780  e1855007          ORR      r5,r5,r7
000784  e5d03003          LDRB     r3,[r0,#3]
000788  e3a07000          MOV      r7,#0
00078c  e2036001          AND      r6,r3,#1
000790  e0077007          AND      r7,r7,r7
000794  e1a07207          LSL      r7,r7,#4
000798  e1873e26          ORR      r3,r7,r6,LSR #28
00079c  e1844206          ORR      r4,r4,r6,LSL #4
0007a0  e1855003          ORR      r5,r5,r3
0007a4  e5d03001          LDRB     r3,[r0,#1]
0007a8  e3a0c000          MOV      r12,#0
0007ac  e2037007          AND      r7,r3,#7
0007b0  e00c300c          AND      r3,r12,r12
0007b4  e0976007          ADDS     r6,r7,r7
0007b8  e0a33003          ADC      r3,r3,r3
0007bc  e1a07005          MOV      r7,r5
0007c0  e1845006          ORR      r5,r4,r6
0007c4  e1874003          ORR      r4,r7,r3
0007c8  e5d03002          LDRB     r3,[r0,#2]
0007cc  e2033001          AND      r3,r3,#1
0007d0  e1856003          ORR      r6,r5,r3
0007d4  e184700c          ORR      r7,r4,r12
0007d8  e1a04006          MOV      r4,r6
0007dc  e6ff6077          UXTH     r6,r7
0007e0  e59f57f8          LDR      r5,|L1.4064|
0007e4  e1a03004          MOV      r3,r4
0007e8  e1864005          ORR      r4,r6,r5
0007ec  e8820018          STM      r2,{r3,r4}
                  |L1.2032|
;;;545                                              pstParam->eAntialEn2,
;;;546                                              pstParam->eAntialEn1,
;;;547                                              pstParam->eBlndMode,
;;;548                                              pstParam->eClipWndEn);
;;;549        }
;;;550    
;;;551        pstCmdList->pu64Current = &pu64Curr[1];
0007f0  e2823008          ADD      r3,r2,#8
0007f4  e3044000          MOVW     r4,#0x4000
0007f8  e7843001          STR      r3,[r4,r1]
;;;552    }
0007fc  e8bd80f0          POP      {r4-r7,pc}
;;;553    
                          ENDP

                  vDrw_DrawLine PROC
;;;554    /* ....................................................................... */
;;;555    void vDrw_DrawLine(drw_mem_st* pstMem, drw_OpCfg_st *pstOption,
000800  e92d43f0          PUSH     {r4-r9,lr}
;;;556                       drw_Line_st *pstLine, ga_list_st* pstCmdList)
;;;557    {
000804  e1a04000          MOV      r4,r0
000808  e1a05003          MOV      r5,r3
;;;558        uint8_t u8Curr = 5;
00080c  e3a00005          MOV      r0,#5
;;;559        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000810  e3046000          MOVW     r6,#0x4000
000814  e7963005          LDR      r3,[r6,r5]
;;;560    
;;;561    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;562    
;;;563        uint32_t u32NeededDW  = 6;
;;;564        if(pstOption->eClipWndEn == GA_EN)
;;;565        {
;;;566            u32NeededDW = u32NeededDW + 2;
;;;567        }
;;;568        if(pstOption->eBlndMode == DRW_OVERWRITING)
;;;569        {
;;;570            u32NeededDW++;
;;;571        }
;;;572        u32NeededDW = u32NeededDW + RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;573        
;;;574        /* check if there is enough space in command list: */
;;;575        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;576        {
;;;577          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;578          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;579          return;
;;;580        }
;;;581        else 
;;;582        {
;;;583          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;584        }
;;;585    #endif
;;;586    
;;;587        /* Destination Memory */
;;;588        pu64Curr[0] = DRW_LOAD_DESTADDR(pstMem->u32DstAddr);
000818  e3a07000          MOV      r7,#0
00081c  e5946000          LDR      r6,[r4,#0]
000820  e1a0e006          MOV      lr,r6
000824  e007c007          AND      r12,r7,r7
000828  e1a06007          MOV      r6,r7
00082c  e186600e          ORR      r6,r6,lr
000830  e6ff707c          UXTH     r7,r12
000834  e1a0e006          MOV      lr,r6
000838  e3877004          ORR      r7,r7,#4
00083c  e59fc78c          LDR      r12,|L1.4048|
000840  e187700c          ORR      r7,r7,r12
000844  e1c360f0          STRD     r6,r7,[r3,#0]
;;;589        pu64Curr[1] = DRW_LOAD_DESTDIM(pstMem->u16DstImgWidth, pstMem->u16DstImgHeight);
000848  e1d460b6          LDRH     r6,[r4,#6]
00084c  e3a0c000          MOV      r12,#0
000850  e3007fff          MOV      r7,#0xfff
000854  e0066007          AND      r6,r6,r7
000858  e00c700c          AND      r7,r12,r12
00085c  e1a07807          LSL      r7,r7,#16
000860  e1877826          ORR      r7,r7,r6,LSR #16
000864  e1a0c806          LSL      r12,r6,#16
000868  e1d460b4          LDRH     r6,[r4,#4]
00086c  e3a09000          MOV      r9,#0
000870  e3008fff          MOV      r8,#0xfff
000874  e0066008          AND      r6,r6,r8
000878  e009e009          AND      lr,r9,r9
00087c  e186600c          ORR      r6,r6,r12
000880  e18ee007          ORR      lr,lr,r7
000884  e00ec009          AND      r12,lr,r9
000888  e186e009          ORR      lr,r6,r9
00088c  e38c7005          ORR      r7,r12,#5
000890  e30f6fff          MOV      r6,#0xffff
000894  e1a0c00e          MOV      r12,lr
000898  e1a0e006          MOV      lr,r6
00089c  e1a0600c          MOV      r6,r12
0008a0  e00ee007          AND      lr,lr,r7
0008a4  e59fc724          LDR      r12,|L1.4048|
0008a8  e18e700c          ORR      r7,lr,r12
0008ac  e1c360f8          STRD     r6,r7,[r3,#8]
;;;590    
;;;591        /* Line Parameters */
;;;592        pu64Curr[2] = DRW_LOAD_LINESTART(pstLine->stPtStart.u16X, pstLine->stPtStart.u16Y);
0008b0  e1d260b2          LDRH     r6,[r2,#2]
0008b4  e3a0e000          MOV      lr,#0
0008b8  e6ff6076          UXTH     r6,r6
0008bc  e00e700e          AND      r7,lr,lr
0008c0  e1a07807          LSL      r7,r7,#16
0008c4  e1877826          ORR      r7,r7,r6,LSR #16
0008c8  e1a0c806          LSL      r12,r6,#16
0008cc  e1d260b0          LDRH     r6,[r2,#0]
0008d0  e6ff6076          UXTH     r6,r6
0008d4  e00ee00e          AND      lr,lr,lr
0008d8  e186600c          ORR      r6,r6,r12
0008dc  e187700e          ORR      r7,r7,lr
0008e0  e1a07006          MOV      r7,r6
0008e4  e3a08000          MOV      r8,#0
0008e8  e1877008          ORR      r7,r7,r8
0008ec  e3a06006          MOV      r6,#6
0008f0  e1a0c006          MOV      r12,r6
0008f4  e59fe6d4          LDR      lr,|L1.4048|
0008f8  e1876008          ORR      r6,r7,r8
0008fc  e18c700e          ORR      r7,r12,lr
000900  e1c361f0          STRD     r6,r7,[r3,#0x10]
;;;593        pu64Curr[3] = DRW_LOAD_LINEEND(pstLine->stPtEnd.u16X, pstLine->stPtEnd.u16Y);
000904  e1d260b6          LDRH     r6,[r2,#6]
000908  e3a0c000          MOV      r12,#0
00090c  e6ff6076          UXTH     r6,r6
000910  e00c700c          AND      r7,r12,r12
000914  e1a07807          LSL      r7,r7,#16
000918  e187c826          ORR      r12,r7,r6,LSR #16
00091c  e1a0e806          LSL      lr,r6,#16
000920  e1d260b4          LDRH     r6,[r2,#4]
000924  e3a07000          MOV      r7,#0
000928  e6ff6076          UXTH     r6,r6
00092c  e0077007          AND      r7,r7,r7
000930  e186600e          ORR      r6,r6,lr
000934  e18ce007          ORR      lr,r12,r7
000938  e3a0e000          MOV      lr,#0
00093c  e186600e          ORR      r6,r6,lr
000940  e3a07007          MOV      r7,#7
000944  e1a0c006          MOV      r12,r6
000948  e1a0e007          MOV      lr,r7
00094c  e59f767c          LDR      r7,|L1.4048|
000950  e187700e          ORR      r7,r7,lr
000954  e1c361f8          STRD     r6,r7,[r3,#0x18]
;;;594        pu64Curr[4] = DRW_LOAD_THICKNESS(pstLine->u16Thickness);
000958  e1d261b8          LDRH     r6,[r2,#0x18]
00095c  e30071ff          MOV      r7,#0x1ff
000960  e006e007          AND      lr,r6,r7
000964  e0087008          AND      r7,r8,r8
000968  e007c008          AND      r12,r7,r8
00096c  e6ff807c          UXTH     r8,r12
000970  e1a0c00e          MOV      r12,lr
000974  e388e009          ORR      lr,r8,#9
000978  e59f7650          LDR      r7,|L1.4048|
00097c  e187700e          ORR      r7,r7,lr
000980  e5837024          STR      r7,[r3,#0x24]
000984  e583c020          STR      r12,[r3,#0x20]
;;;595    
;;;596        /* Clipping Window */
;;;597        if(pstOption->eClipWndEn == GA_EN)
000988  e5d16008          LDRB     r6,[r1,#8]
00098c  e3560001          CMP      r6,#1
000990  1a000038          BNE      |L1.2680|
;;;598        {
;;;599            pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDSTART(pstOption->stClipWnd.u16UlX,
000994  e1d160bc          LDRH     r6,[r1,#0xc]
000998  e3a0e000          MOV      lr,#0
00099c  e3007fff          MOV      r7,#0xfff
0009a0  e0066007          AND      r6,r6,r7
0009a4  e00e700e          AND      r7,lr,lr
0009a8  e1a07807          LSL      r7,r7,#16
0009ac  e187c826          ORR      r12,r7,r6,LSR #16
0009b0  e1a07806          LSL      r7,r6,#16
0009b4  e1d160ba          LDRH     r6,[r1,#0xa]
0009b8  e3008fff          MOV      r8,#0xfff
0009bc  e0066008          AND      r6,r6,r8
0009c0  e00ee00e          AND      lr,lr,lr
0009c4  e1a0800c          MOV      r8,r12
0009c8  e187c006          ORR      r12,r7,r6
0009cc  e18ee008          ORR      lr,lr,r8
0009d0  e1a0e00c          MOV      lr,r12
0009d4  e3a08000          MOV      r8,#0
0009d8  e1a07008          MOV      r7,r8
0009dc  e3a0c001          MOV      r12,#1
0009e0  e1a06008          MOV      r6,r8
0009e4  e1a0800c          MOV      r8,r12
0009e8  e18ee007          ORR      lr,lr,r7
0009ec  e1888006          ORR      r8,r8,r6
0009f0  e6ff6078          UXTH     r6,r8
0009f4  e59f75d4          LDR      r7,|L1.4048|
0009f8  e1866007          ORR      r6,r6,r7
0009fc  e0837180          ADD      r7,r3,r0,LSL #3
000a00  e5876004          STR      r6,[r7,#4]
000a04  e587e000          STR      lr,[r7,#0]
;;;600                                                     pstOption->stClipWnd.u16UlY);
;;;601            u8Curr++;
000a08  e2806001          ADD      r6,r0,#1
000a0c  e20600ff          AND      r0,r6,#0xff
;;;602            pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDEND(pstOption->stClipWnd.u16LrX,
000a10  e1d161b0          LDRH     r6,[r1,#0x10]
000a14  e3a0e000          MOV      lr,#0
000a18  e3007fff          MOV      r7,#0xfff
000a1c  e0066007          AND      r6,r6,r7
000a20  e00e700e          AND      r7,lr,lr
000a24  e1a07807          LSL      r7,r7,#16
000a28  e1877826          ORR      r7,r7,r6,LSR #16
000a2c  e1a0c806          LSL      r12,r6,#16
000a30  e1d160be          LDRH     r6,[r1,#0xe]
000a34  e3008fff          MOV      r8,#0xfff
000a38  e0066008          AND      r6,r6,r8
000a3c  e00ee00e          AND      lr,lr,lr
000a40  e1a08007          MOV      r8,r7
000a44  e18c7006          ORR      r7,r12,r6
000a48  e18ee008          ORR      lr,lr,r8
000a4c  e3a08000          MOV      r8,#0
000a50  e1876008          ORR      r6,r7,r8
000a54  e3a0c002          MOV      r12,#2
000a58  e1a0e00c          MOV      lr,r12
000a5c  e59fc56c          LDR      r12,|L1.4048|
000a60  e1866008          ORR      r6,r6,r8
000a64  e18e700c          ORR      r7,lr,r12
000a68  e083c180          ADD      r12,r3,r0,LSL #3
000a6c  e1cc60f0          STRD     r6,r7,[r12,#0]
;;;603                                                   pstOption->stClipWnd.u16LrY);
;;;604            u8Curr++;
000a70  e2806001          ADD      r6,r0,#1
000a74  e20600ff          AND      r0,r6,#0xff
                  |L1.2680|
;;;605        }
;;;606    
;;;607        if(pstLine->stColor.eColFmt == GA_RGB16)
000a78  e5d2600c          LDRB     r6,[r2,#0xc]
000a7c  e3560000          CMP      r6,#0
000a80  1a000053          BNE      |L1.3028|
;;;608        {
;;;609            /* Background Color */
;;;610            if(pstOption->eBlndMode == DRW_OVERWRITING)
000a84  e5d16000          LDRB     r6,[r1,#0]
000a88  e3560002          CMP      r6,#2
000a8c  1a000014          BNE      |L1.2788|
;;;611            {
;;;612                pu64Curr[u8Curr] = DRW_LOAD_RGB16BGRND(pstOption->u32BgColor);
000a90  e3a0e000          MOV      lr,#0
000a94  e5916004          LDR      r6,[r1,#4]
000a98  e6ffc076          UXTH     r12,r6
000a9c  e00e800e          AND      r8,lr,lr
000aa0  e1a0600e          MOV      r6,lr
000aa4  e1a0e00c          MOV      lr,r12
000aa8  e1a0c008          MOV      r12,r8
000aac  e1a08006          MOV      r8,r6
000ab0  e1a0600e          MOV      r6,lr
000ab4  e00ce008          AND      lr,r12,r8
000ab8  e6ff807e          UXTH     r8,lr
000abc  e1a0c006          MOV      r12,r6
000ac0  e1a0700c          MOV      r7,r12
000ac4  e388c00b          ORR      r12,r8,#0xb
000ac8  e59fe500          LDR      lr,|L1.4048|
000acc  e18c600e          ORR      r6,r12,lr
000ad0  e083c180          ADD      r12,r3,r0,LSL #3
000ad4  e58c6004          STR      r6,[r12,#4]
000ad8  e58c7000          STR      r7,[r12,#0]
;;;613                u8Curr++;
000adc  e2806001          ADD      r6,r0,#1
000ae0  e20600ff          AND      r0,r6,#0xff
                  |L1.2788|
;;;614            }
;;;615    
;;;616            /* Line Color */
;;;617            pu64Curr[u8Curr] = DRW_LOAD_RGB16((uint16_t)(pstLine->stColor.u32Color),
000ae4  e5d26014          LDRB     r6,[r2,#0x14]
000ae8  e3a0c000          MOV      r12,#0
000aec  e00c700c          AND      r7,r12,r12
000af0  e1a07807          LSL      r7,r7,#16
000af4  e1877826          ORR      r7,r7,r6,LSR #16
000af8  e1a0c806          LSL      r12,r6,#16
000afc  e1d261b0          LDRH     r6,[r2,#0x10]
000b00  e3a09000          MOV      r9,#0
000b04  e6ff6076          UXTH     r6,r6
000b08  e009e009          AND      lr,r9,r9
000b0c  e186600c          ORR      r6,r6,r12
000b10  e187800e          ORR      r8,r7,lr
000b14  e0087009          AND      r7,r8,r9
000b18  e186e009          ORR      lr,r6,r9
000b1c  e6ff6077          UXTH     r6,r7
000b20  e1a0700e          MOV      r7,lr
000b24  e386c00a          ORR      r12,r6,#0xa
000b28  e59fe4a0          LDR      lr,|L1.4048|
000b2c  e18c600e          ORR      r6,r12,lr
000b30  e083c180          ADD      r12,r3,r0,LSL #3
000b34  e58c6004          STR      r6,[r12,#4]
000b38  e58c7000          STR      r7,[r12,#0]
;;;618                                               pstLine->stColor.u8Alpha);
;;;619            u8Curr++;
000b3c  e2806001          ADD      r6,r0,#1
000b40  e20600ff          AND      r0,r6,#0xff
;;;620    
;;;621            /* Line Draw Command */
;;;622            pu64Curr[u8Curr] = DRW_LINERGB16(pstLine->eStartCap,
000b44  e5d26008          LDRB     r6,[r2,#8]
000b48  e3a0c000          MOV      r12,#0
000b4c  e206600f          AND      r6,r6,#0xf
000b50  e00c700c          AND      r7,r12,r12
000b54  e1a07407          LSL      r7,r7,#8
000b58  e1877c26          ORR      r7,r7,r6,LSR #24
000b5c  e1a0c406          LSL      r12,r6,#8
000b60  e5d26009          LDRB     r6,[r2,#9]
000b64  e3a0e000          MOV      lr,#0
000b68  e206600f          AND      r6,r6,#0xf
000b6c  e00ee00e          AND      lr,lr,lr
000b70  e1a0e20e          LSL      lr,lr,#4
000b74  e18e8e26          ORR      r8,lr,r6,LSR #28
000b78  e18ce206          ORR      lr,r12,r6,LSL #4
000b7c  e1877008          ORR      r7,r7,r8
000b80  e5d16000          LDRB     r6,[r1,#0]
000b84  e2068007          AND      r8,r6,#7
000b88  e0096009          AND      r6,r9,r9
000b8c  e098c008          ADDS     r12,r8,r8
000b90  e0a66006          ADC      r6,r6,r6
000b94  e18ee00c          ORR      lr,lr,r12
000b98  e1878006          ORR      r8,r7,r6
000b9c  e5d16008          LDRB     r6,[r1,#8]
000ba0  e2066001          AND      r6,r6,#1
000ba4  e0097009          AND      r7,r9,r9
000ba8  e18ee006          ORR      lr,lr,r6
000bac  e1886007          ORR      r6,r8,r7
000bb0  e6ff7076          UXTH     r7,r6
000bb4  e59f8418          LDR      r8,|L1.4052|
000bb8  e1877008          ORR      r7,r7,r8
000bbc  e083c180          ADD      r12,r3,r0,LSL #3
000bc0  e58c7004          STR      r7,[r12,#4]
000bc4  e58ce000          STR      lr,[r12,#0]
;;;623                                             pstLine->eEndCap,
;;;624                                             pstOption->eBlndMode,
;;;625                                             pstOption->eClipWndEn);
;;;626            u8Curr++;
000bc8  e2806001          ADD      r6,r0,#1
000bcc  e20600ff          AND      r0,r6,#0xff
000bd0  ea000045          B        |L1.3308|
                  |L1.3028|
;;;627        }
;;;628        else
;;;629        {
;;;630            if(pstOption->eBlndMode == DRW_OVERWRITING)
000bd4  e5d16000          LDRB     r6,[r1,#0]
000bd8  e3560002          CMP      r6,#2
000bdc  1a000012          BNE      |L1.3116|
;;;631            {
;;;632                pu64Curr[u8Curr] = DRW_LOAD_RGBA32BGRND(pstOption->u32BgColor);
000be0  e3a07000          MOV      r7,#0
000be4  e007e007          AND      lr,r7,r7
000be8  e1a08007          MOV      r8,r7
000bec  e1a0c007          MOV      r12,r7
000bf0  e3a0700b          MOV      r7,#0xb
000bf4  e5916004          LDR      r6,[r1,#4]
000bf8  e1a0e006          MOV      lr,r6
000bfc  e1a06008          MOV      r6,r8
000c00  e1a08007          MOV      r8,r7
000c04  e18ee00c          ORR      lr,lr,r12
000c08  e1866008          ORR      r6,r6,r8
000c0c  e6ff7076          UXTH     r7,r6
000c10  e59f83b8          LDR      r8,|L1.4048|
000c14  e1877008          ORR      r7,r7,r8
000c18  e083c180          ADD      r12,r3,r0,LSL #3
000c1c  e58c7004          STR      r7,[r12,#4]
000c20  e58ce000          STR      lr,[r12,#0]
;;;633                u8Curr++;
000c24  e2806001          ADD      r6,r0,#1
000c28  e20600ff          AND      r0,r6,#0xff
                  |L1.3116|
;;;634            }
;;;635    
;;;636            pu64Curr[u8Curr] = DRW_LOAD_RGBA32(pstLine->stColor.u32Color);
000c2c  e3a0e000          MOV      lr,#0
000c30  e5926010          LDR      r6,[r2,#0x10]
000c34  e1a07006          MOV      r7,r6
000c38  e00e600e          AND      r6,lr,lr
000c3c  e1a0c00e          MOV      r12,lr
000c40  e1a06007          MOV      r6,r7
000c44  e186600c          ORR      r6,r6,r12
000c48  e1a07006          MOV      r7,r6
000c4c  e59f6390          LDR      r6,|L1.4068|
000c50  e083c180          ADD      r12,r3,r0,LSL #3
000c54  e58c6004          STR      r6,[r12,#4]
000c58  e58c7000          STR      r7,[r12,#0]
;;;637            u8Curr++;
000c5c  e2806001          ADD      r6,r0,#1
000c60  e20600ff          AND      r0,r6,#0xff
;;;638    
;;;639            pu64Curr[u8Curr] = DRW_LINERGBA32(pstLine->eStartCap,
000c64  e5d26008          LDRB     r6,[r2,#8]
000c68  e206600f          AND      r6,r6,#0xf
000c6c  e00e700e          AND      r7,lr,lr
000c70  e1a07407          LSL      r7,r7,#8
000c74  e187ec26          ORR      lr,r7,r6,LSR #24
000c78  e1a08406          LSL      r8,r6,#8
000c7c  e5d26009          LDRB     r6,[r2,#9]
000c80  e3a09000          MOV      r9,#0
000c84  e206c00f          AND      r12,r6,#0xf
000c88  e0097009          AND      r7,r9,r9
000c8c  e1a07207          LSL      r7,r7,#4
000c90  e1876e2c          ORR      r6,r7,r12,LSR #28
000c94  e188820c          ORR      r8,r8,r12,LSL #4
000c98  e18ee006          ORR      lr,lr,r6
000c9c  e5d16000          LDRB     r6,[r1,#0]
000ca0  e206c007          AND      r12,r6,#7
000ca4  e0096009          AND      r6,r9,r9
000ca8  e09c700c          ADDS     r7,r12,r12
000cac  e0a66006          ADC      r6,r6,r6
000cb0  e1877008          ORR      r7,r7,r8
000cb4  e18ee006          ORR      lr,lr,r6
000cb8  e5d16008          LDRB     r6,[r1,#8]
000cbc  e3a0c000          MOV      r12,#0
000cc0  e2066001          AND      r6,r6,#1
000cc4  e00cc00c          AND      r12,r12,r12
000cc8  e1866007          ORR      r6,r6,r7
000ccc  e18e700c          ORR      r7,lr,r12
000cd0  e6ff7077          UXTH     r7,r7
000cd4  e59f82fc          LDR      r8,|L1.4056|
000cd8  e1877008          ORR      r7,r7,r8
000cdc  e083c180          ADD      r12,r3,r0,LSL #3
000ce0  e1cc60f0          STRD     r6,r7,[r12,#0]
;;;640                                              pstLine->eEndCap,
;;;641                                              pstOption->eBlndMode,
;;;642                                              pstOption->eClipWndEn);
;;;643            u8Curr++;
000ce4  e2806001          ADD      r6,r0,#1
000ce8  e20600ff          AND      r0,r6,#0xff
                  |L1.3308|
;;;644        }
;;;645    
;;;646        pstCmdList->pu64Current = &pu64Curr[u8Curr];
000cec  e0836180          ADD      r6,r3,r0,LSL #3
000cf0  e3047000          MOVW     r7,#0x4000
000cf4  e7876005          STR      r6,[r7,r5]
;;;647    }
000cf8  e8bd83f0          POP      {r4-r9,pc}
;;;648    
                          ENDP

                  vDrw_DrawTriangle PROC
;;;649    /* ....................................................................... */
;;;650    void vDrw_DrawTriangle(drw_mem_st* pstMem, drw_OpCfg_st *pstOption,
000cfc  e92d43f0          PUSH     {r4-r9,lr}
;;;651                           drw_Trngl_st *pstTrngl, ga_list_st* pstCmdList)
;;;652    {
000d00  e1a04000          MOV      r4,r0
000d04  e1a05003          MOV      r5,r3
;;;653        uint8_t u8Curr = 5;
000d08  e3a00005          MOV      r0,#5
;;;654        uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
000d0c  e3046000          MOVW     r6,#0x4000
000d10  e7963005          LDR      r3,[r6,r5]
;;;655    
;;;656    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;657    
;;;658        uint32_t u32NeededDW  = 6;
;;;659       
;;;660        if(pstOption->eClipWndEn == GA_EN)
;;;661        {
;;;662            u32NeededDW = u32NeededDW + 2;
;;;663        }
;;;664        if(pstOption->eBlndMode == DRW_OVERWRITING)
;;;665        {
;;;666            u32NeededDW++;
;;;667        }
;;;668        u32NeededDW = u32NeededDW + RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;669        
;;;670        /* check if there is enough space in command list: */
;;;671        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;672        {
;;;673          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;674          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;675          return;
;;;676        }
;;;677        else 
;;;678        {
;;;679          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;680        }
;;;681    #endif
;;;682    
;;;683        /* Destination Memory */
;;;684        pu64Curr[0] = DRW_LOAD_DESTADDR(pstMem->u32DstAddr);
000d14  e3a07000          MOV      r7,#0
000d18  e0076007          AND      r6,r7,r7
000d1c  e594c000          LDR      r12,[r4,#0]
000d20  e187700c          ORR      r7,r7,r12
000d24  e6ffe076          UXTH     lr,r6
000d28  e38ec004          ORR      r12,lr,#4
000d2c  e59fe29c          LDR      lr,|L1.4048|
000d30  e1a06007          MOV      r6,r7
000d34  e18c700e          ORR      r7,r12,lr
000d38  e1c360f0          STRD     r6,r7,[r3,#0]
;;;685        pu64Curr[1] = DRW_LOAD_DESTDIM(pstMem->u16DstImgWidth, pstMem->u16DstImgHeight);
000d3c  e1d460b6          LDRH     r6,[r4,#6]
000d40  e3a0c000          MOV      r12,#0
000d44  e3007fff          MOV      r7,#0xfff
000d48  e0066007          AND      r6,r6,r7
000d4c  e00c700c          AND      r7,r12,r12
000d50  e1a07807          LSL      r7,r7,#16
000d54  e1877826          ORR      r7,r7,r6,LSR #16
000d58  e1a0c806          LSL      r12,r6,#16
000d5c  e1d460b4          LDRH     r6,[r4,#4]
000d60  e3a08000          MOV      r8,#0
000d64  e300efff          MOV      lr,#0xfff
000d68  e006600e          AND      r6,r6,lr
000d6c  e008e008          AND      lr,r8,r8
000d70  e18cc006          ORR      r12,r12,r6
000d74  e187700e          ORR      r7,r7,lr
000d78  e0077008          AND      r7,r7,r8
000d7c  e1a0e008          MOV      lr,r8
000d80  e18cc00e          ORR      r12,r12,lr
000d84  e6ff6077          UXTH     r6,r7
000d88  e1a0700c          MOV      r7,r12
000d8c  e386e005          ORR      lr,r6,#5
000d90  e59fc238          LDR      r12,|L1.4048|
000d94  e1a06007          MOV      r6,r7
000d98  e18e700c          ORR      r7,lr,r12
000d9c  e1c360f8          STRD     r6,r7,[r3,#8]
;;;686    
;;;687        /* Triangle Points */
;;;688        pu64Curr[2] = DRW_LOAD_TRNGLE1(pstTrngl->stPt1.u16X, pstTrngl->stPt1.u16Y);
000da0  e1d260b2          LDRH     r6,[r2,#2]
000da4  e3a07000          MOV      r7,#0
000da8  e6ff6076          UXTH     r6,r6
000dac  e0077007          AND      r7,r7,r7
000db0  e1a07807          LSL      r7,r7,#16
000db4  e187e826          ORR      lr,r7,r6,LSR #16
000db8  e1a08806          LSL      r8,r6,#16
000dbc  e1d260b0          LDRH     r6,[r2,#0]
000dc0  e3a09000          MOV      r9,#0
000dc4  e6ff6076          UXTH     r6,r6
000dc8  e009c009          AND      r12,r9,r9
000dcc  e1887006          ORR      r7,r8,r6
000dd0  e18e600c          ORR      r6,lr,r12
000dd4  e006e009          AND      lr,r6,r9
000dd8  e1878009          ORR      r8,r7,r9
000ddc  e6ffc07e          UXTH     r12,lr
000de0  e38c7006          ORR      r7,r12,#6
000de4  e59fc1e4          LDR      r12,|L1.4048|
000de8  e187700c          ORR      r7,r7,r12
000dec  e5837014          STR      r7,[r3,#0x14]
000df0  e5838010          STR      r8,[r3,#0x10]
;;;689        pu64Curr[3] = DRW_LOAD_TRNGLE2(pstTrngl->stPt2.u16X, pstTrngl->stPt2.u16Y);
000df4  e1d260b6          LDRH     r6,[r2,#6]
000df8  e3a0c000          MOV      r12,#0
000dfc  e6ff6076          UXTH     r6,r6
000e00  e00c700c          AND      r7,r12,r12
000e04  e1a07807          LSL      r7,r7,#16
000e08  e1877826          ORR      r7,r7,r6,LSR #16
000e0c  e1a0c806          LSL      r12,r6,#16
000e10  e1d260b4          LDRH     r6,[r2,#4]
000e14  e3a0e000          MOV      lr,#0
000e18  e6ff6076          UXTH     r6,r6
000e1c  e00ee00e          AND      lr,lr,lr
000e20  e186600c          ORR      r6,r6,r12
000e24  e187800e          ORR      r8,r7,lr
000e28  e1a0e006          MOV      lr,r6
000e2c  e3a06000          MOV      r6,#0
000e30  e18e7006          ORR      r7,lr,r6
000e34  e1a0c006          MOV      r12,r6
000e38  e187700c          ORR      r7,r7,r12
000e3c  e59f61a4          LDR      r6,|L1.4072|
000e40  e583601c          STR      r6,[r3,#0x1c]
000e44  e5837018          STR      r7,[r3,#0x18]
;;;690        pu64Curr[4] = DRW_LOAD_TRNGLE3(pstTrngl->stPt3.u16X, pstTrngl->stPt3.u16Y);
000e48  e1d260ba          LDRH     r6,[r2,#0xa]
000e4c  e3a0e000          MOV      lr,#0
000e50  e6ff6076          UXTH     r6,r6
000e54  e00e700e          AND      r7,lr,lr
000e58  e1a07807          LSL      r7,r7,#16
000e5c  e187c826          ORR      r12,r7,r6,LSR #16
000e60  e1a0e806          LSL      lr,r6,#16
000e64  e1d260b8          LDRH     r6,[r2,#8]
000e68  e6ff6076          UXTH     r6,r6
000e6c  e0098009          AND      r8,r9,r9
000e70  e18e7006          ORR      r7,lr,r6
000e74  e18ce008          ORR      lr,r12,r8
000e78  e00ee009          AND      lr,lr,r9
000e7c  e1877009          ORR      r7,r7,r9
000e80  e6ff607e          UXTH     r6,lr
000e84  e1a0e007          MOV      lr,r7
000e88  e3868008          ORR      r8,r6,#8
000e8c  e59fc13c          LDR      r12,|L1.4048|
000e90  e188700c          ORR      r7,r8,r12
000e94  e5837024          STR      r7,[r3,#0x24]
000e98  e583e020          STR      lr,[r3,#0x20]
;;;691        /* Clipping Window */
;;;692        if(pstOption->eClipWndEn == GA_EN)
000e9c  e5d16008          LDRB     r6,[r1,#8]
000ea0  e3560001          CMP      r6,#1
000ea4  1a00003d          BNE      |L1.4000|
;;;693        {
;;;694            pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDSTART(pstOption->stClipWnd.u16UlX,
000ea8  e1d160bc          LDRH     r6,[r1,#0xc]
000eac  e3a0e000          MOV      lr,#0
000eb0  e300cfff          MOV      r12,#0xfff
000eb4  e006600c          AND      r6,r6,r12
000eb8  e00e700e          AND      r7,lr,lr
000ebc  e1a07807          LSL      r7,r7,#16
000ec0  e1877826          ORR      r7,r7,r6,LSR #16
000ec4  e1a0c806          LSL      r12,r6,#16
000ec8  e1d160ba          LDRH     r6,[r1,#0xa]
000ecc  e3009fff          MOV      r9,#0xfff
000ed0  e0066009          AND      r6,r6,r9
000ed4  e00e800e          AND      r8,lr,lr
000ed8  e18ce006          ORR      lr,r12,r6
000edc  e1888007          ORR      r8,r8,r7
000ee0  e3a0c000          MOV      r12,#0
000ee4  e1a0700e          MOV      r7,lr
000ee8  e1a0e008          MOV      lr,r8
000eec  e1a0800c          MOV      r8,r12
000ef0  e1a0c007          MOV      r12,r7
000ef4  e00e6008          AND      r6,lr,r8
000ef8  e1a0e00c          MOV      lr,r12
000efc  e6ff6076          UXTH     r6,r6
000f00  e1a0700e          MOV      r7,lr
000f04  e386c001          ORR      r12,r6,#1
000f08  e59f80c0          LDR      r8,|L1.4048|
000f0c  e1a06007          MOV      r6,r7
000f10  e18c7008          ORR      r7,r12,r8
000f14  e083c180          ADD      r12,r3,r0,LSL #3
000f18  e1cc60f0          STRD     r6,r7,[r12,#0]
;;;695                                                     pstOption->stClipWnd.u16UlY);
;;;696            u8Curr++;
000f1c  e2806001          ADD      r6,r0,#1
000f20  e20600ff          AND      r0,r6,#0xff
;;;697            pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDEND(pstOption->stClipWnd.u16LrX,
000f24  e1d161b0          LDRH     r6,[r1,#0x10]
000f28  e3a0e000          MOV      lr,#0
000f2c  e300cfff          MOV      r12,#0xfff
000f30  e006600c          AND      r6,r6,r12
000f34  e00e700e          AND      r7,lr,lr
000f38  e1a07807          LSL      r7,r7,#16
000f3c  e1878826          ORR      r8,r7,r6,LSR #16
000f40  e1a07806          LSL      r7,r6,#16
000f44  e1d160be          LDRH     r6,[r1,#0xe]
000f48  e006600c          AND      r6,r6,r12
000f4c  e00ec00e          AND      r12,lr,lr
000f50  e1866007          ORR      r6,r6,r7
000f54  e188800c          ORR      r8,r8,r12
000f58  e3a07000          MOV      r7,#0
000f5c  e1a0c006          MOV      r12,r6
000f60  e1a06008          MOV      r6,r8
000f64  e1a08007          MOV      r8,r7
000f68  e1a0700c          MOV      r7,r12
000f6c  e006c008          AND      r12,r6,r8
000f70  e1a06007          MOV      r6,r7
000f74  e6ff807c          UXTH     r8,r12
000f78  e1a0c006          MOV      r12,r6
000f7c  e1a0700c          MOV      r7,r12
000f80  e3886002          ORR      r6,r8,#2
000f84  e59fe044          LDR      lr,|L1.4048|
000f88  e186600e          ORR      r6,r6,lr
000f8c  e083c180          ADD      r12,r3,r0,LSL #3
000f90  e58c6004          STR      r6,[r12,#4]
000f94  e58c7000          STR      r7,[r12,#0]
;;;698                                                   pstOption->stClipWnd.u16LrY);
;;;699            u8Curr++;
000f98  e2806001          ADD      r6,r0,#1
000f9c  e20600ff          AND      r0,r6,#0xff
                  |L1.4000|
;;;700        }
;;;701    
;;;702        if(pstTrngl->stColor.eColFmt == GA_RGB16)
000fa0  e5d26010          LDRB     r6,[r2,#0x10]
000fa4  e3560000          CMP      r6,#0
000fa8  1a000065          BNE      |L1.4420|
;;;703        {
;;;704            /* Background Color */
;;;705            if(pstOption->eBlndMode == DRW_OVERWRITING)
000fac  e5d16000          LDRB     r6,[r1,#0]
000fb0  e3560002          CMP      r6,#2
000fb4  1a00001a          BNE      |L1.4132|
;;;706            {
;;;707                pu64Curr[u8Curr] = DRW_LOAD_RGB16BGRND(pstOption->u32BgColor);
000fb8  e3a0e000          MOV      lr,#0
000fbc  ea00000a          B        |L1.4076|
                  |L1.4032|
                          DCD      au8LLDD_GA_DRAW_C_REVISION
                  |L1.4036|
                          DCD      au8LLDD_GA_DRAW_C_TAG
                  |L1.4040|
                          DCD      au8LLDD_GA_DRAW_H_REVISION
                  |L1.4044|
                          DCD      au8LLDD_GA_DRAW_H_TAG
                  |L1.4048|
                          DCD      0x01010000
                  |L1.4052|
                          DCD      0x21040000
                  |L1.4056|
                          DCD      0x21030000
                  |L1.4060|
                          DCD      0x21060000
                  |L1.4064|
                          DCD      0x21050000
                  |L1.4068|
                          DCD      0x0101000a
                  |L1.4072|
                          DCD      0x01010007
                  |L1.4076|
000fec  e5916004          LDR      r6,[r1,#4]
000ff0  e6ffc076          UXTH     r12,r6
000ff4  e00e700e          AND      r7,lr,lr
000ff8  e18cc00e          ORR      r12,r12,lr
000ffc  e3a0600b          MOV      r6,#0xb
001000  e1a0700c          MOV      r7,r12
001004  e1a0c006          MOV      r12,r6
001008  e51f8040          LDR      r8,|L1.4048|
00100c  e187600e          ORR      r6,r7,lr
001010  e18c7008          ORR      r7,r12,r8
001014  e083c180          ADD      r12,r3,r0,LSL #3
001018  e1cc60f0          STRD     r6,r7,[r12,#0]
;;;708                u8Curr++;
00101c  e2806001          ADD      r6,r0,#1
001020  e20600ff          AND      r0,r6,#0xff
                  |L1.4132|
;;;709            }
;;;710    
;;;711            /* Line Color */
;;;712            pu64Curr[u8Curr] = DRW_LOAD_RGB16((uint16_t)(pstTrngl->stColor.u32Color),
001024  e5d26018          LDRB     r6,[r2,#0x18]
001028  e3a0c000          MOV      r12,#0
00102c  e00c700c          AND      r7,r12,r12
001030  e1a07807          LSL      r7,r7,#16
001034  e187c826          ORR      r12,r7,r6,LSR #16
001038  e1a0e806          LSL      lr,r6,#16
00103c  e1d261b4          LDRH     r6,[r2,#0x14]
001040  e3a08000          MOV      r8,#0
001044  e6ff6076          UXTH     r6,r6
001048  e0087008          AND      r7,r8,r8
00104c  e186600e          ORR      r6,r6,lr
001050  e18ce007          ORR      lr,r12,r7
001054  e1a07006          MOV      r7,r6
001058  e00e6008          AND      r6,lr,r8
00105c  e187e008          ORR      lr,r7,r8
001060  e6ff7076          UXTH     r7,r6
001064  e1a0c00e          MOV      r12,lr
001068  e387e00a          ORR      lr,r7,#0xa
00106c  e51f80a4          LDR      r8,|L1.4048|
001070  e1a0600c          MOV      r6,r12
001074  e18e7008          ORR      r7,lr,r8
001078  e083c180          ADD      r12,r3,r0,LSL #3
00107c  e1cc60f0          STRD     r6,r7,[r12,#0]
;;;713                                              pstTrngl->stColor.u8Alpha);
;;;714            u8Curr++;
001080  e2806001          ADD      r6,r0,#1
001084  e20600ff          AND      r0,r6,#0xff
;;;715    
;;;716            /* Triangle Draw Command */
;;;717            pu64Curr[u8Curr] = DRW_TRIANGLE_RGB16(pstTrngl->eAntialEn3,
001088  e5d2600e          LDRB     r6,[r2,#0xe]
00108c  e3a0c000          MOV      r12,#0
001090  e2066001          AND      r6,r6,#1
001094  e00c700c          AND      r7,r12,r12
001098  e1a07307          LSL      r7,r7,#6
00109c  e1877d26          ORR      r7,r7,r6,LSR #26
0010a0  e1a0e306          LSL      lr,r6,#6
0010a4  e5d2600d          LDRB     r6,[r2,#0xd]
0010a8  e2066001          AND      r6,r6,#1
0010ac  e00cc00c          AND      r12,r12,r12
0010b0  e1a0c28c          LSL      r12,r12,#5
0010b4  e18c8da6          ORR      r8,r12,r6,LSR #27
0010b8  e18ec286          ORR      r12,lr,r6,LSL #5
0010bc  e1877008          ORR      r7,r7,r8
0010c0  e5d2600c          LDRB     r6,[r2,#0xc]
0010c4  e3a09000          MOV      r9,#0
0010c8  e206e001          AND      lr,r6,#1
0010cc  e0098009          AND      r8,r9,r9
0010d0  e1a08208          LSL      r8,r8,#4
0010d4  e1886e2e          ORR      r6,r8,lr,LSR #28
0010d8  e18cc20e          ORR      r12,r12,lr,LSL #4
0010dc  e1877006          ORR      r7,r7,r6
0010e0  e5d16000          LDRB     r6,[r1,#0]
0010e4  e2066007          AND      r6,r6,#7
0010e8  e009e009          AND      lr,r9,r9
0010ec  e0966006          ADDS     r6,r6,r6
0010f0  e0ae800e          ADC      r8,lr,lr
0010f4  e18ce006          ORR      lr,r12,r6
0010f8  e187c008          ORR      r12,r7,r8
0010fc  e5d16008          LDRB     r6,[r1,#8]
001100  e3a08000          MOV      r8,#0
001104  e2066001          AND      r6,r6,#1
001108  e0087008          AND      r7,r8,r8
00110c  e186600e          ORR      r6,r6,lr
001110  e18ce007          ORR      lr,r12,r7
001114  e6ff807e          UXTH     r8,lr
001118  e51f7144          LDR      r7,|L1.4060|
00111c  e1a0e006          MOV      lr,r6
001120  e1a06008          MOV      r6,r8
001124  e1a08007          MOV      r8,r7
001128  e1866008          ORR      r6,r6,r8
00112c  e083c180          ADD      r12,r3,r0,LSL #3
001130  e58c6004          STR      r6,[r12,#4]
001134  e58ce000          STR      lr,[r12,#0]
;;;718                                                  pstTrngl->eAntialEn2,
;;;719                                                  pstTrngl->eAntialEn1,
;;;720                                                  pstOption->eBlndMode,
;;;721                                                  pstOption->eClipWndEn);
;;;722            u8Curr++;
001138  e2806001          ADD      r6,r0,#1
00113c  e20600ff          AND      r0,r6,#0xff
001140  ea00004f          B        |L1.4740|
                  |L1.4420|
;;;723        }
;;;724        else
;;;725        {
;;;726            /* Background Color */
;;;727            if(pstOption->eBlndMode == DRW_OVERWRITING)
001144  e5d16000          LDRB     r6,[r1,#0]
001148  e3560002          CMP      r6,#2
00114c  1a00000e          BNE      |L1.4492|
;;;728            {
;;;729                pu64Curr[u8Curr] = DRW_LOAD_RGBA32BGRND(pstOption->u32BgColor);
001150  e3a07000          MOV      r7,#0
001154  e0076007          AND      r6,r7,r7
001158  e1a08007          MOV      r8,r7
00115c  e591e004          LDR      lr,[r1,#4]
001160  e1a0700e          MOV      r7,lr
001164  e0066008          AND      r6,r6,r8
001168  e6ffe076          UXTH     lr,r6
00116c  e38e600b          ORR      r6,lr,#0xb
001170  e51f81a8          LDR      r8,|L1.4048|
001174  e1866008          ORR      r6,r6,r8
001178  e083c180          ADD      r12,r3,r0,LSL #3
00117c  e58c6004          STR      r6,[r12,#4]
001180  e58c7000          STR      r7,[r12,#0]
;;;730                u8Curr++;
001184  e2806001          ADD      r6,r0,#1
001188  e20600ff          AND      r0,r6,#0xff
                  |L1.4492|
;;;731            }
;;;732    
;;;733            /* Line Color */
;;;734            pu64Curr[u8Curr] = DRW_LOAD_RGBA32(pstTrngl->stColor.u32Color);
00118c  e3a07000          MOV      r7,#0
001190  e0076007          AND      r6,r7,r7
001194  e1a08007          MOV      r8,r7
001198  e592e014          LDR      lr,[r2,#0x14]
00119c  e1a0700e          MOV      r7,lr
0011a0  e006c008          AND      r12,r6,r8
0011a4  e1a06007          MOV      r6,r7
0011a8  e6ff707c          UXTH     r7,r12
0011ac  e387700a          ORR      r7,r7,#0xa
0011b0  e51fc1e8          LDR      r12,|L1.4048|
0011b4  e187700c          ORR      r7,r7,r12
0011b8  e083c180          ADD      r12,r3,r0,LSL #3
0011bc  e1cc60f0          STRD     r6,r7,[r12,#0]
;;;735            u8Curr++;
0011c0  e2806001          ADD      r6,r0,#1
0011c4  e20600ff          AND      r0,r6,#0xff
;;;736    
;;;737            /* Triangle Draw Command */
;;;738            pu64Curr[u8Curr] = DRW_TRIANGLE_RGBA32(pstTrngl->eAntialEn3,
0011c8  e5d2600e          LDRB     r6,[r2,#0xe]
0011cc  e3a07000          MOV      r7,#0
0011d0  e2066001          AND      r6,r6,#1
0011d4  e0077007          AND      r7,r7,r7
0011d8  e1a07307          LSL      r7,r7,#6
0011dc  e187ed26          ORR      lr,r7,r6,LSR #26
0011e0  e1a08306          LSL      r8,r6,#6
0011e4  e5d2600d          LDRB     r6,[r2,#0xd]
0011e8  e3a09000          MOV      r9,#0
0011ec  e206c001          AND      r12,r6,#1
0011f0  e0097009          AND      r7,r9,r9
0011f4  e1a07287          LSL      r7,r7,#5
0011f8  e1876dac          ORR      r6,r7,r12,LSR #27
0011fc  e1a0700e          MOV      r7,lr
001200  e188e28c          ORR      lr,r8,r12,LSL #5
001204  e1877006          ORR      r7,r7,r6
001208  e5d2600c          LDRB     r6,[r2,#0xc]
00120c  e2066001          AND      r6,r6,#1
001210  e3a0c000          MOV      r12,#0
001214  e1a0c20c          LSL      r12,r12,#4
001218  e18c8e26          ORR      r8,r12,r6,LSR #28
00121c  e1a0c007          MOV      r12,r7
001220  e18e7206          ORR      r7,lr,r6,LSL #4
001224  e18cc008          ORR      r12,r12,r8
001228  e5d16000          LDRB     r6,[r1,#0]
00122c  e3a0e000          MOV      lr,#0
001230  e2068007          AND      r8,r6,#7
001234  e00e600e          AND      r6,lr,lr
001238  e098e008          ADDS     lr,r8,r8
00123c  e0a66006          ADC      r6,r6,r6
001240  e187800e          ORR      r8,r7,lr
001244  e18cc006          ORR      r12,r12,r6
001248  e5d16008          LDRB     r6,[r1,#8]
00124c  e2066001          AND      r6,r6,#1
001250  e0097009          AND      r7,r9,r9
001254  e1866008          ORR      r6,r6,r8
001258  e18cc007          ORR      r12,r12,r7
00125c  e6ff807c          UXTH     r8,r12
001260  e51fe288          LDR      lr,|L1.4064|
001264  e1a0c006          MOV      r12,r6
001268  e18c7009          ORR      r7,r12,r9
00126c  e188600e          ORR      r6,r8,lr
001270  e083c180          ADD      r12,r3,r0,LSL #3
001274  e58c6004          STR      r6,[r12,#4]
001278  e58c7000          STR      r7,[r12,#0]
;;;739                                                   pstTrngl->eAntialEn2,
;;;740                                                   pstTrngl->eAntialEn1,
;;;741                                                   pstOption->eBlndMode,
;;;742                                                   pstOption->eClipWndEn);
;;;743            u8Curr++;
00127c  e2806001          ADD      r6,r0,#1
001280  e20600ff          AND      r0,r6,#0xff
                  |L1.4740|
;;;744        }
;;;745    
;;;746        pstCmdList->pu64Current = &pu64Curr[u8Curr];
001284  e0836180          ADD      r6,r3,r0,LSL #3
001288  e3047000          MOVW     r7,#0x4000
00128c  e7876005          STR      r6,[r7,r5]
;;;747    }
001290  e8bd83f0          POP      {r4-r9,pc}
;;;748    
                          ENDP

                  boDrw_SetFilterCoefDrawEngine PROC
;;;749    /* ....................................................................... */
;;;750    bool_t boDrw_SetFilterCoefDrawEngine (uint8_t u8CoefIndex,  
001294  e1a02000          MOV      r2,r0
;;;751                                          uint32_t u32CoefValue)
;;;752    {
;;;753        bool_t    boRes = C_TRUE;
001298  e3a00001          MOV      r0,#1
;;;754        
;;;755        /* check parameters: */
;;;756        if (u8CoefIndex > LAST_FILTER_COEF_INDEX)
00129c  e352003f          CMP      r2,#0x3f
0012a0  da000001          BLE      |L1.4780|
;;;757        {
;;;758            boRes = C_FALSE;
0012a4  e3a00000          MOV      r0,#0
0012a8  ea000002          B        |L1.4792|
                  |L1.4780|
;;;759        }
;;;760        else
;;;761        {
;;;762            vSetGADEFCR(u8CoefIndex, u32CoefValue);
0012ac  e1a03102          LSL      r3,r2,#2
0012b0  e24335fd          SUB      r3,r3,#0x3f400000
0012b4  e5831200          STR      r1,[r3,#0x200]
                  |L1.4792|
;;;763        }
;;;764        return (boRes);
;;;765    }
0012b8  e12fff1e          BX       lr
;;;766    /****************************************************************************/
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  au8LLDD_GA_DRAW_C_REVISION
000000  24526576          DCB      0x24,0x52,0x65,0x76
000004  6973696f          DCB      0x69,0x73,0x69,0x6f
000008  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00000c  2e313520          DCB      0x2e,0x31,0x35,0x20
000010  2400              DCB      0x24,0x00
                  au8LLDD_GA_DRAW_C_TAG
000012  244e              DCB      0x24,0x4e
000014  616d653a          DCB      0x61,0x6d,0x65,0x3a
000018  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00001c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000020  375f4746          DCB      0x37,0x5f,0x47,0x46
000024  58202400          DCB      0x58,0x20,0x24,0x00
                  au8LLDD_GA_DRAW_H_REVISION
000028  24526576          DCB      0x24,0x52,0x65,0x76
00002c  6973696f          DCB      0x69,0x73,0x69,0x6f
000030  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000034  2e313520          DCB      0x2e,0x31,0x35,0x20
000038  2400              DCB      0x24,0x00
                  au8LLDD_GA_DRAW_H_TAG
00003a  244e              DCB      0x24,0x4e
00003c  616d653a          DCB      0x61,0x6d,0x65,0x3a
000040  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000044  445f315f          DCB      0x44,0x5f,0x31,0x5f
000048  375f4746          DCB      0x37,0x5f,0x47,0x46
00004c  58202400          DCB      0x58,0x20,0x24,0x00
