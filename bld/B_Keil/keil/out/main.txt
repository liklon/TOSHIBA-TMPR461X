; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\main.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\main.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\main.crf ..\..\src\main.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vInitSytem PROC
;;;82     /****************************************************************************/
;;;83     void vInitSytem(void)
000000  e92d401f          PUSH     {r0-r4,lr}
;;;84     {
;;;85         gf_cliprect_st stFill_GDC0 = {0, 0, GDC0_LAYERA_WIDTH, GDC0_LAYERA_HEIGHT};
000004  e59f1c84          LDR      r1,|L1.3216|
000008  e1c100d0          LDRD     r0,r1,[r1,#0]  ; <Data1>, <Data1>
00000c  e1cd00f8          STRD     r0,r1,[sp,#8]
;;;86     	gf_cliprect_st stFill_GDC0_B = {0, 0, GDC0_LAYERB_WIDTH, GDC0_LAYERB_HEIGHT};
000010  e59f1c7c          LDR      r1,|L1.3220|
000014  e1c100d0          LDRD     r0,r1,[r1,#0]  ; <Data2>, <Data2>
000018  e1cd00f0          STRD     r0,r1,[sp,#0]
;;;87         //gf_cliprect_st stFill_GDC1 = {0, 0, GDC1_LAYERA_WIDTH, GDC1_LAYERA_HEIGHT};
;;;88     
;;;89         /* Board specific, clocks and ports configuration */
;;;90         vBoardCfg();
00001c  ebfffffe          BL       vBoardCfg
;;;91     
;;;92         /* Initialize the middleware */
;;;93         vInitGraphicsSystem();
000020  ebfffffe          BL       vInitGraphicsSystem
;;;94         
;;;95         /* Initialize images */
;;;96         vGfInitImages();
000024  ebfffffe          BL       vGfInitImages
;;;97     
;;;98         /* get Images out of ROM */
;;;99         vGfCopyImagesROMtoRAM();
000028  ebfffffe          BL       vGfCopyImagesROMtoRAM
;;;100    
;;;101        /* init statevariables*/
;;;102        vInitStatevariables();
00002c  ebfffffe          BL       vInitStatevariables
;;;103    
;;;104        vGfBuffFillArea(&stGDC0LayerA.stDispFB, &stFill_GDC0, 0x00000000);
000030  e3a02000          MOV      r2,#0
000034  e28d1008          ADD      r1,sp,#8
000038  e59f0c58          LDR      r0,|L1.3224|
00003c  ebfffffe          BL       vGfBuffFillArea
;;;105        vGfListExecute();
000040  ebfffffe          BL       vGfListExecute
;;;106        vGfBuffFillArea(&stGDC0LayerA.stWriteFB, &stFill_GDC0, 0x00000000);
000044  e3a02000          MOV      r2,#0
000048  e28d1008          ADD      r1,sp,#8
00004c  e59f0c48          LDR      r0,|L1.3228|
000050  ebfffffe          BL       vGfBuffFillArea
;;;107        vGfListExecute();
000054  ebfffffe          BL       vGfListExecute
;;;108    
;;;109    
;;;110        vGfBuffFillArea(&stGDC0LayerB.stDispFB, &stFill_GDC0_B, 0x000000FF);
000058  e3a020ff          MOV      r2,#0xff
00005c  e1a0100d          MOV      r1,sp
000060  e59f0c38          LDR      r0,|L1.3232|
000064  ebfffffe          BL       vGfBuffFillArea
;;;111        vGfListExecute();
000068  ebfffffe          BL       vGfListExecute
;;;112        vGfBuffFillArea(&stGDC0LayerB.stWriteFB, &stFill_GDC0_B, 0x000000FF);
00006c  e3a020ff          MOV      r2,#0xff
000070  e1a0100d          MOV      r1,sp
000074  e59f0c28          LDR      r0,|L1.3236|
000078  ebfffffe          BL       vGfBuffFillArea
;;;113        vGfListExecute();
00007c  ebfffffe          BL       vGfListExecute
;;;114    
;;;115    
;;;116    
;;;117    	
;;;118        /* set icons */
;;;119        vInitIcons();
000080  ebfffffe          BL       vInitIcons
;;;120    
;;;121    }
000084  e8bd801f          POP      {r0-r4,pc}
;;;122    
                          ENDP

                  vPinconfig_UART PROC
;;;128     */
;;;129    void vPinconfig_UART(void)
000088  e92d4010          PUSH     {r4,lr}
;;;130    {
;;;131    #ifdef _MY_UART
;;;132    
;;;133        /* set input port for button 1 */
;;;134        i32GPIO_EnableLatchFunction(PORT_UART0RX, GPIO_DISABLE);
00008c  e3a01000          MOV      r1,#0
000090  e3000108          MOVW     r0,#0x108
000094  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;135        i32GPIO_SetPinFunction(PORT_UART0RX, PORT_UART0RX_AS_UART0RX);
000098  e3a01001          MOV      r1,#1
00009c  e3000108          MOVW     r0,#0x108
0000a0  ebfffffe          BL       i32GPIO_SetPinFunction
;;;136        i32GPIO_EnablePullUp(PORT_UART0RX, GPIO_DISABLE);
0000a4  e3a01000          MOV      r1,#0
0000a8  e3000108          MOVW     r0,#0x108
0000ac  ebfffffe          BL       i32GPIO_EnablePullUp
;;;137        i32GPIO_SetOutputResistance(PORT_UART0RX, GPIO_OUTPUT_RESISTANCE_50);
0000b0  e3a01001          MOV      r1,#1
0000b4  e3000108          MOVW     r0,#0x108
0000b8  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;138    
;;;139        /* set input port for button 2 */
;;;140        i32GPIO_EnableLatchFunction(PORT_UART0TX, GPIO_DISABLE);
0000bc  e3a01000          MOV      r1,#0
0000c0  e3000109          MOV      r0,#0x109
0000c4  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;141        i32GPIO_SetPinFunction(PORT_UART0TX, PORT_UART0TX_AS_UART0TX);
0000c8  e3a01001          MOV      r1,#1
0000cc  e3000109          MOV      r0,#0x109
0000d0  ebfffffe          BL       i32GPIO_SetPinFunction
;;;142        i32GPIO_EnablePullUp(PORT_UART0TX, GPIO_DISABLE);
0000d4  e3a01000          MOV      r1,#0
0000d8  e3000109          MOV      r0,#0x109
0000dc  ebfffffe          BL       i32GPIO_EnablePullUp
;;;143        i32GPIO_SetOutputResistance(PORT_UART0TX, GPIO_OUTPUT_RESISTANCE_50);
0000e0  e3a01001          MOV      r1,#1
0000e4  e3000109          MOV      r0,#0x109
0000e8  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;144    #endif
;;;145    
;;;146    }
0000ec  e8bd8010          POP      {r4,pc}
;;;147    
                          ENDP

                  vUartIrq PROC
                  |L1.240|
;;;159    #else
;;;160    __irq void vUartIrq(void)
0000f0  e92d503f          PUSH     {r0-r5,r12,lr}
;;;161    #endif /* defined(__GHS__) || defined(__ghs__) */
;;;162    {
;;;163    	u8ReadBuf[u16ReadIndex++] = u8GetSIRFIFO(UART_CH0);
0000f4  e59f0bac          LDR      r0,|L1.3240|
0000f8  e5d00020          LDRB     r0,[r0,#0x20]
0000fc  e59f1ba8          LDR      r1,|L1.3244|
000100  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
000104  e59f2ba0          LDR      r2,|L1.3244|
000108  e1d220b0          LDRH     r2,[r2,#0]  ; u16ReadIndex
00010c  e2822001          ADD      r2,r2,#1
000110  e59f3b94          LDR      r3,|L1.3244|
000114  e1c320b0          STRH     r2,[r3,#0]  ; u16ReadIndex
000118  e59f2b90          LDR      r2,|L1.3248|
00011c  e7c20001          STRB     r0,[r2,r1]
;;;164    	if(gModeData.u8type1Data == 0)
000120  e59f0b8c          LDR      r0,|L1.3252|
000124  e5d00000          LDRB     r0,[r0,#0]  ; gModeData
000128  e3500000          CMP      r0,#0
00012c  1a000018          BNE      |L1.404|
;;;165    	{
;;;166    		if(u8ReadBuf[u16ReadIndex - 1] == 0x55)
000130  e2830000          ADD      r0,r3,#0
000134  e1d000b0          LDRH     r0,[r0,#0]  ; u16ReadIndex
000138  e2400001          SUB      r0,r0,#1
00013c  e2821000          ADD      r1,r2,#0
000140  e7d10000          LDRB     r0,[r1,r0]
000144  e3500055          CMP      r0,#0x55
000148  1a000007          BNE      |L1.364|
;;;167    		{
;;;168    			if(u8CheckConnectSendData == 0x55) u8CheckConnectSendData = 0xBB;
00014c  e59f0b64          LDR      r0,|L1.3256|
000150  e5d00000          LDRB     r0,[r0,#0]  ; u8CheckConnectSendData
000154  e3500055          CMP      r0,#0x55
000158  1a00000d          BNE      |L1.404|
00015c  e3a000bb          MOV      r0,#0xbb
000160  e59f1b50          LDR      r1,|L1.3256|
000164  e5c10000          STRB     r0,[r1,#0]  ; u8CheckConnectSendData
000168  ea000009          B        |L1.404|
                  |L1.364|
;;;169    		}
;;;170    		else if(u8ReadBuf[u16ReadIndex - 1] == 0xBB)
00016c  e59f0b38          LDR      r0,|L1.3244|
000170  e1d000b0          LDRH     r0,[r0,#0]  ; u16ReadIndex
000174  e2400001          SUB      r0,r0,#1
000178  e59f1b30          LDR      r1,|L1.3248|
00017c  e7d10000          LDRB     r0,[r1,r0]
000180  e35000bb          CMP      r0,#0xbb
000184  1a000002          BNE      |L1.404|
;;;171    		{
;;;172    			u8CheckConnectSendData = 'o';
000188  e3a0006f          MOV      r0,#0x6f
00018c  e59f1b24          LDR      r1,|L1.3256|
000190  e5c10000          STRB     r0,[r1,#0]  ; u8CheckConnectSendData
                  |L1.404|
;;;173    		}
;;;174    	}
;;;175    	if(u16ReadIndex >= MAX_LEN)
000194  e59f0b10          LDR      r0,|L1.3244|
000198  e1d000b0          LDRH     r0,[r0,#0]  ; u16ReadIndex
00019c  e3500b01          CMP      r0,#0x400
0001a0  ba000002          BLT      |L1.432|
;;;176    	{
;;;177    		u16ReadIndex = 0;
0001a4  e3a00000          MOV      r0,#0
0001a8  e59f1afc          LDR      r1,|L1.3244|
0001ac  e1c100b0          STRH     r0,[r1,#0]  ; u16ReadIndex
                  |L1.432|
;;;178    	}
;;;179    	vClrSIDISR_RDIS(UART_CH0);
0001b0  e59f0af0          LDR      r0,|L1.3240|
0001b4  e1d000b8          LDRH     r0,[r0,#8]
0001b8  e3c00080          BIC      r0,r0,#0x80
0001bc  e59f1ae4          LDR      r1,|L1.3240|
0001c0  e1c100b8          STRH     r0,[r1,#8]
;;;180        i32INTC_ClearIrq(u32INTC_GetVectAddr());
0001c4  ebfffffe          BL       u32INTC_GetVectAddr
0001c8  e1a04000          MOV      r4,r0
0001cc  ebfffffe          BL       i32INTC_ClearIrq
;;;181        vINTC_ModifyIrqLevel(INTC_RESTORE_OLD, INTC_LEVEL_7);
0001d0  e3a01007          MOV      r1,#7
0001d4  e3a00000          MOV      r0,#0
0001d8  ebfffffe          BL       vINTC_ModifyIrqLevel
;;;182    }
0001dc  e8bd503f          POP      {r0-r5,r12,lr}
0001e0  e25ef004          SUBS     pc,lr,#4
;;;183    
                          ENDP

                  vMyInitUart PROC
;;;184    
;;;185    void vMyInitUart(uart_Ch_e eCh)
0001e4  e92d4010          PUSH     {r4,lr}
;;;186    {
0001e8  e24dd028          SUB      sp,sp,#0x28
0001ec  e1a04000          MOV      r4,r0
;;;187    #ifdef _MY_UART
;;;188    	uart_DataFmt_st stDataFmt;
;;;189        uart_DmaIrq_st  stDmaIrq;
;;;190        uart_Fifo_st    stFifo;
;;;191        uart_Flow_st    stFlow;
;;;192    
;;;193        /* Line/Data Format configuration */
;;;194        stDataFmt.eRwub  = UART_NOT_WAIT_WUB;  /* No wait for Wake-up bit */
0001f0  e3a00000          MOV      r0,#0
0001f4  e5cd0020          STRB     r0,[sp,#0x20]
;;;195        stDataFmt.eTwub  = UART_NFRAME_DATA;   /* Next Frame is Data Frame */
0001f8  e5cd0021          STRB     r0,[sp,#0x21]
;;;196        stDataFmt.eLsbf  = UART_LSB;           /* LSB bit goes first */
0001fc  e3a00001          MOV      r0,#1
000200  e5cd0022          STRB     r0,[sp,#0x22]
;;;197        stDataFmt.eUeps  = UART_ODD;           /* Odd Parity*/ 
000204  e3a00000          MOV      r0,#0
000208  e5cd0023          STRB     r0,[sp,#0x23]
;;;198        stDataFmt.eUpen  = UART_PARITY_DIS;    /* Parity enable */
00020c  e5cd0024          STRB     r0,[sp,#0x24]
;;;199        stDataFmt.eUsbl  = UART_ONE_BIT;       /* One stop bit */
000210  e5cd0025          STRB     r0,[sp,#0x25]
;;;200        stDataFmt.eUmode = UART_8BIT;          /* 8-bit data transmission */
000214  e5cd0026          STRB     r0,[sp,#0x26]
;;;201    
;;;202        /* DMA IRQ settings */
;;;203        stDmaIrq.eTir   = UART_IRQ_DIS;
000218  e5cd0014          STRB     r0,[sp,#0x14]
;;;204        stDmaIrq.eRir   = UART_IRQ_EN;
00021c  e3a00001          MOV      r0,#1
000220  e5cd0015          STRB     r0,[sp,#0x15]
;;;205        stDmaIrq.eSpir  = UART_IRQ_DIS;
000224  e3a00000          MOV      r0,#0
000228  e5cd0016          STRB     r0,[sp,#0x16]
;;;206        stDmaIrq.eSioe  = UART_IRQ_DIS;
00022c  e5cd0019          STRB     r0,[sp,#0x19]
;;;207        stDmaIrq.eSicts = UART_IRQ_DIS;
000230  e5cd001a          STRB     r0,[sp,#0x1a]
;;;208        stDmaIrq.eSibrk = UART_IRQ_DIS;
000234  e5cd001b          STRB     r0,[sp,#0x1b]
;;;209        stDmaIrq.eSitr  = UART_IRQ_DIS;
000238  e5cd001c          STRB     r0,[sp,#0x1c]
;;;210        stDmaIrq.eSias  = UART_IRQ_DIS;
00023c  e5cd001d          STRB     r0,[sp,#0x1d]
;;;211        stDmaIrq.eSiub  = UART_BRK_DET_DIS;    /* BREAK detection disabled*/
000240  e5cd001e          STRB     r0,[sp,#0x1e]
;;;212    
;;;213    
;;;214        /* Fifo configuration */
;;;215        stFifo.u8Rdil  = 0;                    /* Receive FIFO Threshold */
000244  e5cd0010          STRB     r0,[sp,#0x10]
;;;216        stFifo.u8Tdil  = 1;                    /* Transmit FIFO Threshold */
000248  e3a00001          MOV      r0,#1
00024c  e5cd0011          STRB     r0,[sp,#0x11]
;;;217        stFifo.eFrStew = UART_FIFO_RST_EN;    
000250  e5cd0012          STRB     r0,[sp,#0x12]
;;;218    
;;;219        /* Flow control configuration */
;;;220        stFlow.eRsdr = UART_DATA_STORE;        /* Enable data storing in Rx FIFO */
000254  e3a00000          MOV      r0,#0
000258  e5cd0008          STRB     r0,[sp,#8]
;;;221        stFlow.eTsdr = UART_TRANS_HALT;        /* Do not start transmission immediately*/
00025c  e3a00001          MOV      r0,#1
000260  e5cd0009          STRB     r0,[sp,#9]
;;;222        stFlow.eTbrk = UART_TRANS_NORM;        /* Normal operation (no BREAK sent) */
000264  e3a00000          MOV      r0,#0
000268  e5cd000a          STRB     r0,[sp,#0xa]
;;;223    
;;;224        /* set baudrate accordingly */
;;;225        vUART_Init(eCh, UART_BR_115200, &stDataFmt, &stDmaIrq);
00026c  e28d3014          ADD      r3,sp,#0x14
000270  e28d2020          ADD      r2,sp,#0x20
000274  e3a01014          MOV      r1,#0x14
000278  e1a00004          MOV      r0,r4
00027c  ebfffffe          BL       vUART_Init
;;;226    
;;;227        /* Configure Tx/Rx FIFOs */
;;;228        vUART_FifoConfig(eCh, &stFifo);
000280  e28d1010          ADD      r1,sp,#0x10
000284  e1a00004          MOV      r0,r4
000288  ebfffffe          BL       vUART_FifoConfig
;;;229    
;;;230        /* Configure Flow Control */
;;;231        vUART_FlowCtrlConfig(eCh, &stFlow);
00028c  e28d1008          ADD      r1,sp,#8
000290  e1a00004          MOV      r0,r4
000294  ebfffffe          BL       vUART_FlowCtrlConfig
;;;232    
;;;233        i32INTC_SourceConfig(INTC_HSUART0_RX, INTC_TO_CPU, INTC_LEVEL_LO, INTC_LEVEL_1, INTC_AUTO_CLEAR_DISABLE);
000298  e3a00000          MOV      r0,#0
00029c  e3a03001          MOV      r3,#1
0002a0  e58d0000          STR      r0,[sp,#0]
0002a4  e1a02000          MOV      r2,r0
0002a8  e1a01000          MOV      r1,r0
0002ac  e59f0a08          LDR      r0,|L1.3260|
0002b0  ebfffffe          BL       i32INTC_SourceConfig
;;;234        vINTC_SetISRStartAddress(INTC_HSUART0_RX, (uint32_t)&vUartIrq);
0002b4  e24f1f73          ADR      r1,|L1.240|
0002b8  e59f09fc          LDR      r0,|L1.3260|
0002bc  ebfffffe          BL       vINTC_SetISRStartAddress
;;;235    
;;;236        /* Enable Transmition */
;;;237        vUART_TxRunCtrl(eCh, UART_TRANS_RUN);
0002c0  e3a01000          MOV      r1,#0
0002c4  e1a00004          MOV      r0,r4
0002c8  ebfffffe          BL       vUART_TxRunCtrl
;;;238     	vPinconfig_UART();
0002cc  ebfffffe          BL       vPinconfig_UART
;;;239    #endif
;;;240    
;;;241    }
0002d0  e28dd028          ADD      sp,sp,#0x28
0002d4  e8bd8010          POP      {r4,pc}
;;;242    
                          ENDP

                  vReadUartToBuf PROC
;;;243    
;;;244    void vReadUartToBuf()
0002d8  e92d4010          PUSH     {r4,lr}
;;;245    {
;;;246    #ifdef _MY_UART
;;;247        uint16_t u8readRXCNT = 0;
0002dc  e3a00000          MOV      r0,#0
;;;248    	if((u8readRXCNT = biGetSIDISR_RFDN(UART_CH0)) > 0)
0002e0  e59f19c0          LDR      r1,|L1.3240|
0002e4  e1d110b8          LDRH     r1,[r1,#8]
0002e8  e201101f          AND      r1,r1,#0x1f
0002ec  e2510000          SUBS     r0,r1,#0
0002f0  da000016          BLE      |L1.848|
;;;249    	{
;;;250    		while(u8readRXCNT--)
0002f4  ea000011          B        |L1.832|
                  |L1.760|
;;;251    		{
;;;252    			u8ReadBuf[u16ReadIndex++] = u8GetSIRFIFO(UART_CH0);
0002f8  e59f19a8          LDR      r1,|L1.3240|
0002fc  e5d11020          LDRB     r1,[r1,#0x20]
000300  e59f29a4          LDR      r2,|L1.3244|
000304  e1d220b0          LDRH     r2,[r2,#0]  ; u16ReadIndex
000308  e59f399c          LDR      r3,|L1.3244|
00030c  e1d330b0          LDRH     r3,[r3,#0]  ; u16ReadIndex
000310  e2833001          ADD      r3,r3,#1
000314  e59f4990          LDR      r4,|L1.3244|
000318  e1c430b0          STRH     r3,[r4,#0]  ; u16ReadIndex
00031c  e59f398c          LDR      r3,|L1.3248|
000320  e7c31002          STRB     r1,[r3,r2]
;;;253    			if(u16ReadIndex >= MAX_LEN)
000324  e2841000          ADD      r1,r4,#0
000328  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
00032c  e3510b01          CMP      r1,#0x400
000330  ba000002          BLT      |L1.832|
;;;254    			{
;;;255    				u16ReadIndex = 0;
000334  e3a01000          MOV      r1,#0
000338  e2842000          ADD      r2,r4,#0
00033c  e1c210b0          STRH     r1,[r2,#0]  ; u16ReadIndex
                  |L1.832|
000340  e1b01000          MOVS     r1,r0                 ;250
000344  e2402001          SUB      r2,r0,#1              ;250
000348  e6ff0072          UXTH     r0,r2                 ;250
00034c  1affffe9          BNE      |L1.760|
                  |L1.848|
;;;256    			}
;;;257    		}
;;;258    	}
;;;259    #endif
;;;260    }
000350  e8bd8010          POP      {r4,pc}
;;;261    
                          ENDP

                  u8GetCommand PROC
;;;262    
;;;263    uint8_t u8GetCommand(model_parameters_st *pmodel)
000354  e92d41f0          PUSH     {r4-r8,lr}
;;;264    {
000358  e1a04000          MOV      r4,r0
;;;265    	uint8_t u8dataLen = 0;
00035c  e3a07000          MOV      r7,#0
;;;266    	uint8_t u8i;
;;;267    	uint8_t u8check;
;;;268    	if(  ((u16RunIndex + CODE_LEN) <= u16ReadIndex) || 
000360  e59f0958          LDR      r0,|L1.3264|
000364  e1d000b0          LDRH     r0,[r0,#0]  ; u16RunIndex
000368  e2800005          ADD      r0,r0,#5
00036c  e59f1938          LDR      r1,|L1.3244|
000370  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
000374  e1500001          CMP      r0,r1
000378  da00000d          BLE      |L1.948|
;;;269    		((u16RunIndex > u16ReadIndex) && ((u16RunIndex + CODE_LEN - MAX_LEN) <= u16ReadIndex))  )
00037c  e59f093c          LDR      r0,|L1.3264|
000380  e1d000b0          LDRH     r0,[r0,#0]  ; u16RunIndex
000384  e59f1920          LDR      r1,|L1.3244|
000388  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
00038c  e1500001          CMP      r0,r1
000390  da00019b          BLE      |L1.2564|
000394  e59f0924          LDR      r0,|L1.3264|
000398  e1d000b0          LDRH     r0,[r0,#0]  ; u16RunIndex
00039c  e2800005          ADD      r0,r0,#5
0003a0  e2400b01          SUB      r0,r0,#0x400
0003a4  e59f1900          LDR      r1,|L1.3244|
0003a8  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
0003ac  e1500001          CMP      r0,r1
0003b0  ca000193          BGT      |L1.2564|
                  |L1.948|
;;;270    	{
;;;271    		if(u8ReadBuf[u16RunIndex] == CODE_HEAD)
0003b4  e59f08f4          LDR      r0,|L1.3248|
0003b8  e59f1900          LDR      r1,|L1.3264|
0003bc  e1d110b0          LDRH     r1,[r1,#0]  ; u16RunIndex
0003c0  e7d00001          LDRB     r0,[r0,r1]
0003c4  e35000aa          CMP      r0,#0xaa
0003c8  1a000182          BNE      |L1.2520|
;;;272    		{
;;;273    			if(u8ReadBuf[u16RunIndex + 1] == CODE_TYPE1)
0003cc  e59f08dc          LDR      r0,|L1.3248|
0003d0  e59f18e8          LDR      r1,|L1.3264|
0003d4  e1d110b0          LDRH     r1,[r1,#0]  ; u16RunIndex
0003d8  e2811001          ADD      r1,r1,#1
0003dc  e7d00001          LDRB     r0,[r0,r1]
0003e0  e3500001          CMP      r0,#1
0003e4  0a000047          BEQ      |L1.1288|
;;;274    			{
;;;275    				
;;;276    			}
;;;277    			else if(u8ReadBuf[u16RunIndex + 1] == CODE_TYPE2)
0003e8  e59f08c0          LDR      r0,|L1.3248|
0003ec  e59f18cc          LDR      r1,|L1.3264|
0003f0  e1d110b0          LDRH     r1,[r1,#0]  ; u16RunIndex
0003f4  e2811001          ADD      r1,r1,#1
0003f8  e7d00001          LDRB     r0,[r0,r1]
0003fc  e3500002          CMP      r0,#2
000400  1a000016          BNE      |L1.1120|
;;;278    			{
;;;279    				if(  ((u16RunIndex + CODE_TYPE2_LEN) <= u16ReadIndex) || 
000404  e59f08b4          LDR      r0,|L1.3264|
000408  e1d000b0          LDRH     r0,[r0,#0]  ; u16RunIndex
00040c  e2800006          ADD      r0,r0,#6
000410  e59f1894          LDR      r1,|L1.3244|
000414  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
000418  e1500001          CMP      r0,r1
00041c  da000039          BLE      |L1.1288|
;;;280    				((u16RunIndex > u16ReadIndex) && ((u16RunIndex + CODE_TYPE2_LEN - MAX_LEN) <= u16ReadIndex)))
000420  e59f0898          LDR      r0,|L1.3264|
000424  e1d000b0          LDRH     r0,[r0,#0]  ; u16RunIndex
000428  e59f187c          LDR      r1,|L1.3244|
00042c  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
000430  e1500001          CMP      r0,r1
000434  da000007          BLE      |L1.1112|
000438  e59f0880          LDR      r0,|L1.3264|
00043c  e1d000b0          LDRH     r0,[r0,#0]  ; u16RunIndex
000440  e2800006          ADD      r0,r0,#6
000444  e2400b01          SUB      r0,r0,#0x400
000448  e59f185c          LDR      r1,|L1.3244|
00044c  e1d110b0          LDRH     r1,[r1,#0]  ; u16ReadIndex
000450  e1500001          CMP      r0,r1
000454  da00002b          BLE      |L1.1288|
                  |L1.1112|
;;;281    				{
;;;282    					
;;;283    				}
;;;284    				else
;;;285    				{
;;;286    					return C_FALSE;
000458  e3a00000          MOV      r0,#0
                  |L1.1116|
;;;287    				}
;;;288    			}
;;;289    			else if(u8ReadBuf[u16RunIndex + 1] == CODE_TYPE3)
;;;290    			{
;;;291    				if(  ((u16RunIndex + CODE_TYPE3_LEN + u8ReadBuf[u16RunIndex + 3]) <= u16ReadIndex) || 
;;;292    				((u16RunIndex > u16ReadIndex) && ((u16RunIndex + CODE_TYPE3_LEN + u8ReadBuf[u16RunIndex + 3] - MAX_LEN) <= u16ReadIndex)))
;;;293    				{
;;;294    					
;;;295    				}
;;;296    				else
;;;297    				{
;;;298    					return C_FALSE;
;;;299    				}
;;;300    			}
;;;301    			u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;302    			//保证数据长度满足
;;;303    			if(u8ReadBuf[u16RunIndex] == CODE_TYPE1)
;;;304    			{
;;;305    				pmodel->u8typex = CODE_TYPE1;
;;;306    				u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;307    				if(u8ReadBuf[u16RunIndex + CODE_TYPE1_LEN - 3] == CODE_END)
;;;308    				{
;;;309    					pmodel->utmodel.stCmdType1.u8screenIndex = u8ReadBuf[u16RunIndex];
;;;310    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;311    					u8check = u8ReadBuf[u16RunIndex];
;;;312    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;313    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;314    					if((uint8_t)((CODE_TYPE1 + pmodel->utmodel.stCmdType1.u8screenIndex) & 0XFF) == u8check)
;;;315    					{
;;;316    					    i32UART_WriteByte(UART_CH0,pmodel->utmodel.stCmdType1.u8screenIndex);
;;;317    						return C_TRUE;
;;;318    					}
;;;319    					return C_FALSE;
;;;320    				}
;;;321    			}
;;;322    			else if(u8ReadBuf[u16RunIndex] == CODE_TYPE2)
;;;323    			{
;;;324    				pmodel->u8typex = CODE_TYPE2;
;;;325    				u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;326    				if(u8ReadBuf[u16RunIndex + CODE_TYPE2_LEN - 3] == CODE_END)
;;;327    				{
;;;328    					pmodel->utmodel.stCmdType2.u8modelIndex = u8ReadBuf[u16RunIndex];
;;;329    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;330    					pmodel->utmodel.stCmdType2.u8status = u8ReadBuf[u16RunIndex];
;;;331    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;332    					u8check = u8ReadBuf[u16RunIndex];
;;;333    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;334    					u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;335    					if((uint8_t)((CODE_TYPE2 + pmodel->utmodel.stCmdType2.u8modelIndex + pmodel->utmodel.stCmdType2.u8status) & 0XFF) == u8check)
;;;336    					{
;;;337    					    i32UART_WriteByte(UART_CH0,pmodel->utmodel.stCmdType2.u8modelIndex);
;;;338    						return C_TRUE;
;;;339    					}
;;;340    					return C_FALSE;
;;;341    				}
;;;342    
;;;343    			}
;;;344    			else if(u8ReadBuf[u16RunIndex] == CODE_TYPE3)
;;;345    			{
;;;346    				pmodel->u8typex = CODE_TYPE3;
;;;347    				u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;348    				if((u8dataLen = u8ReadBuf[u16RunIndex + 1]) <= MAX_DATA_LEN)
;;;349    				{
;;;350    					if(u8ReadBuf[u16RunIndex + CODE_TYPE3_LEN + u8dataLen - 3] == CODE_END)
;;;351    					{
;;;352    						pmodel->utmodel.stCmdType3.u8modelIndex = u8ReadBuf[u16RunIndex];
;;;353    						u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;354    						pmodel->utmodel.stCmdType3.u8dataLen = u8ReadBuf[u16RunIndex];
;;;355    						u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;356    						for(u8i = 0;u8i < u8dataLen;u8i++)
;;;357    						{
;;;358    							pmodel->utmodel.stCmdType3.u8data[u8i]= u8ReadBuf[u16RunIndex];
;;;359    						    u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;360    						}
;;;361    						for(;u8i < 4;u8i++)
;;;362    						{
;;;363    							pmodel->utmodel.stCmdType3.u8data[u8i]= 0;
;;;364    						}
;;;365    						pmodel->utmodel.stCmdType3.u8flag = u8ReadBuf[u16RunIndex];
;;;366    						u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;367    						u8check = u8ReadBuf[u16RunIndex];
;;;368    						u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;369    						u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;370    						if((uint8_t)((CODE_TYPE3 + pmodel->utmodel.stCmdType3.u8modelIndex + pmodel->utmodel.stCmdType3.u8dataLen +
;;;371    							pmodel->utmodel.stCmdType3.u8data[0] + pmodel->utmodel.stCmdType3.u8data[1] + pmodel->utmodel.stCmdType3.u8data[2] +
;;;372                                pmodel->utmodel.stCmdType3.u8data[3] + pmodel->utmodel.stCmdType3.u8flag) & 0XFF) == u8check)
;;;373    						{
;;;374    						    i32UART_WriteByte(UART_CH0,pmodel->utmodel.stCmdType3.u8modelIndex);
;;;375    							return C_TRUE;
;;;376    						}
;;;377    						return C_FALSE;
;;;378    					}
;;;379    				}
;;;380    			}
;;;381    			
;;;382    		}
;;;383    		else
;;;384    		{
;;;385    			u16RunIndex = (u16RunIndex + 1) % MAX_LEN;
;;;386    		}
;;;387    		return C_FALSE;
;;;388    		
;;;389    	}
;;;390    	return C_FALSE;
;;;391    }
00045c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1120|
000460  e59f0848          LDR      r0,|L1.3248|
000464  e59f1854          LDR      r1,|L1.3264|
000468  e1d110b0          LDRH     r1,[r1,#0]            ;289  ; u16RunIndex
00046c  e2811001          ADD      r1,r1,#1              ;289
000470  e7d00001          LDRB     r0,[r0,r1]            ;289
000474  e3500003          CMP      r0,#3                 ;289
000478  1a000022          BNE      |L1.1288|
00047c  e59f082c          LDR      r0,|L1.3248|
000480  e59f1838          LDR      r1,|L1.3264|
000484  e1d110b0          LDRH     r1,[r1,#0]            ;291  ; u16RunIndex
000488  e2811003          ADD      r1,r1,#3              ;291
00048c  e7d00001          LDRB     r0,[r0,r1]            ;291
000490  e59f1828          LDR      r1,|L1.3264|
000494  e1d110b0          LDRH     r1,[r1,#0]            ;291  ; u16RunIndex
000498  e2811007          ADD      r1,r1,#7              ;291
00049c  e0800001          ADD      r0,r0,r1              ;291
0004a0  e59f1804          LDR      r1,|L1.3244|
0004a4  e1d110b0          LDRH     r1,[r1,#0]            ;291  ; u16ReadIndex
0004a8  e1500001          CMP      r0,r1                 ;291
0004ac  da000015          BLE      |L1.1288|
0004b0  e59f0808          LDR      r0,|L1.3264|
0004b4  e1d000b0          LDRH     r0,[r0,#0]            ;292  ; u16RunIndex
0004b8  e59f17ec          LDR      r1,|L1.3244|
0004bc  e1d110b0          LDRH     r1,[r1,#0]            ;292  ; u16ReadIndex
0004c0  e1500001          CMP      r0,r1                 ;292
0004c4  da00000d          BLE      |L1.1280|
0004c8  e59f07e0          LDR      r0,|L1.3248|
0004cc  e59f17ec          LDR      r1,|L1.3264|
0004d0  e1d110b0          LDRH     r1,[r1,#0]            ;292  ; u16RunIndex
0004d4  e2811003          ADD      r1,r1,#3              ;292
0004d8  e7d00001          LDRB     r0,[r0,r1]            ;292
0004dc  e59f17dc          LDR      r1,|L1.3264|
0004e0  e1d110b0          LDRH     r1,[r1,#0]            ;292  ; u16RunIndex
0004e4  e2811007          ADD      r1,r1,#7              ;292
0004e8  e0800001          ADD      r0,r0,r1              ;292
0004ec  e2400b01          SUB      r0,r0,#0x400          ;292
0004f0  e59f17b4          LDR      r1,|L1.3244|
0004f4  e1d110b0          LDRH     r1,[r1,#0]            ;292  ; u16ReadIndex
0004f8  e1500001          CMP      r0,r1                 ;292
0004fc  da000001          BLE      |L1.1288|
                  |L1.1280|
000500  e3a00000          MOV      r0,#0                 ;298
000504  eaffffd4          B        |L1.1116|
                  |L1.1288|
000508  e59f17b0          LDR      r1,|L1.3264|
00050c  e1d110b0          LDRH     r1,[r1,#0]            ;301  ; u16RunIndex
000510  e2810001          ADD      r0,r1,#1              ;301
000514  e1a01fc0          ASR      r1,r0,#31             ;301
000518  e0801b21          ADD      r1,r0,r1,LSR #22      ;301
00051c  e1a01541          ASR      r1,r1,#10             ;301
000520  e0401501          SUB      r1,r0,r1,LSL #10      ;301
000524  e59f2794          LDR      r2,|L1.3264|
000528  e1c210b0          STRH     r1,[r2,#0]            ;301  ; u16RunIndex
00052c  e59f077c          LDR      r0,|L1.3248|
000530  e2821000          ADD      r1,r2,#0              ;303
000534  e1d110b0          LDRH     r1,[r1,#0]            ;303  ; u16RunIndex
000538  e7d00001          LDRB     r0,[r0,r1]            ;303
00053c  e3500001          CMP      r0,#1                 ;303
000540  1a00003d          BNE      |L1.1596|
000544  e3a00001          MOV      r0,#1                 ;305
000548  e5c40007          STRB     r0,[r4,#7]            ;305
00054c  e2821000          ADD      r1,r2,#0              ;306
000550  e1d110b0          LDRH     r1,[r1,#0]            ;306  ; u16RunIndex
000554  e2810001          ADD      r0,r1,#1              ;306
000558  e1a01fc0          ASR      r1,r0,#31             ;306
00055c  e0801b21          ADD      r1,r0,r1,LSR #22      ;306
000560  e1a01541          ASR      r1,r1,#10             ;306
000564  e0401501          SUB      r1,r0,r1,LSL #10      ;306
000568  e1c210b0          STRH     r1,[r2,#0]            ;306  ; u16RunIndex
00056c  e2820000          ADD      r0,r2,#0              ;307
000570  e1d000b0          LDRH     r0,[r0,#0]            ;307  ; u16RunIndex
000574  e2800002          ADD      r0,r0,#2              ;307
000578  e59f1730          LDR      r1,|L1.3248|
00057c  e7d10000          LDRB     r0,[r1,r0]            ;307
000580  e35000dd          CMP      r0,#0xdd              ;307
000584  1a00011c          BNE      |L1.2556|
000588  e2810000          ADD      r0,r1,#0              ;309
00058c  e2821000          ADD      r1,r2,#0              ;309
000590  e1d110b0          LDRH     r1,[r1,#0]            ;309  ; u16RunIndex
000594  e7d00001          LDRB     r0,[r0,r1]            ;309
000598  e5c40000          STRB     r0,[r4,#0]            ;309
00059c  e2821000          ADD      r1,r2,#0              ;310
0005a0  e1d110b0          LDRH     r1,[r1,#0]            ;310  ; u16RunIndex
0005a4  e2810001          ADD      r0,r1,#1              ;310
0005a8  e1a01fc0          ASR      r1,r0,#31             ;310
0005ac  e0801b21          ADD      r1,r0,r1,LSR #22      ;310
0005b0  e1a01541          ASR      r1,r1,#10             ;310
0005b4  e0401501          SUB      r1,r0,r1,LSL #10      ;310
0005b8  e1c210b0          STRH     r1,[r2,#0]            ;310  ; u16RunIndex
0005bc  e59f06ec          LDR      r0,|L1.3248|
0005c0  e2821000          ADD      r1,r2,#0              ;311
0005c4  e1d110b0          LDRH     r1,[r1,#0]            ;311  ; u16RunIndex
0005c8  e7d06001          LDRB     r6,[r0,r1]            ;311
0005cc  e2821000          ADD      r1,r2,#0              ;312
0005d0  e1d110b0          LDRH     r1,[r1,#0]            ;312  ; u16RunIndex
0005d4  e2810001          ADD      r0,r1,#1              ;312
0005d8  e1a01fc0          ASR      r1,r0,#31             ;312
0005dc  e0801b21          ADD      r1,r0,r1,LSR #22      ;312
0005e0  e1a01541          ASR      r1,r1,#10             ;312
0005e4  e0401501          SUB      r1,r0,r1,LSL #10      ;312
0005e8  e1c210b0          STRH     r1,[r2,#0]            ;312  ; u16RunIndex
0005ec  e2821000          ADD      r1,r2,#0              ;313
0005f0  e1d110b0          LDRH     r1,[r1,#0]            ;313  ; u16RunIndex
0005f4  e2810001          ADD      r0,r1,#1              ;313
0005f8  e1a01fc0          ASR      r1,r0,#31             ;313
0005fc  e0801b21          ADD      r1,r0,r1,LSR #22      ;313
000600  e1a01541          ASR      r1,r1,#10             ;313
000604  e0401501          SUB      r1,r0,r1,LSL #10      ;313
000608  e1c210b0          STRH     r1,[r2,#0]            ;313  ; u16RunIndex
00060c  e5d40000          LDRB     r0,[r4,#0]            ;314
000610  e2800001          ADD      r0,r0,#1              ;314
000614  e20000ff          AND      r0,r0,#0xff           ;314
000618  e1500006          CMP      r0,r6                 ;314
00061c  1a000004          BNE      |L1.1588|
000620  e5d41000          LDRB     r1,[r4,#0]            ;316
000624  e3a00000          MOV      r0,#0                 ;316
000628  ebfffffe          BL       i32UART_WriteByte
00062c  e3a00001          MOV      r0,#1                 ;317
000630  eaffff89          B        |L1.1116|
                  |L1.1588|
000634  e3a00000          MOV      r0,#0                 ;319
000638  eaffff87          B        |L1.1116|
                  |L1.1596|
00063c  e59f066c          LDR      r0,|L1.3248|
000640  e59f1678          LDR      r1,|L1.3264|
000644  e1d110b0          LDRH     r1,[r1,#0]            ;322  ; u16RunIndex
000648  e7d00001          LDRB     r0,[r0,r1]            ;322
00064c  e3500002          CMP      r0,#2                 ;322
000650  1a00004d          BNE      |L1.1932|
000654  e3a00002          MOV      r0,#2                 ;324
000658  e5c40007          STRB     r0,[r4,#7]            ;324
00065c  e59f165c          LDR      r1,|L1.3264|
000660  e1d110b0          LDRH     r1,[r1,#0]            ;325  ; u16RunIndex
000664  e2810001          ADD      r0,r1,#1              ;325
000668  e1a01fc0          ASR      r1,r0,#31             ;325
00066c  e0801b21          ADD      r1,r0,r1,LSR #22      ;325
000670  e1a01541          ASR      r1,r1,#10             ;325
000674  e0401501          SUB      r1,r0,r1,LSL #10      ;325
000678  e59f2640          LDR      r2,|L1.3264|
00067c  e1c210b0          STRH     r1,[r2,#0]            ;325  ; u16RunIndex
000680  e2820000          ADD      r0,r2,#0              ;326
000684  e1d000b0          LDRH     r0,[r0,#0]            ;326  ; u16RunIndex
000688  e2800003          ADD      r0,r0,#3              ;326
00068c  e59f161c          LDR      r1,|L1.3248|
000690  e7d10000          LDRB     r0,[r1,r0]            ;326
000694  e35000dd          CMP      r0,#0xdd              ;326
000698  1a0000d7          BNE      |L1.2556|
00069c  e2810000          ADD      r0,r1,#0              ;328
0006a0  e2821000          ADD      r1,r2,#0              ;328
0006a4  e1d110b0          LDRH     r1,[r1,#0]            ;328  ; u16RunIndex
0006a8  e7d00001          LDRB     r0,[r0,r1]            ;328
0006ac  e5c40000          STRB     r0,[r4,#0]            ;328
0006b0  e2821000          ADD      r1,r2,#0              ;329
0006b4  e1d110b0          LDRH     r1,[r1,#0]            ;329  ; u16RunIndex
0006b8  e2810001          ADD      r0,r1,#1              ;329
0006bc  e1a01fc0          ASR      r1,r0,#31             ;329
0006c0  e0801b21          ADD      r1,r0,r1,LSR #22      ;329
0006c4  e1a01541          ASR      r1,r1,#10             ;329
0006c8  e0401501          SUB      r1,r0,r1,LSL #10      ;329
0006cc  e1c210b0          STRH     r1,[r2,#0]            ;329  ; u16RunIndex
0006d0  e59f05d8          LDR      r0,|L1.3248|
0006d4  e2821000          ADD      r1,r2,#0              ;330
0006d8  e1d110b0          LDRH     r1,[r1,#0]            ;330  ; u16RunIndex
0006dc  e7d00001          LDRB     r0,[r0,r1]            ;330
0006e0  e5c40001          STRB     r0,[r4,#1]            ;330
0006e4  e2821000          ADD      r1,r2,#0              ;331
0006e8  e1d110b0          LDRH     r1,[r1,#0]            ;331  ; u16RunIndex
0006ec  e2810001          ADD      r0,r1,#1              ;331
0006f0  e1a01fc0          ASR      r1,r0,#31             ;331
0006f4  e0801b21          ADD      r1,r0,r1,LSR #22      ;331
0006f8  e1a01541          ASR      r1,r1,#10             ;331
0006fc  e0401501          SUB      r1,r0,r1,LSL #10      ;331
000700  e1c210b0          STRH     r1,[r2,#0]            ;331  ; u16RunIndex
000704  e59f05a4          LDR      r0,|L1.3248|
000708  e2821000          ADD      r1,r2,#0              ;332
00070c  e1d110b0          LDRH     r1,[r1,#0]            ;332  ; u16RunIndex
000710  e7d06001          LDRB     r6,[r0,r1]            ;332
000714  e2821000          ADD      r1,r2,#0              ;333
000718  e1d110b0          LDRH     r1,[r1,#0]            ;333  ; u16RunIndex
00071c  e2810001          ADD      r0,r1,#1              ;333
000720  e1a01fc0          ASR      r1,r0,#31             ;333
000724  e0801b21          ADD      r1,r0,r1,LSR #22      ;333
000728  e1a01541          ASR      r1,r1,#10             ;333
00072c  e0401501          SUB      r1,r0,r1,LSL #10      ;333
000730  e1c210b0          STRH     r1,[r2,#0]            ;333  ; u16RunIndex
000734  e2821000          ADD      r1,r2,#0              ;334
000738  e1d110b0          LDRH     r1,[r1,#0]            ;334  ; u16RunIndex
00073c  e2810001          ADD      r0,r1,#1              ;334
000740  e1a01fc0          ASR      r1,r0,#31             ;334
000744  e0801b21          ADD      r1,r0,r1,LSR #22      ;334
000748  e1a01541          ASR      r1,r1,#10             ;334
00074c  e0401501          SUB      r1,r0,r1,LSL #10      ;334
000750  e1c210b0          STRH     r1,[r2,#0]            ;334  ; u16RunIndex
000754  e5d40000          LDRB     r0,[r4,#0]            ;335
000758  e2800002          ADD      r0,r0,#2              ;335
00075c  e5d41001          LDRB     r1,[r4,#1]            ;335
000760  e0800001          ADD      r0,r0,r1              ;335
000764  e20000ff          AND      r0,r0,#0xff           ;335
000768  e1500006          CMP      r0,r6                 ;335
00076c  1a000004          BNE      |L1.1924|
000770  e5d41000          LDRB     r1,[r4,#0]            ;337
000774  e3a00000          MOV      r0,#0                 ;337
000778  ebfffffe          BL       i32UART_WriteByte
00077c  e3a00001          MOV      r0,#1                 ;338
000780  eaffff35          B        |L1.1116|
                  |L1.1924|
000784  e3a00000          MOV      r0,#0                 ;340
000788  eaffff33          B        |L1.1116|
                  |L1.1932|
00078c  e59f051c          LDR      r0,|L1.3248|
000790  e59f1528          LDR      r1,|L1.3264|
000794  e1d110b0          LDRH     r1,[r1,#0]            ;344  ; u16RunIndex
000798  e7d00001          LDRB     r0,[r0,r1]            ;344
00079c  e3500003          CMP      r0,#3                 ;344
0007a0  1a000095          BNE      |L1.2556|
0007a4  e3a00003          MOV      r0,#3                 ;346
0007a8  e5c40007          STRB     r0,[r4,#7]            ;346
0007ac  e59f150c          LDR      r1,|L1.3264|
0007b0  e1d110b0          LDRH     r1,[r1,#0]            ;347  ; u16RunIndex
0007b4  e2810001          ADD      r0,r1,#1              ;347
0007b8  e1a01fc0          ASR      r1,r0,#31             ;347
0007bc  e0801b21          ADD      r1,r0,r1,LSR #22      ;347
0007c0  e1a01541          ASR      r1,r1,#10             ;347
0007c4  e0401501          SUB      r1,r0,r1,LSL #10      ;347
0007c8  e59f24f0          LDR      r2,|L1.3264|
0007cc  e1c210b0          STRH     r1,[r2,#0]            ;347  ; u16RunIndex
0007d0  e59f04d8          LDR      r0,|L1.3248|
0007d4  e2821000          ADD      r1,r2,#0              ;348
0007d8  e1d110b0          LDRH     r1,[r1,#0]            ;348  ; u16RunIndex
0007dc  e2811001          ADD      r1,r1,#1              ;348
0007e0  e7d00001          LDRB     r0,[r0,r1]            ;348
0007e4  e1a07000          MOV      r7,r0                 ;348
0007e8  e3500004          CMP      r0,#4                 ;348
0007ec  ca000082          BGT      |L1.2556|
0007f0  e2820000          ADD      r0,r2,#0              ;350
0007f4  e1d000b0          LDRH     r0,[r0,#0]            ;350  ; u16RunIndex
0007f8  e2800007          ADD      r0,r0,#7              ;350
0007fc  e0800007          ADD      r0,r0,r7              ;350
000800  e2400003          SUB      r0,r0,#3              ;350
000804  e59f14a4          LDR      r1,|L1.3248|
000808  e7d10000          LDRB     r0,[r1,r0]            ;350
00080c  e35000dd          CMP      r0,#0xdd              ;350
000810  1a000079          BNE      |L1.2556|
000814  e2810000          ADD      r0,r1,#0              ;352
000818  e2821000          ADD      r1,r2,#0              ;352
00081c  e1d110b0          LDRH     r1,[r1,#0]            ;352  ; u16RunIndex
000820  e7d00001          LDRB     r0,[r0,r1]            ;352
000824  e5c40000          STRB     r0,[r4,#0]            ;352
000828  e2821000          ADD      r1,r2,#0              ;353
00082c  e1d110b0          LDRH     r1,[r1,#0]            ;353  ; u16RunIndex
000830  e2810001          ADD      r0,r1,#1              ;353
000834  e1a01fc0          ASR      r1,r0,#31             ;353
000838  e0801b21          ADD      r1,r0,r1,LSR #22      ;353
00083c  e1a01541          ASR      r1,r1,#10             ;353
000840  e0401501          SUB      r1,r0,r1,LSL #10      ;353
000844  e1c210b0          STRH     r1,[r2,#0]            ;353  ; u16RunIndex
000848  e59f0460          LDR      r0,|L1.3248|
00084c  e2821000          ADD      r1,r2,#0              ;354
000850  e1d110b0          LDRH     r1,[r1,#0]            ;354  ; u16RunIndex
000854  e7d00001          LDRB     r0,[r0,r1]            ;354
000858  e5c40001          STRB     r0,[r4,#1]            ;354
00085c  e2821000          ADD      r1,r2,#0              ;355
000860  e1d110b0          LDRH     r1,[r1,#0]            ;355  ; u16RunIndex
000864  e2810001          ADD      r0,r1,#1              ;355
000868  e1a01fc0          ASR      r1,r0,#31             ;355
00086c  e0801b21          ADD      r1,r0,r1,LSR #22      ;355
000870  e1a01541          ASR      r1,r1,#10             ;355
000874  e0401501          SUB      r1,r0,r1,LSL #10      ;355
000878  e1c210b0          STRH     r1,[r2,#0]            ;355  ; u16RunIndex
00087c  e3a05000          MOV      r5,#0                 ;356
000880  ea000010          B        |L1.2248|
                  |L1.2180|
000884  e59f0424          LDR      r0,|L1.3248|
000888  e59f1430          LDR      r1,|L1.3264|
00088c  e1d110b0          LDRH     r1,[r1,#0]            ;358  ; u16RunIndex
000890  e7d00001          LDRB     r0,[r0,r1]            ;358
000894  e2841002          ADD      r1,r4,#2              ;358
000898  e7c10005          STRB     r0,[r1,r5]            ;358
00089c  e59f141c          LDR      r1,|L1.3264|
0008a0  e1d110b0          LDRH     r1,[r1,#0]            ;359  ; u16RunIndex
0008a4  e2810001          ADD      r0,r1,#1              ;359
0008a8  e1a01fc0          ASR      r1,r0,#31             ;359
0008ac  e0801b21          ADD      r1,r0,r1,LSR #22      ;359
0008b0  e1a01541          ASR      r1,r1,#10             ;359
0008b4  e0401501          SUB      r1,r0,r1,LSL #10      ;359
0008b8  e59f2400          LDR      r2,|L1.3264|
0008bc  e1c210b0          STRH     r1,[r2,#0]            ;359  ; u16RunIndex
0008c0  e2850001          ADD      r0,r5,#1              ;356
0008c4  e20050ff          AND      r5,r0,#0xff           ;356
                  |L1.2248|
0008c8  e1550007          CMP      r5,r7                 ;356
0008cc  baffffec          BLT      |L1.2180|
0008d0  ea000004          B        |L1.2280|
                  |L1.2260|
0008d4  e3a00000          MOV      r0,#0                 ;363
0008d8  e2841002          ADD      r1,r4,#2              ;363
0008dc  e7c10005          STRB     r0,[r1,r5]            ;363
0008e0  e2850001          ADD      r0,r5,#1              ;361
0008e4  e20050ff          AND      r5,r0,#0xff           ;361
                  |L1.2280|
0008e8  e3550004          CMP      r5,#4                 ;361
0008ec  bafffff8          BLT      |L1.2260|
0008f0  e59f03b8          LDR      r0,|L1.3248|
0008f4  e59f13c4          LDR      r1,|L1.3264|
0008f8  e1d110b0          LDRH     r1,[r1,#0]            ;365  ; u16RunIndex
0008fc  e7d00001          LDRB     r0,[r0,r1]            ;365
000900  e5c40006          STRB     r0,[r4,#6]            ;365
000904  e59f13b4          LDR      r1,|L1.3264|
000908  e1d110b0          LDRH     r1,[r1,#0]            ;366  ; u16RunIndex
00090c  e2810001          ADD      r0,r1,#1              ;366
000910  e1a01fc0          ASR      r1,r0,#31             ;366
000914  e0801b21          ADD      r1,r0,r1,LSR #22      ;366
000918  e1a01541          ASR      r1,r1,#10             ;366
00091c  e0401501          SUB      r1,r0,r1,LSL #10      ;366
000920  e59f2398          LDR      r2,|L1.3264|
000924  e1c210b0          STRH     r1,[r2,#0]            ;366  ; u16RunIndex
000928  e59f0380          LDR      r0,|L1.3248|
00092c  e2821000          ADD      r1,r2,#0              ;367
000930  e1d110b0          LDRH     r1,[r1,#0]            ;367  ; u16RunIndex
000934  e7d06001          LDRB     r6,[r0,r1]            ;367
000938  e2821000          ADD      r1,r2,#0              ;368
00093c  e1d110b0          LDRH     r1,[r1,#0]            ;368  ; u16RunIndex
000940  e2810001          ADD      r0,r1,#1              ;368
000944  e1a01fc0          ASR      r1,r0,#31             ;368
000948  e0801b21          ADD      r1,r0,r1,LSR #22      ;368
00094c  e1a01541          ASR      r1,r1,#10             ;368
000950  e0401501          SUB      r1,r0,r1,LSL #10      ;368
000954  e1c210b0          STRH     r1,[r2,#0]            ;368  ; u16RunIndex
000958  e2821000          ADD      r1,r2,#0              ;369
00095c  e1d110b0          LDRH     r1,[r1,#0]            ;369  ; u16RunIndex
000960  e2810001          ADD      r0,r1,#1              ;369
000964  e1a01fc0          ASR      r1,r0,#31             ;369
000968  e0801b21          ADD      r1,r0,r1,LSR #22      ;369
00096c  e1a01541          ASR      r1,r1,#10             ;369
000970  e0401501          SUB      r1,r0,r1,LSL #10      ;369
000974  e1c210b0          STRH     r1,[r2,#0]            ;369  ; u16RunIndex
000978  e5d40000          LDRB     r0,[r4,#0]            ;370
00097c  e2800003          ADD      r0,r0,#3              ;370
000980  e5d41001          LDRB     r1,[r4,#1]            ;370
000984  e0800001          ADD      r0,r0,r1              ;370
000988  e5d41002          LDRB     r1,[r4,#2]            ;370
00098c  e0800001          ADD      r0,r0,r1              ;370
000990  e5d41003          LDRB     r1,[r4,#3]            ;370
000994  e0800001          ADD      r0,r0,r1              ;370
000998  e5d41004          LDRB     r1,[r4,#4]            ;370
00099c  e0800001          ADD      r0,r0,r1              ;370
0009a0  e5d41005          LDRB     r1,[r4,#5]            ;370
0009a4  e0800001          ADD      r0,r0,r1              ;370
0009a8  e5d41006          LDRB     r1,[r4,#6]            ;370
0009ac  e0800001          ADD      r0,r0,r1              ;370
0009b0  e20000ff          AND      r0,r0,#0xff           ;370
0009b4  e1500006          CMP      r0,r6                 ;370
0009b8  1a000004          BNE      |L1.2512|
0009bc  e5d41000          LDRB     r1,[r4,#0]            ;374
0009c0  e3a00000          MOV      r0,#0                 ;374
0009c4  ebfffffe          BL       i32UART_WriteByte
0009c8  e3a00001          MOV      r0,#1                 ;375
0009cc  eafffea2          B        |L1.1116|
                  |L1.2512|
0009d0  e3a00000          MOV      r0,#0                 ;377
0009d4  eafffea0          B        |L1.1116|
                  |L1.2520|
0009d8  e59f12e0          LDR      r1,|L1.3264|
0009dc  e1d110b0          LDRH     r1,[r1,#0]            ;385  ; u16RunIndex
0009e0  e2810001          ADD      r0,r1,#1              ;385
0009e4  e1a01fc0          ASR      r1,r0,#31             ;385
0009e8  e0801b21          ADD      r1,r0,r1,LSR #22      ;385
0009ec  e1a01541          ASR      r1,r1,#10             ;385
0009f0  e0401501          SUB      r1,r0,r1,LSL #10      ;385
0009f4  e59f22c4          LDR      r2,|L1.3264|
0009f8  e1c210b0          STRH     r1,[r2,#0]            ;385  ; u16RunIndex
                  |L1.2556|
0009fc  e3a00000          MOV      r0,#0                 ;387
000a00  eafffe95          B        |L1.1116|
                  |L1.2564|
000a04  e3a00000          MOV      r0,#0                 ;390
000a08  eafffe93          B        |L1.1116|
;;;392    
                          ENDP

                  vGetCommandFunction PROC
;;;394    
;;;395    void vGetCommandFunction(void)
000a0c  e92d41ff          PUSH     {r0-r8,lr}
;;;396    {
;;;397    	model_parameters_st model_Param;
;;;398    	uint8_t u8Check = C_FALSE;
000a10  e3a06000          MOV      r6,#0
;;;399    	model_index_et etFunction;
;;;400    	uint8_t u8type2Data = 0;
000a14  e3a07000          MOV      r7,#0
;;;401    	all_data_st sttype3Data = {0,0};
000a18  e3a00000          MOV      r0,#0
000a1c  e58d0000          STR      r0,[sp,#0]
000a20  e58d0004          STR      r0,[sp,#4]
;;;402    	int i = 0,j = 0;
000a24  e3a05000          MOV      r5,#0
000a28  e3a08000          MOV      r8,#0
;;;403    	u8Check = u8GetCommand(&model_Param);
000a2c  e28d0008          ADD      r0,sp,#8
000a30  ebfffffe          BL       u8GetCommand
000a34  e1a06000          MOV      r6,r0
;;;404    	if(u8Check == C_TRUE)
000a38  e3560001          CMP      r6,#1
000a3c  1a00002b          BNE      |L1.2800|
;;;405    	{
;;;406    		if(model_Param.u8typex == CODE_TYPE1)
000a40  e5dd000f          LDRB     r0,[sp,#0xf]
000a44  e3500001          CMP      r0,#1
000a48  1a000003          BNE      |L1.2652|
;;;407    		{
;;;408    			etFunction = (model_index_et)model_Param.utmodel.stCmdType1.u8screenIndex;
000a4c  e5dd4008          LDRB     r4,[sp,#8]
;;;409    			gModeData.u8type1Data = (uint8_t)etFunction;
000a50  e59f025c          LDR      r0,|L1.3252|
000a54  e5c04000          STRB     r4,[r0,#0]  ; gModeData
000a58  ea000024          B        |L1.2800|
                  |L1.2652|
;;;410    		}
;;;411    		else if(model_Param.u8typex == CODE_TYPE2)
000a5c  e5dd000f          LDRB     r0,[sp,#0xf]
000a60  e3500002          CMP      r0,#2
000a64  1a000005          BNE      |L1.2688|
;;;412    		{
;;;413    			etFunction = (model_index_et)model_Param.utmodel.stCmdType2.u8modelIndex;
000a68  e5dd4008          LDRB     r4,[sp,#8]
;;;414    			u8type2Data = model_Param.utmodel.stCmdType2.u8status;
000a6c  e5dd7009          LDRB     r7,[sp,#9]
;;;415    	        gModeData.u8type2DataTable[(uint8_t)etFunction - TYPE2_NUMBER_BASE] = u8type2Data;
000a70  e2440011          SUB      r0,r4,#0x11
000a74  e59f1248          LDR      r1,|L1.3268|
000a78  e7c17000          STRB     r7,[r1,r0]
000a7c  ea00001b          B        |L1.2800|
                  |L1.2688|
;;;416    		}
;;;417    		else if(model_Param.u8typex == CODE_TYPE3)
000a80  e5dd000f          LDRB     r0,[sp,#0xf]
000a84  e3500003          CMP      r0,#3
000a88  1a000018          BNE      |L1.2800|
;;;418    		{
;;;419    			etFunction = (model_index_et)model_Param.utmodel.stCmdType3.u8modelIndex;
000a8c  e5dd4008          LDRB     r4,[sp,#8]
;;;420    			i = model_Param.utmodel.stCmdType3.u8dataLen;
000a90  e5dd5009          LDRB     r5,[sp,#9]
;;;421    			sttype3Data.u32data = 0x0;
000a94  e3a00000          MOV      r0,#0
000a98  e58d0000          STR      r0,[sp,#0]
;;;422    			while(i)
000a9c  ea00000a          B        |L1.2764|
                  |L1.2720|
;;;423    			{
;;;424    				sttype3Data.u32data |= model_Param.utmodel.stCmdType3.u8data[j++] << ((i - 1) * 8);
000aa0  e1a00008          MOV      r0,r8
000aa4  e2888001          ADD      r8,r8,#1
000aa8  e28d100a          ADD      r1,sp,#0xa
000aac  e7d10000          LDRB     r0,[r1,r0]
000ab0  e2451001          SUB      r1,r5,#1
000ab4  e1a01181          LSL      r1,r1,#3
000ab8  e1a00110          LSL      r0,r0,r1
000abc  e59d1000          LDR      r1,[sp,#0]
000ac0  e1800001          ORR      r0,r0,r1
000ac4  e58d0000          STR      r0,[sp,#0]
;;;425    				i--;
000ac8  e2455001          SUB      r5,r5,#1
                  |L1.2764|
000acc  e3550000          CMP      r5,#0                 ;422
000ad0  1afffff2          BNE      |L1.2720|
;;;426    			}
;;;427    			sttype3Data.u8dp = model_Param.utmodel.stCmdType3.u8flag;
000ad4  e5dd000e          LDRB     r0,[sp,#0xe]
000ad8  e5cd0004          STRB     r0,[sp,#4]
;;;428    			gModeData.sttype3DataTable[(uint8_t)etFunction - TYPE3_NUMBER_BASE] = sttype3Data;
000adc  e2440041          SUB      r0,r4,#0x41
000ae0  e59f11e0          LDR      r1,|L1.3272|
000ae4  e0810180          ADD      r0,r1,r0,LSL #3
000ae8  e89d0006          LDM      sp,{r1,r2}
000aec  e8800006          STM      r0,{r1,r2}
                  |L1.2800|
;;;429    		}
;;;430    	}
;;;431    
;;;432    }
000af0  e8bd81ff          POP      {r0-r8,pc}
;;;433    
                          ENDP

                  vAppMain PROC
;;;434    
;;;435    void vAppMain(void)
000af4  e3a04000          MOV      r4,#0
;;;436    {
;;;437    	uint8_t u8iIndex = 0;
;;;438    	PMU_ENABLE() ;
000af8  ebfffffe          BL       vCR4_EnablePMU
;;;439    	/* Timer Enable */
;;;440    	TIMER_ENABLE() ; 
000afc  ebfffffe          BL       vCR4_EnableCCNT
;;;441    	/* Timer Reset */
;;;442    	TIMER_RESET();			
000b00  ebfffffe          BL       vCR4_ResetCCNT
;;;443    	/* Initialisation of buttons */
;;;444        vInitPanelPin();
000b04  ebfffffe          BL       vInitPanelPin
;;;445    	vBLControl(PANEL_PIN, 1, PANEL_ON_GP_STAT);  
000b08  e3a02001          MOV      r2,#1
000b0c  e1a01002          MOV      r1,r2
000b10  e3a00091          MOV      r0,#0x91
000b14  ebfffffe          BL       vBLControl
;;;446    	//vInterruptEnable();
;;;447    	vInitSytem();
000b18  ebfffffe          BL       vInitSytem
;;;448    	vMyInitUart(UART_CH0);
000b1c  e3a00000          MOV      r0,#0
000b20  ebfffffe          BL       vMyInitUart
;;;449    	//vInitPushbuttons();
;;;450        vAOBInstallEncPollTimer(10);
000b24  e3a0000a          MOV      r0,#0xa
000b28  ebfffffe          BL       vAOBInstallEncPollTimer
;;;451    	//显示黑屏
;;;452        memset(&gModeData,1,sizeof(model_data_st));
000b2c  e3a02001          MOV      r2,#1
000b30  e3a010fc          MOV      r1,#0xfc
000b34  e59f0178          LDR      r0,|L1.3252|
000b38  ebfffffe          BL       __aeabi_memset
;;;453        vInitAllData();
000b3c  ebfffffe          BL       vInitAllData
;;;454    	/* Main loop */
;;;455        u8SpeedChangeTimeFlag = 0;
000b40  e3a00000          MOV      r0,#0
000b44  e59f1180          LDR      r1,|L1.3276|
000b48  e5c10000          STRB     r0,[r1,#0]  ; u8SpeedChangeTimeFlag
;;;456    
;;;457    
;;;458    	while(gModeData.u8type1Data == 0 && u8CheckConnectSendData != 'o')
000b4c  ea00000a          B        |L1.2940|
                  |L1.2896|
;;;459    	{
;;;460    		if(u8SpeedChangeTimeFlag > 10)
000b50  e59f0174          LDR      r0,|L1.3276|
000b54  e5d00000          LDRB     r0,[r0,#0]  ; u8SpeedChangeTimeFlag
000b58  e350000a          CMP      r0,#0xa
000b5c  da000006          BLE      |L1.2940|
;;;461    		{
;;;462    			i32UART_WriteByte(UART_CH0,u8CheckConnectSendData);
000b60  e59f0150          LDR      r0,|L1.3256|
000b64  e5d01000          LDRB     r1,[r0,#0]  ; u8CheckConnectSendData
000b68  e3a00000          MOV      r0,#0
000b6c  ebfffffe          BL       i32UART_WriteByte
;;;463    			u8SpeedChangeTimeFlag = 0;
000b70  e3a00000          MOV      r0,#0
000b74  e59f1150          LDR      r1,|L1.3276|
000b78  e5c10000          STRB     r0,[r1,#0]  ; u8SpeedChangeTimeFlag
                  |L1.2940|
000b7c  e59f0130          LDR      r0,|L1.3252|
000b80  e5d00000          LDRB     r0,[r0,#0]            ;458  ; gModeData
000b84  e3500000          CMP      r0,#0                 ;458
000b88  1a000003          BNE      |L1.2972|
000b8c  e59f0124          LDR      r0,|L1.3256|
000b90  e5d00000          LDRB     r0,[r0,#0]            ;458  ; u8CheckConnectSendData
000b94  e350006f          CMP      r0,#0x6f              ;458
000b98  1affffec          BNE      |L1.2896|
                  |L1.2972|
;;;464    		}
;;;465    	}
;;;466    	
;;;467        i32UART_WriteByte(UART_CH0,0XBB);
000b9c  e3a010bb          MOV      r1,#0xbb
000ba0  e3a00000          MOV      r0,#0
000ba4  ebfffffe          BL       i32UART_WriteByte
;;;468    	u8SpeedChangeTimeFlag = 0;
000ba8  e3a00000          MOV      r0,#0
000bac  e59f1118          LDR      r1,|L1.3276|
000bb0  e5c10000          STRB     r0,[r1,#0]  ; u8SpeedChangeTimeFlag
;;;469    	while( 1 )
000bb4  ea000034          B        |L1.3212|
                  |L1.3000|
;;;470    	{
;;;471    		vGetCommandFunction();
000bb8  ebfffffe          BL       vGetCommandFunction
;;;472    		if(u8SpeedChangeTimeFlag > 2)
000bbc  e59f0108          LDR      r0,|L1.3276|
000bc0  e5d00000          LDRB     r0,[r0,#0]  ; u8SpeedChangeTimeFlag
000bc4  e3500002          CMP      r0,#2
000bc8  da000028          BLE      |L1.3184|
;;;473    		{
;;;474    			if(gModeData.u8type1Data == POWER_ON_LOGO)
000bcc  e59f00e0          LDR      r0,|L1.3252|
000bd0  e5d00000          LDRB     r0,[r0,#0]  ; gModeData
000bd4  e3500001          CMP      r0,#1
000bd8  1a000004          BNE      |L1.3056|
;;;475    			{
;;;476    				vShowPowerOnLogo();
000bdc  ebfffffe          BL       vShowPowerOnLogo
;;;477    				gModeData.u8type1Data = MOTOR_BATTERY_INFO_SCREEN + 1;
000be0  e3a00006          MOV      r0,#6
000be4  e59f10c8          LDR      r1,|L1.3252|
000be8  e5c10000          STRB     r0,[r1,#0]  ; gModeData
000bec  ea00001c          B        |L1.3172|
                  |L1.3056|
;;;478    			}
;;;479    			else if(gModeData.u8type1Data == MAIN_SCREEN)
000bf0  e59f00bc          LDR      r0,|L1.3252|
000bf4  e5d00000          LDRB     r0,[r0,#0]  ; gModeData
000bf8  e3500002          CMP      r0,#2
000bfc  1a00000f          BNE      |L1.3136|
;;;480    			{
;;;481    				u8iIndex = 0;
000c00  e3a04000          MOV      r4,#0
;;;482    				while(gRunFunTable[u8iIndex] != 0)
000c04  ea000004          B        |L1.3100|
                  |L1.3080|
;;;483    				{
;;;484    					gRunFunTable[u8iIndex]();
000c08  e59f10c0          LDR      r1,|L1.3280|
000c0c  e7910104          LDR      r0,[r1,r4,LSL #2]
000c10  e12fff30          BLX      r0
;;;485    					u8iIndex++;
000c14  e2840001          ADD      r0,r4,#1
000c18  e20040ff          AND      r4,r0,#0xff
                  |L1.3100|
000c1c  e59f00ac          LDR      r0,|L1.3280|
000c20  e7900104          LDR      r0,[r0,r4,LSL #2]     ;482
000c24  e3500000          CMP      r0,#0                 ;482
000c28  1afffff6          BNE      |L1.3080|
;;;486    				}	
;;;487    				vMainMenuFunc();
000c2c  ebfffffe          BL       vMainMenuFunc
;;;488    				vGfLayerSwitchBufferSync(GDC0, &stGDC0LayerA);
000c30  e59f109c          LDR      r1,|L1.3284|
000c34  e3a00000          MOV      r0,#0
000c38  ebfffffe          BL       vGfLayerSwitchBufferSync
000c3c  ea000008          B        |L1.3172|
                  |L1.3136|
;;;489    			}
;;;490    			else if(gModeData.u8type1Data == WAKE_UP_SCREEN)
000c40  e59f006c          LDR      r0,|L1.3252|
000c44  e5d00000          LDRB     r0,[r0,#0]  ; gModeData
000c48  e3500003          CMP      r0,#3
000c4c  0a000004          BEQ      |L1.3172|
;;;491    			{
;;;492    
;;;493    			}
;;;494    			else if(gModeData.u8type1Data == POWER_DOWN_SCREEN)
000c50  e59f005c          LDR      r0,|L1.3252|
000c54  e5d00000          LDRB     r0,[r0,#0]  ; gModeData
000c58  e3500004          CMP      r0,#4
000c5c  0a000000          BEQ      |L1.3172|
;;;495    			{
;;;496    
;;;497    			}
;;;498    			else if(gModeData.u8type1Data == MOTOR_BATTERY_INFO_SCREEN)
000c60  e320f000          NOP      
                  |L1.3172|
;;;499    			{
;;;500    
;;;501    			}
;;;502    			u8SpeedChangeTimeFlag = 0;
000c64  e3a00000          MOV      r0,#0
000c68  e59f105c          LDR      r1,|L1.3276|
000c6c  e5c10000          STRB     r0,[r1,#0]  ; u8SpeedChangeTimeFlag
                  |L1.3184|
;;;503    		}
;;;504    
;;;505    		if(u16Timer1SFlag > 100)
000c70  e59f0060          LDR      r0,|L1.3288|
000c74  e1d000b0          LDRH     r0,[r0,#0]  ; u16Timer1SFlag
000c78  e3500064          CMP      r0,#0x64
000c7c  da000002          BLE      |L1.3212|
;;;506    		{
;;;507    			u16Timer1SFlag = 0;
000c80  e3a00000          MOV      r0,#0
000c84  e59f104c          LDR      r1,|L1.3288|
000c88  e1c100b0          STRH     r0,[r1,#0]  ; u16Timer1SFlag
                  |L1.3212|
000c8c  eaffffc9          B        |L1.3000|
;;;508    		}
;;;509    
;;;510    
;;;511    
;;;512    
;;;513    			
;;;514    	}
;;;515    }
;;;516    
                          ENDP

                  |L1.3216|
                          DCD      ||.constdata||
                  |L1.3220|
                          DCD      ||.constdata||+0x8
                  |L1.3224|
                          DCD      stGDC0LayerA+0xc
                  |L1.3228|
                          DCD      stGDC0LayerA+0x20
                  |L1.3232|
                          DCD      stGDC0LayerB+0xc
                  |L1.3236|
                          DCD      stGDC0LayerB+0x20
                  |L1.3240|
                          DCD      0xc0404000
                  |L1.3244|
                          DCD      u16ReadIndex
                  |L1.3248|
                          DCD      u8ReadBuf
                  |L1.3252|
                          DCD      gModeData
                  |L1.3256|
                          DCD      u8CheckConnectSendData
                  |L1.3260|
                          DCD      0x0001f87e
                  |L1.3264|
                          DCD      u16RunIndex
                  |L1.3268|
                          DCD      gModeData+0x1
                  |L1.3272|
                          DCD      gModeData+0x24
                  |L1.3276|
                          DCD      u8SpeedChangeTimeFlag
                  |L1.3280|
                          DCD      gRunFunTable
                  |L1.3284|
                          DCD      stGDC0LayerA
                  |L1.3288|
                          DCD      u16Timer1SFlag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gModeData
                          %        252
                  u8IconConfigTable
                          %        35
                  u8ReadBuf
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00000000          DCW      0x0000,0x0000
000004  050001a4          DCW      0x0500,0x01a4
000008  00000000          DCW      0x0000,0x0000
00000c  01900190          DCW      0x0190,0x0190

                          AREA ||.data||, DATA, ALIGN=1

                  u8SpeedChangeTimeFlag
000000  00                DCB      0x00
                  u8CheckConnectSendData
000001  55                DCB      0x55
                  u16RunIndex
000002  0000              DCW      0x0000
                  u16ReadIndex
000004  0000              DCW      0x0000
