L 1 "..\..\..\..\lldd\src\txcan.c"
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : CAN Low-Level Driver (CAN)
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : CAN Low-Level Driver (CAN)
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.10 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "txcan_io.h"
L 1 "..\..\..\..\lldd\hdr\txcan_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : TCAN 
N/  Date of creation (y-m-d:time): 2013-06-26+02:00  :  17:51:06.103+02:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.17 $ 
N/  Excel Sheet ver.             : v1.1
N/  Excel Sheet date             : 2013-Jun-21
N/  Excel Sheet author           : ZUL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : TXCAN low level driver io-header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : TXCAN
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.17 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef TCANIO_H
N#define TCANIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */ 
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 40 "..\..\..\..\lldd\hdr\txcan_io.h" 2
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_TXCAN_IO_H_REVISION     "$Revision: 1.17 $"
N#define LLDD_TXCAN_IO_H_TAG          "$Name: LLDD_1_6 $"
N
N/****************************************************************************
N*                          CONTROLER SELECTION MACROS
N*             (Please use these macros to select module instances)
N*****************************************************************************/
Ntypedef enum tag_txcan_ch_def_e
N{
N  TXCAN_CH0__ = 0,
N  TXCAN_CH1__ = 0x1000,  
N  TXCAN_CH2__ = 0x2000 
N} txcan_ch_def_e;
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: ID_MBn                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400000                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define ID_MBn_REG__       0xC0400000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   EXT_ID	:18; 	 /* 0..17  bit(s) R/W */
N  uint32_t   STD_ID	:11; 	 /* 18..28  bit(s) R/W */
N  uint32_t   RFH	:1; 	 /* 29..29  bit(s) R/W */
N  uint32_t   GAME	:1; 	 /* 30..30  bit(s) R/W */ 
N  uint32_t   IDE	:1; 	 /* 31..31  bit(s) R/W */                    
N} ID_MBn_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} ID_MBn_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} ID_MBn_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32ID_MBn_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitID_MBn(ctrlr,ch)     ((volatile ID_MBn_bit_view_st *)\
N(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_bitID_MBn(ctrlr,ch)     ((volatile ID_MBn_bit_view_st *)(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8ID_MBn(ctrlr,ch)     ((volatile ID_MBn_byte_view_st *)\
N(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u8ID_MBn(ctrlr,ch)     ((volatile ID_MBn_byte_view_st *)(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16ID_MBn(ctrlr,ch)     ((volatile ID_MBn_halfword_view_st *)\
N(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u16ID_MBn(ctrlr,ch)     ((volatile ID_MBn_halfword_view_st *)(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to WORD  */ 
N#define pu32ID_MBn(ctrlr,ch)     ((volatile u32ID_MBn_word_view *)\
N(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pu32ID_MBn(ctrlr,ch)     ((volatile u32ID_MBn_word_view *)(ID_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetID_MBn_EXT_ID(ctrlr,ch) (pst_bitID_MBn(ctrlr,ch) -> EXT_ID)
N#define vSetID_MBn_EXT_ID(ctrlr,ch,ParValue)  (pst_bitID_MBn(ctrlr,ch) -> EXT_ID=(ParValue))
N#define biGetID_MBn_STD_ID(ctrlr,ch) (pst_bitID_MBn(ctrlr,ch) -> STD_ID)
N#define vSetID_MBn_STD_ID(ctrlr,ch,ParValue)  (pst_bitID_MBn(ctrlr,ch) -> STD_ID=(ParValue))
N#define biGetID_MBn_RFH(ctrlr,ch) (pst_bitID_MBn(ctrlr,ch) -> RFH)
N#define vSetID_MBn_RFH(ctrlr,ch,ParValue)  (pst_bitID_MBn(ctrlr,ch) -> RFH=(ParValue))
N#define biGetID_MBn_GAME(ctrlr,ch) (pst_bitID_MBn(ctrlr,ch) -> GAME)
N#define vSetID_MBn_GAME(ctrlr,ch,ParValue)  (pst_bitID_MBn(ctrlr,ch) -> GAME=(ParValue))
N#define biGetID_MBn_IDE(ctrlr,ch) (pst_bitID_MBn(ctrlr,ch) -> IDE)
N#define vSetID_MBn_IDE(ctrlr,ch,ParValue)  (pst_bitID_MBn(ctrlr,ch) -> IDE=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetID_MBnLL(ctrlr,ch,ParValue) (pst_u8ID_MBn(ctrlr,ch) -> u8LL = (ParValue))
N#define u8GetID_MBnLL(ctrlr,ch) (pst_u8ID_MBn(ctrlr,ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetID_MBnLH(ctrlr,ch,ParValue) (pst_u8ID_MBn(ctrlr,ch) -> u8LH = (ParValue))
N#define u8GetID_MBnLH(ctrlr,ch) (pst_u8ID_MBn(ctrlr,ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetID_MBnHL(ctrlr,ch,ParValue) (pst_u8ID_MBn(ctrlr,ch) -> u8HL = (ParValue))
N#define u8GetID_MBnHL(ctrlr,ch) (pst_u8ID_MBn(ctrlr,ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetID_MBnHH(ctrlr,ch,ParValue) (pst_u8ID_MBn(ctrlr,ch) -> u8HH = (ParValue))
N#define u8GetID_MBnHH(ctrlr,ch) (pst_u8ID_MBn(ctrlr,ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetID_MBnL(ctrlr,ch,ParValue) (pst_u16ID_MBn(ctrlr,ch) -> u16L = (ParValue))
N#define u16GetID_MBnL(ctrlr,ch) (pst_u16ID_MBn(ctrlr,ch) -> u16L)
N#define vSetID_MBnH(ctrlr,ch,ParValue) (pst_u16ID_MBn(ctrlr,ch) -> u16H = (ParValue))
N#define u16GetID_MBnH(ctrlr,ch) (pst_u16ID_MBn(ctrlr,ch) -> u16H)
N            
N/* Word access */
N#define vSetID_MBn(ctrlr,ch,ParValue)  (*pu32ID_MBn(ctrlr,ch) = (ParValue))
N#define u32GetID_MBn(ctrlr,ch)  (*pu32ID_MBn(ctrlr,ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: FTS_MBn                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400008                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define FTS_MBn_REG__       0xC0400008U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DLC	:4; 	 /* 0..3  bit(s) R/W */
N  uint32_t   RTR	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   	:11; 	 /* 5..15  bit(s) R */ 
N  uint32_t   TSV	:16; 	 /* 16..31  bit(s) R/W */                    
N} FTS_MBn_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} FTS_MBn_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} FTS_MBn_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32FTS_MBn_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitFTS_MBn(ctrlr,ch)     ((volatile FTS_MBn_bit_view_st *)\
N(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_bitFTS_MBn(ctrlr,ch)     ((volatile FTS_MBn_bit_view_st *)(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8FTS_MBn(ctrlr,ch)     ((volatile FTS_MBn_byte_view_st *)\
N(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u8FTS_MBn(ctrlr,ch)     ((volatile FTS_MBn_byte_view_st *)(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16FTS_MBn(ctrlr,ch)     ((volatile FTS_MBn_halfword_view_st *)\
N(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u16FTS_MBn(ctrlr,ch)     ((volatile FTS_MBn_halfword_view_st *)(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to WORD  */ 
N#define pu32FTS_MBn(ctrlr,ch)     ((volatile u32FTS_MBn_word_view *)\
N(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pu32FTS_MBn(ctrlr,ch)     ((volatile u32FTS_MBn_word_view *)(FTS_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetFTS_MBn_DLC(ctrlr,ch) (pst_bitFTS_MBn(ctrlr,ch) -> DLC)
N#define vSetFTS_MBn_DLC(ctrlr,ch,ParValue)  (pst_bitFTS_MBn(ctrlr,ch) -> DLC=(ParValue))
N#define biGetFTS_MBn_RTR(ctrlr,ch) (pst_bitFTS_MBn(ctrlr,ch) -> RTR)
N#define vSetFTS_MBn_RTR(ctrlr,ch,ParValue)  (pst_bitFTS_MBn(ctrlr,ch) -> RTR=(ParValue))
N#define biGetFTS_MBn_TSV(ctrlr,ch) (pst_bitFTS_MBn(ctrlr,ch) -> TSV)
N#define vSetFTS_MBn_TSV(ctrlr,ch,ParValue)  (pst_bitFTS_MBn(ctrlr,ch) -> TSV=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetFTS_MBnLL(ctrlr,ch,ParValue) (pst_u8FTS_MBn(ctrlr,ch) -> u8LL = (ParValue))
N#define u8GetFTS_MBnLL(ctrlr,ch) (pst_u8FTS_MBn(ctrlr,ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetFTS_MBnLH(ctrlr,ch,ParValue) (pst_u8FTS_MBn(ctrlr,ch) -> u8LH = (ParValue))
N#define u8GetFTS_MBnLH(ctrlr,ch) (pst_u8FTS_MBn(ctrlr,ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetFTS_MBnHL(ctrlr,ch,ParValue) (pst_u8FTS_MBn(ctrlr,ch) -> u8HL = (ParValue))
N#define u8GetFTS_MBnHL(ctrlr,ch) (pst_u8FTS_MBn(ctrlr,ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetFTS_MBnHH(ctrlr,ch,ParValue) (pst_u8FTS_MBn(ctrlr,ch) -> u8HH = (ParValue))
N#define u8GetFTS_MBnHH(ctrlr,ch) (pst_u8FTS_MBn(ctrlr,ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetFTS_MBnL(ctrlr,ch,ParValue) (pst_u16FTS_MBn(ctrlr,ch) -> u16L = (ParValue))
N#define u16GetFTS_MBnL(ctrlr,ch) (pst_u16FTS_MBn(ctrlr,ch) -> u16L)
N#define vSetFTS_MBnH(ctrlr,ch,ParValue) (pst_u16FTS_MBn(ctrlr,ch) -> u16H = (ParValue))
N#define u16GetFTS_MBnH(ctrlr,ch) (pst_u16FTS_MBn(ctrlr,ch) -> u16H)
N            
N/* Word access */
N#define vSetFTS_MBn(ctrlr,ch,ParValue)  (*pu32FTS_MBn(ctrlr,ch) = (ParValue))
N#define u32GetFTS_MBn(ctrlr,ch)  (*pu32FTS_MBn(ctrlr,ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DATL_MBn                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DATL_MBn_REG__       0xC0400010U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   D0	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   D1	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   D2	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   D3	:8; 	 /* 24..31  bit(s) R/W */                    
N} DATL_MBn_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} DATL_MBn_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} DATL_MBn_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32DATL_MBn_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDATL_MBn(ctrlr,ch)     ((volatile DATL_MBn_bit_view_st *)\
N(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_bitDATL_MBn(ctrlr,ch)     ((volatile DATL_MBn_bit_view_st *)(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8DATL_MBn(ctrlr,ch)     ((volatile DATL_MBn_byte_view_st *)\
N(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u8DATL_MBn(ctrlr,ch)     ((volatile DATL_MBn_byte_view_st *)(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16DATL_MBn(ctrlr,ch)     ((volatile DATL_MBn_halfword_view_st *)\
N(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u16DATL_MBn(ctrlr,ch)     ((volatile DATL_MBn_halfword_view_st *)(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to WORD  */ 
N#define pu32DATL_MBn(ctrlr,ch)     ((volatile u32DATL_MBn_word_view *)\
N(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pu32DATL_MBn(ctrlr,ch)     ((volatile u32DATL_MBn_word_view *)(DATL_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDATL_MBn_D0(ctrlr,ch) (pst_bitDATL_MBn(ctrlr,ch) -> D0)
N#define vSetDATL_MBn_D0(ctrlr,ch,ParValue)  (pst_bitDATL_MBn(ctrlr,ch) -> D0=(ParValue))
N#define biGetDATL_MBn_D1(ctrlr,ch) (pst_bitDATL_MBn(ctrlr,ch) -> D1)
N#define vSetDATL_MBn_D1(ctrlr,ch,ParValue)  (pst_bitDATL_MBn(ctrlr,ch) -> D1=(ParValue))
N#define biGetDATL_MBn_D2(ctrlr,ch) (pst_bitDATL_MBn(ctrlr,ch) -> D2)
N#define vSetDATL_MBn_D2(ctrlr,ch,ParValue)  (pst_bitDATL_MBn(ctrlr,ch) -> D2=(ParValue))
N#define biGetDATL_MBn_D3(ctrlr,ch) (pst_bitDATL_MBn(ctrlr,ch) -> D3)
N#define vSetDATL_MBn_D3(ctrlr,ch,ParValue)  (pst_bitDATL_MBn(ctrlr,ch) -> D3=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetDATL_MBnLL(ctrlr,ch,ParValue) (pst_u8DATL_MBn(ctrlr,ch) -> u8LL = (ParValue))
N#define u8GetDATL_MBnLL(ctrlr,ch) (pst_u8DATL_MBn(ctrlr,ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetDATL_MBnLH(ctrlr,ch,ParValue) (pst_u8DATL_MBn(ctrlr,ch) -> u8LH = (ParValue))
N#define u8GetDATL_MBnLH(ctrlr,ch) (pst_u8DATL_MBn(ctrlr,ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetDATL_MBnHL(ctrlr,ch,ParValue) (pst_u8DATL_MBn(ctrlr,ch) -> u8HL = (ParValue))
N#define u8GetDATL_MBnHL(ctrlr,ch) (pst_u8DATL_MBn(ctrlr,ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetDATL_MBnHH(ctrlr,ch,ParValue) (pst_u8DATL_MBn(ctrlr,ch) -> u8HH = (ParValue))
N#define u8GetDATL_MBnHH(ctrlr,ch) (pst_u8DATL_MBn(ctrlr,ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetDATL_MBnL(ctrlr,ch,ParValue) (pst_u16DATL_MBn(ctrlr,ch) -> u16L = (ParValue))
N#define u16GetDATL_MBnL(ctrlr,ch) (pst_u16DATL_MBn(ctrlr,ch) -> u16L)
N#define vSetDATL_MBnH(ctrlr,ch,ParValue) (pst_u16DATL_MBn(ctrlr,ch) -> u16H = (ParValue))
N#define u16GetDATL_MBnH(ctrlr,ch) (pst_u16DATL_MBn(ctrlr,ch) -> u16H)
N            
N/* Word access */
N#define vSetDATL_MBn(ctrlr,ch,ParValue)  (*pu32DATL_MBn(ctrlr,ch) = (ParValue))
N#define u32GetDATL_MBn(ctrlr,ch)  (*pu32DATL_MBn(ctrlr,ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DATH_MBn                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400018                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DATH_MBn_REG__       0xC0400018U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   D4	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   D5	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   D6	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   D7	:8; 	 /* 24..31  bit(s) R/W */                    
N} DATH_MBn_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} DATH_MBn_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} DATH_MBn_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32DATH_MBn_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDATH_MBn(ctrlr,ch)     ((volatile DATH_MBn_bit_view_st *)\
N(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_bitDATH_MBn(ctrlr,ch)     ((volatile DATH_MBn_bit_view_st *)(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8DATH_MBn(ctrlr,ch)     ((volatile DATH_MBn_byte_view_st *)\
N(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u8DATH_MBn(ctrlr,ch)     ((volatile DATH_MBn_byte_view_st *)(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16DATH_MBn(ctrlr,ch)     ((volatile DATH_MBn_halfword_view_st *)\
N(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pst_u16DATH_MBn(ctrlr,ch)     ((volatile DATH_MBn_halfword_view_st *)(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N            
N/* Pointer to WORD  */ 
N#define pu32DATH_MBn(ctrlr,ch)     ((volatile u32DATH_MBn_word_view *)\
N(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
X#define pu32DATH_MBn(ctrlr,ch)     ((volatile u32DATH_MBn_word_view *)(DATH_MBn_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDATH_MBn_D4(ctrlr,ch) (pst_bitDATH_MBn(ctrlr,ch) -> D4)
N#define vSetDATH_MBn_D4(ctrlr,ch,ParValue)  (pst_bitDATH_MBn(ctrlr,ch) -> D4=(ParValue))
N#define biGetDATH_MBn_D5(ctrlr,ch) (pst_bitDATH_MBn(ctrlr,ch) -> D5)
N#define vSetDATH_MBn_D5(ctrlr,ch,ParValue)  (pst_bitDATH_MBn(ctrlr,ch) -> D5=(ParValue))
N#define biGetDATH_MBn_D6(ctrlr,ch) (pst_bitDATH_MBn(ctrlr,ch) -> D6)
N#define vSetDATH_MBn_D6(ctrlr,ch,ParValue)  (pst_bitDATH_MBn(ctrlr,ch) -> D6=(ParValue))
N#define biGetDATH_MBn_D7(ctrlr,ch) (pst_bitDATH_MBn(ctrlr,ch) -> D7)
N#define vSetDATH_MBn_D7(ctrlr,ch,ParValue)  (pst_bitDATH_MBn(ctrlr,ch) -> D7=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetDATH_MBnLL(ctrlr,ch,ParValue) (pst_u8DATH_MBn(ctrlr,ch) -> u8LL = (ParValue))
N#define u8GetDATH_MBnLL(ctrlr,ch) (pst_u8DATH_MBn(ctrlr,ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetDATH_MBnLH(ctrlr,ch,ParValue) (pst_u8DATH_MBn(ctrlr,ch) -> u8LH = (ParValue))
N#define u8GetDATH_MBnLH(ctrlr,ch) (pst_u8DATH_MBn(ctrlr,ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetDATH_MBnHL(ctrlr,ch,ParValue) (pst_u8DATH_MBn(ctrlr,ch) -> u8HL = (ParValue))
N#define u8GetDATH_MBnHL(ctrlr,ch) (pst_u8DATH_MBn(ctrlr,ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetDATH_MBnHH(ctrlr,ch,ParValue) (pst_u8DATH_MBn(ctrlr,ch) -> u8HH = (ParValue))
N#define u8GetDATH_MBnHH(ctrlr,ch) (pst_u8DATH_MBn(ctrlr,ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetDATH_MBnL(ctrlr,ch,ParValue) (pst_u16DATH_MBn(ctrlr,ch) -> u16L = (ParValue))
N#define u16GetDATH_MBnL(ctrlr,ch) (pst_u16DATH_MBn(ctrlr,ch) -> u16L)
N#define vSetDATH_MBnH(ctrlr,ch,ParValue) (pst_u16DATH_MBn(ctrlr,ch) -> u16H = (ParValue))
N#define u16GetDATH_MBnH(ctrlr,ch) (pst_u16DATH_MBn(ctrlr,ch) -> u16H)
N            
N/* Word access */
N#define vSetDATH_MBn(ctrlr,ch,ParValue)  (*pu32DATH_MBn(ctrlr,ch) = (ParValue))
N#define u32GetDATH_MBn(ctrlr,ch)  (*pu32DATH_MBn(ctrlr,ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MC                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400400                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MC_REG__       0xC0400400U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   MC	:32; 	 /* 0..31  bit(s) R/W */                    
N} MC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} MC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} MC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32MC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMC(ctrlr)     ((volatile MC_bit_view_st *)\
N(MC_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitMC(ctrlr)     ((volatile MC_bit_view_st *)(MC_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MC(ctrlr)     ((volatile MC_byte_view_st *)\
N(MC_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8MC(ctrlr)     ((volatile MC_byte_view_st *)(MC_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16MC(ctrlr)     ((volatile MC_halfword_view_st *)\
N(MC_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16MC(ctrlr)     ((volatile MC_halfword_view_st *)(MC_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32MC(ctrlr)     ((volatile u32MC_word_view *)\
N(MC_REG__  + ((int32_t)(ctrlr))))
X#define pu32MC(ctrlr)     ((volatile u32MC_word_view *)(MC_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMC_MC(ctrlr) (pst_bitMC(ctrlr) -> MC)
N#define vSetMC_MC(ctrlr,ParValue)  (pst_bitMC(ctrlr) -> MC=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetMCLL(ctrlr,ParValue) (pst_u8MC(ctrlr) -> u8LL = (ParValue))
N#define u8GetMCLL(ctrlr) (pst_u8MC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetMCLH(ctrlr,ParValue) (pst_u8MC(ctrlr) -> u8LH = (ParValue))
N#define u8GetMCLH(ctrlr) (pst_u8MC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetMCHL(ctrlr,ParValue) (pst_u8MC(ctrlr) -> u8HL = (ParValue))
N#define u8GetMCHL(ctrlr) (pst_u8MC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetMCHH(ctrlr,ParValue) (pst_u8MC(ctrlr) -> u8HH = (ParValue))
N#define u8GetMCHH(ctrlr) (pst_u8MC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetMCL(ctrlr,ParValue) (pst_u16MC(ctrlr) -> u16L = (ParValue))
N#define u16GetMCL(ctrlr) (pst_u16MC(ctrlr) -> u16L)
N#define vSetMCH(ctrlr,ParValue) (pst_u16MC(ctrlr) -> u16H = (ParValue))
N#define u16GetMCH(ctrlr) (pst_u16MC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetMC(ctrlr,ParValue)  (*pu32MC(ctrlr) = (ParValue))
N#define u32GetMC(ctrlr)  (*pu32MC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MD                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400408                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MD_REG__       0xC0400408U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MD	:31; 	 /* 0..30  bit(s) R/W */ 
N  uint32_t   MD31	:1; 	 /* 31..31  bit(s) R */                    
N} MD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} MD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} MD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32MD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMD(ctrlr)     ((volatile MD_bit_view_st *)\
N(MD_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitMD(ctrlr)     ((volatile MD_bit_view_st *)(MD_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MD(ctrlr)     ((volatile MD_byte_view_st *)\
N(MD_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8MD(ctrlr)     ((volatile MD_byte_view_st *)(MD_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16MD(ctrlr)     ((volatile MD_halfword_view_st *)\
N(MD_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16MD(ctrlr)     ((volatile MD_halfword_view_st *)(MD_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32MD(ctrlr)     ((volatile u32MD_word_view *)\
N(MD_REG__  + ((int32_t)(ctrlr))))
X#define pu32MD(ctrlr)     ((volatile u32MD_word_view *)(MD_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMD_MD(ctrlr) (pst_bitMD(ctrlr) -> MD)
N#define vSetMD_MD(ctrlr,ParValue)  (pst_bitMD(ctrlr) -> MD=(ParValue))            
N#define biGetMD_MD31(ctrlr) (pst_bitMD(ctrlr) -> MD31)
N            
N/* LL-struct byte access */
N#define vSetMDLL(ctrlr,ParValue) (pst_u8MD(ctrlr) -> u8LL = (ParValue))
N#define u8GetMDLL(ctrlr) (pst_u8MD(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetMDLH(ctrlr,ParValue) (pst_u8MD(ctrlr) -> u8LH = (ParValue))
N#define u8GetMDLH(ctrlr) (pst_u8MD(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetMDHL(ctrlr,ParValue) (pst_u8MD(ctrlr) -> u8HL = (ParValue))
N#define u8GetMDHL(ctrlr) (pst_u8MD(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetMDHH(ctrlr,ParValue) (pst_u8MD(ctrlr) -> u8HH = (ParValue))
N#define u8GetMDHH(ctrlr) (pst_u8MD(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetMDL(ctrlr,ParValue) (pst_u16MD(ctrlr) -> u16L = (ParValue))
N#define u16GetMDL(ctrlr) (pst_u16MD(ctrlr) -> u16L)
N#define vSetMDH(ctrlr,ParValue) (pst_u16MD(ctrlr) -> u16H = (ParValue))
N#define u16GetMDH(ctrlr) (pst_u16MD(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetMD(ctrlr,ParValue)  (*pu32MD(ctrlr) = (ParValue))
N#define u32GetMD(ctrlr)  (*pu32MD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: TRS                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400410                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define TRS_REG__       0xC0400410U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   TRS	:31; 	 /* 0..30  bit(s) R/S */ 
N  uint32_t   	:1; 	 /* 31..31  bit(s) R */                    
N} TRS_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} TRS_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} TRS_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32TRS_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitTRS(ctrlr)     ((volatile TRS_bit_view_st *)\
N(TRS_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitTRS(ctrlr)     ((volatile TRS_bit_view_st *)(TRS_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8TRS(ctrlr)     ((volatile TRS_byte_view_st *)\
N(TRS_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8TRS(ctrlr)     ((volatile TRS_byte_view_st *)(TRS_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16TRS(ctrlr)     ((volatile TRS_halfword_view_st *)\
N(TRS_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16TRS(ctrlr)     ((volatile TRS_halfword_view_st *)(TRS_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32TRS(ctrlr)     ((volatile u32TRS_word_view *)\
N(TRS_REG__  + ((int32_t)(ctrlr))))
X#define pu32TRS(ctrlr)     ((volatile u32TRS_word_view *)(TRS_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetTRS_TRS(ctrlr) (pst_bitTRS(ctrlr) -> TRS)
N#define vSetTRS_TRS(ctrlr) (pst_bitTRS(ctrlr) -> TRS=(1))
N            
N/* LL-struct byte access */
N#define vSetTRSLL(ctrlr,ParValue) (pst_u8TRS(ctrlr) -> u8LL = (ParValue))
N#define u8GetTRSLL(ctrlr) (pst_u8TRS(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetTRSLH(ctrlr,ParValue) (pst_u8TRS(ctrlr) -> u8LH = (ParValue))
N#define u8GetTRSLH(ctrlr) (pst_u8TRS(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetTRSHL(ctrlr,ParValue) (pst_u8TRS(ctrlr) -> u8HL = (ParValue))
N#define u8GetTRSHL(ctrlr) (pst_u8TRS(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetTRSHH(ctrlr,ParValue) (pst_u8TRS(ctrlr) -> u8HH = (ParValue))
N#define u8GetTRSHH(ctrlr) (pst_u8TRS(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetTRSL(ctrlr,ParValue) (pst_u16TRS(ctrlr) -> u16L = (ParValue))
N#define u16GetTRSL(ctrlr) (pst_u16TRS(ctrlr) -> u16L)
N#define vSetTRSH(ctrlr,ParValue) (pst_u16TRS(ctrlr) -> u16H = (ParValue))
N#define u16GetTRSH(ctrlr) (pst_u16TRS(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetTRS(ctrlr,ParValue)  (*pu32TRS(ctrlr) = (ParValue))
N#define u32GetTRS(ctrlr)  (*pu32TRS(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: TRR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400418                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define TRR_REG__       0xC0400418U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   TRR	:31; 	 /* 0..30  bit(s) R/S */ 
N  uint32_t   	:1; 	 /* 31..31  bit(s) R */                    
N} TRR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} TRR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} TRR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32TRR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitTRR(ctrlr)     ((volatile TRR_bit_view_st *)\
N(TRR_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitTRR(ctrlr)     ((volatile TRR_bit_view_st *)(TRR_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8TRR(ctrlr)     ((volatile TRR_byte_view_st *)\
N(TRR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8TRR(ctrlr)     ((volatile TRR_byte_view_st *)(TRR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16TRR(ctrlr)     ((volatile TRR_halfword_view_st *)\
N(TRR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16TRR(ctrlr)     ((volatile TRR_halfword_view_st *)(TRR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32TRR(ctrlr)     ((volatile u32TRR_word_view *)\
N(TRR_REG__  + ((int32_t)(ctrlr))))
X#define pu32TRR(ctrlr)     ((volatile u32TRR_word_view *)(TRR_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetTRR_TRR(ctrlr) (pst_bitTRR(ctrlr) -> TRR)
N#define vSetTRR_TRR(ctrlr) (pst_bitTRR(ctrlr) -> TRR=(1))
N            
N/* LL-struct byte access */
N#define vSetTRRLL(ctrlr,ParValue) (pst_u8TRR(ctrlr) -> u8LL = (ParValue))
N#define u8GetTRRLL(ctrlr) (pst_u8TRR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetTRRLH(ctrlr,ParValue) (pst_u8TRR(ctrlr) -> u8LH = (ParValue))
N#define u8GetTRRLH(ctrlr) (pst_u8TRR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetTRRHL(ctrlr,ParValue) (pst_u8TRR(ctrlr) -> u8HL = (ParValue))
N#define u8GetTRRHL(ctrlr) (pst_u8TRR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetTRRHH(ctrlr,ParValue) (pst_u8TRR(ctrlr) -> u8HH = (ParValue))
N#define u8GetTRRHH(ctrlr) (pst_u8TRR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetTRRL(ctrlr,ParValue) (pst_u16TRR(ctrlr) -> u16L = (ParValue))
N#define u16GetTRRL(ctrlr) (pst_u16TRR(ctrlr) -> u16L)
N#define vSetTRRH(ctrlr,ParValue) (pst_u16TRR(ctrlr) -> u16H = (ParValue))
N#define u16GetTRRH(ctrlr) (pst_u16TRR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetTRR(ctrlr,ParValue)  (*pu32TRR(ctrlr) = (ParValue))
N#define u32GetTRR(ctrlr)  (*pu32TRR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: TA                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400420                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define TA_REG__       0xC0400420U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   TA	:31; 	 /* 0..30  bit(s) R/W1C */ 
N  uint32_t   	:1; 	 /* 31..31  bit(s) R */                    
N} TA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} TA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} TA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32TA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitTA(ctrlr)     ((volatile TA_bit_view_st *)\
N(TA_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitTA(ctrlr)     ((volatile TA_bit_view_st *)(TA_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8TA(ctrlr)     ((volatile TA_byte_view_st *)\
N(TA_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8TA(ctrlr)     ((volatile TA_byte_view_st *)(TA_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16TA(ctrlr)     ((volatile TA_halfword_view_st *)\
N(TA_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16TA(ctrlr)     ((volatile TA_halfword_view_st *)(TA_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32TA(ctrlr)     ((volatile u32TA_word_view *)\
N(TA_REG__  + ((int32_t)(ctrlr))))
X#define pu32TA(ctrlr)     ((volatile u32TA_word_view *)(TA_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetTA_TA(ctrlr) (pst_bitTA(ctrlr) -> TA)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr function can be applied for bit 0..30: */
N#define vClrTA_TA(ctrlr, BitNo) (pst_bitTA(ctrlr) -> TA = ( (0x00000001 << BitNo) & 0x7FFFFFFFU)) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..30: */
N#define vClrMultiTA_TA(ctrlr, Mask) (pst_bitTA(ctrlr) -> TA = (Mask & 0x7FFFFFFFU))
N/*---------------------------------------------------------------------------*/
N
N/* LL-struct byte access */
N#define vSetTALL(ctrlr,ParValue) (pst_u8TA(ctrlr) -> u8LL = (ParValue))
N#define u8GetTALL(ctrlr) (pst_u8TA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetTALH(ctrlr,ParValue) (pst_u8TA(ctrlr) -> u8LH = (ParValue))
N#define u8GetTALH(ctrlr) (pst_u8TA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetTAHL(ctrlr,ParValue) (pst_u8TA(ctrlr) -> u8HL = (ParValue))
N#define u8GetTAHL(ctrlr) (pst_u8TA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetTAHH(ctrlr,ParValue) (pst_u8TA(ctrlr) -> u8HH = (ParValue))
N#define u8GetTAHH(ctrlr) (pst_u8TA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetTAL(ctrlr,ParValue) (pst_u16TA(ctrlr) -> u16L = (ParValue))
N#define u16GetTAL(ctrlr) (pst_u16TA(ctrlr) -> u16L)
N#define vSetTAH(ctrlr,ParValue) (pst_u16TA(ctrlr) -> u16H = (ParValue))
N#define u16GetTAH(ctrlr) (pst_u16TA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetTA(ctrlr,ParValue)  (*pu32TA(ctrlr) = (ParValue))
N#define u32GetTA(ctrlr)  (*pu32TA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: AA                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400428                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define AA_REG__       0xC0400428U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   AA	:31; 	 /* 0..30  bit(s) R/W1C */ 
N  uint32_t   	:1; 	 /* 31..31  bit(s) R */                    
N} AA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} AA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} AA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32AA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitAA(ctrlr)     ((volatile AA_bit_view_st *)\
N(AA_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitAA(ctrlr)     ((volatile AA_bit_view_st *)(AA_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8AA(ctrlr)     ((volatile AA_byte_view_st *)\
N(AA_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8AA(ctrlr)     ((volatile AA_byte_view_st *)(AA_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16AA(ctrlr)     ((volatile AA_halfword_view_st *)\
N(AA_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16AA(ctrlr)     ((volatile AA_halfword_view_st *)(AA_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32AA(ctrlr)     ((volatile u32AA_word_view *)\
N(AA_REG__  + ((int32_t)(ctrlr))))
X#define pu32AA(ctrlr)     ((volatile u32AA_word_view *)(AA_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetAA_AA(ctrlr) (pst_bitAA(ctrlr) -> AA)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr function can be applied for bit 0..30: */
N#define vClrAA_AA(ctrlr, BitNo) (pst_bitAA(ctrlr) -> AA = ( (0x00000001 << BitNo) & 0x7FFFFFFFU)) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..30: */
N#define vClrMultiAA_AA(ctrlr, Mask) (pst_bitAA(ctrlr) -> AA = (Mask & 0x7FFFFFFFU))
N/*---------------------------------------------------------------------------*/
N            
N/* LL-struct byte access */
N#define vSetAALL(ctrlr,ParValue) (pst_u8AA(ctrlr) -> u8LL = (ParValue))
N#define u8GetAALL(ctrlr) (pst_u8AA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetAALH(ctrlr,ParValue) (pst_u8AA(ctrlr) -> u8LH = (ParValue))
N#define u8GetAALH(ctrlr) (pst_u8AA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetAAHL(ctrlr,ParValue) (pst_u8AA(ctrlr) -> u8HL = (ParValue))
N#define u8GetAAHL(ctrlr) (pst_u8AA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetAAHH(ctrlr,ParValue) (pst_u8AA(ctrlr) -> u8HH = (ParValue))
N#define u8GetAAHH(ctrlr) (pst_u8AA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetAAL(ctrlr,ParValue) (pst_u16AA(ctrlr) -> u16L = (ParValue))
N#define u16GetAAL(ctrlr) (pst_u16AA(ctrlr) -> u16L)
N#define vSetAAH(ctrlr,ParValue) (pst_u16AA(ctrlr) -> u16H = (ParValue))
N#define u16GetAAH(ctrlr) (pst_u16AA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetAA(ctrlr,ParValue)  (*pu32AA(ctrlr) = (ParValue))
N#define u32GetAA(ctrlr)  (*pu32AA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: RMP                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400430                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define RMP_REG__       0xC0400430U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   RMP	:32; 	 /* 0..31  bit(s) R/W1C */                    
N} RMP_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} RMP_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} RMP_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32RMP_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitRMP(ctrlr)     ((volatile RMP_bit_view_st *)\
N(RMP_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitRMP(ctrlr)     ((volatile RMP_bit_view_st *)(RMP_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8RMP(ctrlr)     ((volatile RMP_byte_view_st *)\
N(RMP_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8RMP(ctrlr)     ((volatile RMP_byte_view_st *)(RMP_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16RMP(ctrlr)     ((volatile RMP_halfword_view_st *)\
N(RMP_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16RMP(ctrlr)     ((volatile RMP_halfword_view_st *)(RMP_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32RMP(ctrlr)     ((volatile u32RMP_word_view *)\
N(RMP_REG__  + ((int32_t)(ctrlr))))
X#define pu32RMP(ctrlr)     ((volatile u32RMP_word_view *)(RMP_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetRMP_RMP(ctrlr) (pst_bitRMP(ctrlr) -> RMP)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..31: */
N#define vClrRMP_RMP(ctrlr, BitNo) (pst_bitRMP(ctrlr) -> RMP = (0x00000001 << BitNo))
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..31: */
N#define vClrMultiRMP_RMP(ctrlr, Mask) (pst_bitRMP(ctrlr) -> RMP = (Mask))
N/*---------------------------------------------------------------------------*/
N           
N/* LL-struct byte access */
N#define vSetRMPLL(ctrlr,ParValue) (pst_u8RMP(ctrlr) -> u8LL = (ParValue))
N#define u8GetRMPLL(ctrlr) (pst_u8RMP(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetRMPLH(ctrlr,ParValue) (pst_u8RMP(ctrlr) -> u8LH = (ParValue))
N#define u8GetRMPLH(ctrlr) (pst_u8RMP(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetRMPHL(ctrlr,ParValue) (pst_u8RMP(ctrlr) -> u8HL = (ParValue))
N#define u8GetRMPHL(ctrlr) (pst_u8RMP(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetRMPHH(ctrlr,ParValue) (pst_u8RMP(ctrlr) -> u8HH = (ParValue))
N#define u8GetRMPHH(ctrlr) (pst_u8RMP(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetRMPL(ctrlr,ParValue) (pst_u16RMP(ctrlr) -> u16L = (ParValue))
N#define u16GetRMPL(ctrlr) (pst_u16RMP(ctrlr) -> u16L)
N#define vSetRMPH(ctrlr,ParValue) (pst_u16RMP(ctrlr) -> u16H = (ParValue))
N#define u16GetRMPH(ctrlr) (pst_u16RMP(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetRMP(ctrlr,ParValue)  (*pu32RMP(ctrlr) = (ParValue))
N#define u32GetRMP(ctrlr)  (*pu32RMP(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: RML                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400438                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define RML_REG__       0xC0400438U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   RML	:32; 	 /* 0..31  bit(s) R/W1C */                    
N} RML_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} RML_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} RML_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32RML_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitRML(ctrlr)     ((volatile RML_bit_view_st *)\
N(RML_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitRML(ctrlr)     ((volatile RML_bit_view_st *)(RML_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8RML(ctrlr)     ((volatile RML_byte_view_st *)\
N(RML_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8RML(ctrlr)     ((volatile RML_byte_view_st *)(RML_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16RML(ctrlr)     ((volatile RML_halfword_view_st *)\
N(RML_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16RML(ctrlr)     ((volatile RML_halfword_view_st *)(RML_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32RML(ctrlr)     ((volatile u32RML_word_view *)\
N(RML_REG__  + ((int32_t)(ctrlr))))
X#define pu32RML(ctrlr)     ((volatile u32RML_word_view *)(RML_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetRML_RML(ctrlr) (pst_bitRML(ctrlr) -> RML)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..31: */
N#define vClrRML_RML(ctrlr, BitNo) (pst_bitRML(ctrlr) -> RML = (0x00000001 << BitNo))
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..31: */
N#define vClrMultiRML_RML(ctrlr, Mask) (pst_bitRML(ctrlr) -> RML = (Mask))
N/*---------------------------------------------------------------------------*/
N            
N/* LL-struct byte access */
N#define vSetRMLLL(ctrlr,ParValue) (pst_u8RML(ctrlr) -> u8LL = (ParValue))
N#define u8GetRMLLL(ctrlr) (pst_u8RML(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetRMLLH(ctrlr,ParValue) (pst_u8RML(ctrlr) -> u8LH = (ParValue))
N#define u8GetRMLLH(ctrlr) (pst_u8RML(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetRMLHL(ctrlr,ParValue) (pst_u8RML(ctrlr) -> u8HL = (ParValue))
N#define u8GetRMLHL(ctrlr) (pst_u8RML(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetRMLHH(ctrlr,ParValue) (pst_u8RML(ctrlr) -> u8HH = (ParValue))
N#define u8GetRMLHH(ctrlr) (pst_u8RML(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetRMLL(ctrlr,ParValue) (pst_u16RML(ctrlr) -> u16L = (ParValue))
N#define u16GetRMLL(ctrlr) (pst_u16RML(ctrlr) -> u16L)
N#define vSetRMLH(ctrlr,ParValue) (pst_u16RML(ctrlr) -> u16H = (ParValue))
N#define u16GetRMLH(ctrlr) (pst_u16RML(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetRML(ctrlr,ParValue)  (*pu32RML(ctrlr) = (ParValue))
N#define u32GetRML(ctrlr)  (*pu32RML(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400450                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MCR_REG__       0xC0400450U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   SRES	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   TSCC	:1; 	 /* 1..1  bit(s) R/W */
N  uint16_t   	:1; 	 /* 2..2  bit(s) R */
N  uint16_t   MTOS	:1; 	 /* 3..3  bit(s) R/W */
N  uint16_t   WUBA	:1; 	 /* 4..4  bit(s) R/W */
N  uint16_t   TSBTEST	:1; 	 /* 5..5  bit(s) R/W */
N  uint16_t   SMR	:1; 	 /* 6..6  bit(s) R/W */
N  uint16_t   CCR	:1; 	 /* 7..7  bit(s) R/W */
N  uint16_t   TSTERR	:1; 	 /* 8..8  bit(s) R/W */
N  uint16_t   TSTLB	:1; 	 /* 9..9  bit(s) R/W */
N  uint16_t   INTLB	:1; 	 /* 10..10  bit(s) R/W */
N  uint16_t   SUR	:1; 	 /* 11..11  bit(s) R/W */ 
N  uint16_t   	:4; 	 /* 12..31  bit(s) R */                    
N} MCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} MCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16MCR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMCR(ctrlr)     ((volatile MCR_bit_view_st *)\
N(MCR_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitMCR(ctrlr)     ((volatile MCR_bit_view_st *)(MCR_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MCR(ctrlr)     ((volatile MCR_byte_view_st *)\
N(MCR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8MCR(ctrlr)     ((volatile MCR_byte_view_st *)(MCR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD */
N#define pu16MCR(ctrlr)     ((volatile u16MCR_halfword_view *)\
N(MCR_REG__  + ((int32_t)(ctrlr))))
X#define pu16MCR(ctrlr)     ((volatile u16MCR_halfword_view *)(MCR_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMCR_SRES(ctrlr) (pst_bitMCR(ctrlr) -> SRES)
N#define vSetMCR_SRES(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> SRES=(ParValue))
N#define biGetMCR_TSCC(ctrlr) (pst_bitMCR(ctrlr) -> TSCC)
N#define vSetMCR_TSCC(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> TSCC=(ParValue))
N#define biGetMCR_MTOS(ctrlr) (pst_bitMCR(ctrlr) -> MTOS)
N#define vSetMCR_MTOS(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> MTOS=(ParValue))
N#define biGetMCR_WUBA(ctrlr) (pst_bitMCR(ctrlr) -> WUBA)
N#define vSetMCR_WUBA(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> WUBA=(ParValue))
N#define biGetMCR_TSBTEST(ctrlr) (pst_bitMCR(ctrlr) -> TSBTEST)
N#define vSetMCR_TSBTEST(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> TSBTEST=(ParValue))
N#define biGetMCR_SMR(ctrlr) (pst_bitMCR(ctrlr) -> SMR)
N#define vSetMCR_SMR(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> SMR=(ParValue))
N#define biGetMCR_CCR(ctrlr) (pst_bitMCR(ctrlr) -> CCR)
N#define vSetMCR_CCR(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> CCR=(ParValue))
N#define biGetMCR_TSTERR(ctrlr) (pst_bitMCR(ctrlr) -> TSTERR)
N#define vSetMCR_TSTERR(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> TSTERR=(ParValue))
N#define biGetMCR_TSTLB(ctrlr) (pst_bitMCR(ctrlr) -> TSTLB)
N#define vSetMCR_TSTLB(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> TSTLB=(ParValue))
N#define biGetMCR_INTLB(ctrlr) (pst_bitMCR(ctrlr) -> INTLB)
N#define vSetMCR_INTLB(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> INTLB=(ParValue))
N#define biGetMCR_SUR(ctrlr) (pst_bitMCR(ctrlr) -> SUR)
N#define vSetMCR_SUR(ctrlr,ParValue)  (pst_bitMCR(ctrlr) -> SUR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetMCRL(ctrlr,ParValue) (pst_u8MCR(ctrlr) -> u8L = (ParValue))
N#define u8GetMCRL(ctrlr) (pst_u8MCR(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetMCRH(ctrlr,ParValue) (pst_u8MCR(ctrlr) -> u8H = (ParValue))
N#define u8GetMCRH(ctrlr) (pst_u8MCR(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetMCR(ctrlr,ParValue) (*pu16MCR(ctrlr)  = (ParValue))
N#define u16GetMCR(ctrlr) (*pu16MCR(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GSR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400458                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define GSR_REG__       0xC0400458U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   EW	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   EP	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BO	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   TSO	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   	:2; 	 /* 4..5  bit(s) R */
N  uint32_t   SMA	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   CCE	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   SUA	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   TM	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   RM	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   MIS	:5; 	 /* 12..16  bit(s) R */ 
N  uint32_t   	:15; 	 /* 17..31  bit(s) R */                    
N} GSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GSR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GSR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGSR(ctrlr)     ((volatile GSR_bit_view_st *)\
N(GSR_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitGSR(ctrlr)     ((volatile GSR_bit_view_st *)(GSR_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GSR(ctrlr)     ((volatile GSR_byte_view_st *)\
N(GSR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8GSR(ctrlr)     ((volatile GSR_byte_view_st *)(GSR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GSR(ctrlr)     ((volatile GSR_halfword_view_st *)\
N(GSR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16GSR(ctrlr)     ((volatile GSR_halfword_view_st *)(GSR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32GSR(ctrlr)     ((volatile u32GSR_word_view *)\
N(GSR_REG__  + ((int32_t)(ctrlr))))
X#define pu32GSR(ctrlr)     ((volatile u32GSR_word_view *)(GSR_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGSR_EW(ctrlr) (pst_bitGSR(ctrlr) -> EW)            
N#define biGetGSR_EP(ctrlr) (pst_bitGSR(ctrlr) -> EP)            
N#define biGetGSR_BO(ctrlr) (pst_bitGSR(ctrlr) -> BO)            
N#define biGetGSR_TSO(ctrlr) (pst_bitGSR(ctrlr) -> TSO)            
N#define biGetGSR_SMA(ctrlr) (pst_bitGSR(ctrlr) -> SMA)            
N#define biGetGSR_CCE(ctrlr) (pst_bitGSR(ctrlr) -> CCE)            
N#define biGetGSR_SUA(ctrlr) (pst_bitGSR(ctrlr) -> SUA)            
N#define biGetGSR_TM(ctrlr) (pst_bitGSR(ctrlr) -> TM)            
N#define biGetGSR_RM(ctrlr) (pst_bitGSR(ctrlr) -> RM)            
N#define biGetGSR_MIS(ctrlr) (pst_bitGSR(ctrlr) -> MIS)
N            
N/* LL-struct byte access */
N
N#define u8GetGSRLL(ctrlr) (pst_u8GSR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetGSRLH(ctrlr) (pst_u8GSR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetGSRHL(ctrlr) (pst_u8GSR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetGSRHH(ctrlr) (pst_u8GSR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N
N#define u16GetGSRL(ctrlr) (pst_u16GSR(ctrlr) -> u16L)
N
N#define u16GetGSRH(ctrlr) (pst_u16GSR(ctrlr) -> u16H)
N            
N/* Word access */
N
N#define u32GetGSR(ctrlr)  (*pu32GSR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: BCR1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400460                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define BCR1_REG__       0xC0400460U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   BRP	:10; 	 /* 0..9  bit(s) R/W */ 
N  uint16_t   	:6; 	 /* 10..31  bit(s) R */                    
N} BCR1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} BCR1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16BCR1_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitBCR1(ctrlr)     ((volatile BCR1_bit_view_st *)\
N(BCR1_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitBCR1(ctrlr)     ((volatile BCR1_bit_view_st *)(BCR1_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8BCR1(ctrlr)     ((volatile BCR1_byte_view_st *)\
N(BCR1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8BCR1(ctrlr)     ((volatile BCR1_byte_view_st *)(BCR1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD */
N#define pu16BCR1(ctrlr)     ((volatile u16BCR1_halfword_view *)\
N(BCR1_REG__  + ((int32_t)(ctrlr))))
X#define pu16BCR1(ctrlr)     ((volatile u16BCR1_halfword_view *)(BCR1_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetBCR1_BRP(ctrlr) (pst_bitBCR1(ctrlr) -> BRP)
N#define vSetBCR1_BRP(ctrlr,ParValue)  (pst_bitBCR1(ctrlr) -> BRP=(ParValue))
N            
N/* L-struct byte access */
N#define vSetBCR1L(ctrlr,ParValue) (pst_u8BCR1(ctrlr) -> u8L = (ParValue))
N#define u8GetBCR1L(ctrlr) (pst_u8BCR1(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetBCR1H(ctrlr,ParValue) (pst_u8BCR1(ctrlr) -> u8H = (ParValue))
N#define u8GetBCR1H(ctrlr) (pst_u8BCR1(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetBCR1(ctrlr,ParValue) (*pu16BCR1(ctrlr)  = (ParValue))
N#define u16GetBCR1(ctrlr) (*pu16BCR1(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: BCR2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400468                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define BCR2_REG__       0xC0400468U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   TSEG1	:4; 	 /* 0..3  bit(s) R/W */
N  uint16_t   TSEG2	:3; 	 /* 4..6  bit(s) R/W */
N  uint16_t   SAM	:1; 	 /* 7..7  bit(s) R/W */
N  uint16_t   SJW	:2; 	 /* 8..9  bit(s) R/W */ 
N  uint16_t   	:6; 	 /* 10..31  bit(s) R */                    
N} BCR2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} BCR2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16BCR2_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitBCR2(ctrlr)     ((volatile BCR2_bit_view_st *)\
N(BCR2_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitBCR2(ctrlr)     ((volatile BCR2_bit_view_st *)(BCR2_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8BCR2(ctrlr)     ((volatile BCR2_byte_view_st *)\
N(BCR2_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8BCR2(ctrlr)     ((volatile BCR2_byte_view_st *)(BCR2_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD */
N#define pu16BCR2(ctrlr)     ((volatile u16BCR2_halfword_view *)\
N(BCR2_REG__  + ((int32_t)(ctrlr))))
X#define pu16BCR2(ctrlr)     ((volatile u16BCR2_halfword_view *)(BCR2_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetBCR2_TSEG1(ctrlr) (pst_bitBCR2(ctrlr) -> TSEG1)
N#define vSetBCR2_TSEG1(ctrlr,ParValue)  (pst_bitBCR2(ctrlr) -> TSEG1=(ParValue))
N#define biGetBCR2_TSEG2(ctrlr) (pst_bitBCR2(ctrlr) -> TSEG2)
N#define vSetBCR2_TSEG2(ctrlr,ParValue)  (pst_bitBCR2(ctrlr) -> TSEG2=(ParValue))
N#define biGetBCR2_SAM(ctrlr) (pst_bitBCR2(ctrlr) -> SAM)
N#define vSetBCR2_SAM(ctrlr,ParValue)  (pst_bitBCR2(ctrlr) -> SAM=(ParValue))
N#define biGetBCR2_SJW(ctrlr) (pst_bitBCR2(ctrlr) -> SJW)
N#define vSetBCR2_SJW(ctrlr,ParValue)  (pst_bitBCR2(ctrlr) -> SJW=(ParValue))
N            
N/* L-struct byte access */
N#define vSetBCR2L(ctrlr,ParValue) (pst_u8BCR2(ctrlr) -> u8L = (ParValue))
N#define u8GetBCR2L(ctrlr) (pst_u8BCR2(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetBCR2H(ctrlr,ParValue) (pst_u8BCR2(ctrlr) -> u8H = (ParValue))
N#define u8GetBCR2H(ctrlr) (pst_u8BCR2(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetBCR2(ctrlr,ParValue) (*pu16BCR2(ctrlr)  = (ParValue))
N#define u16GetBCR2(ctrlr) (*pu16BCR2(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GIF                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400470                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define GIF_REG__       0xC0400470U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   WLIF	:1; 	 /* 0..0  bit(s) R/W1C */
N  uint8_t   EPIF	:1; 	 /* 1..1  bit(s) R/W1C */
N  uint8_t   BOIF	:1; 	 /* 2..2  bit(s) R/W1C */
N  uint8_t   TSOIF	:1; 	 /* 3..3  bit(s) R/W1C */
N  uint8_t   TRMABF	:1; 	 /* 4..4  bit(s) R/W1C */
N  uint8_t   RMLIF	:1; 	 /* 5..5  bit(s) R/W1C */
N  uint8_t   WUIF	:1; 	 /* 6..6  bit(s) R/W1C */
N  uint8_t   RFPF	:1; 	 /* 7..7  bit(s) R/W1C */                    
N} GIF_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GIF_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGIF(ctrlr)     ((volatile GIF_bit_view_st *)\
N(GIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitGIF(ctrlr)     ((volatile GIF_bit_view_st *)(GIF_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE  */
N#define pu8GIF(ctrlr)     ((volatile u8GIF_byte_view *)\
N(GIF_REG__  + ((int32_t)(ctrlr))))
X#define pu8GIF(ctrlr)     ((volatile u8GIF_byte_view *)(GIF_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGIF_WLIF(ctrlr) (pst_bitGIF(ctrlr) -> WLIF)
N#define vClrGIF_WLIF(ctrlr) (pst_bitGIF(ctrlr) -> WLIF = (1))
N#define biGetGIF_EPIF(ctrlr) (pst_bitGIF(ctrlr) -> EPIF)
N#define vClrGIF_EPIF(ctrlr) (pst_bitGIF(ctrlr) -> EPIF = (1))
N#define biGetGIF_BOIF(ctrlr) (pst_bitGIF(ctrlr) -> BOIF)
N#define vClrGIF_BOIF(ctrlr) (pst_bitGIF(ctrlr) -> BOIF = (1))
N#define biGetGIF_TSOIF(ctrlr) (pst_bitGIF(ctrlr) -> TSOIF)
N#define vClrGIF_TSOIF(ctrlr) (pst_bitGIF(ctrlr) -> TSOIF = (1))
N#define biGetGIF_TRMABF(ctrlr) (pst_bitGIF(ctrlr) -> TRMABF)
N#define vClrGIF_TRMABF(ctrlr) (pst_bitGIF(ctrlr) -> TRMABF = (1))
N#define biGetGIF_RMLIF(ctrlr) (pst_bitGIF(ctrlr) -> RMLIF)
N#define vClrGIF_RMLIF(ctrlr) (pst_bitGIF(ctrlr) -> RMLIF = (1))
N#define biGetGIF_WUIF(ctrlr) (pst_bitGIF(ctrlr) -> WUIF)
N#define vClrGIF_WUIF(ctrlr) (pst_bitGIF(ctrlr) -> WUIF = (1))
N#define biGetGIF_RFPF(ctrlr) (pst_bitGIF(ctrlr) -> RFPF)
N#define vClrGIF_RFPF(ctrlr) (pst_bitGIF(ctrlr) -> RFPF = (1))
N            
N/* byte access */
N#define vSetGIF(ctrlr,ParValue) (*pu8GIF(ctrlr) = (ParValue))
N#define u8GetGIF(ctrlr) (*pu8GIF(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GIM                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400478                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define GIM_REG__       0xC0400478U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   WLIM	:1; 	 /* 0..0  bit(s) R/W */
N  uint8_t   EPIM	:1; 	 /* 1..1  bit(s) R/W */
N  uint8_t   BOIM	:1; 	 /* 2..2  bit(s) R/W */
N  uint8_t   TSOIM	:1; 	 /* 3..3  bit(s) R/W */
N  uint8_t   TRMABFM	:1; 	 /* 4..4  bit(s) R/W */
N  uint8_t   RMLIM	:1; 	 /* 5..5  bit(s) R/W */
N  uint8_t   WUIM	:1; 	 /* 6..6  bit(s) R/W */
N  uint8_t   RFPM	:1; 	 /* 7..7  bit(s) R/W */                    
N} GIM_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GIM_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGIM(ctrlr)     ((volatile GIM_bit_view_st *)\
N(GIM_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitGIM(ctrlr)     ((volatile GIM_bit_view_st *)(GIM_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE  */
N#define pu8GIM(ctrlr)     ((volatile u8GIM_byte_view *)\
N(GIM_REG__  + ((int32_t)(ctrlr))))
X#define pu8GIM(ctrlr)     ((volatile u8GIM_byte_view *)(GIM_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGIM_WLIM(ctrlr) (pst_bitGIM(ctrlr) -> WLIM)
N#define vSetGIM_WLIM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> WLIM=(ParValue))
N#define biGetGIM_EPIM(ctrlr) (pst_bitGIM(ctrlr) -> EPIM)
N#define vSetGIM_EPIM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> EPIM=(ParValue))
N#define biGetGIM_BOIM(ctrlr) (pst_bitGIM(ctrlr) -> BOIM)
N#define vSetGIM_BOIM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> BOIM=(ParValue))
N#define biGetGIM_TSOIM(ctrlr) (pst_bitGIM(ctrlr) -> TSOIM)
N#define vSetGIM_TSOIM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> TSOIM=(ParValue))
N#define biGetGIM_TRMABFM(ctrlr) (pst_bitGIM(ctrlr) -> TRMABFM)
N#define vSetGIM_TRMABFM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> TRMABFM=(ParValue))
N#define biGetGIM_RMLIM(ctrlr) (pst_bitGIM(ctrlr) -> RMLIM)
N#define vSetGIM_RMLIM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> RMLIM=(ParValue))
N#define biGetGIM_WUIM(ctrlr) (pst_bitGIM(ctrlr) -> WUIM)
N#define vSetGIM_WUIM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> WUIM=(ParValue))
N#define biGetGIM_RFPM(ctrlr) (pst_bitGIM(ctrlr) -> RFPM)
N#define vSetGIM_RFPM(ctrlr,ParValue)  (pst_bitGIM(ctrlr) -> RFPM=(ParValue))
N            
N/* byte access */
N#define vSetGIM(ctrlr,ParValue) (*pu8GIM(ctrlr) = (ParValue))
N#define u8GetGIM(ctrlr) (*pu8GIM(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MBTIF                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400480                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MBTIF_REG__       0xC0400480U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MBTIF	:31; 	 /* 0..30  bit(s) R/W1C */ 
N  uint32_t   	:1; 	 /* 31..31  bit(s) R */                    
N} MBTIF_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} MBTIF_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} MBTIF_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32MBTIF_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMBTIF(ctrlr)     ((volatile MBTIF_bit_view_st *)\
N(MBTIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitMBTIF(ctrlr)     ((volatile MBTIF_bit_view_st *)(MBTIF_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MBTIF(ctrlr)     ((volatile MBTIF_byte_view_st *)\
N(MBTIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8MBTIF(ctrlr)     ((volatile MBTIF_byte_view_st *)(MBTIF_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16MBTIF(ctrlr)     ((volatile MBTIF_halfword_view_st *)\
N(MBTIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16MBTIF(ctrlr)     ((volatile MBTIF_halfword_view_st *)(MBTIF_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32MBTIF(ctrlr)     ((volatile u32MBTIF_word_view *)\
N(MBTIF_REG__  + ((int32_t)(ctrlr))))
X#define pu32MBTIF(ctrlr)     ((volatile u32MBTIF_word_view *)(MBTIF_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMBTIF_MBTIF(ctrlr) (pst_bitMBTIF(ctrlr) -> MBTIF)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..30: */
N#define vClrMBTIF_MBTIF(ctrlr, BitNo) (pst_bitMBTIF(ctrlr) -> MBTIF = ( (0x00000001 << BitNo) & 0x7FFFFFFFU)) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..30: */
N#define vClrMultiMBTIF_MBTIF(ctrlr, Mask) (pst_bitMBTIF(ctrlr) -> MBTIF = (Mask & 0x7FFFFFFFU))
N/*---------------------------------------------------------------------------*/
N            
N/* LL-struct byte access */
N#define vSetMBTIFLL(ctrlr,ParValue) (pst_u8MBTIF(ctrlr) -> u8LL = (ParValue))
N#define u8GetMBTIFLL(ctrlr) (pst_u8MBTIF(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetMBTIFLH(ctrlr,ParValue) (pst_u8MBTIF(ctrlr) -> u8LH = (ParValue))
N#define u8GetMBTIFLH(ctrlr) (pst_u8MBTIF(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetMBTIFHL(ctrlr,ParValue) (pst_u8MBTIF(ctrlr) -> u8HL = (ParValue))
N#define u8GetMBTIFHL(ctrlr) (pst_u8MBTIF(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetMBTIFHH(ctrlr,ParValue) (pst_u8MBTIF(ctrlr) -> u8HH = (ParValue))
N#define u8GetMBTIFHH(ctrlr) (pst_u8MBTIF(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetMBTIFL(ctrlr,ParValue) (pst_u16MBTIF(ctrlr) -> u16L = (ParValue))
N#define u16GetMBTIFL(ctrlr) (pst_u16MBTIF(ctrlr) -> u16L)
N#define vSetMBTIFH(ctrlr,ParValue) (pst_u16MBTIF(ctrlr) -> u16H = (ParValue))
N#define u16GetMBTIFH(ctrlr) (pst_u16MBTIF(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetMBTIF(ctrlr,ParValue)  (*pu32MBTIF(ctrlr) = (ParValue))
N#define u32GetMBTIF(ctrlr)  (*pu32MBTIF(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MBRIF                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400488                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MBRIF_REG__       0xC0400488U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   MBRIF	:32; 	 /* 0..31  bit(s) R/W1C */                    
N} MBRIF_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} MBRIF_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} MBRIF_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32MBRIF_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMBRIF(ctrlr)     ((volatile MBRIF_bit_view_st *)\
N(MBRIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitMBRIF(ctrlr)     ((volatile MBRIF_bit_view_st *)(MBRIF_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MBRIF(ctrlr)     ((volatile MBRIF_byte_view_st *)\
N(MBRIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8MBRIF(ctrlr)     ((volatile MBRIF_byte_view_st *)(MBRIF_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16MBRIF(ctrlr)     ((volatile MBRIF_halfword_view_st *)\
N(MBRIF_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16MBRIF(ctrlr)     ((volatile MBRIF_halfword_view_st *)(MBRIF_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32MBRIF(ctrlr)     ((volatile u32MBRIF_word_view *)\
N(MBRIF_REG__  + ((int32_t)(ctrlr))))
X#define pu32MBRIF(ctrlr)     ((volatile u32MBRIF_word_view *)(MBRIF_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMBRIF_MBRIF(ctrlr) (pst_bitMBRIF(ctrlr) -> MBRIF)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for bit 0..31: */
N#define vClrMBRIF_MBRIF(ctrlr, BitNo) (pst_bitMBRIF(ctrlr) -> MBRIF = (0x00000001 << BitNo))
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..31: */
N#define vClrMultiMBRIF_MBRIF(ctrlr, Mask) (pst_bitMBRIF(ctrlr) -> MBRIF = (Mask))
N/*---------------------------------------------------------------------------*/
N            
N/* LL-struct byte access */
N#define vSetMBRIFLL(ctrlr,ParValue) (pst_u8MBRIF(ctrlr) -> u8LL = (ParValue))
N#define u8GetMBRIFLL(ctrlr) (pst_u8MBRIF(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetMBRIFLH(ctrlr,ParValue) (pst_u8MBRIF(ctrlr) -> u8LH = (ParValue))
N#define u8GetMBRIFLH(ctrlr) (pst_u8MBRIF(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetMBRIFHL(ctrlr,ParValue) (pst_u8MBRIF(ctrlr) -> u8HL = (ParValue))
N#define u8GetMBRIFHL(ctrlr) (pst_u8MBRIF(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetMBRIFHH(ctrlr,ParValue) (pst_u8MBRIF(ctrlr) -> u8HH = (ParValue))
N#define u8GetMBRIFHH(ctrlr) (pst_u8MBRIF(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetMBRIFL(ctrlr,ParValue) (pst_u16MBRIF(ctrlr) -> u16L = (ParValue))
N#define u16GetMBRIFL(ctrlr) (pst_u16MBRIF(ctrlr) -> u16L)
N#define vSetMBRIFH(ctrlr,ParValue) (pst_u16MBRIF(ctrlr) -> u16H = (ParValue))
N#define u16GetMBRIFH(ctrlr) (pst_u16MBRIF(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetMBRIF(ctrlr,ParValue)  (*pu32MBRIF(ctrlr) = (ParValue))
N#define u32GetMBRIF(ctrlr)  (*pu32MBRIF(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MBIM                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400490                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MBIM_REG__       0xC0400490U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   MBIM	:32; 	 /* 0..31  bit(s) R/W */                    
N} MBIM_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} MBIM_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} MBIM_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32MBIM_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMBIM(ctrlr)     ((volatile MBIM_bit_view_st *)\
N(MBIM_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitMBIM(ctrlr)     ((volatile MBIM_bit_view_st *)(MBIM_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MBIM(ctrlr)     ((volatile MBIM_byte_view_st *)\
N(MBIM_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8MBIM(ctrlr)     ((volatile MBIM_byte_view_st *)(MBIM_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16MBIM(ctrlr)     ((volatile MBIM_halfword_view_st *)\
N(MBIM_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16MBIM(ctrlr)     ((volatile MBIM_halfword_view_st *)(MBIM_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32MBIM(ctrlr)     ((volatile u32MBIM_word_view *)\
N(MBIM_REG__  + ((int32_t)(ctrlr))))
X#define pu32MBIM(ctrlr)     ((volatile u32MBIM_word_view *)(MBIM_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMBIM_MBIM(ctrlr) (pst_bitMBIM(ctrlr) -> MBIM)
N#define vSetMBIM_MBIM(ctrlr,ParValue)  (pst_bitMBIM(ctrlr) -> MBIM=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetMBIMLL(ctrlr,ParValue) (pst_u8MBIM(ctrlr) -> u8LL = (ParValue))
N#define u8GetMBIMLL(ctrlr) (pst_u8MBIM(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetMBIMLH(ctrlr,ParValue) (pst_u8MBIM(ctrlr) -> u8LH = (ParValue))
N#define u8GetMBIMLH(ctrlr) (pst_u8MBIM(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetMBIMHL(ctrlr,ParValue) (pst_u8MBIM(ctrlr) -> u8HL = (ParValue))
N#define u8GetMBIMHL(ctrlr) (pst_u8MBIM(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetMBIMHH(ctrlr,ParValue) (pst_u8MBIM(ctrlr) -> u8HH = (ParValue))
N#define u8GetMBIMHH(ctrlr) (pst_u8MBIM(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetMBIML(ctrlr,ParValue) (pst_u16MBIM(ctrlr) -> u16L = (ParValue))
N#define u16GetMBIML(ctrlr) (pst_u16MBIM(ctrlr) -> u16L)
N#define vSetMBIMH(ctrlr,ParValue) (pst_u16MBIM(ctrlr) -> u16H = (ParValue))
N#define u16GetMBIMH(ctrlr) (pst_u16MBIM(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetMBIM(ctrlr,ParValue)  (*pu32MBIM(ctrlr) = (ParValue))
N#define u32GetMBIM(ctrlr)  (*pu32MBIM(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CDR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0400498                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CDR_REG__       0xC0400498U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   CDR	:31; 	 /* 0..30  bit(s) R/W */ 
N  uint32_t   	:1; 	 /* 31..31  bit(s) R */                    
N} CDR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CDR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CDR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CDR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCDR(ctrlr)     ((volatile CDR_bit_view_st *)\
N(CDR_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitCDR(ctrlr)     ((volatile CDR_bit_view_st *)(CDR_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CDR(ctrlr)     ((volatile CDR_byte_view_st *)\
N(CDR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8CDR(ctrlr)     ((volatile CDR_byte_view_st *)(CDR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CDR(ctrlr)     ((volatile CDR_halfword_view_st *)\
N(CDR_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16CDR(ctrlr)     ((volatile CDR_halfword_view_st *)(CDR_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32CDR(ctrlr)     ((volatile u32CDR_word_view *)\
N(CDR_REG__  + ((int32_t)(ctrlr))))
X#define pu32CDR(ctrlr)     ((volatile u32CDR_word_view *)(CDR_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCDR_CDR(ctrlr) (pst_bitCDR(ctrlr) -> CDR)
N#define vSetCDR_CDR(ctrlr,ParValue)  (pst_bitCDR(ctrlr) -> CDR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCDRLL(ctrlr,ParValue) (pst_u8CDR(ctrlr) -> u8LL = (ParValue))
N#define u8GetCDRLL(ctrlr) (pst_u8CDR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetCDRLH(ctrlr,ParValue) (pst_u8CDR(ctrlr) -> u8LH = (ParValue))
N#define u8GetCDRLH(ctrlr) (pst_u8CDR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetCDRHL(ctrlr,ParValue) (pst_u8CDR(ctrlr) -> u8HL = (ParValue))
N#define u8GetCDRHL(ctrlr) (pst_u8CDR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetCDRHH(ctrlr,ParValue) (pst_u8CDR(ctrlr) -> u8HH = (ParValue))
N#define u8GetCDRHH(ctrlr) (pst_u8CDR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCDRL(ctrlr,ParValue) (pst_u16CDR(ctrlr) -> u16L = (ParValue))
N#define u16GetCDRL(ctrlr) (pst_u16CDR(ctrlr) -> u16L)
N#define vSetCDRH(ctrlr,ParValue) (pst_u16CDR(ctrlr) -> u16H = (ParValue))
N#define u16GetCDRH(ctrlr) (pst_u16CDR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetCDR(ctrlr,ParValue)  (*pu32CDR(ctrlr) = (ParValue))
N#define u32GetCDR(ctrlr)  (*pu32CDR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: RFP                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC04004A0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define RFP_REG__       0xC04004A0U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   RFP	:32; 	 /* 0..31  bit(s) R */                    
N} RFP_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} RFP_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} RFP_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32RFP_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitRFP(ctrlr)     ((volatile RFP_bit_view_st *)\
N(RFP_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitRFP(ctrlr)     ((volatile RFP_bit_view_st *)(RFP_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8RFP(ctrlr)     ((volatile RFP_byte_view_st *)\
N(RFP_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8RFP(ctrlr)     ((volatile RFP_byte_view_st *)(RFP_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16RFP(ctrlr)     ((volatile RFP_halfword_view_st *)\
N(RFP_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16RFP(ctrlr)     ((volatile RFP_halfword_view_st *)(RFP_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32RFP(ctrlr)     ((volatile u32RFP_word_view *)\
N(RFP_REG__  + ((int32_t)(ctrlr))))
X#define pu32RFP(ctrlr)     ((volatile u32RFP_word_view *)(RFP_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetRFP_RFP(ctrlr) (pst_bitRFP(ctrlr) -> RFP)
N            
N/* LL-struct byte access */
N
N#define u8GetRFPLL(ctrlr) (pst_u8RFP(ctrlr) -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetRFPLH(ctrlr) (pst_u8RFP(ctrlr) -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetRFPHL(ctrlr) (pst_u8RFP(ctrlr) -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetRFPHH(ctrlr) (pst_u8RFP(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N
N#define u16GetRFPL(ctrlr) (pst_u16RFP(ctrlr) -> u16L)
N
N#define u16GetRFPH(ctrlr) (pst_u16RFP(ctrlr) -> u16H)
N            
N/* Word access */
N
N#define u32GetRFP(ctrlr)  (*pu32RFP(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CEC                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC04004A8                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CEC_REG__       0xC04004A8U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   REC	:8; 	 /* 0..7  bit(s) R */
N  uint16_t   TEC	:8; 	 /* 8..15  bit(s) R */                    
N} CEC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} CEC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16CEC_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCEC(ctrlr)     ((volatile CEC_bit_view_st *)\
N(CEC_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitCEC(ctrlr)     ((volatile CEC_bit_view_st *)(CEC_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CEC(ctrlr)     ((volatile CEC_byte_view_st *)\
N(CEC_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8CEC(ctrlr)     ((volatile CEC_byte_view_st *)(CEC_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD */
N#define pu16CEC(ctrlr)     ((volatile u16CEC_halfword_view *)\
N(CEC_REG__  + ((int32_t)(ctrlr))))
X#define pu16CEC(ctrlr)     ((volatile u16CEC_halfword_view *)(CEC_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetCEC_REC(ctrlr) (pst_bitCEC(ctrlr) -> REC)            
N#define biGetCEC_TEC(ctrlr) (pst_bitCEC(ctrlr) -> TEC)
N            
N/* L-struct byte access */
N
N#define u8GetCECL(ctrlr) (pst_u8CEC(ctrlr) -> u8L)
N/* H-struct byte access */
N
N#define u8GetCECH(ctrlr) (pst_u8CEC(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N
N#define u16GetCEC(ctrlr) (*pu16CEC(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: TSP                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC04004B0                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define TSP_REG__       0xC04004B0U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   TSP	:4; 	 /* 0..3  bit(s) R/W */ 
N  uint8_t   	:4; 	 /* 4..31  bit(s) R */                    
N} TSP_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8TSP_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitTSP(ctrlr)     ((volatile TSP_bit_view_st *)\
N(TSP_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitTSP(ctrlr)     ((volatile TSP_bit_view_st *)(TSP_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE  */
N#define pu8TSP(ctrlr)     ((volatile u8TSP_byte_view *)\
N(TSP_REG__  + ((int32_t)(ctrlr))))
X#define pu8TSP(ctrlr)     ((volatile u8TSP_byte_view *)(TSP_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetTSP_TSP(ctrlr) (pst_bitTSP(ctrlr) -> TSP)
N#define vSetTSP_TSP(ctrlr,ParValue)  (pst_bitTSP(ctrlr) -> TSP=(ParValue))
N            
N/* byte access */
N#define vSetTSP(ctrlr,ParValue) (*pu8TSP(ctrlr) = (ParValue))
N#define u8GetTSP(ctrlr) (*pu8TSP(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: TSC                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC04004B8                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define TSC_REG__       0xC04004B8U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   TSC	:16; 	 /* 0..15  bit(s) R */                    
N} TSC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} TSC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16TSC_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitTSC(ctrlr)     ((volatile TSC_bit_view_st *)\
N(TSC_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitTSC(ctrlr)     ((volatile TSC_bit_view_st *)(TSC_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8TSC(ctrlr)     ((volatile TSC_byte_view_st *)\
N(TSC_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8TSC(ctrlr)     ((volatile TSC_byte_view_st *)(TSC_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD */
N#define pu16TSC(ctrlr)     ((volatile u16TSC_halfword_view *)\
N(TSC_REG__  + ((int32_t)(ctrlr))))
X#define pu16TSC(ctrlr)     ((volatile u16TSC_halfword_view *)(TSC_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetTSC_TSC(ctrlr) (pst_bitTSC(ctrlr) -> TSC)
N            
N/* L-struct byte access */
N
N#define u8GetTSCL(ctrlr) (pst_u8TSC(ctrlr) -> u8L)
N/* H-struct byte access */
N
N#define u8GetTSCH(ctrlr) (pst_u8TSC(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N
N#define u16GetTSC(ctrlr) (*pu16TSC(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: MBnAM                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC04004C0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define MBnAM_REG__       0xC04004C0U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   AM	:29; 	 /* 0..28  bit(s) R/W */
N  uint32_t   	:2; 	 /* 29..30  bit(s) R */ 
N  uint32_t   AMI	:1; 	 /* 31..31  bit(s) R/W */                    
N} MBnAM_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} MBnAM_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} MBnAM_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32MBnAM_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitMBnAM(ctrlr,ch)     ((volatile MBnAM_bit_view_st *)\
N(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
X#define pst_bitMBnAM(ctrlr,ch)     ((volatile MBnAM_bit_view_st *)(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8MBnAM(ctrlr,ch)     ((volatile MBnAM_byte_view_st *)\
N(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
X#define pst_u8MBnAM(ctrlr,ch)     ((volatile MBnAM_byte_view_st *)(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16MBnAM(ctrlr,ch)     ((volatile MBnAM_halfword_view_st *)\
N(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
X#define pst_u16MBnAM(ctrlr,ch)     ((volatile MBnAM_halfword_view_st *)(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
N            
N/* Pointer to WORD  */ 
N#define pu32MBnAM(ctrlr,ch)     ((volatile u32MBnAM_word_view *)\
N(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
X#define pu32MBnAM(ctrlr,ch)     ((volatile u32MBnAM_word_view *)(MBnAM_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x8U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetMBnAM_AM(ctrlr,ch) (pst_bitMBnAM(ctrlr,ch) -> AM)
N#define vSetMBnAM_AM(ctrlr,ch,ParValue)  (pst_bitMBnAM(ctrlr,ch) -> AM=(ParValue))
N#define biGetMBnAM_AMI(ctrlr,ch) (pst_bitMBnAM(ctrlr,ch) -> AMI)
N#define vSetMBnAM_AMI(ctrlr,ch,ParValue)  (pst_bitMBnAM(ctrlr,ch) -> AMI=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetMBnAMLL(ctrlr,ch,ParValue) (pst_u8MBnAM(ctrlr,ch) -> u8LL = (ParValue))
N#define u8GetMBnAMLL(ctrlr,ch) (pst_u8MBnAM(ctrlr,ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetMBnAMLH(ctrlr,ch,ParValue) (pst_u8MBnAM(ctrlr,ch) -> u8LH = (ParValue))
N#define u8GetMBnAMLH(ctrlr,ch) (pst_u8MBnAM(ctrlr,ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetMBnAMHL(ctrlr,ch,ParValue) (pst_u8MBnAM(ctrlr,ch) -> u8HL = (ParValue))
N#define u8GetMBnAMHL(ctrlr,ch) (pst_u8MBnAM(ctrlr,ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetMBnAMHH(ctrlr,ch,ParValue) (pst_u8MBnAM(ctrlr,ch) -> u8HH = (ParValue))
N#define u8GetMBnAMHH(ctrlr,ch) (pst_u8MBnAM(ctrlr,ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetMBnAML(ctrlr,ch,ParValue) (pst_u16MBnAM(ctrlr,ch) -> u16L = (ParValue))
N#define u16GetMBnAML(ctrlr,ch) (pst_u16MBnAM(ctrlr,ch) -> u16L)
N#define vSetMBnAMH(ctrlr,ch,ParValue) (pst_u16MBnAM(ctrlr,ch) -> u16H = (ParValue))
N#define u16GetMBnAMH(ctrlr,ch) (pst_u16MBnAM(ctrlr,ch) -> u16H)
N            
N/* Word access */
N#define vSetMBnAM(ctrlr,ch,ParValue)  (*pu32MBnAM(ctrlr,ch) = (ParValue))
N#define u32GetMBnAM(ctrlr,ch)  (*pu32MBnAM(ctrlr,ch) )
N            
N
N
N
N
N    
N
N#endif /* TCANIO_H */ 
N    
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 23 "..\..\..\..\lldd\src\txcan.c" 2
N#include "txcan.h"
L 1 "..\..\..\..\lldd\inc\txcan.h" 1
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : TCAN low level driver header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : TCAN
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.12 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N****************************************************************************/
N#ifndef _TXCAN_H
N#define _TXCAN_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_TXCAN_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_TXCAN_H_TAG          "$Name: LLDD_1_6 $"
N
N/****************************************************************************
N*                          CONTROLER SELECTION MACROS
N*             (Please use these macros to select module instances)
N*****************************************************************************/
Ntypedef enum tag_TXCAN_CH_e
N{
N  TXCAN_CH0 =0,
N  TXCAN_CH1 =0x1000,  
N  TXCAN_CH2 =0x2000 
N} TXCAN_CH_e;
N
N/**********************************************
N*                   Enums                     *
N**********************************************/
N/* TXCAN Mailbox selection values */
Ntypedef enum tag_TXCAN_MB_e
N{
N  TXCAN_MB0  = 0x00,    /* Mailbox 0  */
N  TXCAN_MB1  = 0x01,    /* Mailbox 1  */
N  TXCAN_MB2  = 0x02,    /* Mailbox 2  */
N  TXCAN_MB3  = 0x03,    /* Mailbox 3  */
N  TXCAN_MB4  = 0x04,    /* Mailbox 4  */
N  TXCAN_MB5  = 0x05,    /* Mailbox 5  */
N  TXCAN_MB6  = 0x06,    /* Mailbox 6  */
N  TXCAN_MB7  = 0x07,    /* Mailbox 7  */
N  TXCAN_MB8  = 0x08,    /* Mailbox 8  */
N  TXCAN_MB9  = 0x09,    /* Mailbox 9  */
N  TXCAN_MB10 = 0x0A,    /* Mailbox 10 */
N  TXCAN_MB11 = 0x0B,    /* Mailbox 11 */
N  TXCAN_MB12 = 0x0C,    /* Mailbox 12 */
N  TXCAN_MB13 = 0x0D,    /* Mailbox 13 */
N  TXCAN_MB14 = 0x0E,    /* Mailbox 14 */
N  TXCAN_MB15 = 0x0F,    /* Mailbox 15 */
N  TXCAN_MB16 = 0x10,    /* Mailbox 16 */
N  TXCAN_MB17 = 0x11,    /* Mailbox 17 */
N  TXCAN_MB18 = 0x12,    /* Mailbox 18 */
N  TXCAN_MB19 = 0x13,    /* Mailbox 19 */
N  TXCAN_MB20 = 0x14,    /* Mailbox 20 */
N  TXCAN_MB21 = 0x15,    /* Mailbox 21 */
N  TXCAN_MB22 = 0x16,    /* Mailbox 22 */
N  TXCAN_MB23 = 0x17,    /* Mailbox 23 */
N  TXCAN_MB24 = 0x18,    /* Mailbox 24 */
N  TXCAN_MB25 = 0x19,    /* Mailbox 25 */
N  TXCAN_MB26 = 0x1A,    /* Mailbox 26 */
N  TXCAN_MB27 = 0x1B,    /* Mailbox 27 */
N  TXCAN_MB28 = 0x1C,    /* Mailbox 28 */
N  TXCAN_MB29 = 0x1D,    /* Mailbox 29 */
N  TXCAN_MB30 = 0x1E,    /* Mailbox 30 */
N  TXCAN_MB31 = 0x1F     /* Mailbox 31 */
N} TXCAN_MB_e;
N
N/**********************************************
N*                   Timing                    *
N**********************************************/
Ntypedef enum tag_TXCAN_Sampling_e
N{
N  TXCAN_SingleSampling = 0,	/* single sampling */
N  TXCAN_TripleSampling		  /* triple sampling */
N} TXCAN_Sampling_e;
N
Ntypedef enum tag_TXCAN_BitLS_e
N{
N  TXCAN_BitLS1TQ = 0,  /* lengthening and shortening of 1 TQ */
N  TXCAN_BitLS2TQ,      /* lengthening and shortening of 2 TQ */
N  TXCAN_BitLS3TQ,      /* lengthening and shortening of 3 TQ */
N  TXCAN_BitLS4TQ       /* lengthening and shortening of 4 TQ */
N} TXCAN_BitLS_e;
N
N/* TXCAN timing structure */
Ntypedef struct tag_TXCAN_timing_st
N{
N    uint8_t            u8BaudRatePrescaler;     /* prescaler */
N    uint8_t            u8BitTiming1;            /* bit timing parameter 1 */
N    uint8_t            u8BitTiming2;            /* bit timing parameter 2 */
N    TXCAN_Sampling_e   eSamplingType;           /* Source Memory Segment */
N    TXCAN_BitLS_e      eBitLS;                  /* lengthening and shortening of bits */
N} TXCAN_timing_st;
N
N/**********************************************
N*                  Channel                    *
N**********************************************/
Ntypedef enum tag_TXCAN_SoftwareReset_e
N{
N  TXCAN_SRDisable = 0,  /* disable software reset */
N  TXCAN_SREnable        /* enable software reset */
N} TXCAN_SoftwareReset_e;
N
Ntypedef enum tag_TXCAN_TimeStampCounter_e
N{
N  TXCAN_TSCDisable = 0,   /* disable software reset */
N  TXCAN_TSCClear          /* enable software reset */
N} TXCAN_TimeStampCounter_e;
N
Ntypedef enum tag_TXCAN_TransmissionOrder_e
N{
N  TXCAN_MailboxNumber = 0,	/* mailbox number */
N  TXCAN_IdentifierPriority	/* identifier priority */
N} TXCAN_TransmissionOrder_e;
N
Ntypedef enum tag_TXCAN_WakeUpOnBus_e
N{
N  TXCAN_WriteToMCR = 0,   /* wakeup by write access to MCR */
N  TXCAN_BusActivity       /* wakeup by bus activity */
N} TXCAN_WakeUpOnBus_e;
N
Ntypedef enum tag_TXCAN_Sleep_e
N{
N  TXCAN_noRequest = 0,   /* no sleep mode request */
N  TXCAN_SleepMode        /* sleep mode request */
N} TXCAN_Sleep_e;
N
Ntypedef enum tag_TXCAN_ChangeConfig_e
N{
N  TXCAN_CCNormalOperation = 0,   /* normal operation requested */
N  TXCAN_WriteAccess              /* write access to config register */
N} TXCAN_ChangeConfig_e;
N
Ntypedef enum tag_TXCAN_TestError_e
N{
N  TXCAN_TENormalOperation = 0,   /* normal operation requested */
N  TXCAN_TestErrorMode            /* test error mode requested */
N} TXCAN_TestError_e;
N
Ntypedef enum tag_TXCAN_TestLoopback_e
N{
N  TXCAN_TLBNormalOperation = 0,   /* normal operation requested */
N  TXCAN_TestLoopbackMode          /* test loopback mode requested */
N} TXCAN_TestLoopback_e;
N
Ntypedef enum tag_TXCAN_InternalLoopback_e
N{
N  TXCAN_ILBNormalOperation = 0,   /* normal operation requested */
N  TXCAN_InternalLoopbackMode      /* internal loopback mode requested */
N} TXCAN_InternalLoopback_e;
N
Ntypedef enum tag_TXCAN_Suspend_e
N{
N  TXCAN_SNormalOperation = 0,   /* normal operation requested */
N  TXCAN_SuspendkMode            /* internal loopback mode requested */
N} TXCAN_Suspend_e;
N
N/* TXCAN configuration structure */
Ntypedef struct tag_TXCAN_CHconfig_st
N{
N    TXCAN_SoftwareReset_e	    eSoftwareReset;     /* enable software reset */
N    TXCAN_TimeStampCounter_e  eTimeStampCounter;  /* time stamp counter */
N    TXCAN_TransmissionOrder_e eTransmissionOrder; /* transmission order */
N    TXCAN_WakeUpOnBus_e       eWakeUp;            /* wake up on bus activity */
N    TXCAN_Sleep_e             eSleepMode;         /* sleep mode request */
N    TXCAN_ChangeConfig_e      eChangeConfig;      /* change config request */
N    TXCAN_TestError_e         eTestError;         /* test error mode */
N    TXCAN_TestLoopback_e      eTestLoopback;      /* test loopback mode */
N    TXCAN_InternalLoopback_e  eInternalLoopback;  /* internal loopback mode */
N    TXCAN_Suspend_e           eSuspendMode;       /* suspend mode request */
N} TXCAN_CHconfig_st;
N
N/**********************************************
N*                 Mailbox                     *
N**********************************************/
Ntypedef enum tag_TXCAN_RemoteFrameTransmissionRequest_e
N{
N	TXCAN_NormalFrame = 0,   /* normal frame */
N	TXCAN_RemoteFrame        /* remote frame */
N} TXCAN_RemoteFrameTransmissionRequest_e;
N
Ntypedef enum tag_TXCAN_RemoteFrameHandling_e
N{
N  TXCAN_SoftwareHandled = 0,    /* software mus handle remote frames */
N  TXCAN_Automatically           /* mailbox will automatically answer to remote frames */
N} TXCAN_RemoteFrameHandling_e;
N
Ntypedef enum tag_TXCAN_GlobalAcceptanceMask_e
N{
N  TXCAN_Identifier = 0,         /* The received message will only be stored, when the received identifier is identical to that in the mailbox */
N  TXCAN_GlobalAcceptanceMask    /* The global acceptance mask will be used for acceptance filtering */
N} TXCAN_GlobalAcceptanceMask_e;
N
Ntypedef enum tag_TXCAN_FrameType_e
N{
N  TXCAN_Standard = 0,    /* standard frames, 11 bit */
N  TXCAN_Extended         /* extended frames, 29 bit */
N} TXCAN_FrameType_e;
N
Ntypedef enum tag_TXCAN_MailboxDiretion_e
N{
N	TXCAN_Output = 0,    /* mailbox is output */
N	TXCAN_Input          /* mailbox is input */
N} TXCAN_MailboxDiretion_e;
N
Ntypedef struct tag_TXCAN_MBconfig_st
N{
N    TXCAN_CH_e                             eChannel;                          /* CAN channel */
N    TXCAN_MB_e                             eMailbox;                          /* CAN mailbox */
N    uint8_t                                u8DataLength;                      /* data length */
N    TXCAN_RemoteFrameTransmissionRequest_e eRemoteFrameTransmissionRequest;   /* remote frame transmission request */
N    uint32_t                               u32ExtendedIdentifier;             /* extended identifier */
N    uint16_t                               u16StandardIdentifier;             /* standard identifier */
N    TXCAN_RemoteFrameHandling_e            eRemoteFrameHandling;              /* handling of remote frames */
N    TXCAN_GlobalAcceptanceMask_e           eGlobalAcceptanceMask;             /* global acceptance mask */
N    TXCAN_FrameType_e                      eFrameType;                        /* frame type */
N    TXCAN_MailboxDiretion_e                eMailboxDirection;                 /* mailbox direction */
N} TXCAN_MBconfig_st;
N
N/**********************************************
N*                 General                     *
N**********************************************/
Ntypedef enum tag_TXCAN_AcceptanceMaskType_e
N{
N	TXCAN_IdentifierBitLAM = 0,     /* The identifier extension bit stored in the mailbox determines
N                                     which messages shall be received */
N	TXCAN_StandardandExtendedLAM    /* Don’t care: standard and extended frames can be received */
N} TXCAN_AcceptanceMaskType_e;
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      vTXCAN_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                       uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                       uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetDatalength
N *
N * Purpose:       sets data length
N *
N * Inputs:        eCh      - CAN channel
N *                eMB      - mailbox
N *                u8Length - data length
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetDatalength(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Length);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_GetDatalength
N *
N * Purpose:       reads data length
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: data length
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t vTXCAN_GetDatalength(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetRemoteFrameTransmissionRequest
N *
N * Purpose:       sets frame transmission request
N *
N * Inputs:        eCh  - CAN channel
N *                eMB  - mailbox
N *                eRTR - frame transmission request type
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetRemoteFrameTransmissionRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_RemoteFrameTransmissionRequest_e eRTR);
N
N/****************************************************************************
N *
N * Function:      eTXCAN_GetRemoteFrameTransmissionRequest
N *
N * Purpose:       reads frame transmission request individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: remote frame transmission request
N *
N * Limitations:   none
N *
N ***************************************************************************/
NTXCAN_RemoteFrameTransmissionRequest_e eTXCAN_GetRemoteFrameTransmissionRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetTimeStampCounterValue
N *
N * Purpose:       sets time stamp counter value
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u16TSV - time stamp counter value
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetTimeStampCounterValue(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint16_t u16TSV);
N
N/****************************************************************************
N *
N * Function:      u16TXCAN_GetTimeStampCounterValue
N *
N * Purpose:       reads time stamp counter value
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: time stamp counter value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16TXCAN_GetTimeStampCounterValue(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetExtID
N *
N * Purpose:       sets ext. ID
N *
N * Inputs:        eCh   - CAN channel
N *                eMB   - mailbox
N *                u16ID - ext. ID
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetExtID(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint16_t u16ID);
N
N/****************************************************************************
N *
N * Function:      u16TXCAN_GetExtID
N *
N * Purpose:       reads ext. ID
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: ext. ID
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetExtID(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetStdID
N *
N * Purpose:       sets std. ID
N *
N * Inputs:        eCh   - CAN channel
N *                eMB   - mailbox
N *                u16ID - std. ID
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetStdID(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint16_t u16ID);
N
N/****************************************************************************
N *
N * Function:      u16TXCAN_GetStdID
N *
N * Purpose:       reads std. ID
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: std. ID
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16TXCAN_GetStdID(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetRemoteFrameHandling
N *
N * Purpose:       sets remote frame handling
N *
N * Inputs:        eCh  - CAN channel
N *                eMB  - mailbox
N *                eRFH - remote frame handling type
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetRemoteFrameHandling(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_RemoteFrameHandling_e eRFH);
N
N/****************************************************************************
N *
N * Function:      eTXCAN_GetRemoteFrameHandling
N *
N * Purpose:       reads remote frame handling
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: remote frame handling
N *
N * Limitations:   none
N *
N ***************************************************************************/
NTXCAN_RemoteFrameHandling_e eTXCAN_GetRemoteFrameHandling(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetGlobalAcceptanceMask
N *
N * Purpose:       sets global acceptance mask
N *
N * Inputs:        eCh   - CAN channel
N *                eMB   - mailbox
N *                eGAME - global acceptance mask
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetGlobalAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_GlobalAcceptanceMask_e eGAME);
N
N/****************************************************************************
N *
N * Function:      eTXCAN_GetGlobalAcceptanceMask
N *
N * Purpose:       reads global acceptance mask
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: global acceptance mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
NTXCAN_GlobalAcceptanceMask_e eTXCAN_GetGlobalAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetFrameType
N *
N * Purpose:       set frame type
N *
N * Inputs:        eCh  - CAN channel
N *                eMB  - mailbox
N *                eIDE - frame type
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetFrameType(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_FrameType_e eIDE);
N
N/****************************************************************************
N *
N * Function:      eTXCAN_GetFrameType
N *
N * Purpose:       reads frame type
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: frame type
N *
N * Limitations:   none
N *
N ***************************************************************************/
NTXCAN_FrameType_e eTXCAN_GetFrameType(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD0
N *
N * Purpose:       write data into D0 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD0(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD0
N *
N * Purpose:       read data from D0 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D0 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD0(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD1
N *
N * Purpose:       write data into D1 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD1(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD1
N *
N * Purpose:       read data from D1 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D1 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD1(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD2
N *
N * Purpose:       write data into D2 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD2(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD2
N *
N * Purpose:       read data from D2 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D2 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD2(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD3
N *
N * Purpose:       write data into D3 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD3(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD3
N *
N * Purpose:       read data from D3 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D3 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD3(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD4
N *
N * Purpose:       write data into D4 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD4(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD4
N *
N * Purpose:       read data from D4 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D4 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD4(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD5
N *
N * Purpose:       write data into D5 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD5(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD5
N *
N * Purpose:       read data from D5 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D5 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD5(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD6
N *
N * Purpose:       write data into D6 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD6(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD6
N *
N * Purpose:       read data from D6 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D6 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD6(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxD7
N *
N * Purpose:       write data into D7 of mailbox
N *
N * Inputs:        eCh    - CAN channel
N *                eMB    - mailbox
N *                u8Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxD7(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_ReadMailboxD7
N *
N * Purpose:       read data from D7 of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox D7 value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_ReadMailboxD7(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxLow
N *
N * Purpose:       write low part of mailbox
N *
N * Inputs:        eCh     - CAN channel
N *                eMB     - mailbox
N *                u32Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxLow(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint32_t u32Data);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_ReadMailboxLow
N *
N * Purpose:       read low part of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox low value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_ReadMailboxLow(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailboxHigh
N *
N * Purpose:       write high part of mailbox
N *
N * Inputs:        eCh     - CAN channel
N *                eMB     - mailbox
N *                u32Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailboxHigh(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint32_t u32Data);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_ReadMailboxHigh
N *
N * Purpose:       read high part of mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox high value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_ReadMailboxHigh(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_WriteMailbox
N *
N * Purpose:       write data to mailbox
N *
N * Inputs:        eCh     - CAN channel
N *                eMB     - mailbox
N *                u64Data - mailbox data
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_WriteMailbox(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint64_t u64Data);
N
N/****************************************************************************
N *
N * Function:      u64TXCAN_ReadMailbox
N *
N * Purpose:       read data from mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint64_t u64TXCAN_ReadMailbox(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_MailboxEnableAll
N *
N * Purpose:       enable all mailboxes
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_MailboxEnableAll(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_MailboxDisableAll
N *
N * Purpose:       disable all mailboxes
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_MailboxDisableAll(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_MailboxEnable
N *
N * Purpose:       enable mailbox individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_MailboxEnable(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_MailboxDisable
N *
N * Purpose:       disable mailbox individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_MailboxDisable(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetMailboxDirectionAll
N *
N * Purpose:       set mailbox direction
N *
N * Inputs:        eCh              - CAN channel
N *                u32DirectionCode - direction code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetMailboxDirectionAll(TXCAN_CH_e eCh, uint32_t u32DirectionCode);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetMailboxDirectionAll
N *
N * Purpose:       get mailbox direction
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: mailbox direction
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetMailboxDirectionAll(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetMailboxDirection
N *
N * Purpose:       set mailbox direction individual
N *
N * Inputs:        eCh        - CAN channel
N *                eMB        - mailbox
N *                eDirection - mailbox direction
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetMailboxDirection(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_MailboxDiretion_e eDirection);
N
N/****************************************************************************
N *
N * Function:      eGetMailboxDirection
N *
N * Purpose:       returns direction of mailbox
N *
N * Inputs:        eCh        - CAN channel
N *                eMB        - mailbox
N *
N * Outputs:       none
N *
N * Return Values: mailbox direction
N *
N * Limitations:   none
N *
N ***************************************************************************/
NTXCAN_MailboxDiretion_e eGetMailboxDirection(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ConfigureMailbox
N *
N * Purpose:       configures mailbox
N *
N * Inputs:        stMBConfig - mailbox configuration
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ConfigureMailbox(TXCAN_MBconfig_st * stMBConfig);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_TransmitAll
N *
N * Purpose:       transmit mailbox
N *
N * Inputs:        eCh             - CAN channel
N *                u32TransmitCode - transmit code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_TransmitAll(TXCAN_CH_e eCh, uint32_t u32TransmitCode);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_Transmit
N *
N * Purpose:       transmit mailbox individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       data to CAN network
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_Transmit(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SendMsg
N *
N * Purpose:       send message
N *
N * Inputs:        eCh     - CAN channel
N *                eMB     - mailbox
N *                u64Data - data to be send
N *
N * Outputs:       data to CAN network
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SendMsg(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint64_t u64Data);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_CancelTransmissionAll
N *
N * Purpose:       cancel transmission
N *
N * Inputs:        eCh           - CAN channel
N *                u32CancelCode - cancel code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_CancelTransmissionAll(TXCAN_CH_e eCh, uint32_t u32CancelCode);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_CancelTransmission
N *
N * Purpose:       cancel transmission individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_CancelTransmission(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmissionAcknowledgeAll
N *
N * Purpose:       clear transmission acknowledge
N *
N * Inputs:        eCh                 - CAN channel
N *                u32TransmissionCode - transmission code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmissionAcknowledgeAll(TXCAN_CH_e eCh, uint32_t u32TransmissionCode);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmissionAcknowledge
N *
N * Purpose:       clear transmission acknowledge individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmissionAcknowledge(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmissionAbortAcknowledgeAll
N *
N * Purpose:       clear transmission abort acknowledge
N *
N * Inputs:        eCh - CAN channel
N *                u32TransmissionCode - transmission code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmissionAbortAcknowledgeAll(TXCAN_CH_e eCh, uint32_t u32TransmissionCode);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmissionAbortAcknowledge
N *
N * Purpose:       clear transmission abort acknowledge individual
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmissionAbortAcknowledge(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetPendingReceiveMessages
N *
N * Purpose:       get pending receive messages
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: pending receive massages
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetPendingReceiveMessages(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetChangeDataRequestAll
N *
N * Purpose:       set change data request for all mailboxes
N *
N * Inputs:        eCh      - CAN channel
N *                u32Value - value to be set
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetChangeDataRequestAll(TXCAN_CH_e eCh, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetChangeDataRequest
N *
N * Purpose:       set change data request for selected mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetChangeDataRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetChangeDataRequestAll
N *
N * Purpose:       get change data request of all mailboxes
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: change data request value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetChangeDataRequestAll(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetChangeDataRequest
N *
N * Purpose:       get change data request of selected mailbox
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: change data request value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetChangeDataRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetPendingReceiveMessage
N *
N * Purpose:       get pending receive message
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: pending receive massage
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetPendingReceiveMessage(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearPendingReceiveMessages
N *
N * Purpose:       clear pending receive messages
N *
N * Inputs:        eCh      - CAN channel
N *                u32Value - clear code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearPendingReceiveMessages(TXCAN_CH_e eCh, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearPendingReceiveMessage
N *
N * Purpose:       clear pending receive message
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearPendingReceiveMessage(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetReceiveMessageLosts
N *
N * Purpose:       get receive message slots
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: lost receive messages
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetReceiveMessageLosts(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetReceiveMessageLost
N *
N * Purpose:       get receive message slot
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: lost receive message
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetReceiveMessageLost(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearReceiveMessageLosts
N *
N * Purpose:       clear receive message slots
N *
N * Inputs:        eCh      - CAN channel
N *                u32Value - clear code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearReceiveMessageLosts(TXCAN_CH_e eCh, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearReceiveMessageLost
N *
N * Purpose:       clear receive message slot
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearReceiveMessageLost(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetPendingRemoteFrames
N *
N * Purpose:       get pending remote frames
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: pending remote frames
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetPendingRemoteFrames(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetPendingRemoteFrame
N *
N * Purpose:       get pending remote frame
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: pending remote frame
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetPendingRemoteFrame(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vSetAcceptanceMaskType
N *
N * Purpose:       sets type of acceptance mask
N *
N * Inputs:        eCh   - CAN channel
N *                eMB   - Mailbox
N *                eType - mask type
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vSetAcceptanceMaskType(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_AcceptanceMaskType_e eType);
N
N/****************************************************************************
N *
N * Function:      eGetAcceptanceMaskType
N *
N * Purpose:       reads type of acceptance mask
N *
N * Inputs:        eCh - CAN channel
N *                eMB - Mailbox
N *
N * Outputs:       none
N *
N * Return Values: acceptance mask type
N *
N * Limitations:   none
N *
N ***************************************************************************/
NTXCAN_AcceptanceMaskType_e eGetAcceptanceMaskType(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N
N
N
N
N
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetAcceptanceMask
N *
N * Purpose:       sets type of acceptance mask all
N *
N * Inputs:        eCh      - CAN channel
N *                eMB      - mailbox
N *                u32Value - mask value
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetAcceptanceMask
N *
N * Purpose:       gets type of acceptance mask all
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: acceptance mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N
N
N
N
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ConfigureChannel
N *
N * Purpose:       configure channel
N *
N * Inputs:        eCh      - CAN channel
N *                stConfig - channel configuration
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ConfigureChannel(TXCAN_CH_e eCh, TXCAN_CHconfig_st * stConfig);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_GetChannelConfiguration
N *
N * Purpose:       read channel configuration
N *
N * Inputs:        eCh      - CAN channel
N *                stConfig - channel configuration
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_GetChannelConfiguration(TXCAN_CH_e eCh, TXCAN_CHconfig_st * stConfig);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ConfigureTiming
N *
N * Purpose:       configure timing
N *
N * Inputs:        eCh      - CAN channel
N *                stTiming - channel timing
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ConfigureTiming(TXCAN_CH_e eCh, TXCAN_timing_st * stTiming);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_GetTimingConfiguration
N *
N * Purpose:       read timing configuration
N *
N * Inputs:        eCh      - CAN channel
N *                stTiming - channel timing
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_GetTimingConfiguration(TXCAN_CH_e eCh, TXCAN_timing_st * stTiming);
N
N/****************************************************************************
N *
N * Function:      u16TXCAN_GetTimeStampCounter
N *
N * Purpose:       read time stamp counter register
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: time stamp value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16TXCAN_GetTimeStampCounter(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTimeStampValue
N *
N * Purpose:       clear time stamp value
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTimeStampValue(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetTimeStampCounterPrescaler
N *
N * Purpose:       set time stamp counter prescaler value
N *
N * Inputs:        eCh     - CAN channel
N *                u8Value - prescaler value
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetTimeStampCounterPrescaler(TXCAN_CH_e eCh, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTimeStampCounterPrescaler
N *
N * Purpose:       read time stamp counter prescaler value
N *
N * Inputs:        eCh     - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: time stamp counter prescaler value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTimeStampCounterPrescaler(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetGlobalStatus
N *
N * Purpose:       read global status
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: global status
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetGlobalStatus(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetWarningStatus
N *
N * Purpose:       read warning status
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: warning status
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetWarningStatus(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetErrorPassiveStatus
N *
N * Purpose:       read error passive status
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: error passive status
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetErrorPassiveStatus(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetBusOffStatus
N *
N * Purpose:       read buss off status
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: bus off status
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetBusOffStatus(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTimeStampOverflowFlag
N *
N * Purpose:       read time stamp overflov flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: time stamp overflow flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTimeStampOverflowFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetSleepModeAcknowledge
N *
N * Purpose:       read sleep mode acknowledge
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: sleep mode acknowledge
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetSleepModeAcknowledge(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetChangeConfigurationEnable
N *
N * Purpose:       read change config enable
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: change config enable
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetChangeConfigurationEnable(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetSuspendModeAcknowledge
N *
N * Purpose:       read suspend mode acknowledge
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: suspend mode acknowledge
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetSuspendModeAcknowledge(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTransmitMode
N *
N * Purpose:       read transmit mode
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: transmit mode
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTransmitMode(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetReceiveMode
N *
N * Purpose:       read receive mode
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: receive mode
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetReceiveMode(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetMessageInSlot
N *
N * Purpose:       read message in slot
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: message in slot
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetMessageInSlot(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetReceiveErrorCounter
N *
N * Purpose:       read receive error counter
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: receive error counter value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetReceiveErrorCounter(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTransmitErrorCounter
N *
N * Purpose:       read transmit error counter
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: transmit error counter value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTransmitErrorCounter(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetGlobalInterruptFlags
N *
N * Purpose:       read global interrupt flags
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: global interrupt flags
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetGlobalInterruptFlags(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearGlobalInterruptFlags
N *
N * Purpose:       clear global interrupt flags
N *
N * Inputs:        eCh     - CAN channel
N *                u8Flags - global interrupt flags
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearGlobalInterruptFlags(TXCAN_CH_e eCh, uint8_t u8Flags);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetWarningLevelInterruptFlag
N *
N * Purpose:       read warning level interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: warning level interrupt flag value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetWarningLevelInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearWarningLevelInterruptFlag
N *
N * Purpose:       clear warning level interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearWarningLevelInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetErrorPassiveInterruptFlag
N *
N * Purpose:       read error passive interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: error passive interrupt flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetErrorPassiveInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearErrorPassiveInterruptFlag
N *
N * Purpose:       clear error passive interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearErrorPassiveInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetBusOffInterruptFlag
N *
N * Purpose:       read bus off interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: bus off interrupt flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetBusOffInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearBusOffInterruptFlag
N *
N * Purpose:       clear bus off interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearBusOffInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTimeStampCounterOverflowInterruptFlag
N *
N * Purpose:       read time stamp counter overflow flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: time stamp counter overflow flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTimeStampCounterOverflowInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTimeStampCounterOverflowInterruptFlag
N *
N * Purpose:       clear time stamp counter overflow flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTimeStampCounterOverflowInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTransmitAbortFlag
N *
N * Purpose:       read transmit abort flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: transmit abort flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTransmitAbortFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmitAbortFlag
N *
N * Purpose:       clear transmit abort flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmitAbortFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetReceiveMessageLostInterruptFlag
N *
N * Purpose:       read receive message lost flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: receive message lost flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetReceiveMessageLostInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearReceiveMessageLostInterruptFlag
N *
N * Purpose:       clear receive message lost flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearReceiveMessageLostInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetWakeUpInterruptFlag
N *
N * Purpose:       read wake-up interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: wake-up interrupt flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetWakeUpInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearWakeUpInterruptFlag
N *
N * Purpose:       clear wake-up interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearWakeUpInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetRemoteFramePendingFlag
N *
N * Purpose:       read remote frame pending flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: remote frame pending flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetRemoteFramePendingFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearRemoteFramePendingFlag
N *
N * Purpose:       clear remote frame pending flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearRemoteFramePendingFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetGlobalInterruptMasks
N *
N * Purpose:       read global interrupt masks
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: global interrupt masks
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetGlobalInterruptMasks(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetGlobalInterruptMasks
N *
N * Purpose:       set global interrupt masks
N *
N * Inputs:        eCh     - CAN channel
N *                u8Masks - global interrupt masks
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetGlobalInterruptMasks(TXCAN_CH_e eCh, uint8_t u8Masks);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetWarningLevelInterruptMask
N *
N * Purpose:       read warning level interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: warning level interrupt mask value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetWarningLevelInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetWarningLevelInterruptMask
N *
N * Purpose:       set warning level interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetWarningLevelInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetErrorPassiveInterruptMask
N *
N * Purpose:       read error passive interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: error passive interrupt mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetErrorPassiveInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetErrorPassiveInterruptMask
N *
N * Purpose:       set error passive interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetErrorPassiveInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetBusOffInterruptFlag
N *
N * Purpose:       read bus off interrupt flag
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: bus off interrupt flag
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetBusOffInterruptFlag(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetBusOffInterruptMask
N *
N * Purpose:       set bus off interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetBusOffInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTimeStampCounterOverflowInterruptMask
N *
N * Purpose:       read time stamp counter overflow mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: time stamp counter overflow mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTimeStampCounterOverflowInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetTimeStampCounterOverflowInterruptMask
N *
N * Purpose:       set time stamp counter overflow mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetTimeStampCounterOverflowInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTransmitAbortMask
N *
N * Purpose:       read transmit abort mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: transmit abort mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTransmitAbortMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetTransmitAbortMask
N *
N * Purpose:       set transmit abort mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetTransmitAbortMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetReceiveMessageLostInterruptMask
N *
N * Purpose:       read receive message lost mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: receive message lost mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetReceiveMessageLostInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetReceiveMessageLostInterruptMask
N *
N * Purpose:       set receive message lost mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetReceiveMessageLostInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetWakeUpInterruptMask
N *
N * Purpose:       read wake-up interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: wake-up interrupt mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetWakeUpInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetWakeUpInterruptMask
N *
N * Purpose:       set wake-up interrupt mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetWakeUpInterruptMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetRemoteFramePendingMask
N *
N * Purpose:       read remote frame pending mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: remote frame pending mask
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetRemoteFramePendingMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_SetRemoteFramePendingMask
N *
N * Purpose:       set remote frame pending mask
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_SetRemoteFramePendingMask(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_EnableInterrupt
N *
N * Purpose:       enable interrupt
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_EnableInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_DisableInterrupt
N *
N * Purpose:       disable interrupt
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_DisableInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_EnableInterrupts
N *
N * Purpose:       enable interrupts
N *
N * Inputs:        eCh      - CAN channel
N *                u32Value - interrupt code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_EnableInterrupts(TXCAN_CH_e eCh, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmitInterrupts
N *
N * Purpose:       clear transmit interrupts
N *
N * Inputs:        eCh      - CAN channel
N *                u32Value - interrupt code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmitInterrupts(TXCAN_CH_e eCh, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearTransmitInterrupt
N *
N * Purpose:       clear transmit interrupt
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearTransmitInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetTransmitInterrupts
N *
N * Purpose:       get transmit interrupts
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: transmit interrupts
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetTransmitInterrupts(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetTransmitInterrupt
N *
N * Purpose:       get transmit interrupt
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: transmit interrupt
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetTransmitInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearReceiveInterrupts
N *
N * Purpose:       clear receive interrupts
N *
N * Inputs:        eCh      - CAN channel
N *                u32Value - interrupt code
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearReceiveInterrupts(TXCAN_CH_e eCh, uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vTXCAN_ClearReceiveInterrupt
N *
N * Purpose:       clear receive interrupt
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTXCAN_ClearReceiveInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************
N *
N * Function:      u32TXCAN_GetReceiveInterrupts
N *
N * Purpose:       get receive interrupts
N *
N * Inputs:        eCh - CAN channel
N *
N * Outputs:       none
N *
N * Return Values: receive inteerrupts
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32TXCAN_GetReceiveInterrupts(TXCAN_CH_e eCh);
N
N/****************************************************************************
N *
N * Function:      u8TXCAN_GetReceiveInterrupt
N *
N * Purpose:       get receive interrupt
N *
N * Inputs:        eCh - CAN channel
N *                eMB - mailbox
N *
N * Outputs:       none
N *
N * Return Values: receive interrupt
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8TXCAN_GetReceiveInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB);
N
N/****************************************************************************/
N
N
N#endif	/* _TXCAN_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices,” or
N  “TOSHIBA Semiconductor Reliability Handbook” etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage”).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCALIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\txcan.c" 2
N
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N#define LLDD_TXCAN_C_REVISION     "$Revision: 1.10 $"
N#define LLDD_TXCAN_C_TAG          "$Name: LLDD_1_6 $"
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
Nstatic uint8_t au8LLDD_TXCAN_C_REVISION[]    = LLDD_TXCAN_C_REVISION;
Xstatic uint8_t au8LLDD_TXCAN_C_REVISION[]    = "$Revision: 1.10 $";
Nstatic uint8_t au8LLDD_TXCAN_C_TAG[]         = LLDD_TXCAN_C_TAG;
Xstatic uint8_t au8LLDD_TXCAN_C_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_TXCAN_H_REVISION[]    = LLDD_TXCAN_H_REVISION;
Xstatic uint8_t au8LLDD_TXCAN_H_REVISION[]    = "$Revision: 1.12 $";
Nstatic uint8_t au8LLDD_TXCAN_H_TAG[]         = LLDD_TXCAN_H_TAG;
Xstatic uint8_t au8LLDD_TXCAN_H_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_TXCAN_IO_H_REVISION[] = LLDD_TXCAN_IO_H_REVISION;
Xstatic uint8_t au8LLDD_TXCAN_IO_H_REVISION[] = "$Revision: 1.17 $";
Nstatic uint8_t au8LLDD_TXCAN_IO_H_TAG[]      = LLDD_TXCAN_IO_H_TAG;
Xstatic uint8_t au8LLDD_TXCAN_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N/**********************************************
N*                Variables                    *
N**********************************************/
Nuint32_t u32MBOne[32] = {
N  0x00000001,   /* mailbox 0  */
N  0x00000002,   /* mailbox 1  */
N  0x00000004,   /* mailbox 2  */
N  0x00000008,   /* mailbox 3  */
N  0x00000010,   /* mailbox 4  */
N  0x00000020,   /* mailbox 5  */
N  0x00000040,   /* mailbox 6  */
N  0x00000080,   /* mailbox 7  */
N  0x00000100,   /* mailbox 8  */
N  0x00000200,   /* mailbox 9  */
N  0x00000400,   /* mailbox 10 */
N  0x00000800,   /* mailbox 11 */
N  0x00001000,   /* mailbox 12 */
N  0x00002000,   /* mailbox 13 */
N  0x00004000,   /* mailbox 14 */
N  0x00008000,   /* mailbox 15 */
N  0x00010000,   /* mailbox 16 */
N  0x00020000,   /* mailbox 17 */
N  0x00040000,   /* mailbox 18 */
N  0x00080000,   /* mailbox 19 */
N  0x00100000,   /* mailbox 20 */
N  0x00200000,   /* mailbox 21 */
N  0x00400000,   /* mailbox 22 */
N  0x00800000,   /* mailbox 23 */
N  0x01000000,   /* mailbox 24 */
N  0x02000000,   /* mailbox 25 */
N  0x04000000,   /* mailbox 26 */
N  0x08000000,   /* mailbox 27 */
N  0x10000000,   /* mailbox 28 */
N  0x20000000,   /* mailbox 29 */
N  0x40000000,   /* mailbox 30 */
N  0x80000000    /* mailbox 31 */
N};
N
N/**********************************************
N*                 Functions                   *
N**********************************************/
N
Nvoid vTXCAN_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                       uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                       uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N   *pau8ModuleRevision = &au8LLDD_TXCAN_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_TXCAN_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_TXCAN_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_TXCAN_H_TAG[0];
N   *pau8IORevision     = &au8LLDD_TXCAN_IO_H_REVISION[0];
N   *pau8IOTag          = &au8LLDD_TXCAN_IO_H_TAG[0];
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetDatalength(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Length)
N{
N    vSetFTS_MBn_DLC(eCh, eMB, (u8Length & 0x0F));
X    (((volatile FTS_MBn_bit_view_st *)(0xC0400008U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> DLC=((u8Length & 0x0F)));
N}
N
N/****************************************************************************/
N
Nuint8_t vTXCAN_GetDatalength(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetFTS_MBn_DLC(eCh, eMB);
X    return (((volatile FTS_MBn_bit_view_st *)(0xC0400008U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> DLC);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetRemoteFrameTransmissionRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_RemoteFrameTransmissionRequest_e eRTR)
N{
N    vSetFTS_MBn_RTR(eCh, eMB, (eRTR & 0x01));
X    (((volatile FTS_MBn_bit_view_st *)(0xC0400008U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> RTR=((eRTR & 0x01)));
N}
N
N/****************************************************************************/
N
NTXCAN_RemoteFrameTransmissionRequest_e eTXCAN_GetRemoteFrameTransmissionRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return (TXCAN_RemoteFrameTransmissionRequest_e)biGetFTS_MBn_RTR(eCh, eMB);
X    return (TXCAN_RemoteFrameTransmissionRequest_e)(((volatile FTS_MBn_bit_view_st *)(0xC0400008U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> RTR);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetTimeStampCounterValue(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint16_t u16TSV)
N{
N    vSetFTS_MBn_TSV(eCh, eMB, (u16TSV & 0x0FFFF));
X    (((volatile FTS_MBn_bit_view_st *)(0xC0400008U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> TSV=((u16TSV & 0x0FFFF)));
N}
N
N/****************************************************************************/
N
Nuint16_t u16TXCAN_GetTimeStampCounterValue(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetFTS_MBn_TSV(eCh, eMB);
X    return (((volatile FTS_MBn_bit_view_st *)(0xC0400008U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> TSV);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetExtID(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint16_t u16ID)
N{
N    vSetID_MBn_EXT_ID(eCh, eMB, (u16ID & 0x01FFFF));
X    (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> EXT_ID=((u16ID & 0x01FFFF)));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetExtID(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetID_MBn_EXT_ID(eCh, eMB);
X    return (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> EXT_ID);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetStdID(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint16_t u16ID)
N{
N    vSetID_MBn_STD_ID(eCh, eMB, (u16ID & 0x07FF));
X    (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> STD_ID=((u16ID & 0x07FF)));
N}
N
N/****************************************************************************/
N
Nuint16_t u16TXCAN_GetStdID(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetID_MBn_STD_ID(eCh, eMB);
X    return (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> STD_ID);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetRemoteFrameHandling(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_RemoteFrameHandling_e eRFH)
N{
N    vSetID_MBn_RFH(eCh, eMB, (eRFH & 0x01));
X    (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> RFH=((eRFH & 0x01)));
N}
N
N/****************************************************************************/
N
NTXCAN_RemoteFrameHandling_e eTXCAN_GetRemoteFrameHandling(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return (TXCAN_RemoteFrameHandling_e)biGetID_MBn_RFH(eCh, eMB);
X    return (TXCAN_RemoteFrameHandling_e)(((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> RFH);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetGlobalAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_GlobalAcceptanceMask_e eGAME)
N{
N    vSetID_MBn_GAME(eCh, eMB, (eGAME & 0x01));
X    (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> GAME=((eGAME & 0x01)));
N}
N
N/****************************************************************************/
N
NTXCAN_GlobalAcceptanceMask_e eTXCAN_GetGlobalAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return (TXCAN_GlobalAcceptanceMask_e)biGetID_MBn_GAME(eCh, eMB);
X    return (TXCAN_GlobalAcceptanceMask_e)(((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> GAME);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetFrameType(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_FrameType_e eIDE)
N{
N    vSetID_MBn_IDE(eCh, eMB, (eIDE & 0x01));
X    (((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> IDE=((eIDE & 0x01)));
N}
N
N/****************************************************************************/
N
NTXCAN_FrameType_e eTXCAN_GetFrameType(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return (TXCAN_FrameType_e)biGetID_MBn_IDE(eCh, eMB);
X    return (TXCAN_FrameType_e)(((volatile ID_MBn_bit_view_st *)(0xC0400000U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> IDE);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD0(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATL_MBn_D0(eCh, eMB, u8Data);
X    (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D0=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD0(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATL_MBn_D0(eCh, eMB);
X    return (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D0);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD1(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATL_MBn_D1(eCh, eMB, u8Data);
X    (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D1=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD1(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATL_MBn_D1(eCh, eMB);
X    return (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D1);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD2(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATL_MBn_D2(eCh, eMB, u8Data);
X    (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D2=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD2(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATL_MBn_D2(eCh, eMB);
X    return (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D2);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD3(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATL_MBn_D3(eCh, eMB, u8Data);
X    (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D3=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD3(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATL_MBn_D3(eCh, eMB);
X    return (((volatile DATL_MBn_bit_view_st *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D3);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD4(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATH_MBn_D4(eCh, eMB, u8Data);
X    (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D4=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD4(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATH_MBn_D4(eCh, eMB);
X    return (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D4);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD5(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATH_MBn_D5(eCh, eMB, u8Data);
X    (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D5=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD5(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATH_MBn_D5(eCh, eMB);
X    return (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D5);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD6(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATH_MBn_D6(eCh, eMB, u8Data);
X    (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D6=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD6(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATH_MBn_D6(eCh, eMB);
X    return (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D6);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxD7(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint8_t u8Data)
N{
N    vSetDATH_MBn_D7(eCh, eMB, u8Data);
X    (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D7=(u8Data));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_ReadMailboxD7(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetDATH_MBn_D7(eCh, eMB);
X    return (((volatile DATH_MBn_bit_view_st *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) -> D7);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxLow(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint32_t u32Data)
N{
N    vSetDATL_MBn(eCh, eMB, u32Data);
X    (*((volatile u32DATL_MBn_word_view *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) = (u32Data));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_ReadMailboxLow(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return u32GetDATL_MBn(eCh, eMB);
X    return (*((volatile u32DATL_MBn_word_view *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) );
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailboxHigh(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint32_t u32Data)
N{
N    vSetDATH_MBn(eCh, eMB, u32Data);
X    (*((volatile u32DATH_MBn_word_view *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) = (u32Data));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_ReadMailboxHigh(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return u32GetDATH_MBn(eCh, eMB);
X    return (*((volatile u32DATH_MBn_word_view *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) );
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_WriteMailbox(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint64_t u64Data)
N{
N    vSetDATL_MBn(eCh, eMB, (u64Data & 0xFFFFFFFF));
X    (*((volatile u32DATL_MBn_word_view *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) = ((u64Data & 0xFFFFFFFF)));
N    vSetDATH_MBn(eCh, eMB, ((u64Data >> 32) & 0xFFFFFFFF));
X    (*((volatile u32DATH_MBn_word_view *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) = (((u64Data >> 32) & 0xFFFFFFFF)));
N}
N
N/****************************************************************************/
N
Nuint64_t u64TXCAN_ReadMailbox(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint64_t u64Value;
N    
N    u64Value = u32GetDATH_MBn(eCh, eMB);
X    u64Value = (*((volatile u32DATH_MBn_word_view *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) );
N    u64Value = u64Value << 32;
N    u64Value = u64Value + u32GetDATL_MBn(eCh, eMB);
X    u64Value = u64Value + (*((volatile u32DATL_MBn_word_view *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) );
N
N    return u64Value;
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_MailboxEnableAll(TXCAN_CH_e eCh)
N{
N    vSetMC(eCh, 0xFFFF);
X    (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) = (0xFFFF));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_MailboxDisableAll(TXCAN_CH_e eCh)
N{
N    vSetMC(eCh, 0x0);
X    (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) = (0x0));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_MailboxEnable(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMC(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetMC(eCh, u32Value);
X    (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_MailboxDisable(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMC(eCh) & ~u32MBOne[eMB];
X    u32Value = (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) ) & ~u32MBOne[eMB];
N    vSetMC(eCh, u32Value);
X    (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetMailboxDirectionAll(TXCAN_CH_e eCh, uint32_t u32DirectionCode)
N{
N    vSetMD(eCh, u32DirectionCode);
X    (*((volatile u32MD_word_view *)(0xC0400408U + ((int32_t)(eCh)))) = (u32DirectionCode));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetMailboxDirectionAll(TXCAN_CH_e eCh)
N{
N    return u32GetMD(eCh);
X    return (*((volatile u32MD_word_view *)(0xC0400408U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetMailboxDirection(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_MailboxDiretion_e eDirection)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMD(eCh) & ~u32MBOne[eMB];
X    u32Value = (*((volatile u32MD_word_view *)(0xC0400408U + ((int32_t)(eCh)))) ) & ~u32MBOne[eMB];
N    if (eDirection == 1)
N    {
N        u32Value = u32Value | u32MBOne[eMB];
N    }
N
N    vSetMD(eCh, u32Value);
X    (*((volatile u32MD_word_view *)(0xC0400408U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
NTXCAN_MailboxDiretion_e eGetMailboxDirection(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value = 0;
N    TXCAN_MailboxDiretion_e eDirection = TXCAN_Output;
N
N    u32Value = u32GetMD(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32MD_word_view *)(0xC0400408U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value > 0)
N    {
N        eDirection = TXCAN_Input;
N    }
N
N    return eDirection;
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ConfigureMailbox(TXCAN_MBconfig_st * stMBConfig)
N{
N    vTXCAN_SetDatalength(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->u8DataLength);
N    vTXCAN_SetRemoteFrameTransmissionRequest(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->eRemoteFrameTransmissionRequest);
N    vTXCAN_SetTimeStampCounterValue(stMBConfig->eChannel, stMBConfig->eMailbox, 0x0);
N    vTXCAN_SetExtID(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->u32ExtendedIdentifier);
N    vTXCAN_SetStdID(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->u16StandardIdentifier);
N    vTXCAN_SetRemoteFrameHandling(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->eRemoteFrameHandling);
N    vTXCAN_SetGlobalAcceptanceMask(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->eGlobalAcceptanceMask);
N    vTXCAN_SetFrameType(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->eFrameType);
N    vTXCAN_SetMailboxDirection(stMBConfig->eChannel, stMBConfig->eMailbox, stMBConfig->eMailboxDirection);
N    vTXCAN_MailboxEnable(stMBConfig->eChannel, stMBConfig->eMailbox);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_TransmitAll(TXCAN_CH_e eCh, uint32_t u32TransmitCode)
N{
N    vSetTRS(eCh, u32TransmitCode);
X    (*((volatile u32TRS_word_view *)(0xC0400410U + ((int32_t)(eCh)))) = (u32TransmitCode));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_Transmit(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMC(eCh) & ~u32MBOne[eMB];
X    u32Value = (*((volatile u32MC_word_view *)(0xC0400400U + ((int32_t)(eCh)))) ) & ~u32MBOne[eMB];
N    vSetTRS(eCh, u32Value);
X    (*((volatile u32TRS_word_view *)(0xC0400410U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SendMsg(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint64_t u64Data)
N{
N    uint32_t u32Value;
N
N    vSetDATL_MBn(eCh, eMB, (u64Data & 0xFFFFFFFF));
X    (*((volatile u32DATL_MBn_word_view *)(0xC0400010U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) = ((u64Data & 0xFFFFFFFF)));
N    vSetDATH_MBn(eCh, eMB, ((u64Data >> 32) & 0xFFFFFFFF));
X    (*((volatile u32DATH_MBn_word_view *)(0xC0400018U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x020U))) = (((u64Data >> 32) & 0xFFFFFFFF)));
N
N    u32Value = u32GetTRS(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32TRS_word_view *)(0xC0400410U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetTRS(eCh, u32Value);
X    (*((volatile u32TRS_word_view *)(0xC0400410U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_CancelTransmissionAll(TXCAN_CH_e eCh, uint32_t u32CancelCode)
N{
N    vSetTRR(eCh, u32CancelCode);
X    (*((volatile u32TRR_word_view *)(0xC0400418U + ((int32_t)(eCh)))) = (u32CancelCode));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_CancelTransmission(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetTRR(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32TRR_word_view *)(0xC0400418U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetTRR(eCh, u32Value);
X    (*((volatile u32TRR_word_view *)(0xC0400418U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmissionAcknowledgeAll(TXCAN_CH_e eCh, uint32_t u32TransmissionCode)
N{
N    vSetTA(eCh, u32TransmissionCode);
X    (*((volatile u32TA_word_view *)(0xC0400420U + ((int32_t)(eCh)))) = (u32TransmissionCode));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmissionAcknowledge(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetTA(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32TA_word_view *)(0xC0400420U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetTA(eCh, u32Value);
X    (*((volatile u32TA_word_view *)(0xC0400420U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmissionAbortAcknowledgeAll(TXCAN_CH_e eCh, uint32_t u32TransmissionCode)
N{
N    vSetAA(eCh, u32TransmissionCode);
X    (*((volatile u32AA_word_view *)(0xC0400428U + ((int32_t)(eCh)))) = (u32TransmissionCode));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmissionAbortAcknowledge(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetAA(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32AA_word_view *)(0xC0400428U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetAA(eCh, u32Value);
X    (*((volatile u32AA_word_view *)(0xC0400428U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetChangeDataRequestAll(TXCAN_CH_e eCh, uint32_t u32Value)
N{
N    vSetCDR(eCh, u32Value);
X    (*((volatile u32CDR_word_view *)(0xC0400498U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetChangeDataRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetCDR(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32CDR_word_view *)(0xC0400498U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetCDR(eCh, u32Value);
X    (*((volatile u32CDR_word_view *)(0xC0400498U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetChangeDataRequestAll(TXCAN_CH_e eCh)
N{
N    return u32GetCDR(eCh);
X    return (*((volatile u32CDR_word_view *)(0xC0400498U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetChangeDataRequest(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetCDR(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32CDR_word_view *)(0xC0400498U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value == 0)
N    {
N        return 0;
N    }
N    else
N    {
N        return 1;
N    }
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetPendingReceiveMessages(TXCAN_CH_e eCh)
N{
N    return u32GetRMP(eCh);
X    return (*((volatile u32RMP_word_view *)(0xC0400430U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetPendingReceiveMessage(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetRMP(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32RMP_word_view *)(0xC0400430U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value == 0)
N    {
N        return 0;
N    }
N    else
N    {
N        return 1;
N    }
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearPendingReceiveMessages(TXCAN_CH_e eCh, uint32_t u32Value)
N{
N    vSetRMP(eCh, u32Value);
X    (*((volatile u32RMP_word_view *)(0xC0400430U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearPendingReceiveMessage(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetRMP(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32RMP_word_view *)(0xC0400430U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetRMP(eCh, u32Value);
X    (*((volatile u32RMP_word_view *)(0xC0400430U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetReceiveMessageLosts(TXCAN_CH_e eCh)
N{
N    return u32GetRML(eCh);
X    return (*((volatile u32RML_word_view *)(0xC0400438U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetReceiveMessageLost(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetRML(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32RML_word_view *)(0xC0400438U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value == 0)
N    {
N        return 0;
N    }
N    else
N    {
N        return 1;
N    }
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearReceiveMessageLosts(TXCAN_CH_e eCh, uint32_t u32Value)
N{
N    vSetRML(eCh, u32Value);
X    (*((volatile u32RML_word_view *)(0xC0400438U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearReceiveMessageLost(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetRML(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32RML_word_view *)(0xC0400438U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetRML(eCh, u32Value);
X    (*((volatile u32RML_word_view *)(0xC0400438U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetPendingRemoteFrames(TXCAN_CH_e eCh)
N{
N    return u32GetRFP(eCh);
X    return (*((volatile u32RFP_word_view *)(0xC04004A0U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetPendingRemoteFrame(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetRFP(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32RFP_word_view *)(0xC04004A0U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value == 0)
N    {
N        return 0;
N    }
N    else
N    {
N        return 1;
N    }
N}
N
N/****************************************************************************/
N
Nvoid vSetAcceptanceMaskType(TXCAN_CH_e eCh, TXCAN_MB_e eMB, TXCAN_AcceptanceMaskType_e eType)
N{
N    vSetMBnAM_AMI(eCh, eMB, eType);
X    (((volatile MBnAM_bit_view_st *)(0xC04004C0U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x8U))) -> AMI=(eType));
N}
N
N/****************************************************************************/
N
NTXCAN_AcceptanceMaskType_e eGetAcceptanceMaskType(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return (TXCAN_AcceptanceMaskType_e)biGetMBnAM_AMI(eCh, eMB);
X    return (TXCAN_AcceptanceMaskType_e)(((volatile MBnAM_bit_view_st *)(0xC04004C0U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x8U))) -> AMI);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB, uint32_t u32Value)
N{
N    vSetMBnAM_AM(eCh, eMB, u32Value);
X    (((volatile MBnAM_bit_view_st *)(0xC04004C0U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x8U))) -> AM=(u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetAcceptanceMask(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    return biGetMBnAM_AM(eCh, eMB);
X    return (((volatile MBnAM_bit_view_st *)(0xC04004C0U + ((int32_t)(eCh)) + ((int32_t)(eMB) * 0x8U))) -> AM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ConfigureChannel(TXCAN_CH_e eCh, TXCAN_CHconfig_st * stConfig)
N{
N    vSetMCR_SRES(eCh, stConfig->eSoftwareReset);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> SRES=(stConfig->eSoftwareReset));
N    vSetMCR_TSCC(eCh, stConfig->eTimeStampCounter);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSCC=(stConfig->eTimeStampCounter));
N    vSetMCR_MTOS(eCh, stConfig->eTransmissionOrder);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> MTOS=(stConfig->eTransmissionOrder));
N    vSetMCR_WUBA(eCh, stConfig->eWakeUp);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> WUBA=(stConfig->eWakeUp));
N    vSetMCR_SMR(eCh, stConfig->eSleepMode);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> SMR=(stConfig->eSleepMode));
N    vSetMCR_CCR(eCh, stConfig->eChangeConfig);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> CCR=(stConfig->eChangeConfig));
N    vSetMCR_TSTERR(eCh, stConfig->eTestError);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSTERR=(stConfig->eTestError));
N    vSetMCR_TSTLB(eCh, stConfig->eTestLoopback);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSTLB=(stConfig->eTestLoopback));
N    vSetMCR_INTLB(eCh, stConfig->eInternalLoopback);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> INTLB=(stConfig->eInternalLoopback));
N    vSetMCR_SUR(eCh, stConfig->eSuspendMode);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> SUR=(stConfig->eSuspendMode));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_GetChannelConfiguration(TXCAN_CH_e eCh, TXCAN_CHconfig_st * stConfig)
N{
N    stConfig->eSoftwareReset = (TXCAN_SoftwareReset_e)biGetMCR_SRES(eCh);
X    stConfig->eSoftwareReset = (TXCAN_SoftwareReset_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> SRES);
N    stConfig->eTimeStampCounter = (TXCAN_TimeStampCounter_e)biGetMCR_TSCC(eCh);
X    stConfig->eTimeStampCounter = (TXCAN_TimeStampCounter_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSCC);
N    stConfig->eTransmissionOrder = (TXCAN_TransmissionOrder_e)biGetMCR_MTOS(eCh);
X    stConfig->eTransmissionOrder = (TXCAN_TransmissionOrder_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> MTOS);
N    stConfig->eWakeUp = (TXCAN_WakeUpOnBus_e)biGetMCR_WUBA(eCh);
X    stConfig->eWakeUp = (TXCAN_WakeUpOnBus_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> WUBA);
N    stConfig->eSleepMode = (TXCAN_Sleep_e)biGetMCR_SMR(eCh);
X    stConfig->eSleepMode = (TXCAN_Sleep_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> SMR);
N    stConfig->eChangeConfig = (TXCAN_ChangeConfig_e)biGetMCR_CCR(eCh);
X    stConfig->eChangeConfig = (TXCAN_ChangeConfig_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> CCR);
N    stConfig->eTestError = (TXCAN_TestError_e)biGetMCR_TSTERR(eCh);
X    stConfig->eTestError = (TXCAN_TestError_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSTERR);
N    stConfig->eTestLoopback = (TXCAN_TestLoopback_e)biGetMCR_TSTLB(eCh);
X    stConfig->eTestLoopback = (TXCAN_TestLoopback_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSTLB);
N    stConfig->eInternalLoopback = (TXCAN_InternalLoopback_e)biGetMCR_INTLB(eCh);
X    stConfig->eInternalLoopback = (TXCAN_InternalLoopback_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> INTLB);
N    stConfig->eSuspendMode = (TXCAN_Suspend_e)biGetMCR_SUR(eCh);
X    stConfig->eSuspendMode = (TXCAN_Suspend_e)(((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> SUR);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ConfigureTiming(TXCAN_CH_e eCh, TXCAN_timing_st * stTiming)
N{
N    vSetMCR_CCR(eCh, 1);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> CCR=(1));
N    vSetBCR1_BRP(eCh, stTiming->u8BaudRatePrescaler);
X    (((volatile BCR1_bit_view_st *)(0xC0400460U + ((int32_t)(eCh)))) -> BRP=(stTiming->u8BaudRatePrescaler));
N    vSetBCR2_TSEG1(eCh, stTiming->u8BitTiming1);
X    (((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> TSEG1=(stTiming->u8BitTiming1));
N    vSetBCR2_TSEG2(eCh, stTiming->u8BitTiming2);
X    (((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> TSEG2=(stTiming->u8BitTiming2));
N    vSetMCR_CCR(eCh, 0);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> CCR=(0));
N
N    vSetBCR2_SAM(eCh, stTiming->eSamplingType);
X    (((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> SAM=(stTiming->eSamplingType));
N    vSetBCR2_SJW(eCh, stTiming->eBitLS);
X    (((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> SJW=(stTiming->eBitLS));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_GetTimingConfiguration(TXCAN_CH_e eCh, TXCAN_timing_st * stTiming)
N{
N    stTiming->u8BaudRatePrescaler = (uint8_t)biGetBCR1_BRP(eCh);
X    stTiming->u8BaudRatePrescaler = (uint8_t)(((volatile BCR1_bit_view_st *)(0xC0400460U + ((int32_t)(eCh)))) -> BRP);
N    stTiming->u8BitTiming1 = (uint8_t)biGetBCR2_TSEG1(eCh);
X    stTiming->u8BitTiming1 = (uint8_t)(((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> TSEG1);
N    stTiming->u8BitTiming2 = (uint8_t)biGetBCR2_TSEG2(eCh);
X    stTiming->u8BitTiming2 = (uint8_t)(((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> TSEG2);
N    stTiming->eSamplingType = (TXCAN_Sampling_e)biGetBCR2_SAM(eCh);
X    stTiming->eSamplingType = (TXCAN_Sampling_e)(((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> SAM);
N    stTiming->eBitLS = (TXCAN_BitLS_e)biGetBCR2_SJW(eCh);
X    stTiming->eBitLS = (TXCAN_BitLS_e)(((volatile BCR2_bit_view_st *)(0xC0400468U + ((int32_t)(eCh)))) -> SJW);
N}
N
N/****************************************************************************/
N
Nuint16_t u16TXCAN_GetTimeStampCounter(TXCAN_CH_e eCh)
N{
N    return biGetTSC_TSC(eCh);
X    return (((volatile TSC_bit_view_st *)(0xC04004B8U + ((int32_t)(eCh)))) -> TSC);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTimeStampValue(TXCAN_CH_e eCh)
N{
N    vSetMCR_TSCC(eCh, 1);
X    (((volatile MCR_bit_view_st *)(0xC0400450U + ((int32_t)(eCh)))) -> TSCC=(1));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetTimeStampCounterPrescaler(TXCAN_CH_e eCh, uint8_t u8Value)
N{
N    vSetTSP_TSP(eCh, (u8Value & 0xF));
X    (((volatile TSP_bit_view_st *)(0xC04004B0U + ((int32_t)(eCh)))) -> TSP=((u8Value & 0xF)));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTimeStampCounterPrescaler(TXCAN_CH_e eCh)
N{
N    return biGetTSP_TSP(eCh);
X    return (((volatile TSP_bit_view_st *)(0xC04004B0U + ((int32_t)(eCh)))) -> TSP);
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetGlobalStatus(TXCAN_CH_e eCh)
N{
N    return u32GetGSR(eCh);
X    return (*((volatile u32GSR_word_view *)(0xC0400458U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetWarningStatus(TXCAN_CH_e eCh)
N{
N    return biGetGSR_EW(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> EW);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetErrorPassiveStatus(TXCAN_CH_e eCh)
N{
N    return biGetGSR_EP(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> EP);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetBusOffStatus(TXCAN_CH_e eCh)
N{
N    return biGetGSR_BO(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> BO);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTimeStampOverflowFlag(TXCAN_CH_e eCh)
N{
N    return biGetGSR_TSO(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> TSO);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetSleepModeAcknowledge(TXCAN_CH_e eCh)
N{
N    return biGetGSR_SMA(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> SMA);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetChangeConfigurationEnable(TXCAN_CH_e eCh)
N{
N    return biGetGSR_CCE(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> CCE);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetSuspendModeAcknowledge(TXCAN_CH_e eCh)
N{
N    return biGetGSR_SUA(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> SUA);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTransmitMode(TXCAN_CH_e eCh)
N{
N    return biGetGSR_TM(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> TM);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetReceiveMode(TXCAN_CH_e eCh)
N{
N    return biGetGSR_RM(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> RM);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetMessageInSlot(TXCAN_CH_e eCh)
N{
N    return biGetGSR_MIS(eCh);
X    return (((volatile GSR_bit_view_st *)(0xC0400458U + ((int32_t)(eCh)))) -> MIS);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetReceiveErrorCounter(TXCAN_CH_e eCh)
N{
N    return biGetCEC_REC(eCh);
X    return (((volatile CEC_bit_view_st *)(0xC04004A8U + ((int32_t)(eCh)))) -> REC);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTransmitErrorCounter(TXCAN_CH_e eCh)
N{
N    return biGetCEC_TEC(eCh);
X    return (((volatile CEC_bit_view_st *)(0xC04004A8U + ((int32_t)(eCh)))) -> TEC);
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetGlobalInterruptFlags(TXCAN_CH_e eCh)
N{
N    return u8GetGIF(eCh);
X    return (*((volatile u8GIF_byte_view *)(0xC0400470U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearGlobalInterruptFlags(TXCAN_CH_e eCh, uint8_t u8Flags)
N{
N    vSetGIF(eCh, u8Flags);
X    (*((volatile u8GIF_byte_view *)(0xC0400470U + ((int32_t)(eCh)))) = (u8Flags));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetWarningLevelInterruptFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_WLIF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> WLIF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearWarningLevelInterruptFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_WLIF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> WLIF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetErrorPassiveInterruptFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_EPIF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> EPIF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearErrorPassiveInterruptFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_EPIF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> EPIF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetBusOffInterruptFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_BOIF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> BOIF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearBusOffInterruptFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_BOIF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> BOIF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTimeStampCounterOverflowInterruptFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_TSOIF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> TSOIF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTimeStampCounterOverflowInterruptFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_TSOIF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> TSOIF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTransmitAbortFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_TRMABF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> TRMABF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmitAbortFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_TRMABF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> TRMABF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetReceiveMessageLostInterruptFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_RMLIF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> RMLIF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearReceiveMessageLostInterruptFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_RMLIF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> RMLIF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetWakeUpInterruptFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_WUIF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> WUIF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearWakeUpInterruptFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_WUIF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> WUIF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetRemoteFramePendingFlag(TXCAN_CH_e eCh)
N{
N    return biGetGIF_RFPF(eCh);
X    return (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> RFPF);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearRemoteFramePendingFlag(TXCAN_CH_e eCh)
N{
N    vClrGIF_RFPF(eCh);
X    (((volatile GIF_bit_view_st *)(0xC0400470U + ((int32_t)(eCh)))) -> RFPF = (1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetGlobalInterruptMasks(TXCAN_CH_e eCh)
N{
N    return u8GetGIM(eCh);
X    return (*((volatile u8GIM_byte_view *)(0xC0400478U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetGlobalInterruptMasks(TXCAN_CH_e eCh, uint8_t u8Masks)
N{
N    uint8_t u8Value;
N
N    u8Value = u8GetGIM(eCh) | u8Masks;
X    u8Value = (*((volatile u8GIM_byte_view *)(0xC0400478U + ((int32_t)(eCh)))) ) | u8Masks;
N    vSetGIM(eCh, u8Value);
X    (*((volatile u8GIM_byte_view *)(0xC0400478U + ((int32_t)(eCh)))) = (u8Value));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetWarningLevelInterruptMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_WLIM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> WLIM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetWarningLevelInterruptMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_WLIM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> WLIM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetErrorPassiveInterruptMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_EPIM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> EPIM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetErrorPassiveInterruptMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_EPIM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> EPIM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetBusOffInterruptMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_BOIM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> BOIM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetBusOffInterruptMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_BOIM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> BOIM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTimeStampCounterOverflowInterruptMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_TSOIM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> TSOIM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetTimeStampCounterOverflowInterruptMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_TSOIM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> TSOIM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTransmitAbortMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_TRMABFM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> TRMABFM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetTransmitAbortMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_TRMABFM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> TRMABFM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetReceiveMessageLostInterruptMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_RMLIM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> RMLIM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetReceiveMessageLostInterruptMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_RMLIM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> RMLIM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetWakeUpInterruptMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_WUIM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> WUIM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetWakeUpInterruptMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_WUIM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> WUIM=(1));
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetRemoteFramePendingMask(TXCAN_CH_e eCh)
N{
N    return biGetGIM_RFPM(eCh);
X    return (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> RFPM);
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_SetRemoteFramePendingMask(TXCAN_CH_e eCh)
N{
N    vSetGIM_RFPM(eCh, 1);
X    (((volatile GIM_bit_view_st *)(0xC0400478U + ((int32_t)(eCh)))) -> RFPM=(1));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_EnableInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMBIM(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32MBIM_word_view *)(0xC0400490U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetMBIM(eCh, u32Value);
X    (*((volatile u32MBIM_word_view *)(0xC0400490U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_DisableInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMBIM(eCh) & ~u32MBOne[eMB];
X    u32Value = (*((volatile u32MBIM_word_view *)(0xC0400490U + ((int32_t)(eCh)))) ) & ~u32MBOne[eMB];
N    vSetMBIM(eCh, u32Value);
X    (*((volatile u32MBIM_word_view *)(0xC0400490U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_EnableInterrupts(TXCAN_CH_e eCh, uint32_t u32Value)
N{
N    vSetMBIM(eCh, u32Value);
X    (*((volatile u32MBIM_word_view *)(0xC0400490U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmitInterrupts(TXCAN_CH_e eCh, uint32_t u32Value)
N{
N    vSetMBTIF(eCh, u32Value);
X    (*((volatile u32MBTIF_word_view *)(0xC0400480U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearTransmitInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMBTIF(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32MBTIF_word_view *)(0xC0400480U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetMBTIF(eCh, u32Value);
X    (*((volatile u32MBTIF_word_view *)(0xC0400480U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetTransmitInterrupts(TXCAN_CH_e eCh)
N{
N    return u32GetMBTIF(eCh);
X    return (*((volatile u32MBTIF_word_view *)(0xC0400480U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetTransmitInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMBTIF(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32MBTIF_word_view *)(0xC0400480U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value == 0)
N    {
N        return 0;
N    }
N    else
N    {
N        return 1;
N    }
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearReceiveInterrupts(TXCAN_CH_e eCh, uint32_t u32Value)
N{
N    vSetMBRIF(eCh, u32Value);
X    (*((volatile u32MBRIF_word_view *)(0xC0400488U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nvoid vTXCAN_ClearReceiveInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMBRIF(eCh) | u32MBOne[eMB];
X    u32Value = (*((volatile u32MBRIF_word_view *)(0xC0400488U + ((int32_t)(eCh)))) ) | u32MBOne[eMB];
N    vSetMBRIF(eCh, u32Value);
X    (*((volatile u32MBRIF_word_view *)(0xC0400488U + ((int32_t)(eCh)))) = (u32Value));
N}
N
N/****************************************************************************/
N
Nuint32_t u32TXCAN_GetReceiveInterrupts(TXCAN_CH_e eCh)
N{
N    return u32GetMBRIF(eCh);
X    return (*((volatile u32MBRIF_word_view *)(0xC0400488U + ((int32_t)(eCh)))) );
N}
N
N/****************************************************************************/
N
Nuint8_t u8TXCAN_GetReceiveInterrupt(TXCAN_CH_e eCh, TXCAN_MB_e eMB)
N{
N    uint32_t u32Value;
N
N    u32Value = u32GetMBRIF(eCh) & u32MBOne[eMB];
X    u32Value = (*((volatile u32MBRIF_word_view *)(0xC0400488U + ((int32_t)(eCh)))) ) & u32MBOne[eMB];
N    if (u32Value == 0)
N    {
N        return 0;
N    }
N    else
N    {
N        return 1;
N    }
N}
N
N/****************************************************************************/
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: txcan.c
N**  $Revision: 1.10 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :  5 (0286) String literal contains character which is not a
N** |                    member of the basic source character set.
N** |           5 (0288) Source file '<TEXT>' has comments containing characters
N** |                    which are not members of the basic source character set.
N** |          22 (3218) File scope static, '<TEXT>', only accessed in one
N** |                    function.
N** |          45 (0303) Cast between a pointer to volatile object and an
N** |                    integral type.
N** |          52 (1503) The function '%1s' is defined but is not used within
N** |                    this project.
N** |
N** | REASON : This is neccessary because of driver version control.
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N/****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices,” or
N  “TOSHIBA Semiconductor Reliability Handbook” etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage”).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCALIMER ****************************/
N
