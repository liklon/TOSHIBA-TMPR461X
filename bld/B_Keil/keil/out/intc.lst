L 1 "..\..\..\..\lldd\src\intc.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Reference Interrupt Controller (INTC) Low Level Device Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Interrupt Controller (INTC)
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.18 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "core.h"
L 1 "..\..\..\..\common\inc\core.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core access utilities definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Core
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.11 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CORE_H
N#define CORE_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"                     /* Core specific primitive type definitions */
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 25 "..\..\..\..\common\inc\core.h" 2
N#include "cr4_pmu.h"
L 1 "..\..\..\..\cortex_r4_keil\inc\cr4_pmu.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Performance monitor unit routines based on ARM's V7 sample code
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : TSM-SHE Firmware System Longrun Test (Cortex-R4)
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.5 $
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef _CR4_PMU_H
N#define _CR4_PMU_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"                       /* Core specific primitive type definitions */
N
N/*********************************************/
N
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      u32CR4_GetPMN
N *
N * Purpose:       Returns the number of progammable counters
N *
N * Inputs:        none
N *
N * Outputs:       Programmable counters count
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32CR4_GetPMN(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_PMNConfig
N *
N * Purpose:       Sets the event for a programmable counter to record
N *
N * Inputs:        u32Counter: Which counter to program  (e.g. 0 for PMN0, 1 for PMN1)
N *                u32Even:    The event code (ARM Architecture Reference Manual)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_PMNConfig(uint32_t u32Counter, uint32_t u32Event);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_SetCntDivider
N *
N * Purpose:       Enables/disables the divider (1/64) on CCNT
N *
N * Inputs:        u32Divider: 0 - disable, all others enable
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_SetCntDivider(uint32_t u32Divider);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_EnablePMU
N *
N * Purpose:       Global PMU enable
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_EnablePMU(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_DisablePMU
N *
N * Purpose:       Global PMU disable
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_DisablePMU(void);
N
N
N /****************************************************************************
N *
N * Function:      vCR4_EnableCCNT
N *
N * Purpose:       Enable the cycle counter (CCNT)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_EnableCCNT(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_DisableCCNT
N *
N * Purpose:       Disable the cycle counter (CCNT)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_DisableCCNT(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_EnablePMN
N *
N * Purpose:       Enable PMN{n}
N *
N * Inputs:        u32Counter: The counter to enable (e.g. 0 for PMN0, 1 for PMN1)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_EnablePMN(uint32_t u32Counter);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_DisablePMN
N *
N * Purpose:       Disable PMN{n}
N *
N * Inputs:        u32Counter: The counter to disable (e.g. 0 for PMN0, 1 for PMN1)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_DisablePMN(uint32_t u32Counter);
N
N
N/****************************************************************************
N *
N * Function:      uCR4_32ReadCCNT
N *
N * Purpose:       Returns the value of CCNT
N *
N * Inputs:        none
N *
N * Outputs:       Cycle counter value
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32CR4_ReadCCNT(void);
N
N
N/****************************************************************************
N *
N * Function:      u32CR4_ReadPMN
N *
N * Purpose:       Returns the value of PMN{n}
N *
N * Inputs:        u32Counter: The counter to read (e.g. 0 for PMN0, 1 for PMN1)
N *
N * Outputs:       PMNn counter
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32CR4_ReadPMN(uint32_t u32Counter);
N
N
N/****************************************************************************
N *
N * Function:      u32CR4_ReadFlags
N *
N * Purpose:       Returns the value of the overflow flags
N *
N * Inputs:        none
N *
N * Outputs:       Overflow flags
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32CR4_ReadFlags(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_WriteFlags
N *
N * Purpose:       Writes the overflow flags
N *
N * Inputs:        u32Flags: flags to write
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_WriteFlags(uint32_t u32Flags);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_EnableCCNTIrq
N *
N * Purpose:       Enables interrupt generation on overflow of the CCNT
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_EnableCCNTIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_DisableCCNTIrq
N *
N * Purpose:       Disables interrupt generation on overflow of the CCNT
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_DisableCCNTIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_EnablePmnIrq
N *
N * Purpose:       Enables interrupt generation on overflow of PMN{x}
N *
N * Inputs:        u32Counter: The counter to enable the interrupt for (e.g. 0 for PMN0, 1 for PMN1)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_EnablePmnIrq(uint32_t u32Counter);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_DisablePMNIrq
N *
N * Purpose:       Disables interrupt generation on overflow of PMN{x}
N *
N * Inputs:        u32Counter: The counter to disable the interrupt for (e.g. 0 for PMN0, 1 for PMN1)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_DisablePMNIrq(uint32_t u32Counter);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_ResetPMN
N *
N * Purpose:       Resets the programmable counters
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_ResetPMN(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_ResetPMN
N *
N * Purpose:       Resets the CCNT
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_ResetCCNT(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_ResetPMN
N *
N * Purpose:       Writes to software increment register
N *
N * Inputs:        u32Counter: The counter to increment (e.g. 0 for PMN0, 1 for PMN1)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_PMUSoftwareIncrement(uint32_t u32Counter);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_EnablePMUUserAccess
N *
N * Purpose:       Enables User mode access to the PMU (must be called in a priviledged mode)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_EnablePMUUserAccess(void);
N
N
N/****************************************************************************
N *
N * Function:      vCR4_DisablePMUUserAccess
N *
N * Purpose:       Disables User mode access to the PMU (must be called in a priviledged mode)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCR4_DisablePMUUserAccess(void);
N
N
N#endif /* _CR4_PMU_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\common\inc\core.h" 2
N
N/*********************************************/
N
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1862  /* Rule 19.7 : disable function-like macro not allowed */
N#endif
N/**********************************************/
N
N/* Physical translation in un-cached area */
N#define PHYSICAL_ADDR_MASK                  0xFFFFFFFFU
N#define PHYSICAL(addr)                      (((uint32_t)(addr) & PHYSICAL_ADDR_MASK))
N
N/* copy function */
N#define asm_copyfunction                    (asm_copy_word)
N#define asm_copyfunction_hword              (asm_copy_hword)
N#define asm_copyfunction_byte               (asm_copy_byte)
N
N/* PMU enable */
N#define PMU_ENABLE()                        (vCR4_EnablePMU())
N
N/* Timer Enable */
N#define TIMER_ENABLE()                      (vCR4_EnableCCNT())
N
N/* Timer Reset */
N#define TIMER_RESET()                       (vCR4_ResetCCNT())
N
N/* Timer Get */
N#define TIMER_GET()                         (u32CR4_ReadCCNT())
N
N/*********************************************/
N
N
N/**********************************************
N*                 Enumerations                *
N**********************************************/
N
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      __DSB
N *
N * Purpose:       Data barrier
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid __DSB(void);
N
N
N/****************************************************************************
N *
N * Function:      __ISB
N *
N * Purpose:       Instruction barrier
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid __ISB(void);
N
N
N/****************************************************************************
N *
N * Function:      asm_enable_core_int
N *
N * Purpose:       Enable core interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid asm_enable_core_int(void);
N
N
N/****************************************************************************
N *
N * Function:      asm_disable_core_int
N *
N * Purpose:       Disable core interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid asm_disable_core_int(void);
N
N
N/****************************************************************************
N *
N * Function:      asm_enable_core_fast_int
N *
N * Purpose:       Enable core fast interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid asm_enable_core_fast_int(void);
N
N
N/****************************************************************************
N *
N * Function:      asm_disable_core_fast_int
N *
N * Purpose:       Disable core fast interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid asm_disable_core_fast_int(void);
N
N
N/****************************************************************************
N *
N * Function:      asm_enable_core_vic_port
N *
N * Purpose:       Enable VIC port
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid asm_enable_core_vic_port(void);
N
N
N/****************************************************************************
N *
N * Function:      asm_disable_core_vic_port
N *
N * Purpose:       Disable VIC port
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid asm_disable_core_vic_port(void);
N
N
N#endif /* CORE_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 23 "..\..\..\..\lldd\src\intc.c" 2
N#include "intc_io.h"                        /* INTC registers, bits and access macros defintion */
L 1 "..\..\..\..\lldd\hdr\intc_io.h" 1
N
N/*##########################################################################
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE
N/  Module                       : INTC
N/  Date of creation (y-m-d:time): 2013-06-26+02:00  :  17:56:36.688+02:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.12 $
N/  Excel Sheet ver.             : vv1.1
N/  Excel Sheet date             : 2013-Jun-19
N/  Excel Sheet author           : ZUL
N/##########################################################################*/
N
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Reference Interrupt Controller Low Level Device Driver IO
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Interrupt Controller (INTC)
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.12 $
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N
N#ifndef INTCIO_H
N#define INTCIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */
N
N
N/*********************************************
N*         Disable Misra Warnings/Rules       *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 230  /* Rule 3.5 [R] : derived  disable warnings for nonstandard type for a bit field */
S  #pragma ghs nowarning 79   /* Rule 3.5 [R] : derived  disable warnings for nonstandard type for a bit field */
S
S  #pragma ghs nowarning 1840   /* Rule 5.7   [A] : No reuse of identifiers  */
N#endif
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_INTC_IO_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_INTC_IO_H_TAG          "$Name: LLDD_1_6 $"
N
N
N/****************************************************************************
N*
N*       REGISTER: IR
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC0108000
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IR_REG__       0xC0108000U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   EXT0	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   DRS0	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   EIM0	:2; 	 /* 5..6  bit(s) R/W */
N  uint32_t   ACLR0	:1; 	 /* 7..7  bit(s) R/W */
N  uint32_t   EXT1	:3; 	 /* 8..10  bit(s) R/W */
N  uint32_t   	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   DRS1	:1; 	 /* 12..12  bit(s) R/W */
N  uint32_t   EIM1	:2; 	 /* 13..14  bit(s) R/W */
N  uint32_t   ACLR1	:1; 	 /* 15..15  bit(s) R/W */
N  uint32_t   EXT2	:3; 	 /* 16..18  bit(s) R/W */
N  uint32_t   	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   DRS2	:1; 	 /* 20..20  bit(s) R/W */
N  uint32_t   EIM2	:2; 	 /* 21..22  bit(s) R/W */
N  uint32_t   ACLR2	:1; 	 /* 23..23  bit(s) R/W */
N  uint32_t   EXT3	:3; 	 /* 24..26  bit(s) R/W */
N  uint32_t   	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   DRS3	:1; 	 /* 28..28  bit(s) R/W */
N  uint32_t   EIM3	:2; 	 /* 29..30  bit(s) R/W */
N  uint32_t   ACLR3	:1; 	 /* 31..31  bit(s) R/W */
N} IR_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IR_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IR_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IR_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIR(ch)     ((volatile IR_bit_view_st *)\
N(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pst_bitIR(ch)     ((volatile IR_bit_view_st *)(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IR(ch)     ((volatile IR_byte_view_st *)\
N(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pst_u8IR(ch)     ((volatile IR_byte_view_st *)(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IR(ch)     ((volatile IR_halfword_view_st *)\
N(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pst_u16IR(ch)     ((volatile IR_halfword_view_st *)(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/* Pointer to WORD  */
N#define pu32IR(ch)     ((volatile u32IR_word_view *)\
N(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pu32IR(ch)     ((volatile u32IR_word_view *)(IR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIR_EXT0(ch) (pst_bitIR(ch) -> EXT0)
N#define vSetIR_EXT0(ch,ParValue)  (pst_bitIR(ch) -> EXT0=(ParValue))
N#define biGetIR_DRS0(ch) (pst_bitIR(ch) -> DRS0)
N#define vSetIR_DRS0(ch,ParValue)  (pst_bitIR(ch) -> DRS0=(ParValue))
N#define biGetIR_EIM0(ch) (pst_bitIR(ch) -> EIM0)
N#define vSetIR_EIM0(ch,ParValue)  (pst_bitIR(ch) -> EIM0=(ParValue))
N#define biGetIR_ACLR0(ch) (pst_bitIR(ch) -> ACLR0)
N#define vSetIR_ACLR0(ch,ParValue)  (pst_bitIR(ch) -> ACLR0=(ParValue))
N#define biGetIR_EXT1(ch) (pst_bitIR(ch) -> EXT1)
N#define vSetIR_EXT1(ch,ParValue)  (pst_bitIR(ch) -> EXT1=(ParValue))
N#define biGetIR_DRS1(ch) (pst_bitIR(ch) -> DRS1)
N#define vSetIR_DRS1(ch,ParValue)  (pst_bitIR(ch) -> DRS1=(ParValue))
N#define biGetIR_EIM1(ch) (pst_bitIR(ch) -> EIM1)
N#define vSetIR_EIM1(ch,ParValue)  (pst_bitIR(ch) -> EIM1=(ParValue))
N#define biGetIR_ACLR1(ch) (pst_bitIR(ch) -> ACLR1)
N#define vSetIR_ACLR1(ch,ParValue)  (pst_bitIR(ch) -> ACLR1=(ParValue))
N#define biGetIR_EXT2(ch) (pst_bitIR(ch) -> EXT2)
N#define vSetIR_EXT2(ch,ParValue)  (pst_bitIR(ch) -> EXT2=(ParValue))
N#define biGetIR_DRS2(ch) (pst_bitIR(ch) -> DRS2)
N#define vSetIR_DRS2(ch,ParValue)  (pst_bitIR(ch) -> DRS2=(ParValue))
N#define biGetIR_EIM2(ch) (pst_bitIR(ch) -> EIM2)
N#define vSetIR_EIM2(ch,ParValue)  (pst_bitIR(ch) -> EIM2=(ParValue))
N#define biGetIR_ACLR2(ch) (pst_bitIR(ch) -> ACLR2)
N#define vSetIR_ACLR2(ch,ParValue)  (pst_bitIR(ch) -> ACLR2=(ParValue))
N#define biGetIR_EXT3(ch) (pst_bitIR(ch) -> EXT3)
N#define vSetIR_EXT3(ch,ParValue)  (pst_bitIR(ch) -> EXT3=(ParValue))
N#define biGetIR_DRS3(ch) (pst_bitIR(ch) -> DRS3)
N#define vSetIR_DRS3(ch,ParValue)  (pst_bitIR(ch) -> DRS3=(ParValue))
N#define biGetIR_EIM3(ch) (pst_bitIR(ch) -> EIM3)
N#define vSetIR_EIM3(ch,ParValue)  (pst_bitIR(ch) -> EIM3=(ParValue))
N#define biGetIR_ACLR3(ch) (pst_bitIR(ch) -> ACLR3)
N#define vSetIR_ACLR3(ch,ParValue)  (pst_bitIR(ch) -> ACLR3=(ParValue))
N
N/* LL-struct byte access */
N#define vSetIRLL(ch,ParValue) (pst_u8IR(ch) -> u8LL = (ParValue))
N#define u8GetIRLL(ch) (pst_u8IR(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetIRLH(ch,ParValue) (pst_u8IR(ch) -> u8LH = (ParValue))
N#define u8GetIRLH(ch) (pst_u8IR(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetIRHL(ch,ParValue) (pst_u8IR(ch) -> u8HL = (ParValue))
N#define u8GetIRHL(ch) (pst_u8IR(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetIRHH(ch,ParValue) (pst_u8IR(ch) -> u8HH = (ParValue))
N#define u8GetIRHH(ch) (pst_u8IR(ch) -> u8HH)
N
N
N/* Half-word struct access */
N#define vSetIRL(ch,ParValue) (pst_u16IR(ch) -> u16L = (ParValue))
N#define u16GetIRL(ch) (pst_u16IR(ch) -> u16L)
N#define vSetIRH(ch,ParValue) (pst_u16IR(ch) -> u16H = (ParValue))
N#define u16GetIRH(ch) (pst_u16IR(ch) -> u16H)
N
N/* Word access */
N#define vSetIR(ch,ParValue)  (*pu32IR(ch) = (ParValue))
N#define u32GetIR(ch)  (*pu32IR(ch) )
N
N
N/****************************************************************************
N*
N*       REGISTER: IVR
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080C0
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IVR_REG__       0xC01080C0U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   OVA	:10; 	 /* 0..9  bit(s) R */
N  uint32_t   BVA	:22; 	 /* 10..31  bit(s) R/W */
N} IVR_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IVR_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IVR_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IVR_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIVR()     ((volatile IVR_bit_view_st *)\
N(IVR_REG__ ))
X#define pst_bitIVR()     ((volatile IVR_bit_view_st *)(IVR_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IVR()     ((volatile IVR_byte_view_st *)\
N(IVR_REG__ ))
X#define pst_u8IVR()     ((volatile IVR_byte_view_st *)(IVR_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IVR()     ((volatile IVR_halfword_view_st *)\
N(IVR_REG__ ))
X#define pst_u16IVR()     ((volatile IVR_halfword_view_st *)(IVR_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IVR()     ((volatile u32IVR_word_view *)\
N(IVR_REG__ ))
X#define pu32IVR()     ((volatile u32IVR_word_view *)(IVR_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIVR_OVA() (pst_bitIVR() -> OVA)
N#define biGetIVR_BVA() (pst_bitIVR() -> BVA)
N#define vSetIVR_BVA(ParValue)  (pst_bitIVR() -> BVA=(ParValue))
N
N/* LL-struct byte access */
N#define vSetIVRLL(ParValue) (pst_u8IVR() -> u8LL = (ParValue))
N#define u8GetIVRLL() (pst_u8IVR() -> u8LL)
N/* LH-struct byte access */
N#define vSetIVRLH(ParValue) (pst_u8IVR() -> u8LH = (ParValue))
N#define u8GetIVRLH() (pst_u8IVR() -> u8LH)
N/* HL-struct byte access */
N#define vSetIVRHL(ParValue) (pst_u8IVR() -> u8HL = (ParValue))
N#define u8GetIVRHL() (pst_u8IVR() -> u8HL)
N/* HH-struct byte access */
N#define vSetIVRHH(ParValue) (pst_u8IVR() -> u8HH = (ParValue))
N#define u8GetIVRHH() (pst_u8IVR() -> u8HH)
N
N
N/* Half-word struct access */
N#define vSetIVRL(ParValue) (pst_u16IVR() -> u16L = (ParValue))
N#define u16GetIVRL() (pst_u16IVR() -> u16L)
N#define vSetIVRH(ParValue) (pst_u16IVR() -> u16H = (ParValue))
N#define u16GetIVRH() (pst_u16IVR() -> u16H)
N
N/* Word access */
N#define vSetIVR(ParValue)  (*pu32IVR() = (ParValue))
N#define u32GetIVR()  (*pu32IVR() )
N
N
N/****************************************************************************
N*
N*       REGISTER: ICLR
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080C4
N*       ACCESS  : 8, 16, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define ICLR_REG__       0xC01080C4U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   IV	:10; 	 /* 0..9  bit(s) W */
N  uint32_t   	:6; 	 /* 10..31  bit(s) R */
N} ICLR_bit_view_st;
N
N
N/* Note: ICLR register should be written as 32 bit value! : */
N/* WORD View */
Ntypedef uint32_t u32ICLR_word_view;
N
N
N/************************     ACCESS POINTERS    ****************************/
N/* Pointer to WORD  */
N#define pu32ICLR()     ((volatile u32ICLR_word_view *)\
N(ICLR_REG__ ))
X#define pu32ICLR()     ((volatile u32ICLR_word_view *)(ICLR_REG__ ))
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Note: ICLR register should be written as 32 bit value! : */
N
N
N/* Word access */
N#define vSetICLR(ParValue) (*pu32ICLR()  = (ParValue))
N#define u32GetICLR() (*pu32ICLR() )
N
N
N/****************************************************************************
N*
N*       REGISTER: ILEV
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080C8
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define ILEV_REG__       0xC01080C8U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   CMASK	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   PMASK0	:3; 	 /* 4..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   PMASK1	:3; 	 /* 8..10  bit(s) R */
N  uint32_t   	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   PMASK2	:3; 	 /* 12..14  bit(s) R */
N  uint32_t   	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   PMASK3	:3; 	 /* 16..18  bit(s) R */
N  uint32_t   	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   PMASK4	:3; 	 /* 20..22  bit(s) R */
N  uint32_t   	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   PMASK5	:3; 	 /* 24..26  bit(s) R */
N  uint32_t   	:4; 	 /* 27..30  bit(s) R */
N  uint32_t   MLEV	:1; 	 /* 31..31  bit(s) W */
N} ILEV_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} ILEV_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} ILEV_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32ILEV_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitILEV()     ((volatile ILEV_bit_view_st *)\
N(ILEV_REG__ ))
X#define pst_bitILEV()     ((volatile ILEV_bit_view_st *)(ILEV_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8ILEV()     ((volatile ILEV_byte_view_st *)\
N(ILEV_REG__ ))
X#define pst_u8ILEV()     ((volatile ILEV_byte_view_st *)(ILEV_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16ILEV()     ((volatile ILEV_halfword_view_st *)\
N(ILEV_REG__ ))
X#define pst_u16ILEV()     ((volatile ILEV_halfword_view_st *)(ILEV_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32ILEV()     ((volatile u32ILEV_word_view *)\
N(ILEV_REG__ ))
X#define pu32ILEV()     ((volatile u32ILEV_word_view *)(ILEV_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetILEV_CMASK() (pst_bitILEV() -> CMASK)
N#define vSetILEV_CMASK(ParValue)  (pst_bitILEV() -> CMASK=(ParValue))
N#define biGetILEV_PMASK0() (pst_bitILEV() -> PMASK0)
N#define biGetILEV_PMASK1() (pst_bitILEV() -> PMASK1)
N#define biGetILEV_PMASK2() (pst_bitILEV() -> PMASK2)
N#define biGetILEV_PMASK3() (pst_bitILEV() -> PMASK3)
N#define biGetILEV_PMASK4() (pst_bitILEV() -> PMASK4)
N#define biGetILEV_PMASK5() (pst_bitILEV() -> PMASK5)
N#define vSetILEV_MLEV(ParValue) (pst_bitILEV() -> MLEV=(ParValue))
N
N/* LL-struct byte access */
N#define vSetILEVLL(ParValue) (pst_u8ILEV() -> u8LL = (ParValue))
N#define u8GetILEVLL() (pst_u8ILEV() -> u8LL)
N/* LH-struct byte access */
N#define vSetILEVLH(ParValue) (pst_u8ILEV() -> u8LH = (ParValue))
N#define u8GetILEVLH() (pst_u8ILEV() -> u8LH)
N/* HL-struct byte access */
N#define vSetILEVHL(ParValue) (pst_u8ILEV() -> u8HL = (ParValue))
N#define u8GetILEVHL() (pst_u8ILEV() -> u8HL)
N/* HH-struct byte access */
N#define vSetILEVHH(ParValue) (pst_u8ILEV() -> u8HH = (ParValue))
N#define u8GetILEVHH() (pst_u8ILEV() -> u8HH)
N
N
N/* Half-word struct access */
N#define vSetILEVL(ParValue) (pst_u16ILEV() -> u16L = (ParValue))
N#define u16GetILEVL() (pst_u16ILEV() -> u16L)
N#define vSetILEVH(ParValue) (pst_u16ILEV() -> u16H = (ParValue))
N#define u16GetILEVH() (pst_u16ILEV() -> u16H)
N
N/* Word access */
N#define vSetILEV(ParValue)  (*pu32ILEV() = (ParValue))
N#define u32GetILEV()  (*pu32ILEV() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IBLK
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080CC
N*       ACCESS  : 8, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IBLK_REG__       0xC01080CCU
N
N/************************       STRUCTURES        ***************************/
N
N/* BIT View */
Ntypedef struct{
N  uint8_t   IBLK	:1; 	 /* 0..0  bit(s) W */
N  uint8_t   	:7; 	 /* 1..31  bit(s) R */
N} IBLK_bit_view_st;
N
N
N/* BYTE View */
Ntypedef uint8_t u8IBLK_byte_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIBLK()     ((volatile IBLK_bit_view_st *)\
N(IBLK_REG__ ))
X#define pst_bitIBLK()     ((volatile IBLK_bit_view_st *)(IBLK_REG__ ))
N
N/* Pointer to BYTE  */
N#define pu8IBLK()     ((volatile u8IBLK_byte_view *)\
N(IBLK_REG__ ))
X#define pu8IBLK()     ((volatile u8IBLK_byte_view *)(IBLK_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define vSetIBLK_IBLK(ParValue) (pst_bitIBLK() -> IBLK=(ParValue))
N
N/* byte access */
N#define vSetIBLK(ParValue) (*pu8IBLK() = (ParValue))
N#define u8GetIBLK() (*pu8IBLK() )
N
N/****************************************************************************
N*
N*       REGISTER: IRST
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080D0
N*       ACCESS  : 8, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRST_REG__       0xC01080D0U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint8_t   RDR0	:1; 	 /* 0..0  bit(s) R/W1C */
N  uint8_t   RDR1	:1; 	 /* 1..1  bit(s) R/W1C */
N  uint8_t   RDR2	:1; 	 /* 2..2  bit(s) R/W1C */
N  uint8_t   RDR3	:1; 	 /* 3..3  bit(s) R/W1C */
N  uint8_t   RDR4	:1; 	 /* 4..4  bit(s) R/W1C */
N  uint8_t   RDR5	:1; 	 /* 5..5  bit(s) R/W1C */
N  uint8_t   RDR6	:1; 	 /* 6..6  bit(s) R/W1C */
N  uint8_t   RDR7	:1; 	 /* 7..7  bit(s) R/W1C */
N} IRST_bit_view_st;
N
N
N/* BYTE View */
Ntypedef uint8_t u8IRST_byte_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRST()     ((volatile IRST_bit_view_st *)\
N(IRST_REG__ ))
X#define pst_bitIRST()     ((volatile IRST_bit_view_st *)(IRST_REG__ ))
N
N/* Pointer to BYTE  */
N#define pu8IRST()     ((volatile u8IRST_byte_view *)\
N(IRST_REG__ ))
X#define pu8IRST()     ((volatile u8IRST_byte_view *)(IRST_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRST_RDR0() (pst_bitIRST() -> RDR0)
N#define vClrIRST_RDR0() (pst_bitIRST() -> RDR0 = (1))
N#define biGetIRST_RDR1() (pst_bitIRST() -> RDR1)
N#define vClrIRST_RDR1() (pst_bitIRST() -> RDR1 = (1))
N#define biGetIRST_RDR2() (pst_bitIRST() -> RDR2)
N#define vClrIRST_RDR2() (pst_bitIRST() -> RDR2 = (1))
N#define biGetIRST_RDR3() (pst_bitIRST() -> RDR3)
N#define vClrIRST_RDR3() (pst_bitIRST() -> RDR3 = (1))
N#define biGetIRST_RDR4() (pst_bitIRST() -> RDR4)
N#define vClrIRST_RDR4() (pst_bitIRST() -> RDR4 = (1))
N#define biGetIRST_RDR5() (pst_bitIRST() -> RDR5)
N#define vClrIRST_RDR5() (pst_bitIRST() -> RDR5 = (1))
N#define biGetIRST_RDR6() (pst_bitIRST() -> RDR6)
N#define vClrIRST_RDR6() (pst_bitIRST() -> RDR6 = (1))
N#define biGetIRST_RDR7() (pst_bitIRST() -> RDR7)
N#define vClrIRST_RDR7() (pst_bitIRST() -> RDR7 = (1))
N
N/* byte access */
N#define vSetIRST(ParValue) (*pu8IRST() = (ParValue))
N#define u8GetIRST() (*pu8IRST() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IRREST0
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080D4
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRREST0_REG__       0xC01080D4U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   STCH0	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   STCH1	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   STCH2	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   STCH3	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   STCH4	:1; 	 /* 4..4  bit(s) R */
N  uint32_t   STCH5	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   STCH6	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   STCH7	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   STCH8	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   STCH9	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   STCH10	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   STCH11	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   STCH12	:1; 	 /* 12..12  bit(s) R */
N  uint32_t   STCH13	:1; 	 /* 13..13  bit(s) R */
N  uint32_t   STCH14	:1; 	 /* 14..14  bit(s) R */
N  uint32_t   STCH15	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   STCH16	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   STCH17	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   STCH18	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   STCH19	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   STCH20	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   STCH21	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   STCH22	:1; 	 /* 22..22  bit(s) R */
N  uint32_t   STCH23	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   STCH24	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   STCH25	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STCH26	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   STCH27	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   STCH28	:1; 	 /* 28..28  bit(s) R */
N  uint32_t   STCH29	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   STCH30	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   STCH31	:1; 	 /* 31..31  bit(s) R */
N} IRREST0_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IRREST0_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IRREST0_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IRREST0_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRREST0()     ((volatile IRREST0_bit_view_st *)\
N(IRREST0_REG__ ))
X#define pst_bitIRREST0()     ((volatile IRREST0_bit_view_st *)(IRREST0_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IRREST0()     ((volatile IRREST0_byte_view_st *)\
N(IRREST0_REG__ ))
X#define pst_u8IRREST0()     ((volatile IRREST0_byte_view_st *)(IRREST0_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IRREST0()     ((volatile IRREST0_halfword_view_st *)\
N(IRREST0_REG__ ))
X#define pst_u16IRREST0()     ((volatile IRREST0_halfword_view_st *)(IRREST0_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IRREST0()     ((volatile u32IRREST0_word_view *)\
N(IRREST0_REG__ ))
X#define pu32IRREST0()     ((volatile u32IRREST0_word_view *)(IRREST0_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRREST0_STCH0() (pst_bitIRREST0() -> STCH0)
N#define biGetIRREST0_STCH1() (pst_bitIRREST0() -> STCH1)
N#define biGetIRREST0_STCH2() (pst_bitIRREST0() -> STCH2)
N#define biGetIRREST0_STCH3() (pst_bitIRREST0() -> STCH3)
N#define biGetIRREST0_STCH4() (pst_bitIRREST0() -> STCH4)
N#define biGetIRREST0_STCH5() (pst_bitIRREST0() -> STCH5)
N#define biGetIRREST0_STCH6() (pst_bitIRREST0() -> STCH6)
N#define biGetIRREST0_STCH7() (pst_bitIRREST0() -> STCH7)
N#define biGetIRREST0_STCH8() (pst_bitIRREST0() -> STCH8)
N#define biGetIRREST0_STCH9() (pst_bitIRREST0() -> STCH9)
N#define biGetIRREST0_STCH10() (pst_bitIRREST0() -> STCH10)
N#define biGetIRREST0_STCH11() (pst_bitIRREST0() -> STCH11)
N#define biGetIRREST0_STCH12() (pst_bitIRREST0() -> STCH12)
N#define biGetIRREST0_STCH13() (pst_bitIRREST0() -> STCH13)
N#define biGetIRREST0_STCH14() (pst_bitIRREST0() -> STCH14)
N#define biGetIRREST0_STCH15() (pst_bitIRREST0() -> STCH15)
N#define biGetIRREST0_STCH16() (pst_bitIRREST0() -> STCH16)
N#define biGetIRREST0_STCH17() (pst_bitIRREST0() -> STCH17)
N#define biGetIRREST0_STCH18() (pst_bitIRREST0() -> STCH18)
N#define biGetIRREST0_STCH19() (pst_bitIRREST0() -> STCH19)
N#define biGetIRREST0_STCH20() (pst_bitIRREST0() -> STCH20)
N#define biGetIRREST0_STCH21() (pst_bitIRREST0() -> STCH21)
N#define biGetIRREST0_STCH22() (pst_bitIRREST0() -> STCH22)
N#define biGetIRREST0_STCH23() (pst_bitIRREST0() -> STCH23)
N#define biGetIRREST0_STCH24() (pst_bitIRREST0() -> STCH24)
N#define biGetIRREST0_STCH25() (pst_bitIRREST0() -> STCH25)
N#define biGetIRREST0_STCH26() (pst_bitIRREST0() -> STCH26)
N#define biGetIRREST0_STCH27() (pst_bitIRREST0() -> STCH27)
N#define biGetIRREST0_STCH28() (pst_bitIRREST0() -> STCH28)
N#define biGetIRREST0_STCH29() (pst_bitIRREST0() -> STCH29)
N#define biGetIRREST0_STCH30() (pst_bitIRREST0() -> STCH30)
N#define biGetIRREST0_STCH31() (pst_bitIRREST0() -> STCH31)
N
N/* LL-struct byte access */
N
N#define u8GetIRREST0LL() (pst_u8IRREST0() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetIRREST0LH() (pst_u8IRREST0() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetIRREST0HL() (pst_u8IRREST0() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetIRREST0HH() (pst_u8IRREST0() -> u8HH)
N
N
N/* Half-word struct access */
N
N#define u16GetIRREST0L() (pst_u16IRREST0() -> u16L)
N
N#define u16GetIRREST0H() (pst_u16IRREST0() -> u16H)
N
N/* Word access */
N
N#define u32GetIRREST0()  (*pu32IRREST0() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IRREST1
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080D8
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRREST1_REG__       0xC01080D8U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   STCH32	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   STCH33	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   STCH34	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   STCH35	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   STCH36	:1; 	 /* 4..4  bit(s) R */
N  uint32_t   STCH37	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   STCH38	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   STCH39	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   STCH40	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   STCH41	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   STCH42	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   STCH43	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   STCH44	:1; 	 /* 12..12  bit(s) R */
N  uint32_t   STCH45	:1; 	 /* 13..13  bit(s) R */
N  uint32_t   STCH46	:1; 	 /* 14..14  bit(s) R */
N  uint32_t   STCH47	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   STCH48	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   STCH49	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   STCH50	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   STCH51	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   STCH52	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   STCH53	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   STCH54	:1; 	 /* 22..22  bit(s) R */
N  uint32_t   STCH55	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   STCH56	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   STCH57	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STCH58	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   STCH59	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   STCH60	:1; 	 /* 28..28  bit(s) R */
N  uint32_t   STCH61	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   STCH62	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   STCH63	:1; 	 /* 31..31  bit(s) R */
N} IRREST1_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IRREST1_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IRREST1_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IRREST1_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRREST1()     ((volatile IRREST1_bit_view_st *)\
N(IRREST1_REG__ ))
X#define pst_bitIRREST1()     ((volatile IRREST1_bit_view_st *)(IRREST1_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IRREST1()     ((volatile IRREST1_byte_view_st *)\
N(IRREST1_REG__ ))
X#define pst_u8IRREST1()     ((volatile IRREST1_byte_view_st *)(IRREST1_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IRREST1()     ((volatile IRREST1_halfword_view_st *)\
N(IRREST1_REG__ ))
X#define pst_u16IRREST1()     ((volatile IRREST1_halfword_view_st *)(IRREST1_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IRREST1()     ((volatile u32IRREST1_word_view *)\
N(IRREST1_REG__ ))
X#define pu32IRREST1()     ((volatile u32IRREST1_word_view *)(IRREST1_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRREST1_STCH32() (pst_bitIRREST1() -> STCH32)
N#define biGetIRREST1_STCH33() (pst_bitIRREST1() -> STCH33)
N#define biGetIRREST1_STCH34() (pst_bitIRREST1() -> STCH34)
N#define biGetIRREST1_STCH35() (pst_bitIRREST1() -> STCH35)
N#define biGetIRREST1_STCH36() (pst_bitIRREST1() -> STCH36)
N#define biGetIRREST1_STCH37() (pst_bitIRREST1() -> STCH37)
N#define biGetIRREST1_STCH38() (pst_bitIRREST1() -> STCH38)
N#define biGetIRREST1_STCH39() (pst_bitIRREST1() -> STCH39)
N#define biGetIRREST1_STCH40() (pst_bitIRREST1() -> STCH40)
N#define biGetIRREST1_STCH41() (pst_bitIRREST1() -> STCH41)
N#define biGetIRREST1_STCH42() (pst_bitIRREST1() -> STCH42)
N#define biGetIRREST1_STCH43() (pst_bitIRREST1() -> STCH43)
N#define biGetIRREST1_STCH44() (pst_bitIRREST1() -> STCH44)
N#define biGetIRREST1_STCH45() (pst_bitIRREST1() -> STCH45)
N#define biGetIRREST1_STCH46() (pst_bitIRREST1() -> STCH46)
N#define biGetIRREST1_STCH47() (pst_bitIRREST1() -> STCH47)
N#define biGetIRREST1_STCH48() (pst_bitIRREST1() -> STCH48)
N#define biGetIRREST1_STCH49() (pst_bitIRREST1() -> STCH49)
N#define biGetIRREST1_STCH50() (pst_bitIRREST1() -> STCH50)
N#define biGetIRREST1_STCH51() (pst_bitIRREST1() -> STCH51)
N#define biGetIRREST1_STCH52() (pst_bitIRREST1() -> STCH52)
N#define biGetIRREST1_STCH53() (pst_bitIRREST1() -> STCH53)
N#define biGetIRREST1_STCH54() (pst_bitIRREST1() -> STCH54)
N#define biGetIRREST1_STCH55() (pst_bitIRREST1() -> STCH55)
N#define biGetIRREST1_STCH56() (pst_bitIRREST1() -> STCH56)
N#define biGetIRREST1_STCH57() (pst_bitIRREST1() -> STCH57)
N#define biGetIRREST1_STCH58() (pst_bitIRREST1() -> STCH58)
N#define biGetIRREST1_STCH59() (pst_bitIRREST1() -> STCH59)
N#define biGetIRREST1_STCH60() (pst_bitIRREST1() -> STCH60)
N#define biGetIRREST1_STCH61() (pst_bitIRREST1() -> STCH61)
N#define biGetIRREST1_STCH62() (pst_bitIRREST1() -> STCH62)
N#define biGetIRREST1_STCH63() (pst_bitIRREST1() -> STCH63)
N
N/* LL-struct byte access */
N
N#define u8GetIRREST1LL() (pst_u8IRREST1() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetIRREST1LH() (pst_u8IRREST1() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetIRREST1HL() (pst_u8IRREST1() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetIRREST1HH() (pst_u8IRREST1() -> u8HH)
N
N
N/* Half-word struct access */
N
N#define u16GetIRREST1L() (pst_u16IRREST1() -> u16L)
N
N#define u16GetIRREST1H() (pst_u16IRREST1() -> u16H)
N
N/* Word access */
N
N#define u32GetIRREST1()  (*pu32IRREST1() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IRREST2
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080DC
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRREST2_REG__       0xC01080DCU
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   STCH64	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   STCH65	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   STCH66	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   STCH67	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   STCH68	:1; 	 /* 4..4  bit(s) R */
N  uint32_t   STCH69	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   STCH70	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   STCH71	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   STCH72	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   STCH73	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   STCH74	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   STCH75	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   STCH76	:1; 	 /* 12..12  bit(s) R */
N  uint32_t   STCH77	:1; 	 /* 13..13  bit(s) R */
N  uint32_t   STCH78	:1; 	 /* 14..14  bit(s) R */
N  uint32_t   STCH79	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   STCH80	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   STCH81	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   STCH82	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   STCH83	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   STCH84	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   STCH85	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   STCH86	:1; 	 /* 22..22  bit(s) R */
N  uint32_t   STCH87	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   STCH88	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   STCH89	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STCH90	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   STCH91	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   STCH92	:1; 	 /* 28..28  bit(s) R */
N  uint32_t   STCH93	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   STCH94	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   STCH95	:1; 	 /* 31..31  bit(s) R */
N} IRREST2_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IRREST2_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IRREST2_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IRREST2_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRREST2()     ((volatile IRREST2_bit_view_st *)\
N(IRREST2_REG__ ))
X#define pst_bitIRREST2()     ((volatile IRREST2_bit_view_st *)(IRREST2_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IRREST2()     ((volatile IRREST2_byte_view_st *)\
N(IRREST2_REG__ ))
X#define pst_u8IRREST2()     ((volatile IRREST2_byte_view_st *)(IRREST2_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IRREST2()     ((volatile IRREST2_halfword_view_st *)\
N(IRREST2_REG__ ))
X#define pst_u16IRREST2()     ((volatile IRREST2_halfword_view_st *)(IRREST2_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IRREST2()     ((volatile u32IRREST2_word_view *)\
N(IRREST2_REG__ ))
X#define pu32IRREST2()     ((volatile u32IRREST2_word_view *)(IRREST2_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRREST2_STCH64() (pst_bitIRREST2() -> STCH64)
N#define biGetIRREST2_STCH65() (pst_bitIRREST2() -> STCH65)
N#define biGetIRREST2_STCH66() (pst_bitIRREST2() -> STCH66)
N#define biGetIRREST2_STCH67() (pst_bitIRREST2() -> STCH67)
N#define biGetIRREST2_STCH68() (pst_bitIRREST2() -> STCH68)
N#define biGetIRREST2_STCH69() (pst_bitIRREST2() -> STCH69)
N#define biGetIRREST2_STCH70() (pst_bitIRREST2() -> STCH70)
N#define biGetIRREST2_STCH71() (pst_bitIRREST2() -> STCH71)
N#define biGetIRREST2_STCH72() (pst_bitIRREST2() -> STCH72)
N#define biGetIRREST2_STCH73() (pst_bitIRREST2() -> STCH73)
N#define biGetIRREST2_STCH74() (pst_bitIRREST2() -> STCH74)
N#define biGetIRREST2_STCH75() (pst_bitIRREST2() -> STCH75)
N#define biGetIRREST2_STCH76() (pst_bitIRREST2() -> STCH76)
N#define biGetIRREST2_STCH77() (pst_bitIRREST2() -> STCH77)
N#define biGetIRREST2_STCH78() (pst_bitIRREST2() -> STCH78)
N#define biGetIRREST2_STCH79() (pst_bitIRREST2() -> STCH79)
N#define biGetIRREST2_STCH80() (pst_bitIRREST2() -> STCH80)
N#define biGetIRREST2_STCH81() (pst_bitIRREST2() -> STCH81)
N#define biGetIRREST2_STCH82() (pst_bitIRREST2() -> STCH82)
N#define biGetIRREST2_STCH83() (pst_bitIRREST2() -> STCH83)
N#define biGetIRREST2_STCH84() (pst_bitIRREST2() -> STCH84)
N#define biGetIRREST2_STCH85() (pst_bitIRREST2() -> STCH85)
N#define biGetIRREST2_STCH86() (pst_bitIRREST2() -> STCH86)
N#define biGetIRREST2_STCH87() (pst_bitIRREST2() -> STCH87)
N#define biGetIRREST2_STCH88() (pst_bitIRREST2() -> STCH88)
N#define biGetIRREST2_STCH89() (pst_bitIRREST2() -> STCH89)
N#define biGetIRREST2_STCH90() (pst_bitIRREST2() -> STCH90)
N#define biGetIRREST2_STCH91() (pst_bitIRREST2() -> STCH91)
N#define biGetIRREST2_STCH92() (pst_bitIRREST2() -> STCH92)
N#define biGetIRREST2_STCH93() (pst_bitIRREST2() -> STCH93)
N#define biGetIRREST2_STCH94() (pst_bitIRREST2() -> STCH94)
N#define biGetIRREST2_STCH95() (pst_bitIRREST2() -> STCH95)
N
N/* LL-struct byte access */
N
N#define u8GetIRREST2LL() (pst_u8IRREST2() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetIRREST2LH() (pst_u8IRREST2() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetIRREST2HL() (pst_u8IRREST2() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetIRREST2HH() (pst_u8IRREST2() -> u8HH)
N
N
N/* Half-word struct access */
N
N#define u16GetIRREST2L() (pst_u16IRREST2() -> u16L)
N
N#define u16GetIRREST2H() (pst_u16IRREST2() -> u16H)
N
N/* Word access */
N
N#define u32GetIRREST2()  (*pu32IRREST2() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IRREST3
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080E0
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRREST3_REG__       0xC01080E0U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   STCH96	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   STCH97	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   STCH98	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   STCH99	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   STCH100	:1; 	 /* 4..4  bit(s) R */
N  uint32_t   STCH101	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   STCH102	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   STCH103	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   STCH104	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   STCH105	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   STCH106	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   STCH107	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   STCH108	:1; 	 /* 12..12  bit(s) R */
N  uint32_t   STCH109	:1; 	 /* 13..13  bit(s) R */
N  uint32_t   STCH110	:1; 	 /* 14..14  bit(s) R */
N  uint32_t   STCH111	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   STCH112	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   STCH113	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   STCH114	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   STCH115	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   STCH116	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   STCH117	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   STCH118	:1; 	 /* 22..22  bit(s) R */
N  uint32_t   STCH119	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   STCH120	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   STCH121	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STCH122	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   STCH123	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   STCH124	:1; 	 /* 28..28  bit(s) R */
N  uint32_t   STCH125	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   STCH126	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   STCH127	:1; 	 /* 31..31  bit(s) R */
N} IRREST3_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IRREST3_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IRREST3_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IRREST3_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRREST3()     ((volatile IRREST3_bit_view_st *)\
N(IRREST3_REG__ ))
X#define pst_bitIRREST3()     ((volatile IRREST3_bit_view_st *)(IRREST3_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IRREST3()     ((volatile IRREST3_byte_view_st *)\
N(IRREST3_REG__ ))
X#define pst_u8IRREST3()     ((volatile IRREST3_byte_view_st *)(IRREST3_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IRREST3()     ((volatile IRREST3_halfword_view_st *)\
N(IRREST3_REG__ ))
X#define pst_u16IRREST3()     ((volatile IRREST3_halfword_view_st *)(IRREST3_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IRREST3()     ((volatile u32IRREST3_word_view *)\
N(IRREST3_REG__ ))
X#define pu32IRREST3()     ((volatile u32IRREST3_word_view *)(IRREST3_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRREST3_STCH96() (pst_bitIRREST3() -> STCH96)
N#define biGetIRREST3_STCH97() (pst_bitIRREST3() -> STCH97)
N#define biGetIRREST3_STCH98() (pst_bitIRREST3() -> STCH98)
N#define biGetIRREST3_STCH99() (pst_bitIRREST3() -> STCH99)
N#define biGetIRREST3_STCH100() (pst_bitIRREST3() -> STCH100)
N#define biGetIRREST3_STCH101() (pst_bitIRREST3() -> STCH101)
N#define biGetIRREST3_STCH102() (pst_bitIRREST3() -> STCH102)
N#define biGetIRREST3_STCH103() (pst_bitIRREST3() -> STCH103)
N#define biGetIRREST3_STCH104() (pst_bitIRREST3() -> STCH104)
N#define biGetIRREST3_STCH105() (pst_bitIRREST3() -> STCH105)
N#define biGetIRREST3_STCH106() (pst_bitIRREST3() -> STCH106)
N#define biGetIRREST3_STCH107() (pst_bitIRREST3() -> STCH107)
N#define biGetIRREST3_STCH108() (pst_bitIRREST3() -> STCH108)
N#define biGetIRREST3_STCH109() (pst_bitIRREST3() -> STCH109)
N#define biGetIRREST3_STCH110() (pst_bitIRREST3() -> STCH110)
N#define biGetIRREST3_STCH111() (pst_bitIRREST3() -> STCH111)
N#define biGetIRREST3_STCH112() (pst_bitIRREST3() -> STCH112)
N#define biGetIRREST3_STCH113() (pst_bitIRREST3() -> STCH113)
N#define biGetIRREST3_STCH114() (pst_bitIRREST3() -> STCH114)
N#define biGetIRREST3_STCH115() (pst_bitIRREST3() -> STCH115)
N#define biGetIRREST3_STCH116() (pst_bitIRREST3() -> STCH116)
N#define biGetIRREST3_STCH117() (pst_bitIRREST3() -> STCH117)
N#define biGetIRREST3_STCH118() (pst_bitIRREST3() -> STCH118)
N#define biGetIRREST3_STCH119() (pst_bitIRREST3() -> STCH119)
N#define biGetIRREST3_STCH120() (pst_bitIRREST3() -> STCH120)
N#define biGetIRREST3_STCH121() (pst_bitIRREST3() -> STCH121)
N#define biGetIRREST3_STCH122() (pst_bitIRREST3() -> STCH122)
N#define biGetIRREST3_STCH123() (pst_bitIRREST3() -> STCH123)
N#define biGetIRREST3_STCH124() (pst_bitIRREST3() -> STCH124)
N#define biGetIRREST3_STCH125() (pst_bitIRREST3() -> STCH125)
N#define biGetIRREST3_STCH126() (pst_bitIRREST3() -> STCH126)
N#define biGetIRREST3_STCH127() (pst_bitIRREST3() -> STCH127)
N
N/* LL-struct byte access */
N
N#define u8GetIRREST3LL() (pst_u8IRREST3() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetIRREST3LH() (pst_u8IRREST3() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetIRREST3HL() (pst_u8IRREST3() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetIRREST3HH() (pst_u8IRREST3() -> u8HH)
N
N
N/* Half-word struct access */
N
N#define u16GetIRREST3L() (pst_u16IRREST3() -> u16L)
N
N#define u16GetIRREST3H() (pst_u16IRREST3() -> u16H)
N
N/* Word access */
N
N#define u32GetIRREST3()  (*pu32IRREST3() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IRREST4
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080E4
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRREST4_REG__       0xC01080E4U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   STCH128	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   STCH129	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   STCH130	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   STCH131	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   STCH132	:1; 	 /* 4..4  bit(s) R */
N  uint32_t   STCH133	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   STCH134	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   STCH135	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   STCH136	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   STCH137	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   STCH138	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   STCH139	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   STCH140	:1; 	 /* 12..12  bit(s) R */
N  uint32_t   STCH141	:1; 	 /* 13..13  bit(s) R */
N  uint32_t   STCH142	:1; 	 /* 14..14  bit(s) R */
N  uint32_t   STCH143	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   STCH144	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   STCH145	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   STCH146	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   STCH147	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   STCH148	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   STCH149	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   STCH150	:1; 	 /* 22..22  bit(s) R */
N  uint32_t   STCH151	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   STCH152	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   STCH153	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STCH154	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   STCH155	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   STCH156	:1; 	 /* 28..28  bit(s) R */
N  uint32_t   STCH157	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   STCH158	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   STCH159	:1; 	 /* 31..31  bit(s) R */
N} IRREST4_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IRREST4_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IRREST4_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IRREST4_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRREST4()     ((volatile IRREST4_bit_view_st *)\
N(IRREST4_REG__ ))
X#define pst_bitIRREST4()     ((volatile IRREST4_bit_view_st *)(IRREST4_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IRREST4()     ((volatile IRREST4_byte_view_st *)\
N(IRREST4_REG__ ))
X#define pst_u8IRREST4()     ((volatile IRREST4_byte_view_st *)(IRREST4_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IRREST4()     ((volatile IRREST4_halfword_view_st *)\
N(IRREST4_REG__ ))
X#define pst_u16IRREST4()     ((volatile IRREST4_halfword_view_st *)(IRREST4_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IRREST4()     ((volatile u32IRREST4_word_view *)\
N(IRREST4_REG__ ))
X#define pu32IRREST4()     ((volatile u32IRREST4_word_view *)(IRREST4_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRREST4_STCH128() (pst_bitIRREST4() -> STCH128)
N#define biGetIRREST4_STCH129() (pst_bitIRREST4() -> STCH129)
N#define biGetIRREST4_STCH130() (pst_bitIRREST4() -> STCH130)
N#define biGetIRREST4_STCH131() (pst_bitIRREST4() -> STCH131)
N#define biGetIRREST4_STCH132() (pst_bitIRREST4() -> STCH132)
N#define biGetIRREST4_STCH133() (pst_bitIRREST4() -> STCH133)
N#define biGetIRREST4_STCH134() (pst_bitIRREST4() -> STCH134)
N#define biGetIRREST4_STCH135() (pst_bitIRREST4() -> STCH135)
N#define biGetIRREST4_STCH136() (pst_bitIRREST4() -> STCH136)
N#define biGetIRREST4_STCH137() (pst_bitIRREST4() -> STCH137)
N#define biGetIRREST4_STCH138() (pst_bitIRREST4() -> STCH138)
N#define biGetIRREST4_STCH139() (pst_bitIRREST4() -> STCH139)
N#define biGetIRREST4_STCH140() (pst_bitIRREST4() -> STCH140)
N#define biGetIRREST4_STCH141() (pst_bitIRREST4() -> STCH141)
N#define biGetIRREST4_STCH142() (pst_bitIRREST4() -> STCH142)
N#define biGetIRREST4_STCH143() (pst_bitIRREST4() -> STCH143)
N#define biGetIRREST4_STCH144() (pst_bitIRREST4() -> STCH144)
N#define biGetIRREST4_STCH145() (pst_bitIRREST4() -> STCH145)
N#define biGetIRREST4_STCH146() (pst_bitIRREST4() -> STCH146)
N#define biGetIRREST4_STCH147() (pst_bitIRREST4() -> STCH147)
N#define biGetIRREST4_STCH148() (pst_bitIRREST4() -> STCH148)
N#define biGetIRREST4_STCH149() (pst_bitIRREST4() -> STCH149)
N#define biGetIRREST4_STCH150() (pst_bitIRREST4() -> STCH150)
N#define biGetIRREST4_STCH151() (pst_bitIRREST4() -> STCH151)
N#define biGetIRREST4_STCH152() (pst_bitIRREST4() -> STCH152)
N#define biGetIRREST4_STCH153() (pst_bitIRREST4() -> STCH153)
N#define biGetIRREST4_STCH154() (pst_bitIRREST4() -> STCH154)
N#define biGetIRREST4_STCH155() (pst_bitIRREST4() -> STCH155)
N#define biGetIRREST4_STCH156() (pst_bitIRREST4() -> STCH156)
N#define biGetIRREST4_STCH157() (pst_bitIRREST4() -> STCH157)
N#define biGetIRREST4_STCH158() (pst_bitIRREST4() -> STCH158)
N#define biGetIRREST4_STCH159() (pst_bitIRREST4() -> STCH159)
N
N/* LL-struct byte access */
N
N#define u8GetIRREST4LL() (pst_u8IRREST4() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetIRREST4LH() (pst_u8IRREST4() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetIRREST4HL() (pst_u8IRREST4() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetIRREST4HH() (pst_u8IRREST4() -> u8HH)
N
N
N/* Half-word struct access */
N
N#define u16GetIRREST4L() (pst_u16IRREST4() -> u16L)
N
N#define u16GetIRREST4H() (pst_u16IRREST4() -> u16H)
N
N/* Word access */
N
N#define u32GetIRREST4()  (*pu32IRREST4() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IRREST5
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080E8
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IRREST5_REG__       0xC01080E8U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   STCH160	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   STCH161	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   STCH162	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   STCH163	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   STCH164	:1; 	 /* 4..4  bit(s) R */
N  uint32_t   STCH165	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   STCH166	:1; 	 /* 6..6  bit(s) R */
N  uint32_t   STCH167	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   STCH168	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   STCH169	:1; 	 /* 9..9  bit(s) R */
N  uint32_t   STCH170	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   STCH171	:1; 	 /* 11..11  bit(s) R */
N  uint32_t   STCH172	:1; 	 /* 12..12  bit(s) R */
N  uint32_t   STCH173	:1; 	 /* 13..13  bit(s) R */
N  uint32_t   STCH174	:1; 	 /* 14..14  bit(s) R */
N  uint32_t   STCH175	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   STCH176	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   STCH177	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   STCH178	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   STCH179	:1; 	 /* 19..19  bit(s) R */
N  uint32_t   STCH180	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   STCH181	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   STCH182	:1; 	 /* 22..22  bit(s) R */
N  uint32_t   STCH183	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   STCH184	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   STCH185	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STCH186	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   STCH187	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   STCH188	:1; 	 /* 28..28  bit(s) R */
N  uint32_t   STCH189	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   STCH190	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   STCH191	:1; 	 /* 31..31  bit(s) R */
N} IRREST5_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} IRREST5_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} IRREST5_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32IRREST5_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIRREST5()     ((volatile IRREST5_bit_view_st *)\
N(IRREST5_REG__ ))
X#define pst_bitIRREST5()     ((volatile IRREST5_bit_view_st *)(IRREST5_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IRREST5()     ((volatile IRREST5_byte_view_st *)\
N(IRREST5_REG__ ))
X#define pst_u8IRREST5()     ((volatile IRREST5_byte_view_st *)(IRREST5_REG__ ))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16IRREST5()     ((volatile IRREST5_halfword_view_st *)\
N(IRREST5_REG__ ))
X#define pst_u16IRREST5()     ((volatile IRREST5_halfword_view_st *)(IRREST5_REG__ ))
N
N/* Pointer to WORD  */
N#define pu32IRREST5()     ((volatile u32IRREST5_word_view *)\
N(IRREST5_REG__ ))
X#define pu32IRREST5()     ((volatile u32IRREST5_word_view *)(IRREST5_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIRREST5_STCH160() (pst_bitIRREST5() -> STCH160)
N#define biGetIRREST5_STCH161() (pst_bitIRREST5() -> STCH161)
N#define biGetIRREST5_STCH162() (pst_bitIRREST5() -> STCH162)
N#define biGetIRREST5_STCH163() (pst_bitIRREST5() -> STCH163)
N#define biGetIRREST5_STCH164() (pst_bitIRREST5() -> STCH164)
N#define biGetIRREST5_STCH165() (pst_bitIRREST5() -> STCH165)
N#define biGetIRREST5_STCH166() (pst_bitIRREST5() -> STCH166)
N#define biGetIRREST5_STCH167() (pst_bitIRREST5() -> STCH167)
N#define biGetIRREST5_STCH168() (pst_bitIRREST5() -> STCH168)
N#define biGetIRREST5_STCH169() (pst_bitIRREST5() -> STCH169)
N#define biGetIRREST5_STCH170() (pst_bitIRREST5() -> STCH170)
N#define biGetIRREST5_STCH171() (pst_bitIRREST5() -> STCH171)
N#define biGetIRREST5_STCH172() (pst_bitIRREST5() -> STCH172)
N#define biGetIRREST5_STCH173() (pst_bitIRREST5() -> STCH173)
N#define biGetIRREST5_STCH174() (pst_bitIRREST5() -> STCH174)
N#define biGetIRREST5_STCH175() (pst_bitIRREST5() -> STCH175)
N#define biGetIRREST5_STCH176() (pst_bitIRREST5() -> STCH176)
N#define biGetIRREST5_STCH177() (pst_bitIRREST5() -> STCH177)
N#define biGetIRREST5_STCH178() (pst_bitIRREST5() -> STCH178)
N#define biGetIRREST5_STCH179() (pst_bitIRREST5() -> STCH179)
N#define biGetIRREST5_STCH180() (pst_bitIRREST5() -> STCH180)
N#define biGetIRREST5_STCH181() (pst_bitIRREST5() -> STCH181)
N#define biGetIRREST5_STCH182() (pst_bitIRREST5() -> STCH182)
N#define biGetIRREST5_STCH183() (pst_bitIRREST5() -> STCH183)
N#define biGetIRREST5_STCH184() (pst_bitIRREST5() -> STCH184)
N#define biGetIRREST5_STCH185() (pst_bitIRREST5() -> STCH185)
N#define biGetIRREST5_STCH186() (pst_bitIRREST5() -> STCH186)
N#define biGetIRREST5_STCH187() (pst_bitIRREST5() -> STCH187)
N#define biGetIRREST5_STCH188() (pst_bitIRREST5() -> STCH188)
N#define biGetIRREST5_STCH189() (pst_bitIRREST5() -> STCH189)
N#define biGetIRREST5_STCH190() (pst_bitIRREST5() -> STCH190)
N#define biGetIRREST5_STCH191() (pst_bitIRREST5() -> STCH191)
N
N/* LL-struct byte access */
N
N#define u8GetIRREST5LL() (pst_u8IRREST5() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetIRREST5LH() (pst_u8IRREST5() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetIRREST5HL() (pst_u8IRREST5() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetIRREST5HH() (pst_u8IRREST5() -> u8HH)
N
N
N/* Half-word struct access */
N
N#define u16GetIRREST5L() (pst_u16IRREST5() -> u16L)
N
N#define u16GetIRREST5H() (pst_u16IRREST5() -> u16H)
N
N/* Word access */
N
N#define u32GetIRREST5()  (*pu32IRREST5() )
N
N
N/****************************************************************************
N*
N*       REGISTER: IWPERR
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC01080EC
N*       ACCESS  : 8, 16, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define IWPERR_REG__       0xC01080ECU
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint16_t   IWPNTEN	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   	:7; 	 /* 1..7  bit(s) R */
N  uint16_t   IWPINTCLR	:1; 	 /* 8..8  bit(s) R/W */
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */
N} IWPERR_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8L;
N  uint8_t u8H;
N} IWPERR_byte_view_st;
N
N/* HALFWORD View */
Ntypedef uint16_t u16IWPERR_halfword_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitIWPERR()     ((volatile IWPERR_bit_view_st *)\
N(IWPERR_REG__ ))
X#define pst_bitIWPERR()     ((volatile IWPERR_bit_view_st *)(IWPERR_REG__ ))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8IWPERR()     ((volatile IWPERR_byte_view_st *)\
N(IWPERR_REG__ ))
X#define pst_u8IWPERR()     ((volatile IWPERR_byte_view_st *)(IWPERR_REG__ ))
N
N/* Pointer to HALFWORD */
N#define pu16IWPERR()     ((volatile u16IWPERR_halfword_view *)\
N(IWPERR_REG__ ))
X#define pu16IWPERR()     ((volatile u16IWPERR_halfword_view *)(IWPERR_REG__ ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetIWPERR_IWPNTEN() (pst_bitIWPERR() -> IWPNTEN)
N#define vSetIWPERR_IWPNTEN(ParValue)  (pst_bitIWPERR() -> IWPNTEN=(ParValue))
N#define biGetIWPERR_IWPINTCLR() (pst_bitIWPERR() -> IWPINTCLR)
N#define vSetIWPERR_IWPINTCLR(ParValue)  (pst_bitIWPERR() -> IWPINTCLR=(ParValue))
N
N/* L-struct byte access */
N#define vSetIWPERRL(ParValue) (pst_u8IWPERR() -> u8L = (ParValue))
N#define u8GetIWPERRL() (pst_u8IWPERR() -> u8L)
N/* H-struct byte access */
N#define vSetIWPERRH(ParValue) (pst_u8IWPERR() -> u8H = (ParValue))
N#define u8GetIWPERRH() (pst_u8IWPERR() -> u8H)
N
N/* Half-word access */
N#define vSetIWPERR(ParValue) (*pu16IWPERR()  = (ParValue))
N#define u16GetIWPERR() (*pu16IWPERR() )
N
N/****************************************************************************
N*
N*       REGISTER: ISRADDR
N*       SIZE    : 32-bits
N*       ADDRESS : 0xC0108200
N*       ACCESS  : 8, 16, 32, BIT-level
N*
N*****************************************************************************/
N/* Assign Register address: */
N#define ISRADDR_REG__       0xC0108200U
N
N/************************       STRUCTURES        ***************************/
N
N
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:2; 	 /* 0..1  bit(s) R */
N  uint32_t   ISRADDR	:30; 	 /* 2..31  bit(s) R/W */
N} ISRADDR_bit_view_st;
N
N
N/* BYTE View */
Ntypedef struct{
N  uint8_t u8LL;
N  uint8_t u8LH;
N  uint8_t u8HL;
N  uint8_t u8HH;
N} ISRADDR_byte_view_st;
N
N/* HALFWORD View */
Ntypedef struct{
N  uint16_t u16L;
N  uint16_t u16H;
N} ISRADDR_halfword_view_st;
N
N/* WORD View */
Ntypedef uint32_t u32ISRADDR_word_view;
N
N
N
N/************************     ACCESS POINTERS    ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitISRADDR(ch)     ((volatile ISRADDR_bit_view_st *)\
N(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pst_bitISRADDR(ch)     ((volatile ISRADDR_bit_view_st *)(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/* Pointer to BYTE-struct  */
N#define pst_u8ISRADDR(ch)     ((volatile ISRADDR_byte_view_st *)\
N(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pst_u8ISRADDR(ch)     ((volatile ISRADDR_byte_view_st *)(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16ISRADDR(ch)     ((volatile ISRADDR_halfword_view_st *)\
N(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pst_u16ISRADDR(ch)     ((volatile ISRADDR_halfword_view_st *)(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/* Pointer to WORD  */
N#define pu32ISRADDR(ch)     ((volatile u32ISRADDR_word_view *)\
N(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
X#define pu32ISRADDR(ch)     ((volatile u32ISRADDR_word_view *)(ISRADDR_REG__  + ((uint16_t)(ch) * 0x004U)))
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetISRADDR_ISRADDR(ch) (pst_bitISRADDR(ch) -> ISRADDR)
N#define vSetISRADDR_ISRADDR(ch,ParValue)  (pst_bitISRADDR(ch) -> ISRADDR=(ParValue))
N
N/* LL-struct byte access */
N#define vSetISRADDRLL(ch,ParValue) (pst_u8ISRADDR(ch) -> u8LL = (ParValue))
N#define u8GetISRADDRLL(ch) (pst_u8ISRADDR(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetISRADDRLH(ch,ParValue) (pst_u8ISRADDR(ch) -> u8LH = (ParValue))
N#define u8GetISRADDRLH(ch) (pst_u8ISRADDR(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetISRADDRHL(ch,ParValue) (pst_u8ISRADDR(ch) -> u8HL = (ParValue))
N#define u8GetISRADDRHL(ch) (pst_u8ISRADDR(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetISRADDRHH(ch,ParValue) (pst_u8ISRADDR(ch) -> u8HH = (ParValue))
N#define u8GetISRADDRHH(ch) (pst_u8ISRADDR(ch) -> u8HH)
N
N
N/* Half-word struct access */
N#define vSetISRADDRL(ch,ParValue) (pst_u16ISRADDR(ch) -> u16L = (ParValue))
N#define u16GetISRADDRL(ch) (pst_u16ISRADDR(ch) -> u16L)
N#define vSetISRADDRH(ch,ParValue) (pst_u16ISRADDR(ch) -> u16H = (ParValue))
N#define u16GetISRADDRH(ch) (pst_u16ISRADDR(ch) -> u16H)
N
N/* Word access */
N#define vSetISRADDR(ch,ParValue)  (*pu32ISRADDR(ch) = (ParValue))
N#define u32GetISRADDR(ch)  (*pu32ISRADDR(ch) )
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S#pragma ghs endnowarning /* enable Rule 3.5 [R] : derived  disable warnings for nonstandard type for a bit field */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#endif /* _INTCIO_H */
N
N/************************** BEGIN of DISCLAIMER   *************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products. Nevertheless, semiconductor devices in general can
N  malfunction or fail due to their inherent electrical sensitivity and
N  vulnerability to physical stress. It is the responsibility of the buyer,
N  when utilizing TOSHIBA products, to comply with the standards of safety
N  in making a safe design for the entire system, and to avoid situations in
N  which a malfunction or failure of such TOSHIBA products could cause loss of
N  human life, bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications.
N  Also, please keep in mind the precautions and conditions set forth in the
N  Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment, office
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.).
N  These Toshiba products are neither intended nor warranted for usage in
N  equipment that requires extraordinarily high quality and/or reliability or
N  a malfunction or failure of which may cause loss of human life or bodily
N  injury (Unintended Usage). Unintended Usage include atomic energy control
N  instruments, airplane or spaceship instruments, transportation instruments,
N  traffic signal instruments, combustion control instruments, medical
N  instruments, all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be
N  made at the customers own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring
N  from the use of, or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\intc.c" 2
N#include "intc.h"                           /* INTC definitions */
L 1 "..\..\..\..\lldd\inc\intc.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Reference Interrupt Controller (INTC) Low Level Device Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Interrupt Controller (INTC)
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.12 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef INTC_H
N#define INTC_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"                      /* Core specific primitive type definitions */
N
N/*********************************************/
N
N/*********************************************
N*        Disable Misra Warnings/Rules        *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S/* disable warnings for nonstandard type for a bit field */
S#pragma ghs nowarning 230
S#pragma ghs nowarning 79
S/* disable MISRA 2004 Rule 10.5 because for satisfaction this rule violation of rule 10.3 is required */
S#pragma ghs nowarning 1849
N#endif
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_INTC_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_INTC_H_TAG          "$Name: LLDD_1_6 $"
N
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N/* Number of possible external interrupt source */
N#define NUM_EXTERNAL_INT_SOURCES     9U
N/* Number of possible internal interrupt source */
N#define NUM_INTERNAL_INT_SOURCES     126U
N/* Number of reserved interrupt source slots */
N#define NUM_RESERVED_INT_SOURCES     57U
N
N/* Total number of interrupt sources */
N#define NUM_INT_SOURCES              (NUM_EXTERNAL_INT_SOURCES + NUM_INTERNAL_INT_SOURCES)
N
N/* Maximum number of interrupt sources */
N#define NUM_INT_SLOTS                (NUM_INT_SOURCES + NUM_RESERVED_INT_SOURCES)
N
N/* Masks for compacting interrupt source information */
N#define INT_VECTOR_MASK              0x000003FFU
N#define IR_OFFSET_MASK               0x000000FFU
N#define REC_MODE_MASK                0x0000000F
N#define LAST_SRC_INDEX               178U
N
N/*********************************************/
N
N
N/**********************************************
N*                    Macros                   *
N**********************************************/
N
N/* Extract register offset */
N#define INTC_GET_ROFST(val)       (  ((uint32_t)(val)) &  ((uint32_t) IR_OFFSET_MASK ))
N/* Compact register offset */
N#define INTC_SET_ROFST(val)       ( ((uint32_t)(val)) & ((uint32_t) IR_OFFSET_MASK) )
N
N/* Extract vector offset */
N#define INTC_GET_VOFST(val)       ( ( ((uint32_t) (val) ) >> 8 ) & ( (uint32_t) INT_VECTOR_MASK ) )
N/* Compact vector offset */
N#define INTC_SET_VOFST(val)       ( ( ( (uint32_t) (val) ) & ( (uint32_t) INT_VECTOR_MASK )) << 8)
N
N/* Extract recognition mode */
N#define INTC_GET_MODE(val)        (  ( ((uint32_t) (val) ) >> 24 ) & ((uint32_t) REC_MODE_MASK) )
N/* Compact recognition mode */
N#define INTC_SET_MODE(val)        ( ((uint32_t) (val) ) << 24)
N
N/*
N *  Pack register offset, vector offset
N *  and recognition mode in a single word
N */
N#define INTC_CON(roffst, voffst, moffst)    ( INTC_SET_ROFST(roffst) | INTC_SET_VOFST(voffst) | INTC_SET_MODE(moffst) )
N
N/*********************************************/
N
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
Ntypedef enum tag_intc_enable_e
N{
N    INTC_DISABLE = 0,                       /* INTC disable */
N    INTC_ENABLE  = 1                        /* INTC enable */
N} intc_enable_e;
N
N/*
N *  IR[00-47] parameter values
N */
N
N/* IR[xx].EIM - Interrupt recognition mode */
Ntypedef enum tag_intc_eim_e
N{
N    INTC_LEVEL_LO   = 0,                    /* Low-level active */
N    INTC_LEVEL_HI   = 1,                    /* High-level active */
N    INTC_EDGE_FALL  = 2,                    /* Falling-edge */
N    INTC_EDGE_RISE  = 3,                    /* Rising-edge */
N    INTC_RM_CONFIG  = 4,                    /* configurable recognition mode */
N    INTC_RM_DEFAULT = 5,                    /* default recognition mode */
N    INTC_NA         = 6                     /* NA for check */
N} intc_eim_e;
N
N/* IR[xx].DRS - Interrupt redirect selection */
Ntypedef enum tag_intc_drs_e
N{
N    INTC_TO_CPU = 0,                        /* IRQ will be carried to the CPU */
N    INTC_TO_DMA = 1                         /* IRQ used as request for DMA */
N} intc_drs_e;
N
N/* IR[xx].ACLR - Interrupt auto clearing */
Ntypedef enum tag_intc_aclr_e
N{
N    INTC_AUTO_CLEAR_DISABLE = 0,            /* IRQ will be carried to the CPU */
N    INTC_AUTO_CLEAR_ENABLE  = 1             /* IRQ used as request for DMA */
N} intc_aclr_e;
N
N/* IR[xx].EXT - Priority of the interrupt source (DRS == 0) / DMA channel (DRS == 1) */
Ntypedef enum tag_intc_ext_e
N{
N    INTC_LEVEL_0 = 0,                       /* Priority level 0 [disabled] / DMA Channel 0 */
N    INTC_LEVEL_1 = 1,                       /* Priority level 1 [lowest]   / DMA Channel 1 */
N    INTC_LEVEL_2 = 2,                       /* Priority level 2            / DMA Channel 2 */
N    INTC_LEVEL_3 = 3,                       /* Priority level 3            / DMA Channel 3 */
N    INTC_LEVEL_4 = 4,                       /* Priority level 4            / DMA Channel 4 */
N    INTC_LEVEL_5 = 5,                       /* Priority level 5            / DMA Channel 5 */
N    INTC_LEVEL_6 = 6,                       /* Priority level 6            / DMA Channel 6 */
N    INTC_LEVEL_7 = 7                        /* Priority level 7 [highest]  / DMA Channel 7 */
N} intc_ext_e;
N
N/* *** */
N
N/*
N *  Word compacting:
N *      - interrupt register number (not offset)
N *      - interrupt vector offset
N *      - default recognition mode
N */
Ntypedef enum tag_intc_src_e
N{
N    INTC_DUMMY_0       = INTC_CON(  0, 0x000, INTC_NA),
X    INTC_DUMMY_0       = ( ( ((uint32_t)(0)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x000) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N
N    INTC_EXTINT0       = INTC_CON(  1, 0x004, INTC_RM_CONFIG),
X    INTC_EXTINT0       = ( ( ((uint32_t)(1)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x004) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_EXTINT1       = INTC_CON(  2, 0x008, INTC_RM_CONFIG),
X    INTC_EXTINT1       = ( ( ((uint32_t)(2)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x008) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_EXTINT2       = INTC_CON(  3, 0x00C, INTC_RM_CONFIG),
X    INTC_EXTINT2       = ( ( ((uint32_t)(3)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x00C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_EXTINT3       = INTC_CON(  4, 0x010, INTC_RM_CONFIG),
X    INTC_EXTINT3       = ( ( ((uint32_t)(4)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x010) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_EXTINT4       = INTC_CON(  5, 0x014, INTC_RM_CONFIG),
X    INTC_EXTINT4       = ( ( ((uint32_t)(5)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x014) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_EXTINT5       = INTC_CON(  6, 0x018, INTC_RM_CONFIG),
X    INTC_EXTINT5       = ( ( ((uint32_t)(6)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x018) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N
N    INTC_DUMMY_1       = INTC_CON(  7, 0x01C, INTC_NA),
X    INTC_DUMMY_1       = ( ( ((uint32_t)(7)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x01C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_2       = INTC_CON(  8, 0x020, INTC_NA),
X    INTC_DUMMY_2       = ( ( ((uint32_t)(8)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x020) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_3       = INTC_CON(  9, 0x024, INTC_NA),
X    INTC_DUMMY_3       = ( ( ((uint32_t)(9)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x024) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_4       = INTC_CON( 10, 0x028, INTC_NA),
X    INTC_DUMMY_4       = ( ( ((uint32_t)(10)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x028) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_5       = INTC_CON( 11, 0x02C, INTC_NA),
X    INTC_DUMMY_5       = ( ( ((uint32_t)(11)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x02C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_6       = INTC_CON( 12, 0x030, INTC_NA),
X    INTC_DUMMY_6       = ( ( ((uint32_t)(12)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x030) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_7       = INTC_CON( 13, 0x034, INTC_NA),
X    INTC_DUMMY_7       = ( ( ((uint32_t)(13)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x034) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_8       = INTC_CON( 14, 0x038, INTC_NA),
X    INTC_DUMMY_8       = ( ( ((uint32_t)(14)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x038) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N
N    INTC_WDT           = INTC_CON( 15, 0x03C, INTC_EDGE_RISE),
X    INTC_WDT           = ( ( ((uint32_t)(15)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x03C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N
N    INTC_DUMMY_9       = INTC_CON( 16, 0x040, INTC_NA),
X    INTC_DUMMY_9       = ( ( ((uint32_t)(16)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x040) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N
N    INTC_ECCSRAM       = INTC_CON( 17, 0x044, INTC_LEVEL_HI),
X    INTC_ECCSRAM       = ( ( ((uint32_t)(17)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x044) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_DUMMY_10      = INTC_CON( 18, 0x048, INTC_NA),
X    INTC_DUMMY_10      = ( ( ((uint32_t)(18)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x048) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_ECCBAKRAM     = INTC_CON( 19, 0x04C, INTC_LEVEL_HI),
X    INTC_ECCBAKRAM     = ( ( ((uint32_t)(19)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x04C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_GAMPI         = INTC_CON( 20, 0x050, INTC_LEVEL_HI),
X    INTC_GAMPI         = ( ( ((uint32_t)(20)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x050) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_PINMUX        = INTC_CON( 21, 0x054, INTC_EDGE_RISE),
X    INTC_PINMUX        = ( ( ((uint32_t)(21)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x054) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N
N    INTC_IRC           = INTC_CON( 22, 0x058, INTC_LEVEL_HI),
X    INTC_IRC           = ( ( ((uint32_t)(22)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x058) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_TSMRXFIFO     = INTC_CON( 23, 0x05C, INTC_EDGE_RISE),
X    INTC_TSMRXFIFO     = ( ( ((uint32_t)(23)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x05C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_TSMTXFIFO     = INTC_CON( 24, 0x060, INTC_EDGE_RISE),
X    INTC_TSMTXFIFO     = ( ( ((uint32_t)(24)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x060) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_TSMAPERC      = INTC_CON( 25, 0x064, INTC_LEVEL_HI),
X    INTC_TSMAPERC      = ( ( ((uint32_t)(25)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x064) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TSMERCBUSY    = INTC_CON( 26, 0x068, INTC_EDGE_RISE),
X    INTC_TSMERCBUSY    = ( ( ((uint32_t)(26)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x068) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_TSMFW         = INTC_CON( 27, 0x06C, INTC_EDGE_RISE),
X    INTC_TSMFW         = ( ( ((uint32_t)(27)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x06C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N
N    INTC_SYSC          = INTC_CON( 28, 0x070, INTC_LEVEL_HI),
X    INTC_SYSC          = ( ( ((uint32_t)(28)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x070) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_RTC           = INTC_CON( 29, 0x074, INTC_EDGE_RISE),
X    INTC_RTC           = ( ( ((uint32_t)(29)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x074) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N
N    INTC_APC0          = INTC_CON( 30, 0x078, INTC_LEVEL_HI),
X    INTC_APC0          = ( ( ((uint32_t)(30)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x078) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_APC1          = INTC_CON( 31, 0x07C, INTC_LEVEL_HI),
X    INTC_APC1          = ( ( ((uint32_t)(31)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x07C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_QSPI0         = INTC_CON( 32, 0x080, INTC_LEVEL_HI),
X    INTC_QSPI0         = ( ( ((uint32_t)(32)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x080) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_QSPI1         = INTC_CON( 33, 0x084, INTC_LEVEL_HI),
X    INTC_QSPI1         = ( ( ((uint32_t)(33)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x084) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_QSPI2         = INTC_CON( 34, 0x088, INTC_LEVEL_HI),
X    INTC_QSPI2         = ( ( ((uint32_t)(34)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x088) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_PARFLINT      = INTC_CON( 35, 0x08C, INTC_LEVEL_HI),
X    INTC_PARFLINT      = ( ( ((uint32_t)(35)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x08C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_PARFLINT0     = INTC_CON( 36, 0x090, INTC_LEVEL_HI),
X    INTC_PARFLINT0     = ( ( ((uint32_t)(36)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x090) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_PARFLINT1     = INTC_CON( 37, 0x094, INTC_LEVEL_HI),
X    INTC_PARFLINT1     = ( ( ((uint32_t)(37)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x094) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_PARFLECCINT   = INTC_CON( 38, 0x098, INTC_LEVEL_HI),
X    INTC_PARFLECCINT   = ( ( ((uint32_t)(38)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x098) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_DUMMY_11      = INTC_CON( 39, 0x09C, INTC_NA),
X    INTC_DUMMY_11      = ( ( ((uint32_t)(39)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x09C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_12      = INTC_CON( 40, 0x0A0, INTC_NA),
X    INTC_DUMMY_12      = ( ( ((uint32_t)(40)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0A0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N
N    INTC_SMC           = INTC_CON( 41, 0x0A4, INTC_EDGE_RISE),
X    INTC_SMC           = ( ( ((uint32_t)(41)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0A4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N
N    INTC_DUMMY_13      = INTC_CON( 42, 0x0A8, INTC_NA),
X    INTC_DUMMY_13      = ( ( ((uint32_t)(42)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0A8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_14      = INTC_CON( 43, 0x0AC, INTC_NA),
X    INTC_DUMMY_14      = ( ( ((uint32_t)(43)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0AC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N    INTC_DUMMY_15      = INTC_CON( 44, 0x0B0, INTC_NA),
X    INTC_DUMMY_15      = ( ( ((uint32_t)(44)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0B0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_NA) ) << 24) ),
N
N    INTC_GDC0          = INTC_CON( 45, 0x0B4, INTC_LEVEL_HI),
X    INTC_GDC0          = ( ( ((uint32_t)(45)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0B4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_GDC1          = INTC_CON( 46, 0x0B8, INTC_LEVEL_HI),
X    INTC_GDC1          = ( ( ((uint32_t)(46)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0B8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_FG            = INTC_CON( 47, 0x0BC, INTC_LEVEL_HI),
X    INTC_FG            = ( ( ((uint32_t)(47)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0BC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_GA            = INTC_CON( 48, 0x0C0, INTC_LEVEL_HI),
X    INTC_GA            = ( ( ((uint32_t)(48)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0C0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_PNGGIR        = INTC_CON( 49, 0x0C4, INTC_RM_CONFIG),
X    INTC_PNGGIR        = ( ( ((uint32_t)(49)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0C4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR0       = INTC_CON( 50, 0x0C8, INTC_RM_CONFIG),
X    INTC_PNGSIR0       = ( ( ((uint32_t)(50)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0C8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR1       = INTC_CON( 51, 0x0CC, INTC_RM_CONFIG),
X    INTC_PNGSIR1       = ( ( ((uint32_t)(51)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0CC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR2       = INTC_CON( 52, 0x0D0, INTC_RM_CONFIG),
X    INTC_PNGSIR2       = ( ( ((uint32_t)(52)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0D0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR3       = INTC_CON( 53, 0x0D4, INTC_RM_CONFIG),
X    INTC_PNGSIR3       = ( ( ((uint32_t)(53)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0D4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR4       = INTC_CON( 54, 0x0D8, INTC_RM_CONFIG),
X    INTC_PNGSIR4       = ( ( ((uint32_t)(54)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0D8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR5       = INTC_CON( 55, 0x0DC, INTC_RM_CONFIG),
X    INTC_PNGSIR5       = ( ( ((uint32_t)(55)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0DC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR6       = INTC_CON( 56, 0x0E0, INTC_RM_CONFIG),
X    INTC_PNGSIR6       = ( ( ((uint32_t)(56)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0E0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N    INTC_PNGSIR7       = INTC_CON( 57, 0x0E4, INTC_RM_CONFIG),
X    INTC_PNGSIR7       = ( ( ((uint32_t)(57)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0E4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) ),
N
N    INTC_MLBSYS        = INTC_CON( 58, 0x0E8, INTC_LEVEL_HI),
X    INTC_MLBSYS        = ( ( ((uint32_t)(58)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0E8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_MLBCHAN       = INTC_CON( 59, 0x0EC, INTC_LEVEL_HI),
X    INTC_MLBCHAN       = ( ( ((uint32_t)(59)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0EC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_MLBDCHAN0     = INTC_CON( 60, 0x0F0, INTC_EDGE_RISE),
X    INTC_MLBDCHAN0     = ( ( ((uint32_t)(60)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0F0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_MLBDCHAN1     = INTC_CON( 61, 0x0F4, INTC_EDGE_RISE),
X    INTC_MLBDCHAN1     = ( ( ((uint32_t)(61)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0F4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_MLBDCHAN2     = INTC_CON( 62, 0x0F8, INTC_EDGE_RISE),
X    INTC_MLBDCHAN2     = ( ( ((uint32_t)(62)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0F8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_MLBDCHAN3     = INTC_CON( 63, 0x0FC, INTC_EDGE_RISE),
X    INTC_MLBDCHAN3     = ( ( ((uint32_t)(63)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x0FC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_MLBDCHAN4     = INTC_CON( 64, 0x100, INTC_EDGE_RISE),
X    INTC_MLBDCHAN4     = ( ( ((uint32_t)(64)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x100) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_MLBDCHAN5     = INTC_CON( 65, 0x104, INTC_EDGE_RISE),
X    INTC_MLBDCHAN5     = ( ( ((uint32_t)(65)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x104) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N
N    INTC_I2S0          = INTC_CON( 66, 0x108, INTC_LEVEL_HI),
X    INTC_I2S0          = ( ( ((uint32_t)(66)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x108) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_I2S1          = INTC_CON( 67, 0x10C, INTC_LEVEL_HI),
X    INTC_I2S1          = ( ( ((uint32_t)(67)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x10C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_TIM0_MAVAL0   = INTC_CON( 68, 0x110, INTC_EDGE_FALL),
X    INTC_TIM0_MAVAL0   = ( ( ((uint32_t)(68)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x110) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM0_MAVAL1   = INTC_CON( 69, 0x114, INTC_EDGE_FALL),
X    INTC_TIM0_MAVAL1   = ( ( ((uint32_t)(69)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x114) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM0_CMPVAL0  = INTC_CON( 70, 0x118, INTC_EDGE_FALL),
X    INTC_TIM0_CMPVAL0  = ( ( ((uint32_t)(70)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x118) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM0_CMPVAL1  = INTC_CON( 71, 0x11C, INTC_EDGE_FALL),
X    INTC_TIM0_CMPVAL1  = ( ( ((uint32_t)(71)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x11C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM1_MAVAL0   = INTC_CON( 72, 0x120, INTC_EDGE_FALL),
X    INTC_TIM1_MAVAL0   = ( ( ((uint32_t)(72)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x120) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM1_MAVAL1   = INTC_CON( 73, 0x124, INTC_EDGE_FALL),
X    INTC_TIM1_MAVAL1   = ( ( ((uint32_t)(73)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x124) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM1_CMPVAL0  = INTC_CON( 74, 0x128, INTC_EDGE_FALL),
X    INTC_TIM1_CMPVAL0  = ( ( ((uint32_t)(74)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x128) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM1_CMPVAL1  = INTC_CON( 75, 0x12C, INTC_EDGE_FALL),
X    INTC_TIM1_CMPVAL1  = ( ( ((uint32_t)(75)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x12C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM2_MAVAL0   = INTC_CON( 76, 0x130, INTC_EDGE_FALL),
X    INTC_TIM2_MAVAL0   = ( ( ((uint32_t)(76)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x130) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM2_MAVAL1   = INTC_CON( 77, 0x134, INTC_EDGE_FALL),
X    INTC_TIM2_MAVAL1   = ( ( ((uint32_t)(77)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x134) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM2_CMPVAL0  = INTC_CON( 78, 0x138, INTC_EDGE_FALL),
X    INTC_TIM2_CMPVAL0  = ( ( ((uint32_t)(78)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x138) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM2_CMPVAL1  = INTC_CON( 79, 0x13C, INTC_EDGE_FALL),
X    INTC_TIM2_CMPVAL1  = ( ( ((uint32_t)(79)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x13C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM3_MAVAL0   = INTC_CON( 80, 0x140, INTC_EDGE_FALL),
X    INTC_TIM3_MAVAL0   = ( ( ((uint32_t)(80)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x140) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM3_MAVAL1   = INTC_CON( 81, 0x144, INTC_EDGE_FALL),
X    INTC_TIM3_MAVAL1   = ( ( ((uint32_t)(81)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x144) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM3_CMPVAL0  = INTC_CON( 82, 0x148, INTC_EDGE_FALL),
X    INTC_TIM3_CMPVAL0  = ( ( ((uint32_t)(82)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x148) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM3_CMPVAL1  = INTC_CON( 83, 0x14C, INTC_EDGE_FALL),
X    INTC_TIM3_CMPVAL1  = ( ( ((uint32_t)(83)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x14C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM4_MAVAL0   = INTC_CON( 84, 0x150, INTC_EDGE_FALL),
X    INTC_TIM4_MAVAL0   = ( ( ((uint32_t)(84)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x150) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM4_MAVAL1   = INTC_CON( 85, 0x154, INTC_EDGE_FALL),
X    INTC_TIM4_MAVAL1   = ( ( ((uint32_t)(85)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x154) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM4_CMPVAL0  = INTC_CON( 86, 0x158, INTC_EDGE_FALL),
X    INTC_TIM4_CMPVAL0  = ( ( ((uint32_t)(86)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x158) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM4_CMPVAL1  = INTC_CON( 87, 0x15C, INTC_EDGE_FALL),
X    INTC_TIM4_CMPVAL1  = ( ( ((uint32_t)(87)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x15C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM5_MAVAL0   = INTC_CON( 88, 0x160, INTC_EDGE_FALL),
X    INTC_TIM5_MAVAL0   = ( ( ((uint32_t)(88)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x160) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM5_MAVAL1   = INTC_CON( 89, 0x164, INTC_EDGE_FALL),
X    INTC_TIM5_MAVAL1   = ( ( ((uint32_t)(89)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x164) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM5_CMPVAL0  = INTC_CON( 90, 0x168, INTC_EDGE_FALL),
X    INTC_TIM5_CMPVAL0  = ( ( ((uint32_t)(90)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x168) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM5_CMPVAL1  = INTC_CON( 91, 0x16C, INTC_EDGE_FALL),
X    INTC_TIM5_CMPVAL1  = ( ( ((uint32_t)(91)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x16C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM6_MAVAL0   = INTC_CON( 92, 0x170, INTC_EDGE_FALL),
X    INTC_TIM6_MAVAL0   = ( ( ((uint32_t)(92)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x170) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM6_MAVAL1   = INTC_CON( 93, 0x174, INTC_EDGE_FALL),
X    INTC_TIM6_MAVAL1   = ( ( ((uint32_t)(93)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x174) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM6_CMPVAL0  = INTC_CON( 94, 0x178, INTC_EDGE_FALL),
X    INTC_TIM6_CMPVAL0  = ( ( ((uint32_t)(94)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x178) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM6_CMPVAL1  = INTC_CON( 95, 0x17C, INTC_EDGE_FALL),
X    INTC_TIM6_CMPVAL1  = ( ( ((uint32_t)(95)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x17C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM7_MAVAL0   = INTC_CON( 96, 0x180, INTC_EDGE_FALL),
X    INTC_TIM7_MAVAL0   = ( ( ((uint32_t)(96)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x180) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM7_MAVAL1   = INTC_CON( 97, 0x184, INTC_EDGE_FALL),
X    INTC_TIM7_MAVAL1   = ( ( ((uint32_t)(97)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x184) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM7_CMPVAL0  = INTC_CON( 98, 0x188, INTC_EDGE_FALL),
X    INTC_TIM7_CMPVAL0  = ( ( ((uint32_t)(98)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x188) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM7_CMPVAL1  = INTC_CON( 99, 0x18C, INTC_EDGE_FALL),
X    INTC_TIM7_CMPVAL1  = ( ( ((uint32_t)(99)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x18C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM8_MAVAL0   = INTC_CON(100, 0x190, INTC_EDGE_FALL),
X    INTC_TIM8_MAVAL0   = ( ( ((uint32_t)(100)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x190) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM8_MAVAL1   = INTC_CON(101, 0x194, INTC_EDGE_FALL),
X    INTC_TIM8_MAVAL1   = ( ( ((uint32_t)(101)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x194) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM8_CMPVAL0  = INTC_CON(102, 0x198, INTC_EDGE_FALL),
X    INTC_TIM8_CMPVAL0  = ( ( ((uint32_t)(102)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x198) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM8_CMPVAL1  = INTC_CON(103, 0x19C, INTC_EDGE_FALL),
X    INTC_TIM8_CMPVAL1  = ( ( ((uint32_t)(103)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x19C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM9_MAVAL0   = INTC_CON(104, 0x1A0, INTC_EDGE_FALL),
X    INTC_TIM9_MAVAL0   = ( ( ((uint32_t)(104)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1A0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM9_MAVAL1   = INTC_CON(105, 0x1A4, INTC_EDGE_FALL),
X    INTC_TIM9_MAVAL1   = ( ( ((uint32_t)(105)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1A4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM9_CMPVAL0  = INTC_CON(106, 0x1A8, INTC_EDGE_FALL),
X    INTC_TIM9_CMPVAL0  = ( ( ((uint32_t)(106)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1A8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_TIM9_CMPVAL1  = INTC_CON(107, 0x1AC, INTC_EDGE_FALL),
X    INTC_TIM9_CMPVAL1  = ( ( ((uint32_t)(107)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1AC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N
N    INTC_DMACINTR      = INTC_CON(108, 0x1B0, INTC_LEVEL_HI),
X    INTC_DMACINTR      = ( ( ((uint32_t)(108)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1B0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_ESEI_CH0_RX   = INTC_CON(109, 0x1B4, INTC_LEVEL_HI),
X    INTC_ESEI_CH0_RX   = ( ( ((uint32_t)(109)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1B4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_ESEI_CH0_TX   = INTC_CON(110, 0x1B8, INTC_LEVEL_HI),
X    INTC_ESEI_CH0_TX   = ( ( ((uint32_t)(110)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1B8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_ESEI_CH0_ST   = INTC_CON(111, 0x1BC, INTC_LEVEL_HI),
X    INTC_ESEI_CH0_ST   = ( ( ((uint32_t)(111)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1BC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_ESEI_CH1_RX   = INTC_CON(112, 0x1C0, INTC_LEVEL_HI),
X    INTC_ESEI_CH1_RX   = ( ( ((uint32_t)(112)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1C0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_ESEI_CH1_TX   = INTC_CON(113, 0x1C4, INTC_LEVEL_HI),
X    INTC_ESEI_CH1_TX   = ( ( ((uint32_t)(113)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1C4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_ESEI_CH1_ST   = INTC_CON(114, 0x1C8, INTC_LEVEL_HI),
X    INTC_ESEI_CH1_ST   = ( ( ((uint32_t)(114)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1C8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_TXCAN_CH0_RX  = INTC_CON(115, 0x1CC, INTC_LEVEL_HI),
X    INTC_TXCAN_CH0_RX  = ( ( ((uint32_t)(115)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1CC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH0_TX  = INTC_CON(116, 0x1D0, INTC_LEVEL_HI),
X    INTC_TXCAN_CH0_TX  = ( ( ((uint32_t)(116)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1D0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH0_ST  = INTC_CON(117, 0x1D4, INTC_LEVEL_HI),
X    INTC_TXCAN_CH0_ST  = ( ( ((uint32_t)(117)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1D4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH1_RX  = INTC_CON(118, 0x1D8, INTC_LEVEL_HI),
X    INTC_TXCAN_CH1_RX  = ( ( ((uint32_t)(118)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1D8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH1_TX  = INTC_CON(119, 0x1DC, INTC_LEVEL_HI),
X    INTC_TXCAN_CH1_TX  = ( ( ((uint32_t)(119)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1DC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH1_ST  = INTC_CON(120, 0x1E0, INTC_LEVEL_HI),
X    INTC_TXCAN_CH1_ST  = ( ( ((uint32_t)(120)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1E0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH2_RX  = INTC_CON(121, 0x1E4, INTC_LEVEL_HI),
X    INTC_TXCAN_CH2_RX  = ( ( ((uint32_t)(121)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1E4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH2_TX  = INTC_CON(122, 0x1E8, INTC_LEVEL_HI),
X    INTC_TXCAN_CH2_TX  = ( ( ((uint32_t)(122)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1E8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_TXCAN_CH2_ST  = INTC_CON(123, 0x1EC, INTC_LEVEL_HI),
X    INTC_TXCAN_CH2_ST  = ( ( ((uint32_t)(123)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1EC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_I2C           = INTC_CON(124, 0x1F0, INTC_EDGE_FALL),
X    INTC_I2C           = ( ( ((uint32_t)(124)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1F0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N
N    INTC_HSUART0_TX    = INTC_CON(125, 0x1F4, INTC_LEVEL_LO),
X    INTC_HSUART0_TX    = ( ( ((uint32_t)(125)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1F4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_LO) ) << 24) ),
N    INTC_HSUART0_RX    = INTC_CON(126, 0x1F8, INTC_LEVEL_LO),
X    INTC_HSUART0_RX    = ( ( ((uint32_t)(126)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1F8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_LO) ) << 24) ),
N    INTC_HSUART0_ST    = INTC_CON(127, 0x1FC, INTC_LEVEL_LO),
X    INTC_HSUART0_ST    = ( ( ((uint32_t)(127)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x1FC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_LO) ) << 24) ),
N    INTC_HSUART1_TX    = INTC_CON(128, 0x200, INTC_LEVEL_LO),
X    INTC_HSUART1_TX    = ( ( ((uint32_t)(128)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x200) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_LO) ) << 24) ),
N    INTC_HSUART1_RX    = INTC_CON(129, 0x204, INTC_LEVEL_LO),
X    INTC_HSUART1_RX    = ( ( ((uint32_t)(129)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x204) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_LO) ) << 24) ),
N    INTC_HSUART1_ST    = INTC_CON(130, 0x208, INTC_LEVEL_LO),
X    INTC_HSUART1_ST    = ( ( ((uint32_t)(130)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x208) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_LO) ) << 24) ),
N
N    INTC_BCTRL_TOEC    = INTC_CON(131, 0x20C, INTC_LEVEL_HI),
X    INTC_BCTRL_TOEC    = ( ( ((uint32_t)(131)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x20C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCTRL_DS      = INTC_CON(132, 0x210, INTC_LEVEL_HI),
X    INTC_BCTRL_DS      = ( ( ((uint32_t)(132)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x210) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG0_TOEC    = INTC_CON(133, 0x214, INTC_LEVEL_HI),
X    INTC_BCFG0_TOEC    = ( ( ((uint32_t)(133)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x214) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG0_DS      = INTC_CON(134, 0x218, INTC_LEVEL_HI),
X    INTC_BCFG0_DS      = ( ( ((uint32_t)(134)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x218) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG1_TOEC    = INTC_CON(135, 0x21C, INTC_LEVEL_HI),
X    INTC_BCFG1_TOEC    = ( ( ((uint32_t)(135)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x21C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG1_DS      = INTC_CON(136, 0x220, INTC_LEVEL_HI),
X    INTC_BCFG1_DS      = ( ( ((uint32_t)(136)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x220) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BPERIM_TOEC   = INTC_CON(137, 0x224, INTC_LEVEL_HI),
X    INTC_BPERIM_TOEC   = ( ( ((uint32_t)(137)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x224) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BPERIM_DS     = INTC_CON(138, 0x228, INTC_LEVEL_HI),
X    INTC_BPERIM_DS     = ( ( ((uint32_t)(138)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x228) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BPERINM_TOEC  = INTC_CON(139, 0x22C, INTC_LEVEL_HI),
X    INTC_BPERINM_TOEC  = ( ( ((uint32_t)(139)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x22C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BPERINM_DS    = INTC_CON(140, 0x230, INTC_LEVEL_HI),
X    INTC_BPERINM_DS    = ( ( ((uint32_t)(140)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x230) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG0_GS_TOEC = INTC_CON(141, 0x234, INTC_LEVEL_HI),
X    INTC_BCFG0_GS_TOEC = ( ( ((uint32_t)(141)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x234) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG0_GS_DS   = INTC_CON(142, 0x238, INTC_LEVEL_HI),
X    INTC_BCFG0_GS_DS   = ( ( ((uint32_t)(142)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x238) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG1_GS_TOEC = INTC_CON(143, 0x23C, INTC_LEVEL_HI),
X    INTC_BCFG1_GS_TOEC = ( ( ((uint32_t)(143)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x23C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N    INTC_BCFG1_GS_DS   = INTC_CON(144, 0x240, INTC_LEVEL_HI),
X    INTC_BCFG1_GS_DS   = ( ( ((uint32_t)(144)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x240) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_PWMT0         = INTC_CON(145, 0x244, INTC_EDGE_FALL),
X    INTC_PWMT0         = ( ( ((uint32_t)(145)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x244) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT1         = INTC_CON(146, 0x248, INTC_EDGE_FALL),
X    INTC_PWMT1         = ( ( ((uint32_t)(146)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x248) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT2         = INTC_CON(147, 0x24C, INTC_EDGE_FALL),
X    INTC_PWMT2         = ( ( ((uint32_t)(147)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x24C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT3         = INTC_CON(148, 0x250, INTC_EDGE_FALL),
X    INTC_PWMT3         = ( ( ((uint32_t)(148)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x250) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT4         = INTC_CON(149, 0x254, INTC_EDGE_FALL),
X    INTC_PWMT4         = ( ( ((uint32_t)(149)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x254) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT5         = INTC_CON(150, 0x258, INTC_EDGE_FALL),
X    INTC_PWMT5         = ( ( ((uint32_t)(150)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x258) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT6         = INTC_CON(151, 0x25C, INTC_EDGE_FALL),
X    INTC_PWMT6         = ( ( ((uint32_t)(151)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x25C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT7         = INTC_CON(152, 0x260, INTC_EDGE_FALL),
X    INTC_PWMT7         = ( ( ((uint32_t)(152)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x260) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT8         = INTC_CON(153, 0x264, INTC_EDGE_FALL),
X    INTC_PWMT8         = ( ( ((uint32_t)(153)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x264) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT9         = INTC_CON(154, 0x268, INTC_EDGE_FALL),
X    INTC_PWMT9         = ( ( ((uint32_t)(154)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x268) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT10        = INTC_CON(155, 0x26C, INTC_EDGE_FALL),
X    INTC_PWMT10        = ( ( ((uint32_t)(155)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x26C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT11        = INTC_CON(156, 0x270, INTC_EDGE_FALL),
X    INTC_PWMT11        = ( ( ((uint32_t)(156)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x270) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT12        = INTC_CON(157, 0x274, INTC_EDGE_FALL),
X    INTC_PWMT12        = ( ( ((uint32_t)(157)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x274) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT13        = INTC_CON(158, 0x278, INTC_EDGE_FALL),
X    INTC_PWMT13        = ( ( ((uint32_t)(158)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x278) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT14        = INTC_CON(159, 0x27C, INTC_EDGE_FALL),
X    INTC_PWMT14        = ( ( ((uint32_t)(159)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x27C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT15        = INTC_CON(160, 0x280, INTC_EDGE_FALL),
X    INTC_PWMT15        = ( ( ((uint32_t)(160)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x280) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT16        = INTC_CON(161, 0x284, INTC_EDGE_FALL),
X    INTC_PWMT16        = ( ( ((uint32_t)(161)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x284) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT17        = INTC_CON(162, 0x288, INTC_EDGE_FALL),
X    INTC_PWMT17        = ( ( ((uint32_t)(162)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x288) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT18        = INTC_CON(163, 0x28C, INTC_EDGE_FALL),
X    INTC_PWMT18        = ( ( ((uint32_t)(163)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x28C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT19        = INTC_CON(164, 0x290, INTC_EDGE_FALL),
X    INTC_PWMT19        = ( ( ((uint32_t)(164)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x290) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT20        = INTC_CON(165, 0x294, INTC_EDGE_FALL),
X    INTC_PWMT20        = ( ( ((uint32_t)(165)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x294) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT21        = INTC_CON(166, 0x298, INTC_EDGE_FALL),
X    INTC_PWMT21        = ( ( ((uint32_t)(166)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x298) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT22        = INTC_CON(167, 0x29C, INTC_EDGE_FALL),
X    INTC_PWMT22        = ( ( ((uint32_t)(167)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x29C) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_PWMT23        = INTC_CON(168, 0x2A0, INTC_EDGE_FALL),
X    INTC_PWMT23        = ( ( ((uint32_t)(168)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2A0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N
N    INTC_GPWMT0        = INTC_CON(169, 0x2A4, INTC_EDGE_FALL),
X    INTC_GPWMT0        = ( ( ((uint32_t)(169)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2A4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_GPWMT1        = INTC_CON(170, 0x2A8, INTC_EDGE_FALL),
X    INTC_GPWMT1        = ( ( ((uint32_t)(170)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2A8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N
N    INTC_HSPWMT0       = INTC_CON(171, 0x2AC, INTC_EDGE_FALL),
X    INTC_HSPWMT0       = ( ( ((uint32_t)(171)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2AC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_HSPWMT1       = INTC_CON(172, 0x2B0, INTC_EDGE_FALL),
X    INTC_HSPWMT1       = ( ( ((uint32_t)(172)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2B0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_HSPWMT2       = INTC_CON(173, 0x2B4, INTC_EDGE_FALL),
X    INTC_HSPWMT2       = ( ( ((uint32_t)(173)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2B4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N    INTC_HSPWMT3       = INTC_CON(174, 0x2B8, INTC_EDGE_FALL),
X    INTC_HSPWMT3       = ( ( ((uint32_t)(174)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2B8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_FALL) ) << 24) ),
N
N    INTC_ADC_CC        = INTC_CON(175, 0x2BC, INTC_EDGE_RISE),
X    INTC_ADC_CC        = ( ( ((uint32_t)(175)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2BC) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_ADC_HP        = INTC_CON(176, 0x2C0, INTC_EDGE_RISE),
X    INTC_ADC_HP        = ( ( ((uint32_t)(176)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2C0) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_EDGE_RISE) ) << 24) ),
N    INTC_ADC_COM       = INTC_CON(177, 0x2C4, INTC_LEVEL_HI),
X    INTC_ADC_COM       = ( ( ((uint32_t)(177)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2C4) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_LEVEL_HI) ) << 24) ),
N
N    INTC_WAKEUP        = INTC_CON(178, 0x2C8, INTC_RM_CONFIG)
X    INTC_WAKEUP        = ( ( ((uint32_t)(178)) & ((uint32_t) 0x000000FFU) ) | ( ( ( (uint32_t) (0x2C8) ) & ( (uint32_t) 0x000003FFU )) << 8) | ( ((uint32_t) (INTC_RM_CONFIG) ) << 24) )
N} intc_src_e;
N
N/*
N *  IRST parameter values
N */
N
N/* IRST.RDR[x] - Clear DMA Request channel */
Ntypedef enum tag_intc_req_e
N{
N    INTC_DMA_CH0 = 0,                            /* Clear DMA request to channel 0 */
N    INTC_DMA_CH1 = 1,                            /* Clear DMA request to channel 1 */
N    INTC_DMA_CH2 = 2,                           /* Clear DMA request to channel 2 */
N    INTC_DMA_CH3 = 3,                           /* Clear DMA request to channel 3 */
N    INTC_DMA_CH4 = 4,                           /* Clear DMA request to channel 4 */
N    INTC_DMA_CH5 = 5,                           /* Clear DMA request to channel 5 */
N    INTC_DMA_CH6 = 6,                           /* Clear DMA request to channel 6 */
N    INTC_DMA_CH7 = 7,                           /* Clear DMA request to channel 7 */
N    INTC_DMA_CH_ALL = 0xFF                  /* Clear all requests */
N} intc_irst_e;
N
N
N/*
N *  ILEV parameter values
N */
N
N/* ILEV.MLEV - modify interrupt level */
Ntypedef enum tag_intc_ilev_e
N{
N    INTC_RESTORE_OLD = 0,                   /* Restore old interrupt level */
N    INTC_MODIFY_CURR                        /* Modify current interrupt level */
N} intc_ilev_e;
N
N/* ILEV.PMASK/ILEV.CMAKS - interruüpt levels */
Ntypedef enum tag_intc_level_e
N{
N    INTC_CURRENT = 0,                       /* Current IRQ level */
N    INTC_PREV0,                             /* Previous [0]  IRQ level */
N    INTC_PREV1,
N    INTC_PREV2,
N    INTC_PREV3,
N    INTC_PREV4,
N    INTC_PREV5                              /* Previous [5] IRQ level */
N} intc_level_e;
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      vINTC_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                      uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                      uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N/****************************************************************************
N *
N * Function:      vSetIR_EXT_ByIndex
N *
N * Purpose:       Set bit fields EXT in IR register for a specific channel
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                u8EXT       value of EXT
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vSetIR_EXT_ByIndex (uint8_t u8SrcIx, uint8_t u8EXT);
N
N/****************************************************************************
N *
N * Function:      vSetIR_DRS_ByIndex
N *
N * Purpose:       Set bit fields DRS in IR register for a specific channel
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                u8DRS       value of DRS
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vSetIR_DRS_ByIndex (uint8_t u8SrcIx, uint8_t u8DRS);
N
N
N/****************************************************************************
N *
N * Function:      vSetIR_EIM_ByIndex
N *
N * Purpose:       Set bit fields EIM in IR register for a specific channel
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                u8EIM       value of EIM
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vSetIR_EIM_ByIndex (uint8_t u8SrcIx, uint8_t u8EIM);
N
N
N/****************************************************************************
N *
N * Function:      vSetIR_ACLR_ByIndex
N *
N * Purpose:       Set bit fields ACLR in IR register for a specific channel
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                u8ACLR      value of ACLR
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vSetIR_ACLR_ByIndex(uint8_t u8SrcIx, uint8_t u8ACLR);
N
N
N/****************************************************************************
N *
N * Function:      vSetIR_ByIndex
N *
N * Purpose:       Set IR register with bit fields EXT, DRS, EIM and ACLR for a 
N *                specific channel
N *
N * Inputs:        u8SrcIx          0 to LAST_SRC_INDEX
N *                u8Value_write    value of EXT
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vSetIR_ByIndex (uint8_t u8SrcIx, uint8_t u8Value_write);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_SourceConfig
N *
N * Purpose:       Configure each interrupt source in the INTC
N *
N * Inputs:        eSrc        Interrupt source
N *                eMode       Recognition mode. Please note that if
N *                            INTC_DEFAULT is specified then the it
N *                            is set to the default value for the
N *                            selected module [source]
N *                eDst        Specifies where IRQ request will be routed
N *                            [CPU/DMA/MeP]
N *                eLevel      If the request is routed to the CPU, it
N *                            specifies the priority level, otherwise
N *                            specifies the DMA channel
N *                eAutoClear  Specifies for edge sensitive interrupts
N *                            if the interrupt is cleared automatically
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED on invalid parameters [out of range or not
N *                supported values]. The opeartion will be aborted at
N *                the point of detection, thus some values may not be
N *                set
N *
N * Limitations:   INTC_RM_DEFAULT recognition mode cannot be used for
N *                external interrupt sources (INTC_EINT[0-8]). In such
N *                cases the routine will return C_FAILED and will not
N *                set any value
N *
N *                When routing the IRQ request to DMA the eLevel shall
N *                specify the DMA channel number (0 .. 7). In such cases
N *                the routine will return C_FAILED and will not set any
N *                value
N *
N ***************************************************************************/
Nint32_t i32INTC_SourceConfig(intc_src_e eSrc, intc_drs_e eDst, intc_eim_e eMode, intc_ext_e eLevel, intc_aclr_e eAutoClear);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_SetEIM_ByIndex
N *
N * Purpose:       Configure interrupt bits EIM by an source Index
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                eMode       Recognition mode. Please note that only
N *                            following values can be set:
N *                            INTC_LEVEL_LO, , INTC_LEVEL_HI, INTC_EDGE_FALL
N *                            or INTC_EDGE_RISE
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED on invalid parameters [out of range or not
N *                supported values].
N *
N * Limitations:   INTC_RM_DEFAULT recognition mode cannot be used for
N *                external interrupt sources (INTC_EINT[0-8]). In such
N *                cases the routine will return C_FAILED and will not
N *                set any value
N *
N ***************************************************************************/
Nint32_t i32INTC_SetEIM_ByIndex(uint8_t u8SrcIx, intc_eim_e eMode);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_SetDrsByIndex
N *
N * Purpose:       Configure interrupt bits DRS by an source Index
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                eDst        Specifies where IRQ request will be routed
N *                            [CPU/DMA/MeP]
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED on invalid parameters [out of range or not
N *                supported values].
N *
N * Limitations:   INTC_RM_DEFAULT recognition mode cannot be used for
N *                external interrupt sources (INTC_EINT[0-8]). In such
N *                cases the routine will return C_FAILED and will not
N *                set any value
N *
N ***************************************************************************/
Nint32_t i32INTC_SetDrsByIndex(uint8_t u8SrcIx, intc_drs_e eDst);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_SetExtByIndex
N *
N * Purpose:       Configure interrupt bits EXT by an source Index
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                eLevel      If the request is routed to the CPU, it
N *                            specifies the priority level, otherwise
N *                            specifies the DMA channel
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED on invalid parameters [out of range or not
N *                supported values].
N *
N * Limitations:   INTC_RM_DEFAULT recognition mode cannot be used for
N *                external interrupt sources (INTC_EINT[0-8]). In such
N *                cases the routine will return C_FAILED and will not
N *                set any value
N *
N ***************************************************************************/
Nint32_t i32INTC_SetExtByIndex(uint8_t u8SrcIx, intc_ext_e eLevel);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_SetAclrByIndex
N *
N * Purpose:       Configure interrupt bits ACRL by an source Index
N *
N * Inputs:        u8SrcIx     0 to LAST_SRC_INDEX
N *                eAutoClear  Specifies for edge sensitive interrupts
N *                            if the interrupt is cleared automatically
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED on invalid parameters [out of range or not
N *                supported values].
N *
N * Limitations:   INTC_RM_DEFAULT recognition mode cannot be used for
N *                external interrupt sources (INTC_EINT[0-8]). In such
N *                cases the routine will return C_FAILED and will not
N *                set any value
N *
N ***************************************************************************/
Nint32_t i32INTC_SetAclrByIndex(uint8_t u8SrcIx, intc_aclr_e eAutoClear);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_SetVectBaseAddr
N *
N * Purpose:       Configure the vector base address
N *
N * Inputs:        uiAddr  Virtual vector base address (1024-bytes aligned)
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED if address is not aligned
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32INTC_SetVectBaseAddr(uint32_t u32Addr);
N
N
N/****************************************************************************
N *
N * Function:      u32INTC_GetVectAddr
N *
N * Purpose:       Retrieve the vector offset of the currently pending interrupt
N *                with the highest priority level
N *
N * Inputs:        none
N *
N * Outputs:       Interrupt vector address, relevant to the entry made in IVR
N *
N * Return Values: none
N *
N * Limitations:   Vector base [BVA bits] must be set in advance, otherwise the
N *                the vector address may be invalid
N *
N ***************************************************************************/
Nuint32_t u32INTC_GetVectAddr(void);
N
N
N/****************************************************************************
N *
N * Function:      vINTC_ModifyIrqLevel
N *
N * Purpose:       Modify the masked interrupt level
N *
N * Inputs:        eMode  Specifies whether interrupt level
N *                       will be modified or the old one
N *                       shall be restored
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_ModifyIrqLevel(intc_ilev_e eMode, intc_ext_e eLevel);
N
N
N/****************************************************************************
N *
N * Function:      i32INTC_ClearIrq
N *
N * Purpose:       Clear interrupt source
N *
N * Inputs:        uiVoffset  Vector offset address of the interrupt
N *                           source to be cleared. Internal filtering
N *                           is always applied, so the return value of
N *                           u32INTC_GetVectAddr or inc_voffset_e
N *                           constant can be directly used
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on sucess
N *                C_FAILED if vector offset address is not valid
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32INTC_ClearIrq(uint32_t u32Voffset);
N
N
N/****************************************************************************
N *
N * Function:      vINTC_ClearDmaReq
N *
N * Purpose:       Clear DMA request
N *
N * Inputs:        eReqCh  DMA channel reqest to be cleared
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_ClearDmaReq(intc_irst_e eReqCh);
N
N
N/****************************************************************************
N *
N * Function:      vINTC_BlockVectUpdate
N *
N * Purpose:       Protect the IVR against updates from higher priority
N *                interrupts
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_BlockVectUpdate(void);
N
N
N/****************************************************************************
N *
N * Function:      u8INTC_GetIrqLevel
N *
N * Purpose:       Retrieve nested interrupt level
N *
N *
N * Inputs:        eLevel  Nested interrupt level, whose priority should
N *                        be retrieved
N *
N * Outputs:       The priority of the requested level
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint8_t u8INTC_GetIrqLevel(intc_level_e eLevel);
N
N
N/****************************************************************************
N *
N * Function:      u32INTC_GetIrqStatus
N *
N * Purpose:       Retrieve interrupt request status
N *
N *
N * Inputs:        eSrc  Interrupt source
N *
N * Outputs:       0 - not pending
N *                1 - interrupt requested
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32INTC_GetIrqStatus(intc_src_e eSrc);
N
N
N/****************************************************************************
N *
N * Function:      vINTC_EnableInterrupts
N *
N * Purpose:       Enable interrupts
N *
N *
N * Inputs:        eEnable  INTC_DISABLE or INTC_ENABLE
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_EnableInterrupts(intc_enable_e eEnable);
N
N
N/****************************************************************************
N *
N * Function:      eINTC_GetEnabled
N *
N * Purpose:       returns interrupts status
N *
N *
N * Inputs:        none
N *
N * Outputs:       INTC_DISABLE or INTC_ENABLE
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nintc_enable_e eINTC_GetEnabled( void );
N
N
N/****************************************************************************
N *
N * Function:      vINTC_ClearInterrupt
N *
N * Purpose:       Clear interrupts
N *
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_ClearInterrupt(void);
N
N
N/****************************************************************************
N *
N * Function:      vINTC_SetISRStartAddress
N *
N * Purpose:       Set ISR start address
N *
N *
N * Inputs:        eSrc        Interrupt source
N *                u32Address  ISR start address
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vINTC_SetISRStartAddress(intc_src_e eSrc, uint32_t u32Address);
N
N
N/****************************************************************************
N *
N * Function:      u32INTC_GetISRStartAddress
N *
N * Purpose:       Get ISR start address
N *
N *
N * Inputs:        eSrc  Interrupt source
N *
N * Outputs:       ISR start address
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32INTC_GetISRStartAddress(intc_src_e eSrc);
N
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S/* enable warnings 230 and 79 for nonstandard type for a bit field */
S#pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#endif /* _INTC_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 25 "..\..\..\..\lldd\src\intc.c" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1849    /* Rule 10.5 [R] : bitwise ~ or << expression must be immediately cast back to  underlying type, "unsigned char" */
S  
S  #pragma ghs nowarning 1864    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1865    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1866    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1867    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1868    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S
S  #pragma ghs nowarning 1847    /* Rule 10.3 [R] :  Restrict explicit casts for integer type expressions */
S  #pragma ghs nowarning 1848    /* Rule 10.3 [R] :  Restrict explicit casts for integer type expressions */
S  #pragma ghs nowarning 1879    /* Rule 10.3 [R] :  Restrict explicit casts for integer type expressions */
S  #pragma ghs nowarning 1880    /* Rule 10.3 [R] :  Restrict explicit casts for integer type expressions */
S
S  #pragma ghs nowarning 1834    /* Rule 11.3 [A] : disable casting error (used for result of i/o header amcros) */
S  #pragma ghs nowarning 1840    /* Rule 5.7  [A] : identifier reused from declaration of entity-kind "entity" */
S  
S
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_INTC_C_REVISION     "$Revision: 1.18 $"
N#define LLDD_INTC_C_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
Nstatic uint8_t au8LLDD_INTC_C_REVISION[]    = LLDD_INTC_C_REVISION;
Xstatic uint8_t au8LLDD_INTC_C_REVISION[]    = "$Revision: 1.18 $";
Nstatic uint8_t au8LLDD_INTC_C_TAG[]         = LLDD_INTC_C_TAG;
Xstatic uint8_t au8LLDD_INTC_C_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_INTC_H_REVISION[]    = LLDD_INTC_H_REVISION;
Xstatic uint8_t au8LLDD_INTC_H_REVISION[]    = "$Revision: 1.12 $";
Nstatic uint8_t au8LLDD_INTC_H_TAG[]         = LLDD_INTC_H_TAG;
Xstatic uint8_t au8LLDD_INTC_H_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_INTC_IO_H_REVISION[] = LLDD_INTC_IO_H_REVISION;
Xstatic uint8_t au8LLDD_INTC_IO_H_REVISION[] = "$Revision: 1.12 $";
Nstatic uint8_t au8LLDD_INTC_IO_H_TAG[]      = LLDD_INTC_IO_H_TAG;
Xstatic uint8_t au8LLDD_INTC_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N#define IR_ACRL_SHIFT   7
N#define IR_EIMR_SHIFT   5
N#define IR_DRS_SHIFT    4
N
N/*********************************************/
N
N/**********************************************
N*        Exported function definition         *
N**********************************************/
N
Nvoid vINTC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                      uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                      uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N   *pau8ModuleRevision = &au8LLDD_INTC_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_INTC_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_INTC_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_INTC_H_TAG[0];
N   *pau8IORevision     = &au8LLDD_INTC_IO_H_REVISION[0];
N   *pau8IOTag          = &au8LLDD_INTC_IO_H_TAG[0];
N}
N
N
N/****************************************************************************/
N
Nvoid vSetIR_ByIndex(uint8_t u8SrcIx, uint8_t u8Value_write)
N{
N    uint16_t u16RegIx;
N    uint16_t u16FieldOffs;
N    uint32_t u32RegValue;
N    uint32_t u32RegValueNew;
N    uint32_t u32RegMask[4] = {0xFFFFFF00U, 0xFFFF00FFU, 0xFF00FFFFU, 0x00FFFFFFU};
N
N    /* find out which channel and which field (0..3) in related register */
N    u16RegIx     = u8SrcIx >> 2;
N    u16FieldOffs = u8SrcIx % 4;
N    
N    /* read register */
N    u32RegValue = u32GetIR(u16RegIx);
X    u32RegValue = (*((volatile u32IR_word_view *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) );
N    /* mask related bits */
N    u32RegValue &= u32RegMask[u16FieldOffs];
N    
N    /* build 32 bit new value: */
N    u32RegValueNew = (uint32_t)u8Value_write;
N    u32RegValueNew <<= (8*u16FieldOffs);    
N    u32RegValueNew |= u32RegValue;
N    
N    /* write back value in register: */
N    vSetIR(u16RegIx, u32RegValueNew);
X    (*((volatile u32IR_word_view *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) = (u32RegValueNew));
N}
N
N
N/****************************************************************************/
N
Nvoid vSetIR_EXT_ByIndex(uint8_t u8SrcIx, uint8_t u8EXT)
N{
N    uint16_t u16RegIx;
N    uint16_t u16FieldOffs;
N
N    /* find out which channel and which field (0..3) in related register */
N    u16RegIx     = ((uint16_t) u8SrcIx) >> 2;
N    u16FieldOffs = u8SrcIx % 4;
N    
N    switch ( u16FieldOffs )
N    {
N        case 0:
N            vSetIR_EXT0(u16RegIx, u8EXT);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EXT0=(u8EXT));
N            break;
N
N        case 1:
N            vSetIR_EXT1(u16RegIx, u8EXT);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EXT1=(u8EXT));
N            break;
N
N        case 2:
N            vSetIR_EXT2(u16RegIx, u8EXT);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EXT2=(u8EXT));
N            break;
N
N        default:
N            vSetIR_EXT3(u16RegIx, u8EXT);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EXT3=(u8EXT));
N            break;
N    }
N    
N    return;
N}
N
N
N/****************************************************************************/
N
Nvoid vSetIR_DRS_ByIndex(uint8_t u8SrcIx, uint8_t u8DRS)
N{
N    uint16_t u16RegIx;
N    uint16_t u16FieldOffs;
N
N    /* find out which channel and which field (0..3) in related register */
N    u16RegIx     = ((uint16_t) u8SrcIx) >> 2;
N    u16FieldOffs = u8SrcIx % 4;
N    
N    switch ( u16FieldOffs )
N    {
N        case 0:
N            vSetIR_DRS0(u16RegIx, u8DRS);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> DRS0=(u8DRS));
N            break;
N
N        case 1:
N            vSetIR_DRS1(u16RegIx, u8DRS);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> DRS1=(u8DRS));
N            break;
N
N        case 2:
N            vSetIR_DRS2(u16RegIx, u8DRS);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> DRS2=(u8DRS));
N            break;
N
N        default:
N            vSetIR_DRS3(u16RegIx, u8DRS);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> DRS3=(u8DRS));
N            break;
N    }
N    
N    return;
N}
N
N
N/****************************************************************************/
N
Nvoid vSetIR_ACLR_ByIndex(uint8_t u8SrcIx, uint8_t u8ACLR)
N{
N    uint16_t u16RegIx;
N    uint16_t u16FieldOffs;
N
N    /* find out which channel and which field (0..3) in related register */
N    u16RegIx     = ((uint16_t) u8SrcIx) >> 2;
N    u16FieldOffs = u8SrcIx % 4;
N    
N    switch ( u16FieldOffs )
N    {
N        case 0:
N            vSetIR_ACLR0(u16RegIx, u8ACLR);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> ACLR0=(u8ACLR));
N            break;
N
N        case 1:
N            vSetIR_ACLR1(u16RegIx, u8ACLR);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> ACLR1=(u8ACLR));
N            break;
N
N        case 2:
N            vSetIR_ACLR2(u16RegIx, u8ACLR);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> ACLR2=(u8ACLR));
N            break;
N
N        default:
N            vSetIR_ACLR3(u16RegIx, u8ACLR);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> ACLR3=(u8ACLR));
N            break;
N    }
N    
N    return;
N}
N
N
N/****************************************************************************/
N
Nvoid vSetIR_EIM_ByIndex(uint8_t u8SrcIx, uint8_t u8EIM)
N{
N    uint16_t u16RegIx;
N    uint16_t u16FieldOffs;
N
N    /* find out which channel and which field (0..3) in related register */
N    u16RegIx     = u8SrcIx >> 2;
N    u16FieldOffs = u8SrcIx % 4;
N    
N    switch ( u16FieldOffs )
N    {
N        case 0:
N            vSetIR_EIM0(u16RegIx, u8EIM);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EIM0=(u8EIM));
N            break;
N
N        case 1:
N            vSetIR_EIM1(u16RegIx, u8EIM);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EIM1=(u8EIM));
N            break;
N
N        case 2:
N            vSetIR_EIM2(u16RegIx, u8EIM);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EIM2=(u8EIM));
N            break;
N
N        default:
N            vSetIR_EIM3(u16RegIx, u8EIM);
X            (((volatile IR_bit_view_st *)(0xC0108000U + ((uint16_t)(u16RegIx) * 0x004U))) -> EIM3=(u8EIM));
N            break;
N    }
N    
N    return;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_SourceConfig(intc_src_e eSrc, intc_drs_e eDst, intc_eim_e eMode, intc_ext_e eLevel, intc_aclr_e eAutoClear)
N{
N    int32_t     i32Res = C_SUCCESS;
X    int32_t     i32Res = (0);
N    uint8_t     u8SrcIx;
N    intc_eim_e  eSrcEim;
N    uint8_t     u8Value_write;
N    uint8_t     u8EIM_write, u8DRS_write, u8EXT_write, u8ACLR_write;
N
N
N    u8SrcIx = (uint8_t)INTC_GET_ROFST(eSrc);
X    u8SrcIx = (uint8_t)( ((uint32_t)(eSrc)) & ((uint32_t) 0x000000FFU ));
N
N    /* Check the requested source */
N    if( u8SrcIx > LAST_SRC_INDEX )
X    if( u8SrcIx > 178U )
N    {
N        /* Invalid source */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        /* check valid parameters: */
N        if( (eMode < INTC_NA) && (eLevel <= INTC_LEVEL_7) && (eAutoClear <= INTC_AUTO_CLEAR_ENABLE) && (eDst <= INTC_TO_DMA))
N        {
N            /* get source mode: */
N            eSrcEim = (intc_eim_e) INTC_GET_MODE(eSrc);
X            eSrcEim = (intc_eim_e) ( ( ((uint32_t) (eSrc) ) >> 24 ) & ((uint32_t) 0x0000000F) );
N
N            /* Default mode was requested */
N            if( INTC_RM_DEFAULT == eMode )
N            {
N                /* Is there a valid default mode for this source */
N                if( INTC_NA == eSrcEim )
N                {
N                    /* No default mode available, e.g. external interrupt source */
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                else
N                {
N                    /* Use default recognition mode*/
N                    u8EIM_write = (uint8_t) eSrcEim;
N                }
N            }
N            else
N            {
N                /* Use given recognition mode */
N                u8EIM_write = (uint8_t) eMode;
N            }
N
N            if( C_SUCCESS == i32Res )
X            if( (0) == i32Res )
N            {
N                /* Destination set */
N                u8DRS_write = (uint8_t) eDst;
N
N                /* IRQ Level/DMA channel */
N                u8EXT_write = (uint8_t) eLevel;
N
N                /* Set Auto clear */
N                u8ACLR_write = (uint8_t) eAutoClear;
N            }
N        }
N        else
N        {
N            /* Invalid source */
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N    }
N
N    if( C_SUCCESS == i32Res )
X    if( (0) == i32Res )
N    {
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  /* disable MISRA 2004 Rule 10.5 because for satisfaction this rule violation of rule 10.3 is required */
S  #pragma ghs nowarning 1849
S
N#endif
N        u8Value_write =  (u8ACLR_write << IR_ACRL_SHIFT) |(u8EIM_write<< IR_EIMR_SHIFT) | (u8DRS_write << IR_DRS_SHIFT) | (u8EXT_write);
X        u8Value_write =  (u8ACLR_write << 7) |(u8EIM_write<< 5) | (u8DRS_write << 4) | (u8EXT_write);
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N        vSetIR_ByIndex(u8SrcIx, u8Value_write);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_SetEIM_ByIndex(uint8_t u8SrcIx, intc_eim_e eMode)
N{
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    /* Check the requested source */
N    if( (u8SrcIx > LAST_SRC_INDEX) || (eMode>INTC_EDGE_RISE) )
X    if( (u8SrcIx > 178U) || (eMode>INTC_EDGE_RISE) )
N    {
N        /* Invalid source */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        vSetIR_EIM_ByIndex(u8SrcIx, (uint8_t) eMode);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_SetDrsByIndex(uint8_t u8SrcIx, intc_drs_e eDst)
N{
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    /* Check the requested source */
N    if( (u8SrcIx > LAST_SRC_INDEX) || (eDst > INTC_TO_DMA) )
X    if( (u8SrcIx > 178U) || (eDst > INTC_TO_DMA) )
N    {
N        /* Invalid source */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        vSetIR_DRS_ByIndex(u8SrcIx, (uint8_t) eDst);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_SetExtByIndex(uint8_t u8SrcIx, intc_ext_e eLevel)
N{
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    /* Check the requested source */
N    if( (u8SrcIx > LAST_SRC_INDEX) || (eLevel > INTC_LEVEL_7) )
X    if( (u8SrcIx > 178U) || (eLevel > INTC_LEVEL_7) )
N    {
N        /* Invalid source */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        vSetIR_EXT_ByIndex(u8SrcIx, (uint8_t) eLevel);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_SetAclrByIndex(uint8_t u8SrcIx, intc_aclr_e eAutoClear)
N{
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    /* Check the requested source */
N    if( (u8SrcIx > LAST_SRC_INDEX) || (eAutoClear > INTC_AUTO_CLEAR_ENABLE) )
X    if( (u8SrcIx > 178U) || (eAutoClear > INTC_AUTO_CLEAR_ENABLE) )
N    {
N        /* Invalid source */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        vSetIR_ACLR_ByIndex(u8SrcIx, (uint8_t) eAutoClear);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_SetVectBaseAddr(uint32_t u32Addr)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* Check if address is aligned */
N    if( 0U == (u32Addr & INT_VECTOR_MASK) )
X    if( 0U == (u32Addr & 0x000003FFU) )
N    {
N        vSetIVR( (uint32_t)u32Addr );
X        (*((volatile u32IVR_word_view *)(0xC01080C0U )) = ((uint32_t)u32Addr));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32INTC_GetVectAddr(void)
N{
N    return u32GetIVR();
X    return (*((volatile u32IVR_word_view *)(0xC01080C0U )) );
N}
N
N
N/****************************************************************************/
N
Nvoid vINTC_ModifyIrqLevel(intc_ilev_e eMode, intc_ext_e eLevel)
N{
N    uint32_t u32ILEV;
N
N    if(eMode == INTC_RESTORE_OLD)
N    {
N        /* To restore the old level we have to write 0 to the ILEV register */
N        vSetILEV(0U);
X        (*((volatile u32ILEV_word_view *)(0xC01080C8U )) = (0U));
N    }
N    else
N    {
N        /* Adjust the MLEV bit */
N        u32ILEV = ((uint32_t)eMode << 31);
N        /* Update CMASK */
N        u32ILEV = u32ILEV | ((uint32_t)eLevel & 0x07U);
N        vSetILEV(u32ILEV);
X        (*((volatile u32ILEV_word_view *)(0xC01080C8U )) = (u32ILEV));
N    }
N}
N
N
N/****************************************************************************/
N
Nint32_t i32INTC_ClearIrq(uint32_t u32Voffset)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* Check if the offset is in range */
N    if( (u32Voffset & INT_VECTOR_MASK) <= INTC_GET_VOFST(INTC_WAKEUP) )
X    if( (u32Voffset & 0x000003FFU) <= ( ( ((uint32_t) (INTC_WAKEUP) ) >> 8 ) & ( (uint32_t) 0x000003FFU ) ) )
N    {
N        vSetICLR((uint32_t) (u32Voffset & INT_VECTOR_MASK));
X        (*((volatile u32ICLR_word_view *)(0xC01080C4U )) = ((uint32_t) (u32Voffset & 0x000003FFU)));
N        /*
N         *  Ensure that the interrupt is really cleared before
N         *  returning. ARM data barrier replaces the MIPS "sync"
N         */
N        __DSB();
N    }
N    else
N    {
N        /* Offset out of range */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nvoid vINTC_ClearDmaReq(intc_irst_e eReqCh)
N{
N    /* Clear the requested channel */
N    switch ( eReqCh )
N    {
N        case INTC_DMA_CH0:
N            vClrIRST_RDR0();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR0 = (1));
N            break;
N
N        case INTC_DMA_CH1:
N            vClrIRST_RDR1();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR1 = (1));
N            break;
N
N        case INTC_DMA_CH2:
N            vClrIRST_RDR2();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR2 = (1));
N            break;
N
N        case INTC_DMA_CH3:
N            vClrIRST_RDR3();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR3 = (1));
N            break;
N
N        case INTC_DMA_CH4:
N            vClrIRST_RDR4();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR4 = (1));
N            break;
N
N        case INTC_DMA_CH5:
N            vClrIRST_RDR5();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR5 = (1));
N            break;
N
N        case INTC_DMA_CH6:
N            vClrIRST_RDR6();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR6 = (1));
N            break;
N
N        case INTC_DMA_CH7:
N            vClrIRST_RDR7();
X            (((volatile IRST_bit_view_st *)(0xC01080D0U )) -> RDR7 = (1));
N            break;
N
N        case INTC_DMA_CH_ALL:
N
N        default:
N            /* Clear all requests */
N            vSetIRST(INTC_DMA_CH_ALL);
X            (*((volatile u8IRST_byte_view *)(0xC01080D0U )) = (INTC_DMA_CH_ALL));
N            break;
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vINTC_BlockVectUpdate(void)
N{
N    /*
N     *  Write access to IBLK prevents IVR from being updated
N     *  until a write access to ICLR is performed
N     */
N    vSetIBLK(0);
X    (*((volatile u8IBLK_byte_view *)(0xC01080CCU )) = (0));
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8INTC_GetIrqLevel(intc_level_e eLevel)
N{
N    uint32_t u32IrqLevel;
N
N    switch( eLevel )
N    {
N        case INTC_PREV0:
N            u32IrqLevel = biGetILEV_PMASK0();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> PMASK0);
N            break;
N
N        case INTC_PREV1:
N            u32IrqLevel = biGetILEV_PMASK1();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> PMASK1);
N            break;
N
N        case INTC_PREV2:
N            u32IrqLevel = biGetILEV_PMASK2();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> PMASK2);
N            break;
N
N        case INTC_PREV3:
N            u32IrqLevel = biGetILEV_PMASK3();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> PMASK3);
N            break;
N
N        case INTC_PREV4:
N            u32IrqLevel = biGetILEV_PMASK4();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> PMASK4);
N            break;
N
N        case INTC_PREV5:
N            u32IrqLevel = biGetILEV_PMASK5();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> PMASK5);
N            break;
N
N        case INTC_CURRENT:
N
N        default:
N            /* Current IRQ Level */
N            u32IrqLevel = biGetILEV_CMASK();
X            u32IrqLevel = (((volatile ILEV_bit_view_st *)(0xC01080C8U )) -> CMASK);
N            break;
N    }
N
N    return (uint8_t)u32IrqLevel;
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32INTC_GetIrqStatus(intc_src_e eSrc)
N{
N    uint32_t u32IntNumber, u32IRREST, u32BitNumber, u32Ret;
N
N    /* Get the vector offset of the interrupt source */
N    u32IntNumber = INTC_GET_VOFST(eSrc);
X    u32IntNumber = ( ( ((uint32_t) (eSrc) ) >> 8 ) & ( (uint32_t) 0x000003FFU ) );
N
N    /* Calculate the interrupt number [vector offset divided by 4] */
N    u32IntNumber = u32IntNumber >> 2;
N
N    /* Find out the status register [IRREST] to be used (divide by 32) */
N    u32IRREST = (u32IntNumber >> 5) + 1;
N
N    /* Calculate the corresponding bit number */
N    u32BitNumber = u32IntNumber - (32 * (u32IRREST - 1));
N
N    /* Retrieve the entire status register */
N    switch( u32IRREST )
N    {
N        case 1:
N            u32Ret = u32GetIRREST0();
X            u32Ret = (*((volatile u32IRREST0_word_view *)(0xC01080D4U )) );
N            break;
N
N        case 2:
N            u32Ret = u32GetIRREST1();
X            u32Ret = (*((volatile u32IRREST1_word_view *)(0xC01080D8U )) );
N            break;
N
N        case 3:
N            u32Ret = u32GetIRREST2();
X            u32Ret = (*((volatile u32IRREST2_word_view *)(0xC01080DCU )) );
N            break;
N
N        case 4:
N            u32Ret = u32GetIRREST3();
X            u32Ret = (*((volatile u32IRREST3_word_view *)(0xC01080E0U )) );
N            break;
N
N        case 5:
N            u32Ret = u32GetIRREST4();
X            u32Ret = (*((volatile u32IRREST4_word_view *)(0xC01080E4U )) );
N            break;
N
N        case 6:
N            u32Ret = u32GetIRREST5();
X            u32Ret = (*((volatile u32IRREST5_word_view *)(0xC01080E8U )) );
N            break;
N
N        /* On not existing source simply return not pending */
N        default:
N            u32Ret = 0;
N            break;
N    }
N
N    /* mask out the corresponding bit */
N    u32Ret = u32Ret << ( 31 - u32BitNumber);
N    u32Ret = u32Ret >> 31;
N
N    return u32Ret;
N}
N
N
N/****************************************************************************/
N
Nvoid vINTC_EnableInterrupts(intc_enable_e eEnable)
N{
N    vSetIWPERR_IWPNTEN(eEnable);
X    (((volatile IWPERR_bit_view_st *)(0xC01080ECU )) -> IWPNTEN=(eEnable));
N}
N
N
N/****************************************************************************/
N
Nintc_enable_e eINTC_GetEnabled( void )
N{
N    intc_enable_e eEnable;
N
N    if (0 < biGetIWPERR_IWPNTEN())
X    if (0 < (((volatile IWPERR_bit_view_st *)(0xC01080ECU )) -> IWPNTEN))
N    {
N        eEnable = INTC_ENABLE;
N    }
N    else
N    {
N        eEnable = INTC_DISABLE;
N    }
N    return eEnable;
N
N}
N
N
N/****************************************************************************/
N
Nvoid vINTC_ClearInterrupt(void)
N{
N    vSetIWPERR_IWPINTCLR(0x1);
X    (((volatile IWPERR_bit_view_st *)(0xC01080ECU )) -> IWPINTCLR=(0x1));
N}
N
N
N/****************************************************************************/
N
Nvoid vINTC_SetISRStartAddress(intc_src_e eSrc, uint32_t u32Address)
N{
N    vSetISRADDR(INTC_GET_ROFST(eSrc), u32Address);
X    (*((volatile u32ISRADDR_word_view *)(0xC0108200U + ((uint16_t)(( ((uint32_t)(eSrc)) & ((uint32_t) 0x000000FFU ))) * 0x004U))) = (u32Address));
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32INTC_GetISRStartAddress(intc_src_e eSrc)
N{
N    return u32GetISRADDR(INTC_GET_ROFST(eSrc));
X    return (*((volatile u32ISRADDR_word_view *)(0xC0108200U + ((uint16_t)(( ((uint32_t)(eSrc)) & ((uint32_t) 0x000000FFU ))) * 0x004U))) );
N}
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S/* enable warnings for Misra 10.1 & 10.3 */
S#pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: gdc.c
N**  $Revision: 1.18 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1849 / 10.5 - bitwise ~ or << expression must be immediately cast 
N** |                       back to  underlying type, "unsigned char" 
N** | CONS.  : allow
N** | REASON : We shift 8 bit value but saved before as 16 bit. So with shift by 2
N** |          no data will be lost.
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
