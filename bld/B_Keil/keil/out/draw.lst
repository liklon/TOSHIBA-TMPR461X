L 1 "..\..\..\..\lldd\src\draw.c"
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronic Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : Low-Level Driver for draw engine
N* 
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : GA (Drawing Engine)
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.15 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N****************************************************************************/
N
N/**********************************************
N*            Include Files                    *
N**********************************************/
N#include "ga_io.h"
L 1 "..\..\..\..\lldd\hdr\ga_io.h" 1
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : GA 
N/  Date of creation (y-m-d:time): 2013-06-14+02:00  :  15:42:04.554+02:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.12 $ 
N/  Excel Sheet ver.             : vv1.0
N/  Excel Sheet date             : 2013-Apr-24
N/  Excel Sheet author           : BEL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION :
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : 
N*   LIBRARIES   :
N*****************************************************************************
N*   VERSION     : $Revision: 1.12 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef GAIO_H
N#define GAIO_H
N
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"                      /* Core specific primitive type definitions */ 
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 36 "..\..\..\..\lldd\hdr\ga_io.h" 2
N/*********************************************/
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 230    /* Rule 6.4 [R] : 	nonstandard type for a bit field */
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
N#endif
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N#define LLDD_GA_IO_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_GA_IO_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/**********************************************
N*             extern defined varaibles
N**********************************************/
N#ifdef HW_EMULATION_GA
Sextern  volatile  uint32_t  GASCR_REG_EMUL;
Sextern  volatile  uint32_t  GACLAR_REG_EMUL;
Sextern  volatile  uint32_t  GASR_REG_EMUL;
Sextern  volatile  uint32_t  GAICR_REG_EMUL;
Sextern  volatile  uint32_t  GAIMR_REG_EMUL;
Sextern  volatile  uint32_t  GADR_REG_EMUL;
Sextern  volatile  uint32_t  GARBBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GARBBECR_REG_EMUL;
Sextern  volatile  uint32_t  GACBBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GACBBECR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBRBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBRBECR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBWBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBWBECR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR0LR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR0HR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR1LR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR1HR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPICR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPIMR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPACR_REG_EMUL;
Sextern  volatile  uint32_t  GAGPR_REG_EMUL[32];
Sextern  volatile  uint32_t  GACMDL_REG_EMUL;
Sextern  volatile  uint32_t  GACMDH_REG_EMUL;
Sextern  volatile  uint32_t  GADEFCR_REG_EMUL[64];
S
N#endif
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GASCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00000                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GASCR_REG__       0xC0C00000U
N#else
S#define GASCR_REG__       &GASCR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   GARESET	:1; 	 /* 0..0  bit(s) R/S */
N  uint16_t   GAEN	:1; 	 /* 1..1  bit(s) R/W */
N  uint16_t   	:6; 	 /* 2..7  bit(s) R */
N  uint16_t   DISRA	:1; 	 /* 8..8  bit(s) R/W */ 
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */                    
N} GASCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GASCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GASCR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGASCR()     ((volatile GASCR_bit_view_st *)\
N(GASCR_REG__ ))
X#define pst_bitGASCR()     ((volatile GASCR_bit_view_st *)(GASCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GASCR()     ((volatile GASCR_byte_view_st *)\
N(GASCR_REG__ ))
X#define pst_u8GASCR()     ((volatile GASCR_byte_view_st *)(GASCR_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16GASCR()     ((volatile u16GASCR_halfword_view *)\
N(GASCR_REG__ ))
X#define pu16GASCR()     ((volatile u16GASCR_halfword_view *)(GASCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGASCR_GARESET() (pst_bitGASCR() -> GARESET)
N#define vSetGASCR_GARESET() (pst_bitGASCR() -> GARESET=(1))
N#define biGetGASCR_GAEN() (pst_bitGASCR() -> GAEN)
N#define vSetGASCR_GAEN(ParValue)  (pst_bitGASCR() -> GAEN=(ParValue))
N#define biGetGASCR_DISRA() (pst_bitGASCR() -> DISRA)
N#define vSetGASCR_DISRA(ParValue)  (pst_bitGASCR() -> DISRA=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGASCRL(ParValue) (pst_u8GASCR() -> u8L = (ParValue))
N#define u8GetGASCRL() (pst_u8GASCR() -> u8L)
N/* H-struct byte access */
N#define vSetGASCRH(ParValue) (pst_u8GASCR() -> u8H = (ParValue))
N#define u8GetGASCRH() (pst_u8GASCR() -> u8H)
N            
N/* Half-word access */ 
N#define vSetGASCR(ParValue) (*pu16GASCR()  = (ParValue))
N#define u16GetGASCR() (*pu16GASCR() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACLAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00004                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACLAR_REG__       0xC0C00004U
N#else
S#define GACLAR_REG__       &GACLAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   CSLA	:29; 	 /* 3..31  bit(s) R/W */                    
N} GACLAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GACLAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GACLAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GACLAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGACLAR()     ((volatile GACLAR_bit_view_st *)\
N(GACLAR_REG__ ))
X#define pst_bitGACLAR()     ((volatile GACLAR_bit_view_st *)(GACLAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GACLAR()     ((volatile GACLAR_byte_view_st *)\
N(GACLAR_REG__ ))
X#define pst_u8GACLAR()     ((volatile GACLAR_byte_view_st *)(GACLAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GACLAR()     ((volatile GACLAR_halfword_view_st *)\
N(GACLAR_REG__ ))
X#define pst_u16GACLAR()     ((volatile GACLAR_halfword_view_st *)(GACLAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GACLAR()     ((volatile u32GACLAR_word_view *)\
N(GACLAR_REG__ ))
X#define pu32GACLAR()     ((volatile u32GACLAR_word_view *)(GACLAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGACLAR_CSLA() (pst_bitGACLAR() -> CSLA)
N#define vSetGACLAR_CSLA(ParValue)  (pst_bitGACLAR() -> CSLA=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGACLARLL(ParValue) (pst_u8GACLAR() -> u8LL = (ParValue))
N#define u8GetGACLARLL() (pst_u8GACLAR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGACLARLH(ParValue) (pst_u8GACLAR() -> u8LH = (ParValue))
N#define u8GetGACLARLH() (pst_u8GACLAR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGACLARHL(ParValue) (pst_u8GACLAR() -> u8HL = (ParValue))
N#define u8GetGACLARHL() (pst_u8GACLAR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGACLARHH(ParValue) (pst_u8GACLAR() -> u8HH = (ParValue))
N#define u8GetGACLARHH() (pst_u8GACLAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGACLARL(ParValue) (pst_u16GACLAR() -> u16L = (ParValue))
N#define u16GetGACLARL() (pst_u16GACLAR() -> u16L)
N#define vSetGACLARH(ParValue) (pst_u16GACLAR() -> u16H = (ParValue))
N#define u16GetGACLARH() (pst_u16GACLAR() -> u16H)
N            
N/* Word access */
N#define vSetGACLAR(ParValue)  (*pu32GACLAR() = (ParValue))
N#define u32GetGACLAR()  (*pu32GACLAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GASR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00008                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GASR_REG__       0xC0C00008U
N#else
S#define GASR_REG__       &GASR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   BUSY	:1; 	 /* 0..0  bit(s) R */
N  uint8_t   	:1; 	 /* 1..1  bit(s) R */
N  uint8_t   CSCEF	:1; 	 /* 2..2  bit(s) R */
N  uint8_t   CSLEF	:1; 	 /* 3..3  bit(s) R */ 
N  uint8_t   	:4; 	 /* 4..31  bit(s) R */                    
N} GASR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GASR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGASR()     ((volatile GASR_bit_view_st *)\
N(GASR_REG__ ))
X#define pst_bitGASR()     ((volatile GASR_bit_view_st *)(GASR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8GASR()     ((volatile u8GASR_byte_view *)\
N(GASR_REG__ ))
X#define pu8GASR()     ((volatile u8GASR_byte_view *)(GASR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGASR_BUSY() (pst_bitGASR() -> BUSY)            
N#define biGetGASR_CSCEF() (pst_bitGASR() -> CSCEF)            
N#define biGetGASR_CSLEF() (pst_bitGASR() -> CSLEF)
N            
N/* byte access */
N#define u8GetGASR() (*pu8GASR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAICR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0000C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAICR_REG__       0xC0C0000CU
N#else
S#define GAICR_REG__       &GAICR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GACENDI	:1; 	 /* 0..0  bit(s) R/W1C */
N  uint32_t   	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   CSCEI	:1; 	 /* 2..2  bit(s) R/W1C */
N  uint32_t   CSLEI	:1; 	 /* 3..3  bit(s) R/W1C */
N  uint32_t   GAWBWI	:1; 	 /* 4..4  bit(s) R/W1C */
N  uint32_t   GAWBRI	:1; 	 /* 5..5  bit(s) R/W1C */
N  uint32_t   GACBI	:1; 	 /* 6..6  bit(s) R/W1C */
N  uint32_t   GARBI	:1; 	 /* 7..7  bit(s) R/W1C */ 
N  uint32_t   CSLUI	:24; 	 /* 8..31  bit(s) R/W1C */                    
N} GAICR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAICR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAICR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAICR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAICR()     ((volatile GAICR_bit_view_st *)\
N(GAICR_REG__ ))
X#define pst_bitGAICR()     ((volatile GAICR_bit_view_st *)(GAICR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAICR()     ((volatile GAICR_byte_view_st *)\
N(GAICR_REG__ ))
X#define pst_u8GAICR()     ((volatile GAICR_byte_view_st *)(GAICR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAICR()     ((volatile GAICR_halfword_view_st *)\
N(GAICR_REG__ ))
X#define pst_u16GAICR()     ((volatile GAICR_halfword_view_st *)(GAICR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAICR()     ((volatile u32GAICR_word_view *)\
N(GAICR_REG__ ))
X#define pu32GAICR()     ((volatile u32GAICR_word_view *)(GAICR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAICR_GACENDI() (pst_bitGAICR() -> GACENDI)
N#define vClrGAICR_GACENDI() (pst_bitGAICR() -> GACENDI = (1))
N#define biGetGAICR_CSCEI() (pst_bitGAICR() -> CSCEI)
N#define vClrGAICR_CSCEI() (pst_bitGAICR() -> CSCEI = (1))
N#define biGetGAICR_CSLEI() (pst_bitGAICR() -> CSLEI)
N#define vClrGAICR_CSLEI() (pst_bitGAICR() -> CSLEI = (1))
N#define biGetGAICR_GAWBWI() (pst_bitGAICR() -> GAWBWI)
N#define vClrGAICR_GAWBWI() (pst_bitGAICR() -> GAWBWI = (1))
N#define biGetGAICR_GAWBRI() (pst_bitGAICR() -> GAWBRI)
N#define vClrGAICR_GAWBRI() (pst_bitGAICR() -> GAWBRI = (1))
N#define biGetGAICR_GACBI() (pst_bitGAICR() -> GACBI)
N#define vClrGAICR_GACBI() (pst_bitGAICR() -> GACBI = (1))
N#define biGetGAICR_GARBI() (pst_bitGAICR() -> GARBI)
N#define vClrGAICR_GARBI() (pst_bitGAICR() -> GARBI = (1))
N
N#define biGetGAICR_CSLUI() (pst_bitGAICR() -> CSLUI)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for each interrupt 0..23: */
N#define vClrGAICR_CSLUI(BitNo) (pst_bitGAICR() -> CSLUI = ( (0x000001 << (BitNo)) & 0xFFFFFFU) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..23: */
N#define vClrMultiGAICR_CSLUI(Mask) (pst_bitGAICR() -> CSLUI = ((Mask) & 0xFFFFFFU))
N/*---------------------------------------------------------------------------*/
N/* LL-struct byte access */
N#define vSetGAICRLL(ParValue) (pst_u8GAICR() -> u8LL = (ParValue))
N#define u8GetGAICRLL() (pst_u8GAICR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAICRLH(ParValue) (pst_u8GAICR() -> u8LH = (ParValue))
N#define u8GetGAICRLH() (pst_u8GAICR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAICRHL(ParValue) (pst_u8GAICR() -> u8HL = (ParValue))
N#define u8GetGAICRHL() (pst_u8GAICR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAICRHH(ParValue) (pst_u8GAICR() -> u8HH = (ParValue))
N#define u8GetGAICRHH() (pst_u8GAICR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAICRL(ParValue) (pst_u16GAICR() -> u16L = (ParValue))
N#define u16GetGAICRL() (pst_u16GAICR() -> u16L)
N#define vSetGAICRH(ParValue) (pst_u16GAICR() -> u16H = (ParValue))
N#define u16GetGAICRH() (pst_u16GAICR() -> u16H)
N            
N/* Word access */
N#define vSetGAICR(ParValue)  (*pu32GAICR() = (ParValue))
N#define u32GetGAICR()  (*pu32GAICR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAIMR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAIMR_REG__       0xC0C00010U
N#else
S#define GAIMR_REG__       &GAIMR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GACENDIM	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   CSCEIM	:1; 	 /* 2..2  bit(s) R/W */
N  uint32_t   CSLEIM	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   GAWBWIM	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   GAWBRIM	:1; 	 /* 5..5  bit(s) R/W */
N  uint32_t   GACBIM	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   GARBIM	:1; 	 /* 7..7  bit(s) R/W */ 
N  uint32_t   CSLUIM	:24; 	 /* 8..31  bit(s) R/W */                    
N} GAIMR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAIMR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAIMR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAIMR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAIMR()     ((volatile GAIMR_bit_view_st *)\
N(GAIMR_REG__ ))
X#define pst_bitGAIMR()     ((volatile GAIMR_bit_view_st *)(GAIMR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAIMR()     ((volatile GAIMR_byte_view_st *)\
N(GAIMR_REG__ ))
X#define pst_u8GAIMR()     ((volatile GAIMR_byte_view_st *)(GAIMR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAIMR()     ((volatile GAIMR_halfword_view_st *)\
N(GAIMR_REG__ ))
X#define pst_u16GAIMR()     ((volatile GAIMR_halfword_view_st *)(GAIMR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAIMR()     ((volatile u32GAIMR_word_view *)\
N(GAIMR_REG__ ))
X#define pu32GAIMR()     ((volatile u32GAIMR_word_view *)(GAIMR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAIMR_GACENDIM() (pst_bitGAIMR() -> GACENDIM)
N#define vSetGAIMR_GACENDIM(ParValue)  (pst_bitGAIMR() -> GACENDIM=(ParValue))
N#define biGetGAIMR_CSCEIM() (pst_bitGAIMR() -> CSCEIM)
N#define vSetGAIMR_CSCEIM(ParValue)  (pst_bitGAIMR() -> CSCEIM=(ParValue))
N#define biGetGAIMR_CSLEIM() (pst_bitGAIMR() -> CSLEIM)
N#define vSetGAIMR_CSLEIM(ParValue)  (pst_bitGAIMR() -> CSLEIM=(ParValue))
N#define biGetGAIMR_GAWBWIM() (pst_bitGAIMR() -> GAWBWIM)
N#define vSetGAIMR_GAWBWIM(ParValue)  (pst_bitGAIMR() -> GAWBWIM=(ParValue))
N#define biGetGAIMR_GAWBRIM() (pst_bitGAIMR() -> GAWBRIM)
N#define vSetGAIMR_GAWBRIM(ParValue)  (pst_bitGAIMR() -> GAWBRIM=(ParValue))
N#define biGetGAIMR_GACBIM() (pst_bitGAIMR() -> GACBIM)
N#define vSetGAIMR_GACBIM(ParValue)  (pst_bitGAIMR() -> GACBIM=(ParValue))
N#define biGetGAIMR_GARBIM() (pst_bitGAIMR() -> GARBIM)
N#define vSetGAIMR_GARBIM(ParValue)  (pst_bitGAIMR() -> GARBIM=(ParValue))
N#define biGetGAIMR_CSLUIM() (pst_bitGAIMR() -> CSLUIM)
N#define vSetGAIMR_CSLUIM(ParValue)  (pst_bitGAIMR() -> CSLUIM=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAIMRLL(ParValue) (pst_u8GAIMR() -> u8LL = (ParValue))
N#define u8GetGAIMRLL() (pst_u8GAIMR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAIMRLH(ParValue) (pst_u8GAIMR() -> u8LH = (ParValue))
N#define u8GetGAIMRLH() (pst_u8GAIMR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAIMRHL(ParValue) (pst_u8GAIMR() -> u8HL = (ParValue))
N#define u8GetGAIMRHL() (pst_u8GAIMR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAIMRHH(ParValue) (pst_u8GAIMR() -> u8HH = (ParValue))
N#define u8GetGAIMRHH() (pst_u8GAIMR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAIMRL(ParValue) (pst_u16GAIMR() -> u16L = (ParValue))
N#define u16GetGAIMRL() (pst_u16GAIMR() -> u16L)
N#define vSetGAIMRH(ParValue) (pst_u16GAIMR() -> u16H = (ParValue))
N#define u16GetGAIMRH() (pst_u16GAIMR() -> u16H)
N            
N/* Word access */
N#define vSetGAIMR(ParValue)  (*pu32GAIMR() = (ParValue))
N#define u32GetGAIMR()  (*pu32GAIMR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GADR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00014                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GADR_REG__       0xC0C00014U
N#else
S#define GADR_REG__       &GADR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   GAD	:16; 	 /* 0..15  bit(s) R/W */                    
N} GADR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GADR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GADR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGADR()     ((volatile GADR_bit_view_st *)\
N(GADR_REG__ ))
X#define pst_bitGADR()     ((volatile GADR_bit_view_st *)(GADR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GADR()     ((volatile GADR_byte_view_st *)\
N(GADR_REG__ ))
X#define pst_u8GADR()     ((volatile GADR_byte_view_st *)(GADR_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16GADR()     ((volatile u16GADR_halfword_view *)\
N(GADR_REG__ ))
X#define pu16GADR()     ((volatile u16GADR_halfword_view *)(GADR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGADR_GAD() (pst_bitGADR() -> GAD)
N#define vSetGADR_GAD(ParValue)  (pst_bitGADR() -> GAD=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGADRL(ParValue) (pst_u8GADR() -> u8L = (ParValue))
N#define u8GetGADRL() (pst_u8GADR() -> u8L)
N/* H-struct byte access */
N#define vSetGADRH(ParValue) (pst_u8GADR() -> u8H = (ParValue))
N#define u8GetGADRH() (pst_u8GADR() -> u8H)
N            
N/* Half-word access */ 
N#define vSetGADR(ParValue) (*pu16GADR()  = (ParValue))
N#define u16GetGADR() (*pu16GADR() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GARBBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00020                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GARBBEAR_REG__       0xC0C00020U
N#else
S#define GARBBEAR_REG__       &GARBBEAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   RBA	:29; 	 /* 3..31  bit(s) R */                    
N} GARBBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GARBBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GARBBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GARBBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGARBBEAR()     ((volatile GARBBEAR_bit_view_st *)\
N(GARBBEAR_REG__ ))
X#define pst_bitGARBBEAR()     ((volatile GARBBEAR_bit_view_st *)(GARBBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GARBBEAR()     ((volatile GARBBEAR_byte_view_st *)\
N(GARBBEAR_REG__ ))
X#define pst_u8GARBBEAR()     ((volatile GARBBEAR_byte_view_st *)(GARBBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GARBBEAR()     ((volatile GARBBEAR_halfword_view_st *)\
N(GARBBEAR_REG__ ))
X#define pst_u16GARBBEAR()     ((volatile GARBBEAR_halfword_view_st *)(GARBBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GARBBEAR()     ((volatile u32GARBBEAR_word_view *)\
N(GARBBEAR_REG__ ))
X#define pu32GARBBEAR()     ((volatile u32GARBBEAR_word_view *)(GARBBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGARBBEAR_RBA() (pst_bitGARBBEAR() -> RBA)
N            
N/* LL-struct byte access */
N#define u8GetGARBBEARLL() (pst_u8GARBBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGARBBEARLH() (pst_u8GARBBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGARBBEARHL() (pst_u8GARBBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGARBBEARHH() (pst_u8GARBBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGARBBEARL() (pst_u16GARBBEAR() -> u16L)
N#define u16GetGARBBEARH() (pst_u16GARBBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGARBBEAR()  (*pu32GARBBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GARBBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00024                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GARBBECR_REG__       0xC0C00024U
N#else
S#define GARBBECR_REG__       &GARBBECR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GARBBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GARBBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GARBBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GARBBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGARBBECR()     ((volatile GARBBECR_bit_view_st *)\
N(GARBBECR_REG__ ))
X#define pst_bitGARBBECR()     ((volatile GARBBECR_bit_view_st *)(GARBBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GARBBECR()     ((volatile GARBBECR_byte_view_st *)\
N(GARBBECR_REG__ ))
X#define pst_u8GARBBECR()     ((volatile GARBBECR_byte_view_st *)(GARBBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GARBBECR()     ((volatile GARBBECR_halfword_view_st *)\
N(GARBBECR_REG__ ))
X#define pst_u16GARBBECR()     ((volatile GARBBECR_halfword_view_st *)(GARBBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GARBBECR()     ((volatile u32GARBBECR_word_view *)\
N(GARBBECR_REG__ ))
X#define pu32GARBBECR()     ((volatile u32GARBBECR_word_view *)(GARBBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGARBBECR_WR() (pst_bitGARBBECR() -> WR)            
N#define biGetGARBBECR_BTYPE() (pst_bitGARBBECR() -> BTYPE)            
N#define biGetGARBBECR_BSIZE() (pst_bitGARBBECR() -> BSIZE)            
N#define biGetGARBBECR_RTYPE() (pst_bitGARBBECR() -> RTYPE)            
N#define biGetGARBBECR_BEN() (pst_bitGARBBECR() -> BEN)            
N#define biGetGARBBECR_ID() (pst_bitGARBBECR() -> ID)            
N#define biGetGARBBECR_LEN() (pst_bitGARBBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGARBBECRLL() (pst_u8GARBBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGARBBECRLH() (pst_u8GARBBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGARBBECRHL() (pst_u8GARBBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGARBBECRHH() (pst_u8GARBBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGARBBECRL() (pst_u16GARBBECR() -> u16L)
N#define u16GetGARBBECRH() (pst_u16GARBBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGARBBECR()  (*pu32GARBBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACBBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00028                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACBBEAR_REG__       0xC0C00028U
N#else
S#define GACBBEAR_REG__       &GACBBEAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   CBA	:29; 	 /* 3..31  bit(s) R */                    
N} GACBBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GACBBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GACBBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GACBBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGACBBEAR()     ((volatile GACBBEAR_bit_view_st *)\
N(GACBBEAR_REG__ ))
X#define pst_bitGACBBEAR()     ((volatile GACBBEAR_bit_view_st *)(GACBBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GACBBEAR()     ((volatile GACBBEAR_byte_view_st *)\
N(GACBBEAR_REG__ ))
X#define pst_u8GACBBEAR()     ((volatile GACBBEAR_byte_view_st *)(GACBBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GACBBEAR()     ((volatile GACBBEAR_halfword_view_st *)\
N(GACBBEAR_REG__ ))
X#define pst_u16GACBBEAR()     ((volatile GACBBEAR_halfword_view_st *)(GACBBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GACBBEAR()     ((volatile u32GACBBEAR_word_view *)\
N(GACBBEAR_REG__ ))
X#define pu32GACBBEAR()     ((volatile u32GACBBEAR_word_view *)(GACBBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGACBBEAR_CBA() (pst_bitGACBBEAR() -> CBA)
N            
N/* LL-struct byte access */
N#define u8GetGACBBEARLL() (pst_u8GACBBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGACBBEARLH() (pst_u8GACBBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGACBBEARHL() (pst_u8GACBBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGACBBEARHH() (pst_u8GACBBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGACBBEARL() (pst_u16GACBBEAR() -> u16L)
N#define u16GetGACBBEARH() (pst_u16GACBBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGACBBEAR()  (*pu32GACBBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACBBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0002C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACBBECR_REG__       0xC0C0002CU
N#else
S#define GACBBECR_REG__       &GACBBECR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GACBBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GACBBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GACBBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GACBBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGACBBECR()     ((volatile GACBBECR_bit_view_st *)\
N(GACBBECR_REG__ ))
X#define pst_bitGACBBECR()     ((volatile GACBBECR_bit_view_st *)(GACBBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GACBBECR()     ((volatile GACBBECR_byte_view_st *)\
N(GACBBECR_REG__ ))
X#define pst_u8GACBBECR()     ((volatile GACBBECR_byte_view_st *)(GACBBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GACBBECR()     ((volatile GACBBECR_halfword_view_st *)\
N(GACBBECR_REG__ ))
X#define pst_u16GACBBECR()     ((volatile GACBBECR_halfword_view_st *)(GACBBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GACBBECR()     ((volatile u32GACBBECR_word_view *)\
N(GACBBECR_REG__ ))
X#define pu32GACBBECR()     ((volatile u32GACBBECR_word_view *)(GACBBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGACBBECR_WR() (pst_bitGACBBECR() -> WR)            
N#define biGetGACBBECR_BTYPE() (pst_bitGACBBECR() -> BTYPE)            
N#define biGetGACBBECR_BSIZE() (pst_bitGACBBECR() -> BSIZE)            
N#define biGetGACBBECR_RTYPE() (pst_bitGACBBECR() -> RTYPE)            
N#define biGetGACBBECR_BEN() (pst_bitGACBBECR() -> BEN)            
N#define biGetGACBBECR_ID() (pst_bitGACBBECR() -> ID)            
N#define biGetGACBBECR_LEN() (pst_bitGACBBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGACBBECRLL() (pst_u8GACBBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGACBBECRLH() (pst_u8GACBBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGACBBECRHL() (pst_u8GACBBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGACBBECRHH() (pst_u8GACBBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGACBBECRL() (pst_u16GACBBECR() -> u16L)
N#define u16GetGACBBECRH() (pst_u16GACBBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGACBBECR()  (*pu32GACBBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBRBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00030                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBRBEAR_REG__       0xC0C00030U
N#else
S#define GAWBRBEAR_REG__       &GAWBRBEAR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   WBRA	:29; 	 /* 3..31  bit(s) R */                    
N} GAWBRBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBRBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBRBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBRBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBRBEAR()     ((volatile GAWBRBEAR_bit_view_st *)\
N(GAWBRBEAR_REG__ ))
X#define pst_bitGAWBRBEAR()     ((volatile GAWBRBEAR_bit_view_st *)(GAWBRBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBRBEAR()     ((volatile GAWBRBEAR_byte_view_st *)\
N(GAWBRBEAR_REG__ ))
X#define pst_u8GAWBRBEAR()     ((volatile GAWBRBEAR_byte_view_st *)(GAWBRBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBRBEAR()     ((volatile GAWBRBEAR_halfword_view_st *)\
N(GAWBRBEAR_REG__ ))
X#define pst_u16GAWBRBEAR()     ((volatile GAWBRBEAR_halfword_view_st *)(GAWBRBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBRBEAR()     ((volatile u32GAWBRBEAR_word_view *)\
N(GAWBRBEAR_REG__ ))
X#define pu32GAWBRBEAR()     ((volatile u32GAWBRBEAR_word_view *)(GAWBRBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBRBEAR_WBRA() (pst_bitGAWBRBEAR() -> WBRA)
N            
N/* LL-struct byte access */
N#define u8GetGAWBRBEARLL() (pst_u8GAWBRBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBRBEARLH() (pst_u8GAWBRBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBRBEARHL() (pst_u8GAWBRBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBRBEARHH() (pst_u8GAWBRBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBRBEARL() (pst_u16GAWBRBEAR() -> u16L)
N#define u16GetGAWBRBEARH() (pst_u16GAWBRBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBRBEAR()  (*pu32GAWBRBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBRBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00034                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBRBECR_REG__       0xC0C00034U
N#else
S#define GAWBRBECR_REG__       &GAWBRBECR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GAWBRBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBRBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBRBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBRBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBRBECR()     ((volatile GAWBRBECR_bit_view_st *)\
N(GAWBRBECR_REG__ ))
X#define pst_bitGAWBRBECR()     ((volatile GAWBRBECR_bit_view_st *)(GAWBRBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBRBECR()     ((volatile GAWBRBECR_byte_view_st *)\
N(GAWBRBECR_REG__ ))
X#define pst_u8GAWBRBECR()     ((volatile GAWBRBECR_byte_view_st *)(GAWBRBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBRBECR()     ((volatile GAWBRBECR_halfword_view_st *)\
N(GAWBRBECR_REG__ ))
X#define pst_u16GAWBRBECR()     ((volatile GAWBRBECR_halfword_view_st *)(GAWBRBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBRBECR()     ((volatile u32GAWBRBECR_word_view *)\
N(GAWBRBECR_REG__ ))
X#define pu32GAWBRBECR()     ((volatile u32GAWBRBECR_word_view *)(GAWBRBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBRBECR_WR() (pst_bitGAWBRBECR() -> WR)            
N#define biGetGAWBRBECR_BTYPE() (pst_bitGAWBRBECR() -> BTYPE)            
N#define biGetGAWBRBECR_BSIZE() (pst_bitGAWBRBECR() -> BSIZE)            
N#define biGetGAWBRBECR_RTYPE() (pst_bitGAWBRBECR() -> RTYPE)            
N#define biGetGAWBRBECR_BEN() (pst_bitGAWBRBECR() -> BEN)            
N#define biGetGAWBRBECR_ID() (pst_bitGAWBRBECR() -> ID)            
N#define biGetGAWBRBECR_LEN() (pst_bitGAWBRBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGAWBRBECRLL() (pst_u8GAWBRBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBRBECRLH() (pst_u8GAWBRBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBRBECRHL() (pst_u8GAWBRBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBRBECRHH() (pst_u8GAWBRBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBRBECRL() (pst_u16GAWBRBECR() -> u16L)
N#define u16GetGAWBRBECRH() (pst_u16GAWBRBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBRBECR()  (*pu32GAWBRBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBWBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00038                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBWBEAR_REG__       0xC0C00038U
N#else
S#define GAWBWBEAR_REG__       &GAWBWBEAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   WBWA	:29; 	 /* 3..31  bit(s) R */                    
N} GAWBWBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBWBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBWBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBWBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBWBEAR()     ((volatile GAWBWBEAR_bit_view_st *)\
N(GAWBWBEAR_REG__ ))
X#define pst_bitGAWBWBEAR()     ((volatile GAWBWBEAR_bit_view_st *)(GAWBWBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBWBEAR()     ((volatile GAWBWBEAR_byte_view_st *)\
N(GAWBWBEAR_REG__ ))
X#define pst_u8GAWBWBEAR()     ((volatile GAWBWBEAR_byte_view_st *)(GAWBWBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBWBEAR()     ((volatile GAWBWBEAR_halfword_view_st *)\
N(GAWBWBEAR_REG__ ))
X#define pst_u16GAWBWBEAR()     ((volatile GAWBWBEAR_halfword_view_st *)(GAWBWBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBWBEAR()     ((volatile u32GAWBWBEAR_word_view *)\
N(GAWBWBEAR_REG__ ))
X#define pu32GAWBWBEAR()     ((volatile u32GAWBWBEAR_word_view *)(GAWBWBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBWBEAR_WBWA() (pst_bitGAWBWBEAR() -> WBWA)
N            
N/* LL-struct byte access */
N#define u8GetGAWBWBEARLL() (pst_u8GAWBWBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBWBEARLH() (pst_u8GAWBWBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBWBEARHL() (pst_u8GAWBWBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBWBEARHH() (pst_u8GAWBWBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBWBEARL() (pst_u16GAWBWBEAR() -> u16L)
N#define u16GetGAWBWBEARH() (pst_u16GAWBWBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBWBEAR()  (*pu32GAWBWBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBWBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0003C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBWBECR_REG__       0xC0C0003CU
N#else
S#define GAWBWBECR_REG__       &GAWBWBECR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GAWBWBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBWBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBWBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBWBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBWBECR()     ((volatile GAWBWBECR_bit_view_st *)\
N(GAWBWBECR_REG__ ))
X#define pst_bitGAWBWBECR()     ((volatile GAWBWBECR_bit_view_st *)(GAWBWBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBWBECR()     ((volatile GAWBWBECR_byte_view_st *)\
N(GAWBWBECR_REG__ ))
X#define pst_u8GAWBWBECR()     ((volatile GAWBWBECR_byte_view_st *)(GAWBWBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBWBECR()     ((volatile GAWBWBECR_halfword_view_st *)\
N(GAWBWBECR_REG__ ))
X#define pst_u16GAWBWBECR()     ((volatile GAWBWBECR_halfword_view_st *)(GAWBWBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBWBECR()     ((volatile u32GAWBWBECR_word_view *)\
N(GAWBWBECR_REG__ ))
X#define pu32GAWBWBECR()     ((volatile u32GAWBWBECR_word_view *)(GAWBWBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBWBECR_WR() (pst_bitGAWBWBECR() -> WR)            
N#define biGetGAWBWBECR_BTYPE() (pst_bitGAWBWBECR() -> BTYPE)            
N#define biGetGAWBWBECR_BSIZE() (pst_bitGAWBWBECR() -> BSIZE)            
N#define biGetGAWBWBECR_RTYPE() (pst_bitGAWBWBECR() -> RTYPE)            
N#define biGetGAWBWBECR_BEN() (pst_bitGAWBWBECR() -> BEN)            
N#define biGetGAWBWBECR_ID() (pst_bitGAWBWBECR() -> ID)            
N#define biGetGAWBWBECR_LEN() (pst_bitGAWBWBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGAWBWBECRLL() (pst_u8GAWBWBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBWBECRLH() (pst_u8GAWBWBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBWBECRHL() (pst_u8GAWBWBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBWBECRHH() (pst_u8GAWBWBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBWBECRL() (pst_u16GAWBWBECR() -> u16L)
N#define u16GetGAWBWBECRH() (pst_u16GAWBWBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBWBECR()  (*pu32GAWBWBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR0LR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00040                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR0LR_REG__       0xC0C00040U
N#else
S#define GAMPR0LR_REG__       &GAMPR0LR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR0L	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR0LR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR0LR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR0LR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR0LR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR0LR()     ((volatile GAMPR0LR_bit_view_st *)\
N(GAMPR0LR_REG__ ))
X#define pst_bitGAMPR0LR()     ((volatile GAMPR0LR_bit_view_st *)(GAMPR0LR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR0LR()     ((volatile GAMPR0LR_byte_view_st *)\
N(GAMPR0LR_REG__ ))
X#define pst_u8GAMPR0LR()     ((volatile GAMPR0LR_byte_view_st *)(GAMPR0LR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR0LR()     ((volatile GAMPR0LR_halfword_view_st *)\
N(GAMPR0LR_REG__ ))
X#define pst_u16GAMPR0LR()     ((volatile GAMPR0LR_halfword_view_st *)(GAMPR0LR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR0LR()     ((volatile u32GAMPR0LR_word_view *)\
N(GAMPR0LR_REG__ ))
X#define pu32GAMPR0LR()     ((volatile u32GAMPR0LR_word_view *)(GAMPR0LR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR0LR_MPR0L() (pst_bitGAMPR0LR() -> MPR0L)
N#define vSetGAMPR0LR_MPR0L(ParValue)  (pst_bitGAMPR0LR() -> MPR0L=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR0LRLL(ParValue) (pst_u8GAMPR0LR() -> u8LL = (ParValue))
N#define u8GetGAMPR0LRLL() (pst_u8GAMPR0LR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR0LRLH(ParValue) (pst_u8GAMPR0LR() -> u8LH = (ParValue))
N#define u8GetGAMPR0LRLH() (pst_u8GAMPR0LR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR0LRHL(ParValue) (pst_u8GAMPR0LR() -> u8HL = (ParValue))
N#define u8GetGAMPR0LRHL() (pst_u8GAMPR0LR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR0LRHH(ParValue) (pst_u8GAMPR0LR() -> u8HH = (ParValue))
N#define u8GetGAMPR0LRHH() (pst_u8GAMPR0LR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR0LRL(ParValue) (pst_u16GAMPR0LR() -> u16L = (ParValue))
N#define u16GetGAMPR0LRL() (pst_u16GAMPR0LR() -> u16L)
N#define vSetGAMPR0LRH(ParValue) (pst_u16GAMPR0LR() -> u16H = (ParValue))
N#define u16GetGAMPR0LRH() (pst_u16GAMPR0LR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR0LR(ParValue)  (*pu32GAMPR0LR() = (ParValue))
N#define u32GetGAMPR0LR()  (*pu32GAMPR0LR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR0HR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00044                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR0HR_REG__       0xC0C00044U
N#else
S#define GAMPR0HR_REG__       &GAMPR0HR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR0H	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR0HR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR0HR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR0HR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR0HR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR0HR()     ((volatile GAMPR0HR_bit_view_st *)\
N(GAMPR0HR_REG__ ))
X#define pst_bitGAMPR0HR()     ((volatile GAMPR0HR_bit_view_st *)(GAMPR0HR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR0HR()     ((volatile GAMPR0HR_byte_view_st *)\
N(GAMPR0HR_REG__ ))
X#define pst_u8GAMPR0HR()     ((volatile GAMPR0HR_byte_view_st *)(GAMPR0HR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR0HR()     ((volatile GAMPR0HR_halfword_view_st *)\
N(GAMPR0HR_REG__ ))
X#define pst_u16GAMPR0HR()     ((volatile GAMPR0HR_halfword_view_st *)(GAMPR0HR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR0HR()     ((volatile u32GAMPR0HR_word_view *)\
N(GAMPR0HR_REG__ ))
X#define pu32GAMPR0HR()     ((volatile u32GAMPR0HR_word_view *)(GAMPR0HR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR0HR_MPR0H() (pst_bitGAMPR0HR() -> MPR0H)
N#define vSetGAMPR0HR_MPR0H(ParValue)  (pst_bitGAMPR0HR() -> MPR0H=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR0HRLL(ParValue) (pst_u8GAMPR0HR() -> u8LL = (ParValue))
N#define u8GetGAMPR0HRLL() (pst_u8GAMPR0HR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR0HRLH(ParValue) (pst_u8GAMPR0HR() -> u8LH = (ParValue))
N#define u8GetGAMPR0HRLH() (pst_u8GAMPR0HR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR0HRHL(ParValue) (pst_u8GAMPR0HR() -> u8HL = (ParValue))
N#define u8GetGAMPR0HRHL() (pst_u8GAMPR0HR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR0HRHH(ParValue) (pst_u8GAMPR0HR() -> u8HH = (ParValue))
N#define u8GetGAMPR0HRHH() (pst_u8GAMPR0HR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR0HRL(ParValue) (pst_u16GAMPR0HR() -> u16L = (ParValue))
N#define u16GetGAMPR0HRL() (pst_u16GAMPR0HR() -> u16L)
N#define vSetGAMPR0HRH(ParValue) (pst_u16GAMPR0HR() -> u16H = (ParValue))
N#define u16GetGAMPR0HRH() (pst_u16GAMPR0HR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR0HR(ParValue)  (*pu32GAMPR0HR() = (ParValue))
N#define u32GetGAMPR0HR()  (*pu32GAMPR0HR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR1LR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00048                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR1LR_REG__       0xC0C00048U
N#else
S#define GAMPR1LR_REG__       &GAMPR1LR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR1L	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR1LR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR1LR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR1LR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR1LR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR1LR()     ((volatile GAMPR1LR_bit_view_st *)\
N(GAMPR1LR_REG__ ))
X#define pst_bitGAMPR1LR()     ((volatile GAMPR1LR_bit_view_st *)(GAMPR1LR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR1LR()     ((volatile GAMPR1LR_byte_view_st *)\
N(GAMPR1LR_REG__ ))
X#define pst_u8GAMPR1LR()     ((volatile GAMPR1LR_byte_view_st *)(GAMPR1LR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR1LR()     ((volatile GAMPR1LR_halfword_view_st *)\
N(GAMPR1LR_REG__ ))
X#define pst_u16GAMPR1LR()     ((volatile GAMPR1LR_halfword_view_st *)(GAMPR1LR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR1LR()     ((volatile u32GAMPR1LR_word_view *)\
N(GAMPR1LR_REG__ ))
X#define pu32GAMPR1LR()     ((volatile u32GAMPR1LR_word_view *)(GAMPR1LR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR1LR_MPR1L() (pst_bitGAMPR1LR() -> MPR1L)
N#define vSetGAMPR1LR_MPR1L(ParValue)  (pst_bitGAMPR1LR() -> MPR1L=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR1LRLL(ParValue) (pst_u8GAMPR1LR() -> u8LL = (ParValue))
N#define u8GetGAMPR1LRLL() (pst_u8GAMPR1LR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR1LRLH(ParValue) (pst_u8GAMPR1LR() -> u8LH = (ParValue))
N#define u8GetGAMPR1LRLH() (pst_u8GAMPR1LR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR1LRHL(ParValue) (pst_u8GAMPR1LR() -> u8HL = (ParValue))
N#define u8GetGAMPR1LRHL() (pst_u8GAMPR1LR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR1LRHH(ParValue) (pst_u8GAMPR1LR() -> u8HH = (ParValue))
N#define u8GetGAMPR1LRHH() (pst_u8GAMPR1LR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR1LRL(ParValue) (pst_u16GAMPR1LR() -> u16L = (ParValue))
N#define u16GetGAMPR1LRL() (pst_u16GAMPR1LR() -> u16L)
N#define vSetGAMPR1LRH(ParValue) (pst_u16GAMPR1LR() -> u16H = (ParValue))
N#define u16GetGAMPR1LRH() (pst_u16GAMPR1LR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR1LR(ParValue)  (*pu32GAMPR1LR() = (ParValue))
N#define u32GetGAMPR1LR()  (*pu32GAMPR1LR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR1HR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0004C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR1HR_REG__       0xC0C0004CU
N#else
S#define GAMPR1HR_REG__       &GAMPR1HR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR1H	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR1HR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR1HR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR1HR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR1HR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR1HR()     ((volatile GAMPR1HR_bit_view_st *)\
N(GAMPR1HR_REG__ ))
X#define pst_bitGAMPR1HR()     ((volatile GAMPR1HR_bit_view_st *)(GAMPR1HR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR1HR()     ((volatile GAMPR1HR_byte_view_st *)\
N(GAMPR1HR_REG__ ))
X#define pst_u8GAMPR1HR()     ((volatile GAMPR1HR_byte_view_st *)(GAMPR1HR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR1HR()     ((volatile GAMPR1HR_halfword_view_st *)\
N(GAMPR1HR_REG__ ))
X#define pst_u16GAMPR1HR()     ((volatile GAMPR1HR_halfword_view_st *)(GAMPR1HR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR1HR()     ((volatile u32GAMPR1HR_word_view *)\
N(GAMPR1HR_REG__ ))
X#define pu32GAMPR1HR()     ((volatile u32GAMPR1HR_word_view *)(GAMPR1HR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR1HR_MPR1H() (pst_bitGAMPR1HR() -> MPR1H)
N#define vSetGAMPR1HR_MPR1H(ParValue)  (pst_bitGAMPR1HR() -> MPR1H=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR1HRLL(ParValue) (pst_u8GAMPR1HR() -> u8LL = (ParValue))
N#define u8GetGAMPR1HRLL() (pst_u8GAMPR1HR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR1HRLH(ParValue) (pst_u8GAMPR1HR() -> u8LH = (ParValue))
N#define u8GetGAMPR1HRLH() (pst_u8GAMPR1HR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR1HRHL(ParValue) (pst_u8GAMPR1HR() -> u8HL = (ParValue))
N#define u8GetGAMPR1HRHL() (pst_u8GAMPR1HR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR1HRHH(ParValue) (pst_u8GAMPR1HR() -> u8HH = (ParValue))
N#define u8GetGAMPR1HRHH() (pst_u8GAMPR1HR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR1HRL(ParValue) (pst_u16GAMPR1HR() -> u16L = (ParValue))
N#define u16GetGAMPR1HRL() (pst_u16GAMPR1HR() -> u16L)
N#define vSetGAMPR1HRH(ParValue) (pst_u16GAMPR1HR() -> u16H = (ParValue))
N#define u16GetGAMPR1HRH() (pst_u16GAMPR1HR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR1HR(ParValue)  (*pu32GAMPR1HR() = (ParValue))
N#define u32GetGAMPR1HR()  (*pu32GAMPR1HR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPICR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00050                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPICR_REG__       0xC0C00050U
N#else
S#define GAMPICR_REG__       &GAMPICR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   GAMPI	:1; 	 /* 0..0  bit(s) R/W1C */
N  uint8_t   GAMPCI	:1; 	 /* 1..1  bit(s) R/W1C */ 
N  uint8_t   	:6; 	 /* 2..31  bit(s) R */                    
N} GAMPICR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GAMPICR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPICR()     ((volatile GAMPICR_bit_view_st *)\
N(GAMPICR_REG__ ))
X#define pst_bitGAMPICR()     ((volatile GAMPICR_bit_view_st *)(GAMPICR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8GAMPICR()     ((volatile u8GAMPICR_byte_view *)\
N(GAMPICR_REG__ ))
X#define pu8GAMPICR()     ((volatile u8GAMPICR_byte_view *)(GAMPICR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPICR_GAMPI() (pst_bitGAMPICR() -> GAMPI)
N#define vClrGAMPICR_GAMPI() (pst_bitGAMPICR() -> GAMPI = (1))
N#define biGetGAMPICR_GAMPCI() (pst_bitGAMPICR() -> GAMPCI)
N#define vClrGAMPICR_GAMPCI() (pst_bitGAMPICR() -> GAMPCI = (1))
N            
N/* byte access */
N#define vSetGAMPICR(ParValue) (*pu8GAMPICR() = (ParValue))
N#define u8GetGAMPICR() (*pu8GAMPICR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPIMR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00054                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPIMR_REG__       0xC0C00054U
N#else
S#define GAMPIMR_REG__       &GAMPIMR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   GAMPIM	:1; 	 /* 0..0  bit(s) R/W */
N  uint8_t   GAMPCIM	:1; 	 /* 1..1  bit(s) R/W */ 
N  uint8_t   	:6; 	 /* 2..31  bit(s) R */                    
N} GAMPIMR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GAMPIMR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPIMR()     ((volatile GAMPIMR_bit_view_st *)\
N(GAMPIMR_REG__ ))
X#define pst_bitGAMPIMR()     ((volatile GAMPIMR_bit_view_st *)(GAMPIMR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8GAMPIMR()     ((volatile u8GAMPIMR_byte_view *)\
N(GAMPIMR_REG__ ))
X#define pu8GAMPIMR()     ((volatile u8GAMPIMR_byte_view *)(GAMPIMR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPIMR_GAMPIM() (pst_bitGAMPIMR() -> GAMPIM)
N#define vSetGAMPIMR_GAMPIM(ParValue)  (pst_bitGAMPIMR() -> GAMPIM=(ParValue))
N#define biGetGAMPIMR_GAMPCIM() (pst_bitGAMPIMR() -> GAMPCIM)
N#define vSetGAMPIMR_GAMPCIM(ParValue)  (pst_bitGAMPIMR() -> GAMPCIM=(ParValue))
N            
N/* byte access */
N#define vSetGAMPIMR(ParValue) (*pu8GAMPIMR() = (ParValue))
N#define u8GetGAMPIMR() (*pu8GAMPIMR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPACR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00058                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPACR_REG__       0xC0C00058U
N#else
S#define GAMPACR_REG__       &GAMPACR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   MPVA	:29; 	 /* 3..31  bit(s) R */                    
N} GAMPACR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPACR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPACR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPACR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPACR()     ((volatile GAMPACR_bit_view_st *)\
N(GAMPACR_REG__ ))
X#define pst_bitGAMPACR()     ((volatile GAMPACR_bit_view_st *)(GAMPACR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPACR()     ((volatile GAMPACR_byte_view_st *)\
N(GAMPACR_REG__ ))
X#define pst_u8GAMPACR()     ((volatile GAMPACR_byte_view_st *)(GAMPACR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPACR()     ((volatile GAMPACR_halfword_view_st *)\
N(GAMPACR_REG__ ))
X#define pst_u16GAMPACR()     ((volatile GAMPACR_halfword_view_st *)(GAMPACR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPACR()     ((volatile u32GAMPACR_word_view *)\
N(GAMPACR_REG__ ))
X#define pu32GAMPACR()     ((volatile u32GAMPACR_word_view *)(GAMPACR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAMPACR_MPVA() (pst_bitGAMPACR() -> MPVA)
N            
N/* LL-struct byte access */
N#define u8GetGAMPACRLL() (pst_u8GAMPACR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAMPACRLH() (pst_u8GAMPACR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAMPACRHL() (pst_u8GAMPACR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAMPACRHH() (pst_u8GAMPACR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAMPACRL() (pst_u16GAMPACR() -> u16L)
N#define u16GetGAMPACRH() (pst_u16GAMPACR() -> u16H)
N            
N/* Word access */
N#define u32GetGAMPACR()  (*pu32GAMPACR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAGPR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00080                             
N*       ACCESS  : 32,                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAGPR_REG__       0xC0C00080U
N#else
S#define GAGPR_REG__       &GAGPR_REG_EMUL[0]
N#endif
N     
N/************************       STRUCTURES        ***************************/
N        
N/* WORD View */
Ntypedef uint32_t u32GAGPR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to WORD  */ 
N#define pu32GAGPR(ch)     ((volatile u32GAGPR_word_view *)\
N(GAGPR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pu32GAGPR(ch)     ((volatile u32GAGPR_word_view *)(GAGPR_REG__  + ((uint16_t)(ch) * 0x04U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N            
N/* Word access */
N#define vSetGAGPR(ch,ParValue)  (*pu32GAGPR(ch) = (ParValue))
N#define u32GetGAGPR(ch)  (*pu32GAGPR(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACMDL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00100                             
N*       ACCESS  : 32,                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACMDL_REG__       0xC0C00100U
N#else
S#define GACMDL_REG__       &GACMDL_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N        
N/* WORD View */
Ntypedef uint32_t u32GACMDL_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to WORD  */ 
N#define pu32GACMDL()     ((volatile u32GACMDL_word_view *)\
N(GACMDL_REG__ ))
X#define pu32GACMDL()     ((volatile u32GACMDL_word_view *)(GACMDL_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N            
N/* Word access */
N#define vSetGACMDL(ParValue)  (*pu32GACMDL() = (ParValue))
N#define u32GetGACMDL()  (*pu32GACMDL() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACMDH                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00104                             
N*       ACCESS  : 32,                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACMDH_REG__       0xC0C00104U
N#else
S#define GACMDH_REG__       &GACMDH_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N        
N/* WORD View */
Ntypedef uint32_t u32GACMDH_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to WORD  */ 
N#define pu32GACMDH()     ((volatile u32GACMDH_word_view *)\
N(GACMDH_REG__ ))
X#define pu32GACMDH()     ((volatile u32GACMDH_word_view *)(GACMDH_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N            
N/* Word access */
N#define vSetGACMDH(ParValue)  (*pu32GACMDH() = (ParValue))
N#define u32GetGACMDH()  (*pu32GACMDH() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GADEFCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00200                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GADEFCR_REG__       0xC0C00200U
N#else
S#define GADEFCR_REG__       &GADEFCR_REG_EMUL[0]
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   FC3	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   FC2	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   FC1	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   FC0	:8; 	 /* 24..31  bit(s) R/W */                    
N} GADEFCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GADEFCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GADEFCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GADEFCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGADEFCR(ch)     ((volatile GADEFCR_bit_view_st *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pst_bitGADEFCR(ch)     ((volatile GADEFCR_bit_view_st *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GADEFCR(ch)     ((volatile GADEFCR_byte_view_st *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pst_u8GADEFCR(ch)     ((volatile GADEFCR_byte_view_st *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GADEFCR(ch)     ((volatile GADEFCR_halfword_view_st *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pst_u16GADEFCR(ch)     ((volatile GADEFCR_halfword_view_st *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N            
N/* Pointer to WORD  */ 
N#define pu32GADEFCR(ch)     ((volatile u32GADEFCR_word_view *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pu32GADEFCR(ch)     ((volatile u32GADEFCR_word_view *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGADEFCR_FC3(ch) (pst_bitGADEFCR(ch) -> FC3)
N#define vSetGADEFCR_FC3(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC3=(ParValue))
N#define biGetGADEFCR_FC2(ch) (pst_bitGADEFCR(ch) -> FC2)
N#define vSetGADEFCR_FC2(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC2=(ParValue))
N#define biGetGADEFCR_FC1(ch) (pst_bitGADEFCR(ch) -> FC1)
N#define vSetGADEFCR_FC1(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC1=(ParValue))
N#define biGetGADEFCR_FC0(ch) (pst_bitGADEFCR(ch) -> FC0)
N#define vSetGADEFCR_FC0(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC0=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGADEFCRLL(ch,ParValue) (pst_u8GADEFCR(ch) -> u8LL = (ParValue))
N#define u8GetGADEFCRLL(ch) (pst_u8GADEFCR(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetGADEFCRLH(ch,ParValue) (pst_u8GADEFCR(ch) -> u8LH = (ParValue))
N#define u8GetGADEFCRLH(ch) (pst_u8GADEFCR(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetGADEFCRHL(ch,ParValue) (pst_u8GADEFCR(ch) -> u8HL = (ParValue))
N#define u8GetGADEFCRHL(ch) (pst_u8GADEFCR(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetGADEFCRHH(ch,ParValue) (pst_u8GADEFCR(ch) -> u8HH = (ParValue))
N#define u8GetGADEFCRHH(ch) (pst_u8GADEFCR(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGADEFCRL(ch,ParValue) (pst_u16GADEFCR(ch) -> u16L = (ParValue))
N#define u16GetGADEFCRL(ch) (pst_u16GADEFCR(ch) -> u16L)
N#define vSetGADEFCRH(ch,ParValue) (pst_u16GADEFCR(ch) -> u16H = (ParValue))
N#define u16GetGADEFCRH(ch) (pst_u16GADEFCR(ch) -> u16H)
N            
N/* Word access */
N#define vSetGADEFCR(ch,ParValue)  (*pu32GADEFCR(ch) = (ParValue))
N#define u32GetGADEFCR(ch)  (*pu32GADEFCR(ch) )
N
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#endif /* GAIO_H */  
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_io.c
N**  $Revision: 1.12 $
N**  $Date: 2015/05/04 09:07:16 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 230 / 6.4 - bitwise operation may not be performed on signed integer types
N** | CONS.  : allow
N** | REASON : to use macros generated by converter tool 
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 24 "..\..\..\..\lldd\src\draw.c" 2
N#include "ga.h"
L 1 "..\..\..\..\lldd\inc\ga.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.19 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_H
N#define GA_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "ga_common.h"
L 1 "..\..\..\..\lldd\inc\ga_common.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/07/21 12:30:20 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_COMMON_H
N#define GA_COMMON_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
N
N#define LLDD_GA_COMMON_H_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_COMMON_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*==========================================================================
N|                       GA Configuration Parameters                         |
N ==========================================================================*/
N/*---------------------------------------
N|        GA Sub-Module inclusion         |
N ---------------------------------------*/
N/* Blitting Engine */
N#define GA_USE_BLITTING
N
N/* Transformation Engine */
N#define GA_USE_TRANSFORM
N
N/* Rotation Engine */
N#define GA_USE_ROTATION
N
N/* Drawing Engine */
N#define GA_USE_DRAWING
N
N/*---------------------------------------
N|         GA List Configuration          |
N ---------------------------------------*/
N/* Maximal Number of commands in one list */
N#define GA_CMD_MAX    2048
N
N/*---------------------------------------
N|  Enable/Disable boundary check for     |
N|         GA Command List                |
N ---------------------------------------*/
N/* Enable/Disable boundary check in drivers for command buffer: */
N/* #define GA_CMDSLIST_BOUNDARY_CHECK */
N
N
N/* 1 double word more will be reserved by calculation of needed
N   buffers for GA-API's. This is necesary to add later an END-Command to 
N   finalize the command: 
N*/   
N#define RESERVED_FOR_END_CMD    1
N
N/*======================================
N                Defs
N=======================================*/
N
N/*--------------------------------------
N|     GA General Purpose Registers      |
N --------------------------------------*/
N#define GA_GPR0   0
N#define GA_GPR1   1
N#define GA_GPR2   2
N#define GA_GPR3   3
N#define GA_GPR4   4
N#define GA_GPR5   5
N#define GA_GPR6   6
N#define GA_GPR7   7
N#define GA_GPR8   8
N#define GA_GPR9   9
N#define GA_GPR10  10
N#define GA_GPR11  11
N#define GA_GPR12  12
N#define GA_GPR13  13
N#define GA_GPR14  14
N#define GA_GPR15  15
N#define GA_GPR16  16
N#define GA_GPR17  17
N#define GA_GPR18  18
N#define GA_GPR19  19
N#define GA_GPR20  20
N#define GA_GPR21  21
N#define GA_GPR22  22
N#define GA_GPR23  23
N#define GA_GPR24  24
N#define GA_GPR25  25
N#define GA_GPR26  26
N#define GA_GPR27  27
N#define GA_GPR28  28
N#define GA_GPR29  29
N#define GA_GPR30  30
N#define GA_GPR31  31
N
N
N/*--------------------------------------
N|         GA Command Parameters         |
N --------------------------------------*/
N/* Selection of module to wait on */
Ntypedef enum tag_ga_modul_e
N{
N    GA_GDC0        = 0x0u,
N    GA_FG0         = 0x1u,
N    GA_GDC1        = 0x2u
N} ga_modul_e;
N
N/* Enables/Disables option */
Ntypedef enum tag_ga_en_e
N{
N    GA_DIS         = 0x0u,     /* Disable/off */
N    GA_EN          = 0x1u      /* Enable/on */
N} ga_en_e;
N
N/* Blending Order */
Ntypedef enum tag_blendOrd_e
N{
N    GA_ONTO_DEST   = 0x0u,     /* Onto destination */
N    GA_BEHIND_DEST = 0x1u      /* Behind destination */
N} ga_blendOrd_e;
N
N/* Color format selection */
Ntypedef enum tag_ga_colFmt_e
N{
N    GA_RGB16       = 0x0u,      /* 16-bit RGB format */
N    GA_RGBA32      = 0x1u       /* 32-bit RGBA format */
N} ga_colFmt_e;
N
N/*--------------------------------------
N|        GA Command Construction        |
N --------------------------------------*/
N/* Command Field Masks */
N#define GA_MASK1           0x1u
N#define GA_MASK2           0x3u
N#define GA_MASK3           0x7u
N#define GA_MASK4           0xfu
N#define GA_MASK5           0x1fu
N#define GA_MASK6           0x3fu
N#define GA_MASK7           0x7fu
N#define GA_MASK8           0xffu
N#define GA_MASK9           0x1ffu
N#define GA_MASK10          0x3ffu
N#define GA_MASK12          0xfffu
N#define GA_MASK14          0x3fffu
N#define GA_MASK15          0x7fffu
N#define GA_MASK16          0xffffu
N#define GA_MASK22          0x3fffffu
N#define GA_MASK24          0xffffffu
N#define GA_MASK32          0xffffffffu
N#define GA_MASK36          0xfffffffffull
N#define GA_MASK48          0xffffffffffffull
N#define GA_MASK64          0xffffffffffffffffull
N
N/* GA Unit selection */
N#define GA_SCHED           0x0u
N#define GA_BLITING         0x1u
N#define GA_DRAWING         0x2u
N#define GA_ROTATION        0x3u
N#define GA_TRANSFORM       0x4u
N
N/*** Command Codes ***/
N#define GA_CMC_LGPR        0x1u
N#define GA_CMC_CSWVSYNC    0x2u
N#define GA_CMC_CSUIC	     0x3u
N#define GA_CMC_CSGDC0CC	   0x4u
N#define GA_CMC_CSGDC1CC	   0x5u
N#define GA_CMC_END         0xffu
N
N/* Blitting Engine Command Codes */
N
N#define GA_CMC_BLTO16      0x02u
N#define GA_CMC_BLTO32      0x04u
N#define GA_CMC_BLTORLEI16  0x0au
N#define GA_CMC_BLTORLEI24  0x06u
N#define GA_CMC_BLTORLEI24A 0x0Eu
N#define GA_CMC_BLTORLEI32  0x0cu
N#define GA_CMC_BLTOP16     0x12u
N#define GA_CMC_BLTOP32     0x14u
N#define GA_CMC_BLTB16      0x03u
N#define GA_CMC_BLTB32      0x07u
N#define GA_CMC_BLTBRLEI16  0x0bu
N#define GA_CMC_BLTBRLEI24  0x05u
N#define GA_CMC_BLTBRLEI24A 0x0fu
N#define GA_CMC_BLTBRLEI32  0x0du
N#define GA_CMC_BLTBP16     0x13u
N#define GA_CMC_BLTBP32     0x17u
N
N/* Transformation Engine Command Code */
N#define GA_CMC_TRANSF      0x01u
N#define GA_CMC_TRANSFB     0x00u
N
N/* Rotation Engine Command Code */
N#define GA_CMC_ROT         0x01u
N#define GA_CMC_ROTB        0x00u
N
N/* Drawing Engine Command Codes */
N#define GA_CMC_DE_DLRGBA32 0x03u
N#define GA_CMC_DE_DLRGB16  0x04u
N#define GA_CMC_DE_DTRGBA32 0x05u
N#define GA_CMC_DE_DTRGB16  0x06u
N
N/* Command Field Offsets */
N#define GA_ENG_OFF         60
N#define GA_LEN_OFF         56
N#define GA_CMC_OFF         48
N#define GA_SPC_OFF          0
N
N/* Command Field Masks */
N#define GA_ENG_MSK         (GA_MASK3)
N#define GA_LEN_MSK         (GA_MASK4)
N#define GA_CMC_MSK         (GA_MASK8)
N#define GA_SPC_MSK         (GA_MASK48)
N
N/* Macro for command field positioning */
N#define GA_FP(val, offset, mask) (((uint64_t)(val) & (mask)) << (offset))
N
N/* GA Command Fields (Engine, Length, Command code, Cmd Specific Params.)*/
N#define GA_ENG(Engine) (GA_FP((Engine), GA_ENG_OFF, GA_ENG_MSK))
N#define GA_LEN(Len)    (GA_FP((Len)   , GA_LEN_OFF, GA_LEN_MSK))
N#define GA_CMC(Code)   (GA_FP((Code)  , GA_CMC_OFF, GA_CMC_MSK))
N#define GA_SPC(spec)   (GA_FP((spec)  , GA_SPC_OFF, GA_SPC_MSK))
N
N/* GA Command Construction Macro */
N#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    | \
N                                                GA_ENG((Engine))   | \
N                                                GA_LEN((Len))      | \
N                                                GA_CMC((CmdCode))  | \
N                                                GA_SPC((CmdSpec)))
X#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    |                                                 GA_ENG((Engine))   |                                                 GA_LEN((Len))      |                                                 GA_CMC((CmdCode))  |                                                 GA_SPC((CmdSpec)))
N
N/*=========================================================================
N|                        SCHEDULER OPERATION COMMANDS                      |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load General-Purpose Register Command (LGPR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to configure
N|             one out of the 32 General-Purpose Registers. The command
N|             specific parameter for this command is the number of the
N|             register that should be loaded and the value itself.
N|
N|  Params:    regNr   - The number of the General-Purpose Register that
N|                       should be loaded
N|
N|             uiVal   - Value that should be stored within the selected
N|                       register. If the register does not encapsulate
N|                       32 bits the value within the command has to be right
N|                       aligned.
N|
N -------------------------------------------------------------------------*/
N#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,       \
N                               GA_FP ((regNr), 32, GA_MASK5)      |   \
N                               GA_FP ((uiVal),  0,  GA_MASK32)))
X#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,                                      GA_FP ((regNr), 32, GA_MASK5)      |                                  GA_FP ((uiVal),  0,  GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   END Command (CSEND)
N|
N|  Descr  :   The CSEND command must be placed at the end of every command
N|             list. It signals the Command Scheduler that all commands have
N|             been executed. When the Command Scheduler is detecting this
N|             mark, a flag in the status register signals that the command
N|             list was executed. Optionally an interrupt is generated.
N|
N|  Params:    none
N|
N -------------------------------------------------------------------------*/
N#define GA_END() (GA_CMN(GA_SCHED, 0x1u, GA_CMC_END,0x0u))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Wait VSYNC Command (CSWVSYNC)
N|
N|  Descr  :   The CSWVSYNC command can be used to synchronize parts of the
N|             command list with the vertical synchronization signal VSYNC
N|             from the GDC or the Frame Grabber.
N|
N|             When the Command Scheduler is reading the CSWVSYNC command
N|             it waits until the next vertical synchronization of the
N|             display/camera input takes place before executing the next
N|             command.
N|
N|  Params:    module   -  VSYNC select:
N|                         Use: GA_GDC0     - Wait on GDC0
N|                              GA_FG0      - Wait on FG0
N|                              GA_GDC1     - Wait on GDC1
N|                              GA_FG1      - Wait on FG1
N|
N|
N -------------------------------------------------------------------------*/
N#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,        \
N                         GA_FP ((module), 0, GA_MASK2)))
X#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,                                 GA_FP ((module), 0, GA_MASK2)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   User Interrupt Command (CSUIC)
N|
N|  Descr  :   The CSUIC command can be used to signal the MCU that a
N|             certain part of the Command List is already executed or
N|             will now start execution.
N|
N|  Params:    interrupt number:
N|                          Use: 0 - 23
N|                               values > 23 will be ignored
N|
N -------------------------------------------------------------------------*/
N#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,    \
N                                  GA_FP ((number), 0, GA_MASK6)))
X#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,                                      GA_FP ((number), 0, GA_MASK6)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC0 Configuration Command (CSGDC0CC)
N|
N|  Descr  :   The CSGDC0CC command can be used to change the content of GDC0 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC0 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC1 Configuration Command (CSGDC1CC)
N|
N|  Descr  :   The CSGDC1CC command can be used to change the content of GDC1 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC1 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N
N/*======================================
N              Structures
N=======================================*/
N/* Command List Structure */
Ntypedef struct tag_ga_list_st
N{
N    uint64_t  ullCommands[GA_CMD_MAX] ;
X    uint64_t  ullCommands[2048] ;
N    uint64_t* pu64Current;
N    uint32_t  u32UsedDoubleWords; /* used or needed double words for an  GA-API */
N    int32_t   i32FreeSpaceStat;   /* C_SUCCESS: OK no space free error,
N                                     C_FAILED:  No free space for GA-API */
N} ga_list_st ;
N
N/****************************************************************************/
N
N
N#endif /* GA_COMMON_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_common.h
N**  $Revision: 1.14 $
N**  $Date: 2015/07/21 12:30:20 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  : 
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\lldd\inc\ga.h" 2
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_H_REVISION     "$Revision: 1.19 $"
N#define LLDD_GA_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/* Timeout */
N#define GA_TIMEOUT  10000
N
N/* Size of Draw Engine Filter RAM (in doublewords) */
N#define GA_DE_FILTER_SIZE 64
N
N/* GA Interrupt Masks */
N#define GA_IRQ_MASK_CENDIM  0x00000001U    /* GA Command End Interrupt Mask.                          */
N#define GA_IRQ_MASK_CSCEIM  0x00000004U    /* Command Scheduler Command Error Interrupt Mask          */
N#define GA_IRQ_MASK_CSLEIM  0x00000008U    /* Command Scheduler Command List Executed Interrupt Mask  */
N#define GA_IRQ_MASK_WBWIM   0x00000010U    /* GA Write Buffer Write Bus-Error Interrupt Mask          */
N#define GA_IRQ_MASK_WBRIM   0x00000020U    /* GA Write Buffer Read Bus-Error Interrupt Mask           */
N#define GA_IRQ_MASK_CBIM    0x00000040U    /* GA Cache Buffer Bus-Error Interrupt Mask                */
N#define GA_IRQ_MASK_RBIM    0x00000080U    /* GA Read Buffer Bus-Error Interrupt Mask                 */
N#define GA_IRQ_MASK_CSLUIM  0xFFFFFF00U    /* Command List User Interrupt Mask 0 – 23                 */
N
N/*======================================
N                Enums
N=======================================*/
N/****************************************
N*         GAIMR Param.Values
N****************************************/
N/* IRQ Mask */
Ntypedef enum tag_ga_irqen_e
N{
N    GA_IRQ_EN  = 0x1u,     /* Enable IRQ */
N    GA_IRQ_DIS = 0x0u      /* Disable IRQ */
N} ga_irqen_e;
N
N/* Bus type */
Ntypedef enum tag_ga_bus_type_e
N{
N    GA_READ_BUF_BUS        = 0x00U,
N    GA_CACHE_BUF_BUS       = 0x01U,
N    GA_WRITE_BUF_READ_BUS  = 0x02U,
N    GA_WRITE_BUF_WRITE_BUS = 0x03U,
N    GA_MAX_TYPE_BUS        = 0x04U
N} ga_bus_type_e;
N
N/* Read / Write Direction */
Ntypedef enum tag_ga_buserr_dir_e
N{
N    GA_BUSERR_READ_TRANSF   = 0x0U,
N    GA_BUSERR_WRITE_TRANSF  = 0x1U
N} ga_buserr_dir_e;
N
N/* Burs error Type */
Ntypedef enum tag_ga_buserr_bursttype
N{
N    GA_BUSERR_BURST_TYPE_FIXED   = 0x0U,
N    GA_BUSERR_BURST_TYPE_INCR    = 0x1U
N} ga_buserr_bursttype;
N
N/* Burst Size */
Ntypedef enum tag_ga_buserr_burstsize
N{
N    GA_BUSERR_BURST_1BYTE     = 0x0U,
N    GA_BUSERR_BURST_2BYTE     = 0x1U,
N    GA_BUSERR_BURST_4BYTE     = 0x2U,
N    GA_BUSERR_BURST_81BYTE    = 0x3U,
N    GA_BUSERR_BURST_16BYTE    = 0x4U,
N    GA_BUSERR_BURST_32BYTE    = 0x5U,
N    GA_BUSERR_BURST_64BYTE    = 0x6U,
N    GA_BUSERR_BURST_128BYTE   = 0x7U
N} ga_buserr_burstsize;
N
N
N/* Response Type */
Ntypedef enum tag_ga_buserr_resptype
N{
N    GA_BUSERR_RESP_OK        = 0x0U,
N    GA_BUSERR_RESP_EXOKAY    = 0x1U,
N    GA_BUSERR_RESP_SLVERR    = 0x2U,
N    GA_BUSERR_RESP_DECERR    = 0x3U
N} ga_buserr_resptype;
N
N/* Memory Protection Region */
Ntypedef enum tag_ga_memory_region_e
N{
N    GA_MEMORY_PROT_REGION_0   = 0x0U,
N    GA_MEMORY_PROT_REGION_1   = 0x1U,
N    GA_MEMORY_PROT_REGION_MAX = 0x2U
N} ga_memory_region_e;
N
N/*======================================
N              Structures
N=======================================*/
N/* GA bus Error Control Signal-Structure */
Ntypedef struct tag_ga_bus_err_ctrl_st
N{
N    ga_buserr_dir_e      eDirection;       /* Read / Write direction */
N    ga_buserr_bursttype  eBurstType;       /* Burst type */
N    ga_buserr_burstsize  eBurstSize;       /* Burst size */
N    ga_buserr_resptype   eRespType;        /* Response Type */
N    uint8_t              u8ByteEnables;    /* Byte-enables for the erroneous transfer. */
N    uint8_t              u8ID;             /* ID tag of the read/write transaction that triggered an error response. */
N    uint8_t              u8BurstLength;    /* Burst length of the read/write transaction that triggered an error response */
N} ga_bus_err_ctrl_st;
N
N/*======================================
N      Exported Function Prototypes
N=======================================*/
N
N/****************************************************************************
N *
N * Function:      vGA_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8CommonRevision - pointer to common header revision string
N *                pau8CommonTag      - pointer to common header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                    uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                    uint8_t** pau8CommonRevision, uint8_t** pau8CommonTag,
N                    uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetMaxUsedBuffSize
N *
N * Purpose:       Resets the counter for used buffer of command list
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ResetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      u32Ga_GetMaxUsedBuffSize
N *
N * Purpose:       To get max. used size of command buffer. This API can be
N *                used to optimize the need size of "GA_CMD_MAX" in ga_list_st
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_GetLastCmdBuffStatus
N *
N * Purpose:       returns the information if there was enough space free for
N *                command over API
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: space status for command list
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_GetLastCmdBuffStatus(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetLastCmdSize
N *
N * Purpose:       returns the uesed buffer size for last API call (in case it
N *                was enough memory in buffer) or it returns needed size of buffer
N *                for last API call (if there was not enough memory in command buffer)
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: sized of used buffer
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetLastCmdSize(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_CheckList
N *
N * Purpose:       To check whether there is enough space in command buffer
N *                to wrote some doble words 
N *
N * Inputs:        pstCmdList  - pointer to command list
N *                u32NeededDW - needed double words 
N *
N * Outputs:       none
N *
N * Return Values: C_FAILED  requested number of commands will not fit into list
N *                C_SUCCESS requested number of commands will fit into list   
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_CheckList(ga_list_st* pstCmdList, uint32_t u32NeededDW);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetList
N *
N * Purpose:       Resets the Command List
N *
N * Inputs:        pstCmdList - Pointer to command list
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   The pointer to current list position will be reset, the
N *                content of the list will remain un-touched.
N *
N ***************************************************************************/
Nvoid vGA_ResetList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CloseList
N *
N * Purpose:       Closes the given list by inserting CSEND command
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CloseList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SyncList
N *
N * Purpose:       Inserts the VSYNC command in the command list in order to
N *                synchronize the execution of the list with vertical (VSYNC)
N *                signal from the GDC or Frame Grabber. When the command
N *                sceduler reaches this command it will stop the list
N *                execution until next VSYNC signal.
N *
N * Inputs:        eModul     - Modul selection to wait on (GDC/FG)
N *                pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SyncList(ga_modul_e eModule, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetUserInt
N *
N * Purpose:       defines Interrupt to CPU
N *
N * Inputs:        u8Number   - Interrupt number
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetUserInt(uint8_t u8Number, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_Enable
N *
N * Purpose:       Enables/Disables the Graphic Accelerator
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_Enable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ReadAheadEnable
N *
N * Purpose:       Enables/Disables ReadBuffer Read Ahead feature
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ReadAheadEnable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_Reset
N *
N * Purpose:       Resets the Graphic Accelerator
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS - Reset successful
N *                C_FAILED  - Reset timeout (Reset was not completted in
N *                            predefined time interval)
N *
N * Limitations:   The function will wait the reset to complete (it can take
N *                until recent bus cycle execution is finished)
N *
N ***************************************************************************/
Nint32_t i32GA_Reset(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetCmdListAddr
N *
N * Purpose:       Sets the physical address of the current command list
N *
N * Inputs:        u32Addr  - Physical address of the command list
N *                           (Must be 64-bit alligned -> uiAddr[2:0] = 0x0)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Make sure that when calling this function command scheduler
N *                is NOT executing a command list !!! Please note, that after
N *                the address is once written, the GA will automatically
N *                start the command list execution.
N *
N ***************************************************************************/
Nvoid vGA_SetCmdListAddr(uint32_t u32Addr);
N
N
N/****************************************************************************
N *
N * Function:      u8GA_GetStatus
N *
N * Purpose:       Reads the Graphic Accelerator Status register
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA Status Register (GASR) value
N *
N * Limitations:   The caller must parse returned status byte. For this
N *                purpose see the description of GASR Register.
N *
N ***************************************************************************/
Nuint8_t u8GA_GetStatus(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListFinished
N *
N * Purpose:       Indicates that the operation of a command list was finished or
N *                the GA was reset. This bit will be set to zero, when a new pointer
N *                is written.
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  command List Finished (ready to get new values)
N *                C_FALSE: command List is not Finished (not ready to get new values)
N *
N * Limitations: 
N *
N ***************************************************************************/
Nbool_t boGA_CmdListFinished(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListError
N *
N * Purpose:       This function shows if the Command Scheduler detects an invalid command
N *                or not. The Graphics Accelerator halts its operation and has to be reset
N *                if error is any detected. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  any Error detected by command list
N *                C_FALSE: no error detected
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdListError(void);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      boGA_CmdReg_IsBusy
N *
N * Purpose:       This function shows when any of the GA engines is currently operating.
N *                Then also the write access to many registers is prohibited.
N *                NOTE:
N *                  This function should be used from user by using direct comamnd 
N *                  registers instead of command list, before writing new commands. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  GA engine is busy.
N *                C_FALSE: GA engine is ready (not busy).
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdReg_IsBusy(void);
N#endif
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetIrqCause
N *
N * Purpose:       Reads the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA IRQ Cause value
N *
N * Limitations:   The calling function must parse returned IRQ cause byte.
N *                For this purpose see the GAICR register description.
N *                Please note that the funtion will automatically clear
N *                the interrupt source !!!
N *
N ***************************************************************************/
Nuint32_t u32GA_GetIrqCause(void);
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCause
N *
N * Purpose:       Clears the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        u32CauseMask: Mask to clear the bits ("1" in the mask means clear Bit)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCause(uint32_t u32CauseMask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetIrqMask
N *
N * Purpose:       Sets all GA Interrupt masks in one shot
N *
N * Inputs:        u32Mask - Interrupt Mask. For this purpose you may use defines:
N *                         GA_IRQ_MASK_CENDIM, GA_IRQ_MASK_CSCEIM, GA_IRQ_MASK_CSLEIM,
N *                         GA_IRQ_MASK_WBWIM, GA_IRQ_MASK_WBRIM, GA_IRQ_MASK_CBIM,
N *                         GA_IRQ_MASK_RBIM, GA_IRQ_MASK_CSLUIM   
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetIrqMask(uint32_t u32Mask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableUserIrq
N *
N * Purpose:       Enables/Disables interrupt to CPU
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *		  u8Number - interrupt line to be enabled/disabled
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableUserIrq(uint8_t u8Number, ga_en_e eEn);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_EnableIrqCmdEnd
N *
N * Purpose:       Enables/Disables GA Command End Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_EnableIrqCmdEnd(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_ClearIrqCmdEnd
N *
N * Purpose:       Clears GA Command End Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_ClearIrqCmdEnd(void);
N
N
N#endif
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSLEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command List
N *                Executed Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSLEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSLEI
N *
N * Purpose:       Clears Command Scheduler Command List Executed Interrupt. 
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSLEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSCEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command Error IRQ
N *                Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSCEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSCEI
N *
N * Purpose:       Clears GA Command Scheduler Command Error IRQ
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSCEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetGADelay
N *
N * Purpose:       Sets the minimum delay in System Clock cycles between two
N *                consecutive memory accesses performed by any Graphics 
N *                Accelerator engine
N *
N * Inputs:        u16Delay: Delay Value (0x0000 .. 0xFFFF)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetGADelay(uint16_t u16Delay);
N
N
N/****************************************************************************/
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBWI
N *
N * Purpose:       Enables/Disables GA Write Buffer Write Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBWI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBWI
N *
N * Purpose:       Clears GA Write Buffer Write Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBWI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBRI
N *
N * Purpose:       Enables/Disables GA Write Buffer Read Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBRI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBRI
N *
N * Purpose:       Clears GA Write Buffer Read Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBRI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGACBIM
N *
N * Purpose:       Enables/Disables GA Cache Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGACBI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGACBI
N *
N * Purpose:       Clears GA Cache Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGACBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGARBI
N *
N * Purpose:       Enables/Disables GA Read Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGARBI(ga_en_e eEn);
N
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGARBI
N *
N * Purpose:       Clears GA Read Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGARBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearUserIrq
N *
N * Purpose:       Clears GA Command List User Interrupt 0 - 23
N *
N * Inputs:        u8CmdListIntr: No. of Interruot (0..23) to be cleared
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearUserIrq(uint8_t u8CmdListIntr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrAddr
N *
N * Purpose:       Returns the address after bus error on GA 
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       pu32BusErrAddr: Pointer to bus error address
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: NULL pointer
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrAddr(ga_bus_type_e eBusType, uint32_t* pu32BusErrAddr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrCtrlStatus
N *
N * Purpose:       Returns the triggering access’s control status after bus error on GA
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       control status structure
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrCtrlStatus(ga_bus_type_e eBusType, ga_bus_err_ctrl_st* pstCtrlStatus);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetMemoryProtRegionAddr
N *
N * Purpose:       Defines the lower and upper address of the memory region
N *                0 or 1 (primary, secondary) GA is allowed to perform write accesses.
N *                Write accesses outside the memory regions are discarded.
N *                NOTE:
N *                   The memory regions are defined with a granularity of 4Kbyte.
N *
N * Inputs:        eRegion  Related Region (0/1)
N *                u32LowAddress: Lower protected address
N *                u32HighAddress: Higher protected address
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_SetMemoryProtRegionAddr(ga_memory_region_e eRegion, uint32_t u32LowAddress, uint32_t u32HighAddress);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecConfigIrq
N *
N * Purpose:       Enables/Disables interrupt, set if a non-privileged access 
N *                tries to write to GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR,
N *                or GAMPIMR.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecConfigIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecAccessIrq
N *
N * Purpose:       Enables/Disables interrupt, set if GA tries to write to 
N *                memory outside the address range defined by GAMR0L-GAMR0H 
N *                and GAMR1L-GAMR1H.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecAccessIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecConfigIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to have a non-privileged access 
N *                tries to write to protection control registers
N *                (GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR, or GAMPIMR)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecConfigIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecAccessIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to write to memory 
N *                outside the address range defined by GAMR0L-GAMR0H and GAMR1L-GAMR1H
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecAccessIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetMemoryProtecErr_CaptAddr
N *
N * Purpose:       Get the address of the first write access performed by the 
N *                Write Buffer’s write interface that caused a memory protection
N *                violation. The register is automatically set by the Graphics 
N *                Accelerator in case of a protection violation, it is reset to
N *                zero automatically if the corresponding interrupt bit GAMPI is
N *                cleared in the Graphics Accelerator Interrupt Cause Register (GAMPICR).
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: Address caused portection error
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMemoryProtecErr_CaptAddr(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetGeneralPurposeRegister
N *
N * Purpose:       Set one of 32 Purpose Registers of GA, which are used to define  
N *                the required parameters for the triggered engine.
N *                Read access is possible all the time, write access is only allowed
N *                if no engine is currently operating (GASR.BUSY=0). Nevertheless, 
N *                it is recommended to configure these registers using Command Lists.
N *
N * Inputs:        u8RegNo      No. of Register (0..31)
N *                u32RegValue: Register value to be written
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo or GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t u32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetGeneralPurposeRegister
N *
N * Purpose:       Get content of one of 32 Purpose Registers of GA, which are used   
N *                to define the required parameters for the triggered engine.
N *
N * Inputs:        u8RegNo       No. of Register (0..31)
N *                pu32RegValue: Pointer to Register value to be read
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo NULL pointer 
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_GetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t* pu32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetCommandRegisterLowHigh
N *
N * Purpose:       Set command register directly (as alternative to command List).
N *                For this mode, user should take care that GA should be ready 
N *                (not busy) before writng in registers. 
N *
N * Inputs:        u32LowValue:  Lower 32 bits of 64 bits command (0..31)
N *                u32HighValue: Higher 32 bits of 64 bits command (32..63)
N *                NOTE:
N *                  1) API should write first Lowe Part and then higher Part. 
N *                    By writing of higehr word thorugh API GA will be trigegred 
N *                    to execute command if it was not busy before.
N *                  2) Related general purpose registers for command should be
N *                     written before, 
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetCommandRegisterLowHigh (uint32_t u32LowValue,  uint32_t u32HighValue);
N
N
N#endif /* _EXTENDED_GA_APIS_DISABLED_ */
N
N#endif /* GA_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 25 "..\..\..\..\lldd\src\draw.c" 2
N#include "draw.h"
L 1 "..\..\..\..\lldd\inc\draw.h" 1
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronic Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver (Drawing Engine)
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : GA (Drawing Engine)
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.15 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N****************************************************************************/
N#ifndef DRAW_H
N#define DRAW_H
N
N/**********************************************
N*             Include Files                   *
N**********************************************/
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S
S#endif/**********************************************
S*                Defs                         *
N**********************************************/
N#define LLDD_GA_DRAW_H_REVISION     "$Revision: 1.15 $"
N#define LLDD_GA_DRAW_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*--------------------------------------------------------------------------
N|       ------------------------------------------------------------        |
N|      | >>>>>>         DRAWING ENGINE COMMAND INDEX         <<<<<< |       |
N|       ------------------------------------------------------------        |
N|---------------------------------------------------------------------------|
N|---------------------------------------------------------------------------|
N|                                                                           |
N|                                                                           |
N|                                                                           |
N|                      ------------------------------                       |
N|                     |      OPERATION COMMANDS      |                      |
N|                      ------------------------------                       |
N|                                                                           |
N| - Commands:                                                               |
N|   1. DRW_LINERGBA32       - Draw Line RGBA32 Command                      |
N|   2. DRW_LINERGB16        - Draw Line RGB16 Command                       |
N|   3. DRW_TRIANGLE_RGBA32  - Draw Triangle RGBA32 Command                  |
N|   4. DRW_TRIANGLE_RGB16   - Draw Triangle RGB16 Command                   |
N|                                                                           |
N|                                                                           |
N|---------------------------------------------------------------------------|
N|                                                                           |
N|                                                                           |
N|                                                                           |
N|                    ----------------------------------                     |
N|                   |      LOAD REGISTER COMMANDS      |                    |
N|                    ----------------------------------                     |
N|                                                                           |
N| - Destination Regs:                                                       |
N|   1. DRW_LOAD_DESTADDR    - Load Destination Address Reg.         (DEDAR) |
N|   2. DRW_LOAD_DESTDIM     - Load Destination Memory Dim. Reg.     (DEMWR) |
N|                                                                           |
N| - Color Regs:                                                             |
N|   3. DRW_LOAD_RGBA32      - Load RGBA32 Color Register        (DERGBA32R) |
N|   4. DRW_LOAD_RGB16       - Load RGB16 Color Register            (DERGBR) |
N|   5. DRW_LOAD_RGBA32BGRND - Load RGBA32 Backgr. Color Register  (DEBKG32) |
N|   6. DRW_LOAD_RGBA16BGRND - Load RGB16 Backgr. Color Register   (DEBKG16) |
N|                                                                           |
N| - Line Regs:                                                              |
N|   7. DRW_LOAD_LINESTART   - Load Line Start Register              (DELSR) |
N|   8. DRW_LOAD_LINEEND     - Load Line End Register                (DELER) |
N|   9. DRW_LOAD_THICKNESS   - Load Line Thickness Register          (DELTR) |
N|                                                                           |
N| - Triangle Regs:                                                          |
N|  10. DRW_LOAD_TRNGLE1     - Load Drw.Eng. Triangle Point 1 Reg.  (DETP1R) |
N|  11. DRW_LOAD_TRNGLE2     - Load Drw.Eng. Triangle Point 2 Reg.  (DETP2R) |
N|  12. DRW_LOAD_TRNGLE3     - Load Drw.Eng. Triangle Point 3 Reg.  (DETP3R) |
N|                                                                           |
N| - Clipping Window:                                                        |
N|  13. DRW_LOAD_CLIPWNDSTART - Load Clipp.Wnd. Start Register      (DECWSR) |
N|  14. DRW_LOAD_CLIPWNDEND   - Load Clipp.Wnd. Upper-Left Corner   (DECWER) |
N|                                                                           |
N --------------------------------------------------------------------------*/
N/*=========================================================================
N|                            OPERATION COMMANDS                             |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Draw Line RGBA32 Command
N|
N|  Descr  :   The Draw Line RGBA32 command is used to trigger the Drawing
N|             Engine to draw a line in the RGBA32 color space, using the
N|             coordinates already programmed in the Line Start Register
N|             (DELSR) and Line End Register (DELER). Additionally the color
N|             of the line will be the color specified in the RGBA32 Color
N|             Register (DERGBAR). The command code is detailed in the
N|             following table.
N|
N|  Params:    startPtStyle - Start point line caps style
N|                            Use: DRW_BUTTEND      - Butt end NOT anti-aliased
N|                                 DRW_BUTTEND_AA   - Butt end anti-aliased
N|                                 DRW_CIRCULAR     - Circular line caps
N|
N|             endPtStyle - End point line caps style
N|                          Use: DRW_BUTTEND        - Butt end NOT anti-aliased
N|                               DRW_BUTTEND_AA     - Butt end anti-aliased
N|                               DRW_CIRCULAR       - Circular line caps
N|
N|             blendMode   - Blending mode
N|                           Use: DRW_BLEND_OPAQUE  - Opaque blending
N|                                DRW_BLEND_TRANSP  - Transparent blending
N|                                DRW_OVERWRITING   - Overwriting
N|                                DRW_SATURATION    - Saturation
N|
N|             clippWndEn - Clipping Window Option
N|                          Use: GA_EN              - Enable Option
N|                               GA_DIS             - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define DRW_LINERGBA32(startPtStyle,                                   \
N                       endPtStyle,                                     \
N                       blendMode,                                      \
N                       clippWndEn)                                     \
N                       (GA_CMN(GA_DRAWING,    1, GA_CMC_DE_DLRGBA32,   \
N                        GA_FP((startPtStyle), 8, GA_MASK4)   |         \
N                        GA_FP((endPtStyle),   4, GA_MASK4)   |         \
N                        GA_FP((blendMode),    1, GA_MASK3)   |         \
N                        GA_FP((clippWndEn),   0, GA_MASK1)))
X#define DRW_LINERGBA32(startPtStyle,                                                          endPtStyle,                                                            blendMode,                                                             clippWndEn)                                                            (GA_CMN(GA_DRAWING,    1, GA_CMC_DE_DLRGBA32,                           GA_FP((startPtStyle), 8, GA_MASK4)   |                                 GA_FP((endPtStyle),   4, GA_MASK4)   |                                 GA_FP((blendMode),    1, GA_MASK3)   |                                 GA_FP((clippWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Draw Line RGB16 Command
N|
N|  Descr  :   The Draw Line command is used to trigger the Drawing Engine to
N|             draw a line in the RGB16 color space, using the coordinates
N|             already programmed in the Line Start Register (DELSR) and Line
N|             End Register(DELER). Additionally the color of the line will be
N|             the color specified in the RGB16 Color Register (DERGBR).
N|             The command code is detailed in the following table.
N|
N|  Params:    startPtStyle - Start point line caps style
N|                            Use: DRW_BUTTEND      - Butt end NOT anti-aliased
N|                                 DRW_BUTTEND_AA   - Butt end anti-aliased
N|                                 DRW_CIRCULAR     - Circular line caps
N|
N|             endPtStyle - End point line caps style
N|                          Use: DRW_BUTTEND        - Butt end NOT anti-aliased
N|                               DRW_BUTTEND_AA     - Butt end anti-aliased
N|                               DRW_CIRCULAR       - Circular line caps
N|
N|             blendMode   - Blending mode
N|                           Use: DRW_BLEND_OPAQUE  - Opaque blending
N|                                DRW_BLEND_TRANSP  - Transparent blending
N|                                DRW_OVERWRITING   - Overwriting
N|
N|             clippWndEn - Clipping Window Option
N|                          Use: GA_EN              - Enable Option
N|                               GA_DIS             - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define DRW_LINERGB16(startPtStyle,                                   \
N                      endPtStyle,                                     \
N                      blendMode,                                      \
N                      clippWndEn)                                     \
N                      (GA_CMN(GA_DRAWING,    1, GA_CMC_DE_DLRGB16,    \
N                       GA_FP((startPtStyle), 8, GA_MASK4)   |         \
N                       GA_FP((endPtStyle),   4, GA_MASK4)   |         \
N                       GA_FP((blendMode),    1, GA_MASK3)   |         \
N                       GA_FP((clippWndEn),   0, GA_MASK1)))
X#define DRW_LINERGB16(startPtStyle,                                                         endPtStyle,                                                           blendMode,                                                            clippWndEn)                                                           (GA_CMN(GA_DRAWING,    1, GA_CMC_DE_DLRGB16,                           GA_FP((startPtStyle), 8, GA_MASK4)   |                                GA_FP((endPtStyle),   4, GA_MASK4)   |                                GA_FP((blendMode),    1, GA_MASK3)   |                                GA_FP((clippWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Draw Triangle RGBA32 Command
N|
N|  Descr  :   The Draw Triangle command is used to trigger the Drawing Engine
N|             to draw a triangle. The triangle will have the vertices
N|             specified in the Triangle Point 1, 2, and 3 Registers (DEPP1,
N|             DEPP2, and DEPP3), and the color specified in the RGBA32 Color
N|             Register (DERGBAR).
N|
N|  Params:    edgAntiEn1,2,3 - Edge 1,2 and 3 antialiasing
N|                              Use: GA_EN            - Anti-aliased is on
N|                                   GA_DIS           - Anti-aliased is off
N|
N|             blendMode      - Blending mode
N|                              Use: DRW_BLEND_OPAQUE - Opaque blending
N|                                   DRW_BLEND_TRANSP - Transparent blending
N|                                   DRW_OVERWRITING  - Overwriting
N|                                   DRW_SATURATION   - Saturation
N|
N|             clippWndEn     - Clipping Window Option
N|                              Use: GA_EN            - Enable Option
N|                                   GA_DIS           - Disable Option
N|
N|
N -------------------------------------------------------------------------*/
N#define DRW_TRIANGLE_RGBA32(edgAntiEn3,                                   \
N                            edgAntiEn2,                                   \
N                            edgAntiEn1,                                   \
N                            blendMode,                                    \
N                            clippWndEn)                                   \
N                            (GA_CMN(GA_DRAWING,  1, GA_CMC_DE_DTRGBA32,   \
N                             GA_FP((edgAntiEn3), 6, GA_MASK1)   |         \
N                             GA_FP((edgAntiEn2), 5, GA_MASK1)   |         \
N                             GA_FP((edgAntiEn1), 4, GA_MASK1)   |         \
N                             GA_FP((blendMode),  1, GA_MASK3)   |         \
N                             GA_FP((clippWndEn), 0, GA_MASK1)))
X#define DRW_TRIANGLE_RGBA32(edgAntiEn3,                                                               edgAntiEn2,                                                               edgAntiEn1,                                                               blendMode,                                                                clippWndEn)                                                               (GA_CMN(GA_DRAWING,  1, GA_CMC_DE_DTRGBA32,                                GA_FP((edgAntiEn3), 6, GA_MASK1)   |                                      GA_FP((edgAntiEn2), 5, GA_MASK1)   |                                      GA_FP((edgAntiEn1), 4, GA_MASK1)   |                                      GA_FP((blendMode),  1, GA_MASK3)   |                                      GA_FP((clippWndEn), 0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Draw Triangle RGB16 Command
N|
N|  Descr  :   The Draw Triangle command is used to trigger the Drawing Engine
N|             to draw a triangle. The triangle will have the vertices
N|             specified in the Triangle Point 1, 2, and 3 Registers (DEPP1,
N|             DEPP2, and DEPP3), and the color specified in the RGB16 Color
N|             Register (DERGBR), according to the color format in use.
N|
N|  Params:    edgAntiEn1,2,3 - Edge 1,2 and 3 anti-aliasing
N|                              Use: GA_EN            - Anti-aliasing is ON
N|                                   GA_DIS           - Anti-aliasing is OFF
N|
N|             blendMode      - Blending mode
N|                              Use: DRW_BLEND_OPAQUE - Opaque blending
N|                                   DRW_BLEND_TRANSP - Transparent blending
N|                                   DRW_OVERWRITING  - Overwriting
N|
N|             clippWndEn     - Clipping Window Option
N|                              Use: GA_EN            - Enable Option
N|                                   GA_DIS           - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define DRW_TRIANGLE_RGB16(edgAntiEn3,                                  \
N                           edgAntiEn2,                                  \
N                           edgAntiEn1,                                  \
N                           blendMode,                                   \
N                           clippWndEn)                                  \
N                           (GA_CMN(GA_DRAWING,  1, GA_CMC_DE_DTRGB16,   \
N                            GA_FP((edgAntiEn3), 6, GA_MASK1)   |        \
N                            GA_FP((edgAntiEn2), 5, GA_MASK1)   |        \
N                            GA_FP((edgAntiEn1), 4, GA_MASK1)   |        \
N                            GA_FP((blendMode),  1, GA_MASK3)   |        \
N                            GA_FP((clippWndEn), 0, GA_MASK1)))
X#define DRW_TRIANGLE_RGB16(edgAntiEn3,                                                             edgAntiEn2,                                                             edgAntiEn1,                                                             blendMode,                                                              clippWndEn)                                                             (GA_CMN(GA_DRAWING,  1, GA_CMC_DE_DTRGB16,                               GA_FP((edgAntiEn3), 6, GA_MASK1)   |                                    GA_FP((edgAntiEn2), 5, GA_MASK1)   |                                    GA_FP((edgAntiEn1), 4, GA_MASK1)   |                                    GA_FP((blendMode),  1, GA_MASK3)   |                                    GA_FP((clippWndEn), 0, GA_MASK1)))
N
N
N/*=========================================================================
N|                          LOAD REGISTER COMMANDS                           |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Clipping Window Start Register (DECWSR)
N|
N|  Descr  :   This register contains X and Y coordinates of the start
N|             (upper left corner) of the clipping window from the origin of
N|             the destination area. The offset is programmed in pixels
N|             coordinates starting from (0,0), no subpixel resolution is
N|             possible in the positioning of the clipping window.
N|
N|  Params:    x - X starting coordinate of the clipping window
N|
N|             y - Y starting coordinate of the clipping window
N|
N|  Limit.:    The contents of this register will be used only if the clipping
N|             window option will be selected in one of the Draw Line or Draw
N|             Triangle commands.
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_CLIPWNDSTART(x,y) (GA_LOAD(GA_GPR1,                \
N                                    GA_FP((y), 16, GA_MASK12)  |    \
N                                    GA_FP((x),  0, GA_MASK12)))
X#define DRW_LOAD_CLIPWNDSTART(x,y) (GA_LOAD(GA_GPR1,                                                    GA_FP((y), 16, GA_MASK12)  |                                        GA_FP((x),  0, GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Clipping Window End Register (DECWER)
N|
N|  Descr  :   The end coordinates (lower right corner) of the clipping window
N|             in pixels, will be programmed into this register. The user has
N|             to take care that the clipping window does not exceed the
N|             destination area where the primitives will be drawn, otherwise
N|             unexpected results may occur.
N|
N|  Params:    x - X ending coordinate of the clipping window
N|
N|             y - Y ending coordinate of the clipping window
N|
N|  Limit.:    The contents of this register will be used only if the clipping
N|             window option will be selected in one of the Draw Line or Draw
N|             Triangle commands.
N|
N|             The maximum allowed values for CYEND and CXEND are (MHEIGHT-1)
N|             and (MWIDTH-1).
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_CLIPWNDEND(x,y) (GA_LOAD(GA_GPR2,                 \
N                                  GA_FP((y), 16, GA_MASK12)  |     \
N                                  GA_FP((x),  0, GA_MASK12)))
X#define DRW_LOAD_CLIPWNDEND(x,y) (GA_LOAD(GA_GPR2,                                                   GA_FP((y), 16, GA_MASK12)  |                                       GA_FP((x),  0, GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Destination Address Register (DEDAR)
N|
N|  Descr  :   This register contains the lower 32 bits of the physical
N|             address of the start location of the destination area, on which
N|             primitives will be drawn. The address should point to the start
N|             of the destination area (e.g. start of frame buffer), since the
N|             offsets will be calculated inside the Drawing Engine according
N|             to start and end coordinates of the primitives.
N|
N|  Params:    addr - Lower 32 bits (address lines [31:0]) of the physical
N|                    address of the starting location of the destination
N|                    memory area.
N|
N|  Limit.:    The address programmed, must be word aligned if an RGBA32 color
N|             space is used,half-word aligned if an RGB16 color space is used.
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_DESTADDR(addr) (GA_LOAD(GA_GPR4,(addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Destination Memory Width and Height
N|             Register (DEMWR)
N|
N|  Descr  :   This register contains the width, in pixels, of the memory area
N|             used as frame buffer or where primitives will be stored.
N|             The value contained in this register is used allow the Drawing
N|             Engine to calculate the correct addresses for read or writes,
N|             given the X,Y offsets of the current calculations.
N|
N|
N|  Params:    width  - Width of display area, in pixels, any value between 16
N|                      and 4095 are allowed.
N|
N|             height - Height of display area, in pixels, any value between
N|                      16 and 4095 are allowed.
N|
N|
N|  Limit.:    Image width can be specified only as an integer number of
N|             pixels, no sub-pixel resolution is available in this register.
N|
N|             If a primitive will be programmed, which partially falls
N|             outside the display area, a hard-clipping of this part will be
N|             performed.
N|
N|             !!! Failing to program this register will lead to malfunction
N|             of the Drawing Engine.!!!
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_DESTDIM(width, height) (GA_LOAD(GA_GPR5,                   \
N                                         GA_FP((height), 16, GA_MASK12)  |  \
N                                         GA_FP((width),   0, GA_MASK12)))
X#define DRW_LOAD_DESTDIM(width, height) (GA_LOAD(GA_GPR5,                                                            GA_FP((height), 16, GA_MASK12)  |                                           GA_FP((width),   0, GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Line Start Register (DELSR)
N|
N|  Descr  :   This register contains the START coordinates of the line to be
N|             drawn. They are expressed as an integer coordinate followed by
N|             a fractional part. The fractional part is not decimal, rather
N|             expressed in 1/16 of a pixelas (see the Capricorn datasheet).
N|
N|
N|  Params:    x - The X coordinate of the start position of the line
N|
N|             y - The Y coordinate of the start position of the line
N|
N|
N|  Limit.:    The integer and sub-pixel position should not be disregarded
N|             (for more details please see the Capricorn M datasheet)
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_LINESTART(x,y) (GA_LOAD(GA_GPR6,                 \
N                                 GA_FP ((y), 16, GA_MASK16)   |   \
N                                 GA_FP ((x),  0, GA_MASK16)))
X#define DRW_LOAD_LINESTART(x,y) (GA_LOAD(GA_GPR6,                                                  GA_FP ((y), 16, GA_MASK16)   |                                    GA_FP ((x),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Line End Register (DELER)
N|
N|  Descr  :   This register contains the END coordinates of the line to be
N|             drawn. They are expressed as an integer coordinate followed by
N|             a fractional part. The fractional part is not decimal, rather
N|             expressed in 1/16 of a pixelas (see the Capricorn datasheet).
N|
N|
N|  Params:    x - The X coordinate of the start position of the line
N|
N|             y - The Y coordinate of the start position of the line
N|
N|
N|  Limit.:    The integer and sub-pixel position should not be disregarded
N|             (for more details please see the Capricorn M datasheet)
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_LINEEND(x,y) (GA_LOAD(GA_GPR7,                 \
N                               GA_FP((y), 16, GA_MASK16)   |    \
N                               GA_FP((x),  0, GA_MASK16)))
X#define DRW_LOAD_LINEEND(x,y) (GA_LOAD(GA_GPR7,                                                GA_FP((y), 16, GA_MASK16)   |                                   GA_FP((x),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Triangle Point 1 Register (DEPP1R)
N|
N|  Descr  :   This register holds the X and Y coordinates of point 1 of a
N|             triangle. The coordinates are expressed by an integer part and
N|             a fractional part. The fractional part allows positioning the
N|             coordinates with 1/16 of pixel precision.
N|
N|
N|  Params:    x - The X coordinate of point 1
N|
N|             y - The Y coordinate of point 1
N|
N|
N|  Limit.:    The integer and sub-pixel position should not be disregarded
N|             (for more details please see the Capricorn M datasheet)
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_TRNGLE1(x,y) (GA_LOAD(GA_GPR6,                  \
N                               GA_FP ((y), 16, GA_MASK16)   |    \
N                               GA_FP ((x),  0, GA_MASK16)))
X#define DRW_LOAD_TRNGLE1(x,y) (GA_LOAD(GA_GPR6,                                                 GA_FP ((y), 16, GA_MASK16)   |                                   GA_FP ((x),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Triangle Point 2 Register (DEPP2R)
N|
N|  Descr  :   This register holds the X and Y coordinates of point 2 of a
N|             triangle. The coordinates are expressed by an integer part and
N|             a fractional part. The fractional part allows positioning the
N|             coordinates with 1/16 of pixel precision.
N|
N|
N|  Params:    x - The X coordinate of point 2
N|
N|             y - The Y coordinate of point 2
N|
N|
N|  Limit.:    The integer and sub-pixel position should not be disregarded
N|             (for more details please see the Capricorn M datasheet)
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_TRNGLE2(x,y) (GA_LOAD(GA_GPR7,                 \
N                               GA_FP((y), 16, GA_MASK16)   |    \
N                               GA_FP((x),  0, GA_MASK16)))
X#define DRW_LOAD_TRNGLE2(x,y) (GA_LOAD(GA_GPR7,                                                GA_FP((y), 16, GA_MASK16)   |                                   GA_FP((x),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Triangle Point 3 Register (DEPP3R)
N|
N|  Descr  :   This register holds the X and Y coordinates of point 3 of a
N|             triangle. The coordinates are expressed by an integer part and
N|             a fractional part. The fractional part allows positioning the
N|             coordinates with 1/16 of pixel precision.
N|
N|
N|  Params:    x - The X coordinate of point 3
N|
N|             y - The Y coordinate of point 3
N|
N|
N|  Limit.:    The integer and sub-pixel position should not be disregarded
N|             (for more details please see the Capricorn M datasheet)
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_TRNGLE3(x,y) (GA_LOAD(GA_GPR8,                  \
N                               GA_FP ((y), 16, GA_MASK16)   |    \
N                               GA_FP ((x),  0, GA_MASK16)))
X#define DRW_LOAD_TRNGLE3(x,y) (GA_LOAD(GA_GPR8,                                                 GA_FP ((y), 16, GA_MASK16)   |                                   GA_FP ((x),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine Line Thickness Register (DELTR)
N|
N|  Descr  :   This register contains the thickness of the line to be drawn.
N|             The thickness is expressed by an integer value followed by a
N|             four-bit fractional part that allows adjusting line thickness
N|             with a precision of 1/16 of a pixel. Sub-pixel thicknesses are
N|             possible by programming the integer value to zero.
N|
N|
N|  Params:    val - line thickness value
N|
N|  Limit.:    Note that programming a value of zero in both intg and sub
N|             fields is not possible if the register has to be used.
N|
N|             The apparent thickness depends on the filter coefficients
N|             as well.
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_THICKNESS(val) (GA_LOAD(GA_GPR9,                \
N                                 GA_FP((val), 0, GA_MASK9)))
X#define DRW_LOAD_THICKNESS(val) (GA_LOAD(GA_GPR9,                                                 GA_FP((val), 0, GA_MASK9)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine RGBA32 Color Register (DERGBAR)
N|
N|  Descr  :   When using the RGBA32 color space, the color used to draw
N|             primitives has to be programmed into this register.
N|
N|
N|  Params:    color  - Color Component: color[31-24] - Red
N|                                       color[23-16] - Green
N|                                       color[15-8]  - Blue
N|                                       color[7-0]   - Alpha
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_RGBA32(color) (GA_LOAD(GA_GPR10,                 \
N                                GA_FP((color), 0, GA_MASK32)))
X#define DRW_LOAD_RGBA32(color) (GA_LOAD(GA_GPR10,                                                 GA_FP((color), 0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine RGB16 Color Register (DERGBR)
N|
N|  Descr  :   When using the RGB16 color space, the color used to draw
N|             primitives has to be programmed into this register.
N|             This register provides also an AVAL field, to set the alpha
N|             value of the primitive. The RGB16 mode does not support alpha,
N|             but this value will be used to set the transparency value of a
N|             primitive.
N|
N|
N|  Params:    color  - Color Component RGB565: color[15-11] - Red
N|                                              color[10-5]  - Green
N|                                              color[4-0]   - Blue
N|
N|             alpha  - Alpha value for RGB16 format alpha[7-0].
N|                      Although RGB16 doesn’t directly support alpha, this
N|                      value will be used as transparency value if the
N|                      transparency blending method is used.
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_RGB16(color,alpha) (GA_LOAD(GA_GPR10,                 \
N                                     GA_FP ((alpha), 16, GA_MASK8)  |  \
N                                     GA_FP ((color),  0, GA_MASK16)))
X#define DRW_LOAD_RGB16(color,alpha) (GA_LOAD(GA_GPR10,                                                      GA_FP ((alpha), 16, GA_MASK8)  |                                       GA_FP ((color),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine RGBA32 Background Color Register (DEBKG32)
N|
N|  Descr  :   When performing operations in non-blending mode, the color of
N|             the background has to be programmed into this register.
N|             The Drawing Engine, in this case, will not read the contents
N|             of memory but only overwrite its contents. The color
N|             information is needed to perform antialiasing against a flat
N|             background.
N|
N|
N|  Params:    color  - Color Component: color[31-24] - Red
N|                                       color[23-16] - Green
N|                                       color[15-8]  - Blue
N|                                       color[7-0]   - Alpha
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_RGBA32BGRND(color) (GA_LOAD(GA_GPR11,               \
N                                     GA_FP ((color), 0, GA_MASK32)))
X#define DRW_LOAD_RGBA32BGRND(color) (GA_LOAD(GA_GPR11,                                                    GA_FP ((color), 0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Drawing Engine RGB16 Background Color Register (DEBKG16R)
N|
N|  Descr  :   When performing operations in non-blending mode, the color of
N|             the background has to be programmed into this register.
N|             The Drawing Engine, in this case, will not read the contents
N|             of memory but only overwrite its contents. The color
N|             information is needed to perform antialiasing against a flat
N|             background.
N|
N|
N|  Params:    color  - Color Component RGB565: color[15-11] - Red
N|                                              color[10-5]  - Green
N|                                              color[4-0]   - Blue
N|
N|             alpha  - Alphablending component value (8-bit)
N|
N -------------------------------------------------------------------------*/
N#define DRW_LOAD_RGB16BGRND(color) (GA_LOAD(GA_GPR11,              \
N                                    GA_FP((color), 0, GA_MASK16)))
X#define DRW_LOAD_RGB16BGRND(color) (GA_LOAD(GA_GPR11,                                                  GA_FP((color), 0, GA_MASK16)))
N
N
N/**********************************************
N*                Enums                        *
N**********************************************/
N#define LAST_FILTER_COEF_INDEX   63 /* 0..63 = 64x4=256 entries */
N/* Start-/End- point line caps style */
Ntypedef enum tag_drw_CapStyle_e
N{
N    DRW_BUTTEND    = 0x0u,          /* Butt-end not anti-aliased */
N    DRW_BUTTEND_AA = 0x1u,          /* Butt-end anti-aliased */
N    DRW_CIRCULAR   = 0x2u           /* Circular line caps */
N} drw_CapStyle_e;
N
N/* Blending Mode */
Ntypedef enum tag_drw_blendMode_e
N{
N    DRW_BLEND_OPAQUE            = 0x0u,    /* Opaque Blending Mode */
N    DRW_BLEND_TRANSP            = 0x1u,    /* Transparent Blending Mode */
N    DRW_OVERWRITING             = 0x2u,    /* Overwriting Mode */
N    DRW_BLEND_RGBA32_SATURATION = 0x3u     /* Saturation Mode - Valid only for RGBA32 mode */
N} drw_blendMode_e;
N
N/**********************************************
N*              Structures                     *
N**********************************************/
N/* Memory Configuration */
Ntypedef struct tag_drw_mem_st
N{
N    /* Destination Mem. Params */
N    uint32_t u32DstAddr;            /* Dest. Memory Addr. First Src. Dot*/
N    uint16_t u16DstImgWidth;        /* Dest. Image Width */
N    uint16_t u16DstImgHeight;       /* Dest. Image Height */
N} drw_mem_st;
N
N/* Point Structure */
Ntypedef struct tag_drw_Point_st
N{
N    uint16_t u16X;                 /* X- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels */
N    uint16_t u16Y;                 /* Y- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels */
N} drw_Point_st;
N
N/* Clipping Window Coordinates */
Ntypedef struct tag_drw_clipWnd_st
N{
N    uint16_t u16UlX;                /* Upper Left X-Coord */
N    uint16_t u16UlY;                /* Upper Left Y-Coord */
N    uint16_t u16LrX;                /* Lower Right X-Coord */
N    uint16_t u16LrY;                /* Lower Right Y-Coord */
N} drw_clipWnd_st;
N
N/* Line (RGB16/RGBA32) Command desc. structure */
Ntypedef struct tag_drw_LnOpCfg_st
N{
N    ga_colFmt_e     eColFmt;        /* Line Color fmt. (RGB16/RGBA32)*/
N    drw_blendMode_e eBlndMode;      /* Blending Mode */
N    drw_CapStyle_e  eStartCap;      /* Cap Style of start point */
N    drw_CapStyle_e  eEndCap;        /* Cap Style of end point */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N} drw_LnOpCfg_st;
N
N/* Triangle (RGB16/RGBA32) Command desc. structure */
Ntypedef struct tag_drw_TriOpCfg_st
N{
N    ga_colFmt_e     eColFmt;        /* Line Color fmt. (RGB16/RGBA32)*/
N    drw_blendMode_e eBlndMode;      /* Blending Mode */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N    ga_en_e         eAntialEn1;     /* Antial. Enable for Edge 1 */
N    ga_en_e         eAntialEn2;     /* Antial. Enable for Edge 2 */
N    ga_en_e         eAntialEn3;     /* Antial. Enable for Edge 3 */
N} drw_TriOpCfg_st;
N
N/* Line/Triangle Draw common config. options */
Ntypedef struct tag_drw_OpCfg_st
N{
N    drw_blendMode_e eBlndMode;      /* Blending Mode */
N    uint32_t        u32BgColor;     /* Background color (RGB16/RGBA32) */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N    drw_clipWnd_st  stClipWnd;      /* Clipping Window Parameters */
N} drw_OpCfg_st;
N
N/* Color config. options */
Ntypedef struct tag_drw_Color_st
N{
N    ga_colFmt_e  eColFmt;           /* Primitive Color fmt. (RGB16/RGBA32)*/
N    uint32_t     u32Color;          /* Primitive color (RGB16/RGBA32) */
N    uint8_t      u8Alpha;           /* Primitive alpha-blending (only if
N                                       Transp. blending mode is used) */
N} drw_Color_st;
N
N/* Line description structure */
Ntypedef struct tag_drw_Line_st
N{
N    drw_Point_st   stPtStart;       /* Line Start Point */
N    drw_Point_st   stPtEnd;         /* Line End Point */
N
N    drw_CapStyle_e eStartCap;       /* Cap Style of start point */
N    drw_CapStyle_e eEndCap;         /* Cap Style of end point */
N
N    drw_Color_st   stColor;         /* Color Configuration */
N    uint16_t u16Thickness;          /* Line Thickness-Integer part 12 bits + 4 bits sub pixels */
N} drw_Line_st;
N
N/* Triangle desription structure */
Ntypedef struct tag_drw_Trngl_st
N{
N    drw_Point_st stPt1;             /* Triangle Point 1 */
N    drw_Point_st stPt2;             /* Triangle Point 2 */
N    drw_Point_st stPt3;             /* Triangle Point 3 */
N
N    ga_en_e      eAntialEn1;        /* Antial. Enable for Edge 1 */
N    ga_en_e      eAntialEn2;        /* Antial. Enable for Edge 2 */
N    ga_en_e      eAntialEn3;        /* Antial. Enable for Edge 3 */
N
N    drw_Color_st stColor;           /* Color Configuration */
N} drw_Trngl_st;
N
N/**********************************************
N*      Exported Function Prototypes           *
N**********************************************/
N/*-------------------------------------------------------------------------
N|
N|                      B A S I C      O P E R A T I O N S
N|
N --------------------------------------------------------------------------*/
N/****************************************************************************
N *
N * Function:      vDrw_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetMemDest
N *
N * Purpose:       Sets the destination memory parameters in the Command List
N *
N * Inputs:        pvAddr     - Destination Memory Address
N *                             (First Dot of the destination)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_SetMemDest(const void* pvAddr, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetMemDim
N *
N * Purpose:       Sets the destination memory size in the Command List
N *
N * Inputs:        u16Width   - Destination Memory Width
N *                             Number of lines of the destination image
N *                             (from 1 up to 4095).
N *
N *                u16Height  - Destination Memory Height
N *                             Memory reserved per line within the destination
N *                             in dots (from 1 up to 4095).
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_SetMemDim(uint16_t u16Width, uint16_t u16Height, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetColorRGB16
N *
N * Purpose:       Sets the color that will be used for drawing the primitives
N *                when using RGB16 color space.
N *
N * Inputs:        u16Color   - Color 16-bit RGB Value
N *
N *                u8Alpha    - Alpha blending (8-bit)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Please note that although RGB16 does not have alpha
N *                blending, the value specified as ucAlpha will be used as
N *                such, but only if transparency blending method is used.
N *
N ***************************************************************************/
Nvoid vDrw_SetColorRGB16(uint16_t u16Color, uint8_t u8Alpha, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetColorRGBA32
N *
N * Purpose:       Sets the color that will be used for drawing the primitives
N *                when using RGBA32 color space.
N *
N * Inputs:        u32Color   - 32-bit RGBA Color Value
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_SetColorRGBA32(uint32_t u32Color, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetBgColorRGBA32
N *
N * Purpose:       Sets the background color that will be used for drawing
N *                the primitives in non-blending mode and when RGBA32 color
N *                space is used. The Drawing Engine, in this case, will not
N *                read the contents of memory but only overwr. its contents.
N *
N * Inputs:        u32Color   - 32-bit RGBA Color Value
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_SetBgColorRGBA32(uint32_t u32Color, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetBgColorRGB16
N *
N * Purpose:       Sets the background color that will be used for drawing
N *                the primitives in non-blending mode and when RGB16 color
N *                space is used. The Drawing Engine, in this case, will not
N *                read the contents of memory but only overwr. its contents.
N *
N * Inputs:        u16Color   - 16-bit RGB Color Value
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_SetBgColorRGB16(uint16_t u16Color, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetLineStart
N *
N * Purpose:       Sets the coordinates of a point where the line should start.
N *                Note: The pixel coordinates: Bits: 15..4  integer part
N *                                             Bits:  3..0  sub pixel (in 1/16 steps)
N *
N * Inputs:        u16X        - X- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels 
N *
N *                u16Y        - Y Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   API will not check the range of values (because of performance).
N *
N ***************************************************************************/
Nvoid vDrw_SetLineStart(uint16_t u16X,  uint16_t u16Y, ga_list_st* pstCmdList);
N/****************************************************************************
N *
N * Function:      vDrw_SetLineEnd
N *
N * Purpose:       Sets the coordinates of a point where the line should end
N *
N * Inputs:        u16X        - X- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels 
N *
N *                u16Y        - Y Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   API will not check the range of values (because of performance).
N *
N ***************************************************************************/
Nvoid vDrw_SetLineEnd(uint16_t u16X,  uint16_t u16Y, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetLineThickness
N *
N * Purpose:       Sets the line thickness
N *                Note: The line Thickness: Bits: 15..4  integer part
N *                                          Bits:  3..0  sub pixel (in 1/16 steps)
N *
N * Inputs:        u16Val        Line thickness value-Integer part 12 bits + 4 bits sub pixels 
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   API will not check the range of values (because of performance).
N *
N ***************************************************************************/
Nvoid vDrw_SetLineThickness(uint16_t u16Val, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetTriangle1
N *
N * Purpose:       Sets the point 1 of the triangle
N *                Note: The pixel coordinates: Bits: 15..4  integer part
N *                                             Bits:  3..0  sub pixel (in 1/16 steps)
N *
N * Inputs:        u16X        - X- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels 
N *
N *                u16Y        - Y Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   API will not check the range of values (because of performance).
N * 
N ***************************************************************************/
Nvoid vDrw_SetTriangle1(uint16_t u16X,  uint16_t u16Y, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetTriangle2
N *
N * Purpose:       Sets the point 2 of the triangle
N *                Note: The pixel coordinates: Bits: 15..4  integer part
N *                                             Bits:  3..0  sub pixel (in 1/16 steps)
N *
N * Inputs:        u16X        - X- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels 
N *
N *                u16Y        - Y Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   API will not check the range of values (because of performance).
N *
N ***************************************************************************/
Nvoid vDrw_SetTriangle2(uint16_t u16X,  uint16_t u16Y, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetTriangle3
N *
N * Purpose:       Sets the point 1 of the triangle
N *                Note: The pixel coordinates: Bits: 15..4  integer part
N *                                             Bits:  3..0  sub pixel (in 1/16 steps)
N  *
N * Inputs:        u16X        - X- Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels 
N *
N *                u16Y        - Y Coordinate of the Point-Integer part 12 bits + 4 bits sub pixels
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   API will not check the range of values (because of performance).
N *
N ***************************************************************************/
Nvoid vDrw_SetTriangle3(uint16_t u16X,  uint16_t u16Y, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetClippWnd
N *
N * Purpose:       Sets the Clipping Window Coordinates
N *
N * Inputs:        pstClipWnd - Pointer to Clipping Window Coordinates
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vDrw_SetClippWnd(drw_clipWnd_st* pstClipWnd, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetLineCmd
N *
N * Purpose:       Inserts the appropriate Line (RGBA32/RGB16) command. The
N *                type of the command is determined by the given color space
N *
N * Inputs:        pstParam   - Pointer to Line Command option parameters
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Blend mode DRW_BLEND_RGBA32_SATURATION in pstParam will be
N *                vaild only for RGBA32 mode. Because of performance reason API
N *                will not check it.
N *
N ***************************************************************************/
Nvoid vDrw_SetLineCmd(drw_LnOpCfg_st* pstParam, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_SetTriangleCmd
N *
N * Purpose:       Inserts the appropriate Triangle (RGBA32/RGB16) command.
N *                The exact type of the command is determined by the given
N *                color space.
N *
N * Inputs:        pstParam   - Pointer to Triangle Command option parameters
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Blend mode DRW_BLEND_RGBA32_SATURATION in pstParam will be
N *                vaild only for RGBA32 mode. Because of performance reason API
N *                will not check it.
N *
N ***************************************************************************/
Nvoid vDrw_SetTriangleCmd(drw_TriOpCfg_st* pstParam, ga_list_st* pstCmdList);
N
N/*-------------------------------------------------------------------------
N|
N|                    D R A W I N G      O P E R A T I O N S
N|
N --------------------------------------------------------------------------*/
N/****************************************************************************
N *
N * Function:      vDrw_DrawLine
N *
N * Purpose:       Inserts all neccessarry commands for drawing the line
N *                Note: The pixel coordinates: Bits: 15..4  integer part
N *                                             Bits:  3..0  sub pixel (in 1/16 steps)
N *
N * Inputs:        pstMem     - Pointer to Destination Memory description parameters
N *
N *                pstOption  - Pointer to Configuration options required for line draw
N *                             operation
N *
N *                pstLine    - Pointer to Specifying line that should be drawn
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Blend mode DRW_BLEND_RGBA32_SATURATION in pstParam will be
N *                vaild only for RGBA32 mode. Because of performance reason API
N *                will not check it.
N *
N ***************************************************************************/
Nvoid vDrw_DrawLine(drw_mem_st* pstMem, drw_OpCfg_st *pstOption,
N                   drw_Line_st *pstLine, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vDrw_DrawTriangle
N *
N * Purpose:       Inserts all neccessarry commands for drawing the triangle
N *                Note: The pixel coordinates: Bits: 15..4  integer part
N *                                             Bits:  3..0  sub pixel (in 1/16 steps)
N *
N * Inputs:        stMem      - Destination Memory description parameters
N *
N *                stOption   - Configuration options required for line draw
N *                             operation
N *
N *                stTrngl    - Specifies the triangle that should be drawn
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Blend mode DRW_BLEND_RGBA32_SATURATION in pstParam will be
N *                vaild only for RGBA32 mode. Because of performance reason API
N *                will not check it.
N *
N ***************************************************************************/
Nvoid vDrw_DrawTriangle(drw_mem_st* pstMem, drw_OpCfg_st *pstOption,
N                       drw_Trngl_st *pstTrngl, ga_list_st* pstCmdList);
N                       
N
N/****************************************************************************
N *
N * Function:      boDrw_SetFilterCoefDrawEngine
N *
N * Purpose:       Sets 32-Bit Filter Coeffcients for 4 entries(4 x 8 Bits).
N *
N * Inputs:        u8CoefIndex  - Index of location for Coefficents 
N *                              (0 .. LAST_FILTER_COEF_INDEX)
N *
N *                u32CoefValue - 32 Bit values for 4 entries (4 x 8 Bits).
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE: Ok
N *                C_FALSE: wrong parameter 
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boDrw_SetFilterCoefDrawEngine (uint8_t u8CoefIndex,  
N                                      uint32_t u32CoefValue);
N                       
N
N/****************************************************************************/
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N
N#endif /* DRAW_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: draw.h
N**  $Revision: 1.15 $
N**  $Date: 2015/05/04 09:07:14 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  : 
N** | REASON : 
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices,” or
N  “TOSHIBA Semiconductor Reliability Handbook” etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage”).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCALIMER ****************************/
N
L 26 "..\..\..\..\lldd\src\draw.c" 2
N
N/*********************************************/
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1847  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to non-integer type "type" not allowed */
S  #pragma ghs nowarning 1858  /* Rule 17.4 [R] : subscript operator may only be applied to objects declared as an array type */
S  #pragma ghs nowarning 1864  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to narrower underlying type, "type", not allowed */
S  #pragma ghs nowarning 1865  /* Rule 10.1 [R] : conversion from underlying type, "int", to same width underlying type, "uint32_t", not allowed */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to underlying type, "type", changes signedness */
S  #pragma ghs nowarning 1867  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
S  #pragma ghs nowarning 1878  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to wider type "type" not allowed */
S  #pragma ghs nowarning 1879  /* Rule 10.3 [R] : Restrict explicit casts for integer type expressions */
S
S  #pragma ghs nowarning 1834  /* Rule 11.3 [A] : disable casting error */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S  #pragma ghs nowarning 1855  /* Rule 13.2 [A] : Explicit test of a value against zero unless the expression is Boolean */
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */
S  #pragma ghs nowarning 1737  /* Rule 12.1 [A] : expression may not depend on operator precedence rules */
S
N#endif
N/**********************************************
N*    Stat. Var and Func. Prototypes           *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*    Glob. Var and Func. Prototypes           *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*                Macros                       *
N**********************************************/
N#define LLDD_GA_DRAW_C_REVISION     "$Revision: 1.15 $"
N#define LLDD_GA_DRAW_C_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*********************************************/
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/ 
N
Nstatic uint8_t au8LLDD_GA_DRAW_C_REVISION[] = LLDD_GA_DRAW_C_REVISION;
Xstatic uint8_t au8LLDD_GA_DRAW_C_REVISION[] = "$Revision: 1.15 $";
Nstatic uint8_t au8LLDD_GA_DRAW_C_TAG[]      = LLDD_GA_DRAW_C_TAG;
Xstatic uint8_t au8LLDD_GA_DRAW_C_TAG[]      = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GA_DRAW_H_REVISION[] = LLDD_GA_DRAW_H_REVISION;
Xstatic uint8_t au8LLDD_GA_DRAW_H_REVISION[] = "$Revision: 1.15 $";
Nstatic uint8_t au8LLDD_GA_DRAW_H_TAG[]      = LLDD_GA_DRAW_H_TAG;
Xstatic uint8_t au8LLDD_GA_DRAW_H_TAG[]      = "$Name: LLDD_1_7_GFX $";
N
N/*********************************************/
N
N/**********************************************
N*          Functions                          *
N**********************************************/
Nvoid vDrw_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag)
N{
N    *pau8ModuleRevision = &au8LLDD_GA_DRAW_C_REVISION[0];
N    *pau8ModuleTag      = &au8LLDD_GA_DRAW_C_TAG[0];
N    *pau8HeaderRevision = &au8LLDD_GA_DRAW_H_REVISION[0];
N    *pau8HeaderTag      = &au8LLDD_GA_DRAW_H_TAG[0];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetMemDest(const void* pvAddr, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N    
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N    
N    pu64Curr[0] = DRW_LOAD_DESTADDR((uint64_t) pvAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)((((uint64_t) pvAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetMemDim(uint16_t u16Width, uint16_t u16Height, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N    
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N    
N    pu64Curr[0] = DRW_LOAD_DESTDIM(u16Width, u16Height);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Height)) & (0xfffu)) << (16)) | (((uint64_t)((u16Width)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetColorRGB16(uint16_t u16Color, uint8_t u8Alpha, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_RGB16(u16Color,u8Alpha);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u8Alpha)) & (0xffu)) << (16)) | (((uint64_t)((u16Color)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetColorRGBA32(uint32_t u32Color, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_RGBA32(u32Color);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u32Color)) & (0xffffffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetBgColorRGBA32(uint32_t u32Color, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_RGBA32BGRND(u32Color);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((11)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u32Color)) & (0xffffffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetBgColorRGB16(uint16_t u16Color, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_RGB16BGRND(u16Color);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((11)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Color)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetLineStart(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_LINESTART( u16X, u16Y);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetLineEnd(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_LINEEND( u16X, u16Y);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
N
Nvoid vDrw_SetLineThickness(uint16_t u16Val, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_THICKNESS(u16Val);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Val)) & (0x1ffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetTriangle1(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_TRNGLE1(u16X, u16Y);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetTriangle2(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_TRNGLE2(u16X, u16Y);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetTriangle3(uint16_t u16X, uint16_t u16Y, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_TRNGLE3(u16X, u16Y);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((8)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetClippWnd(drw_clipWnd_st* pstClipWnd, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 2;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = DRW_LOAD_CLIPWNDSTART(pstClipWnd->u16UlX, pstClipWnd->u16UlY);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((1)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstClipWnd->u16UlY)) & (0xfffu)) << (16)) | (((uint64_t)((pstClipWnd->u16UlX)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = DRW_LOAD_CLIPWNDEND(pstClipWnd->u16LrX, pstClipWnd->u16LrY);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((2)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstClipWnd->u16LrY)) & (0xfffu)) << (16)) | (((uint64_t)((pstClipWnd->u16LrX)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[2];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetLineCmd(drw_LnOpCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    if(pstParam->eColFmt == GA_RGB16)
N    {
N        pu64Curr[0] = DRW_LINERGB16(pstParam->eStartCap,
N                                    pstParam->eEndCap,
N                                    pstParam->eBlndMode,
N                                    pstParam->eClipWndEn);
X        pu64Curr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x04u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eStartCap)) & (0xfu)) << (8)) | (((uint64_t)((pstParam->eEndCap)) & (0xfu)) << (4)) | (((uint64_t)((pstParam->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    else
N    {
N        pu64Curr[0] = DRW_LINERGBA32(pstParam->eStartCap,
N                                     pstParam->eEndCap,
N                                     pstParam->eBlndMode,
N                                     pstParam->eClipWndEn);
X        pu64Curr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x03u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eStartCap)) & (0xfu)) << (8)) | (((uint64_t)((pstParam->eEndCap)) & (0xfu)) << (4)) | (((uint64_t)((pstParam->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        
N    }
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_SetTriangleCmd(drw_TriOpCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    if(pstParam->eColFmt == GA_RGB16)
N    {
N        pu64Curr[0] = DRW_TRIANGLE_RGB16(pstParam->eAntialEn3,
N                                         pstParam->eAntialEn2,
N                                         pstParam->eAntialEn1,
N                                         pstParam->eBlndMode,
N                                         pstParam->eClipWndEn);
X        pu64Curr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x06u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eAntialEn3)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eAntialEn2)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eAntialEn1)) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    else
N    {
N        pu64Curr[0] = DRW_TRIANGLE_RGBA32(pstParam->eAntialEn3,
N                                          pstParam->eAntialEn2,
N                                          pstParam->eAntialEn1,
N                                          pstParam->eBlndMode,
N                                          pstParam->eClipWndEn);
X        pu64Curr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x05u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eAntialEn3)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eAntialEn2)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eAntialEn1)) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N
N    pstCmdList->pu64Current = &pu64Curr[1];
N}
N
N/* ....................................................................... */
Nvoid vDrw_DrawLine(drw_mem_st* pstMem, drw_OpCfg_st *pstOption,
N                   drw_Line_st *pstLine, ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 5;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 6;
S    if(pstOption->eClipWndEn == GA_EN)
S    {
S        u32NeededDW = u32NeededDW + 2;
S    }
S    if(pstOption->eBlndMode == DRW_OVERWRITING)
S    {
S        u32NeededDW++;
S    }
S    u32NeededDW = u32NeededDW + RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    /* Destination Memory */
N    pu64Curr[0] = DRW_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = DRW_LOAD_DESTDIM(pstMem->u16DstImgWidth, pstMem->u16DstImgHeight);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstMem->u16DstImgHeight)) & (0xfffu)) << (16)) | (((uint64_t)((pstMem->u16DstImgWidth)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Line Parameters */
N    pu64Curr[2] = DRW_LOAD_LINESTART(pstLine->stPtStart.u16X, pstLine->stPtStart.u16Y);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstLine ->stPtStart . u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((pstLine ->stPtStart . u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = DRW_LOAD_LINEEND(pstLine->stPtEnd.u16X, pstLine->stPtEnd.u16Y);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstLine ->stPtEnd . u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((pstLine ->stPtEnd . u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[4] = DRW_LOAD_THICKNESS(pstLine->u16Thickness);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstLine ->u16Thickness)) & (0x1ffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Clipping Window */
N    if(pstOption->eClipWndEn == GA_EN)
N    {
N        pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDSTART(pstOption->stClipWnd.u16UlX,
N                                                 pstOption->stClipWnd.u16UlY);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((1)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->stClipWnd . u16UlY)) & (0xfffu)) << (16)) | (((uint64_t)((pstOption->stClipWnd . u16UlX)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N        pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDEND(pstOption->stClipWnd.u16LrX,
N                                               pstOption->stClipWnd.u16LrY);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((2)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->stClipWnd . u16LrY)) & (0xfffu)) << (16)) | (((uint64_t)((pstOption->stClipWnd . u16LrX)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    if(pstLine->stColor.eColFmt == GA_RGB16)
N    {
N        /* Background Color */
N        if(pstOption->eBlndMode == DRW_OVERWRITING)
N        {
N            pu64Curr[u8Curr] = DRW_LOAD_RGB16BGRND(pstOption->u32BgColor);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((11)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->u32BgColor)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N
N        /* Line Color */
N        pu64Curr[u8Curr] = DRW_LOAD_RGB16((uint16_t)(pstLine->stColor.u32Color),
N                                           pstLine->stColor.u8Alpha);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstLine ->stColor . u8Alpha)) & (0xffu)) << (16)) | (((uint64_t)(((uint16_t)(pstLine ->stColor . u32Color))) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        /* Line Draw Command */
N        pu64Curr[u8Curr] = DRW_LINERGB16(pstLine->eStartCap,
N                                         pstLine->eEndCap,
N                                         pstOption->eBlndMode,
N                                         pstOption->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x04u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstLine ->eStartCap)) & (0xfu)) << (8)) | (((uint64_t)((pstLine ->eEndCap)) & (0xfu)) << (4)) | (((uint64_t)((pstOption->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstOption->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        u8Curr++;
N    }
N    else
N    {
N        if(pstOption->eBlndMode == DRW_OVERWRITING)
N        {
N            pu64Curr[u8Curr] = DRW_LOAD_RGBA32BGRND(pstOption->u32BgColor);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((11)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->u32BgColor)) & (0xffffffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N
N        pu64Curr[u8Curr] = DRW_LOAD_RGBA32(pstLine->stColor.u32Color);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstLine ->stColor . u32Color)) & (0xffffffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        pu64Curr[u8Curr] = DRW_LINERGBA32(pstLine->eStartCap,
N                                          pstLine->eEndCap,
N                                          pstOption->eBlndMode,
N                                          pstOption->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x03u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstLine ->eStartCap)) & (0xfu)) << (8)) | (((uint64_t)((pstLine ->eEndCap)) & (0xfu)) << (4)) | (((uint64_t)((pstOption->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstOption->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        u8Curr++;
N    }
N
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N}
N
N/* ....................................................................... */
Nvoid vDrw_DrawTriangle(drw_mem_st* pstMem, drw_OpCfg_st *pstOption,
N                       drw_Trngl_st *pstTrngl, ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 5;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 6;
S   
S    if(pstOption->eClipWndEn == GA_EN)
S    {
S        u32NeededDW = u32NeededDW + 2;
S    }
S    if(pstOption->eBlndMode == DRW_OVERWRITING)
S    {
S        u32NeededDW++;
S    }
S    u32NeededDW = u32NeededDW + RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    /* Destination Memory */
N    pu64Curr[0] = DRW_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = DRW_LOAD_DESTDIM(pstMem->u16DstImgWidth, pstMem->u16DstImgHeight);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstMem->u16DstImgHeight)) & (0xfffu)) << (16)) | (((uint64_t)((pstMem->u16DstImgWidth)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Triangle Points */
N    pu64Curr[2] = DRW_LOAD_TRNGLE1(pstTrngl->stPt1.u16X, pstTrngl->stPt1.u16Y);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstTrngl->stPt1 . u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((pstTrngl->stPt1 . u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = DRW_LOAD_TRNGLE2(pstTrngl->stPt2.u16X, pstTrngl->stPt2.u16Y);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstTrngl->stPt2 . u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((pstTrngl->stPt2 . u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[4] = DRW_LOAD_TRNGLE3(pstTrngl->stPt3.u16X, pstTrngl->stPt3.u16Y);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((8)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstTrngl->stPt3 . u16Y)) & (0xffffu)) << (16)) | (((uint64_t)((pstTrngl->stPt3 . u16X)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    /* Clipping Window */
N    if(pstOption->eClipWndEn == GA_EN)
N    {
N        pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDSTART(pstOption->stClipWnd.u16UlX,
N                                                 pstOption->stClipWnd.u16UlY);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((1)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->stClipWnd . u16UlY)) & (0xfffu)) << (16)) | (((uint64_t)((pstOption->stClipWnd . u16UlX)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N        pu64Curr[u8Curr] = DRW_LOAD_CLIPWNDEND(pstOption->stClipWnd.u16LrX,
N                                               pstOption->stClipWnd.u16LrY);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((2)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->stClipWnd . u16LrY)) & (0xfffu)) << (16)) | (((uint64_t)((pstOption->stClipWnd . u16LrX)) & (0xfffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    if(pstTrngl->stColor.eColFmt == GA_RGB16)
N    {
N        /* Background Color */
N        if(pstOption->eBlndMode == DRW_OVERWRITING)
N        {
N            pu64Curr[u8Curr] = DRW_LOAD_RGB16BGRND(pstOption->u32BgColor);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((11)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->u32BgColor)) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N
N        /* Line Color */
N        pu64Curr[u8Curr] = DRW_LOAD_RGB16((uint16_t)(pstTrngl->stColor.u32Color),
N                                          pstTrngl->stColor.u8Alpha);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstTrngl->stColor . u8Alpha)) & (0xffu)) << (16)) | (((uint64_t)(((uint16_t)(pstTrngl->stColor . u32Color))) & (0xffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        /* Triangle Draw Command */
N        pu64Curr[u8Curr] = DRW_TRIANGLE_RGB16(pstTrngl->eAntialEn3,
N                                              pstTrngl->eAntialEn2,
N                                              pstTrngl->eAntialEn1,
N                                              pstOption->eBlndMode,
N                                              pstOption->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x06u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstTrngl->eAntialEn3)) & (0x1u)) << (6)) | (((uint64_t)((pstTrngl->eAntialEn2)) & (0x1u)) << (5)) | (((uint64_t)((pstTrngl->eAntialEn1)) & (0x1u)) << (4)) | (((uint64_t)((pstOption->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstOption->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        u8Curr++;
N    }
N    else
N    {
N        /* Background Color */
N        if(pstOption->eBlndMode == DRW_OVERWRITING)
N        {
N            pu64Curr[u8Curr] = DRW_LOAD_RGBA32BGRND(pstOption->u32BgColor);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((11)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstOption->u32BgColor)) & (0xffffffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N
N        /* Line Color */
N        pu64Curr[u8Curr] = DRW_LOAD_RGBA32(pstTrngl->stColor.u32Color);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstTrngl->stColor . u32Color)) & (0xffffffffu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        /* Triangle Draw Command */
N        pu64Curr[u8Curr] = DRW_TRIANGLE_RGBA32(pstTrngl->eAntialEn3,
N                                               pstTrngl->eAntialEn2,
N                                               pstTrngl->eAntialEn1,
N                                               pstOption->eBlndMode,
N                                               pstOption->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x2u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x05u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstTrngl->eAntialEn3)) & (0x1u)) << (6)) | (((uint64_t)((pstTrngl->eAntialEn2)) & (0x1u)) << (5)) | (((uint64_t)((pstTrngl->eAntialEn1)) & (0x1u)) << (4)) | (((uint64_t)((pstOption->eBlndMode)) & (0x7u)) << (1)) | (((uint64_t)((pstOption->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        u8Curr++;
N    }
N
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N}
N
N/* ....................................................................... */
Nbool_t boDrw_SetFilterCoefDrawEngine (uint8_t u8CoefIndex,  
N                                      uint32_t u32CoefValue)
N{
N    bool_t    boRes = C_TRUE;
X    bool_t    boRes = (1);
N    
N    /* check parameters: */
N    if (u8CoefIndex > LAST_FILTER_COEF_INDEX)
X    if (u8CoefIndex > 63)
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    else
N    {
N        vSetGADEFCR(u8CoefIndex, u32CoefValue);
X        (*((volatile u32GADEFCR_word_view *)(0xC0C00200U + ((uint16_t)(u8CoefIndex) * 0x04U))) = (u32CoefValue));
N    }
N    return (boRes);
N}
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: draw.c
N**  $Revision: 1.15 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1847 / 10.3 - cast of complex integer expression with underlying type
N** |                        "type" to non-integer type "type" not allowed 
N** | CONS.  : disable
N** | REASON : to use macros from i/o header files, unavoidable when addressing 
N** |          memory mapped registers 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1858 /17.4  - subscript operator may only be applied to objects 
N** |                        declared as an array type
N** | CONS.  : allow
N** | REASON : to handle array of data by usage of pointer 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1864 /10.1  - implicit conversion from underlying type, "type", 
N** |                        to narrower underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : to use macros from i/o header files 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1865 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to same width underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1866 /10.1  -  implicit conversion from underlying type, "type",  
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1867 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1878 /10.3  -   cast of complex integer expression with underlying 
N** |                          type "type" to wider type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as variables in io 
N** |          header file or to allow shift operation
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1879 /10.3  - 	 cast of complex integer expression with underlying
N** |                           type "type" to same width type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as macros in io header file
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices,” or
N  “TOSHIBA Semiconductor Reliability Handbook” etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage”).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCALIMER ****************************/
N
