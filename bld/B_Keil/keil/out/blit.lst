L 1 "..\..\..\..\lldd\src\blit.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver (Blitting Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Blitting Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N/*======================================
N            Include Files
N=======================================*/
N#include "ga.h"
L 1 "..\..\..\..\lldd\inc\ga.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.19 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_H
N#define GA_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "ga_common.h"
L 1 "..\..\..\..\lldd\inc\ga_common.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/07/21 12:30:20 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_COMMON_H
N#define GA_COMMON_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\lldd\inc\ga_common.h" 2
N
N#define LLDD_GA_COMMON_H_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_COMMON_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*==========================================================================
N|                       GA Configuration Parameters                         |
N ==========================================================================*/
N/*---------------------------------------
N|        GA Sub-Module inclusion         |
N ---------------------------------------*/
N/* Blitting Engine */
N#define GA_USE_BLITTING
N
N/* Transformation Engine */
N#define GA_USE_TRANSFORM
N
N/* Rotation Engine */
N#define GA_USE_ROTATION
N
N/* Drawing Engine */
N#define GA_USE_DRAWING
N
N/*---------------------------------------
N|         GA List Configuration          |
N ---------------------------------------*/
N/* Maximal Number of commands in one list */
N#define GA_CMD_MAX    2048
N
N/*---------------------------------------
N|  Enable/Disable boundary check for     |
N|         GA Command List                |
N ---------------------------------------*/
N/* Enable/Disable boundary check in drivers for command buffer: */
N/* #define GA_CMDSLIST_BOUNDARY_CHECK */
N
N
N/* 1 double word more will be reserved by calculation of needed
N   buffers for GA-API's. This is necesary to add later an END-Command to 
N   finalize the command: 
N*/   
N#define RESERVED_FOR_END_CMD    1
N
N/*======================================
N                Defs
N=======================================*/
N
N/*--------------------------------------
N|     GA General Purpose Registers      |
N --------------------------------------*/
N#define GA_GPR0   0
N#define GA_GPR1   1
N#define GA_GPR2   2
N#define GA_GPR3   3
N#define GA_GPR4   4
N#define GA_GPR5   5
N#define GA_GPR6   6
N#define GA_GPR7   7
N#define GA_GPR8   8
N#define GA_GPR9   9
N#define GA_GPR10  10
N#define GA_GPR11  11
N#define GA_GPR12  12
N#define GA_GPR13  13
N#define GA_GPR14  14
N#define GA_GPR15  15
N#define GA_GPR16  16
N#define GA_GPR17  17
N#define GA_GPR18  18
N#define GA_GPR19  19
N#define GA_GPR20  20
N#define GA_GPR21  21
N#define GA_GPR22  22
N#define GA_GPR23  23
N#define GA_GPR24  24
N#define GA_GPR25  25
N#define GA_GPR26  26
N#define GA_GPR27  27
N#define GA_GPR28  28
N#define GA_GPR29  29
N#define GA_GPR30  30
N#define GA_GPR31  31
N
N
N/*--------------------------------------
N|         GA Command Parameters         |
N --------------------------------------*/
N/* Selection of module to wait on */
Ntypedef enum tag_ga_modul_e
N{
N    GA_GDC0        = 0x0u,
N    GA_FG0         = 0x1u,
N    GA_GDC1        = 0x2u
N} ga_modul_e;
N
N/* Enables/Disables option */
Ntypedef enum tag_ga_en_e
N{
N    GA_DIS         = 0x0u,     /* Disable/off */
N    GA_EN          = 0x1u      /* Enable/on */
N} ga_en_e;
N
N/* Blending Order */
Ntypedef enum tag_blendOrd_e
N{
N    GA_ONTO_DEST   = 0x0u,     /* Onto destination */
N    GA_BEHIND_DEST = 0x1u      /* Behind destination */
N} ga_blendOrd_e;
N
N/* Color format selection */
Ntypedef enum tag_ga_colFmt_e
N{
N    GA_RGB16       = 0x0u,      /* 16-bit RGB format */
N    GA_RGBA32      = 0x1u       /* 32-bit RGBA format */
N} ga_colFmt_e;
N
N/*--------------------------------------
N|        GA Command Construction        |
N --------------------------------------*/
N/* Command Field Masks */
N#define GA_MASK1           0x1u
N#define GA_MASK2           0x3u
N#define GA_MASK3           0x7u
N#define GA_MASK4           0xfu
N#define GA_MASK5           0x1fu
N#define GA_MASK6           0x3fu
N#define GA_MASK7           0x7fu
N#define GA_MASK8           0xffu
N#define GA_MASK9           0x1ffu
N#define GA_MASK10          0x3ffu
N#define GA_MASK12          0xfffu
N#define GA_MASK14          0x3fffu
N#define GA_MASK15          0x7fffu
N#define GA_MASK16          0xffffu
N#define GA_MASK22          0x3fffffu
N#define GA_MASK24          0xffffffu
N#define GA_MASK32          0xffffffffu
N#define GA_MASK36          0xfffffffffull
N#define GA_MASK48          0xffffffffffffull
N#define GA_MASK64          0xffffffffffffffffull
N
N/* GA Unit selection */
N#define GA_SCHED           0x0u
N#define GA_BLITING         0x1u
N#define GA_DRAWING         0x2u
N#define GA_ROTATION        0x3u
N#define GA_TRANSFORM       0x4u
N
N/*** Command Codes ***/
N#define GA_CMC_LGPR        0x1u
N#define GA_CMC_CSWVSYNC    0x2u
N#define GA_CMC_CSUIC	     0x3u
N#define GA_CMC_CSGDC0CC	   0x4u
N#define GA_CMC_CSGDC1CC	   0x5u
N#define GA_CMC_END         0xffu
N
N/* Blitting Engine Command Codes */
N
N#define GA_CMC_BLTO16      0x02u
N#define GA_CMC_BLTO32      0x04u
N#define GA_CMC_BLTORLEI16  0x0au
N#define GA_CMC_BLTORLEI24  0x06u
N#define GA_CMC_BLTORLEI24A 0x0Eu
N#define GA_CMC_BLTORLEI32  0x0cu
N#define GA_CMC_BLTOP16     0x12u
N#define GA_CMC_BLTOP32     0x14u
N#define GA_CMC_BLTB16      0x03u
N#define GA_CMC_BLTB32      0x07u
N#define GA_CMC_BLTBRLEI16  0x0bu
N#define GA_CMC_BLTBRLEI24  0x05u
N#define GA_CMC_BLTBRLEI24A 0x0fu
N#define GA_CMC_BLTBRLEI32  0x0du
N#define GA_CMC_BLTBP16     0x13u
N#define GA_CMC_BLTBP32     0x17u
N
N/* Transformation Engine Command Code */
N#define GA_CMC_TRANSF      0x01u
N#define GA_CMC_TRANSFB     0x00u
N
N/* Rotation Engine Command Code */
N#define GA_CMC_ROT         0x01u
N#define GA_CMC_ROTB        0x00u
N
N/* Drawing Engine Command Codes */
N#define GA_CMC_DE_DLRGBA32 0x03u
N#define GA_CMC_DE_DLRGB16  0x04u
N#define GA_CMC_DE_DTRGBA32 0x05u
N#define GA_CMC_DE_DTRGB16  0x06u
N
N/* Command Field Offsets */
N#define GA_ENG_OFF         60
N#define GA_LEN_OFF         56
N#define GA_CMC_OFF         48
N#define GA_SPC_OFF          0
N
N/* Command Field Masks */
N#define GA_ENG_MSK         (GA_MASK3)
N#define GA_LEN_MSK         (GA_MASK4)
N#define GA_CMC_MSK         (GA_MASK8)
N#define GA_SPC_MSK         (GA_MASK48)
N
N/* Macro for command field positioning */
N#define GA_FP(val, offset, mask) (((uint64_t)(val) & (mask)) << (offset))
N
N/* GA Command Fields (Engine, Length, Command code, Cmd Specific Params.)*/
N#define GA_ENG(Engine) (GA_FP((Engine), GA_ENG_OFF, GA_ENG_MSK))
N#define GA_LEN(Len)    (GA_FP((Len)   , GA_LEN_OFF, GA_LEN_MSK))
N#define GA_CMC(Code)   (GA_FP((Code)  , GA_CMC_OFF, GA_CMC_MSK))
N#define GA_SPC(spec)   (GA_FP((spec)  , GA_SPC_OFF, GA_SPC_MSK))
N
N/* GA Command Construction Macro */
N#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    | \
N                                                GA_ENG((Engine))   | \
N                                                GA_LEN((Len))      | \
N                                                GA_CMC((CmdCode))  | \
N                                                GA_SPC((CmdSpec)))
X#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    |                                                 GA_ENG((Engine))   |                                                 GA_LEN((Len))      |                                                 GA_CMC((CmdCode))  |                                                 GA_SPC((CmdSpec)))
N
N/*=========================================================================
N|                        SCHEDULER OPERATION COMMANDS                      |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load General-Purpose Register Command (LGPR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to configure
N|             one out of the 32 General-Purpose Registers. The command
N|             specific parameter for this command is the number of the
N|             register that should be loaded and the value itself.
N|
N|  Params:    regNr   - The number of the General-Purpose Register that
N|                       should be loaded
N|
N|             uiVal   - Value that should be stored within the selected
N|                       register. If the register does not encapsulate
N|                       32 bits the value within the command has to be right
N|                       aligned.
N|
N -------------------------------------------------------------------------*/
N#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,       \
N                               GA_FP ((regNr), 32, GA_MASK5)      |   \
N                               GA_FP ((uiVal),  0,  GA_MASK32)))
X#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,                                      GA_FP ((regNr), 32, GA_MASK5)      |                                  GA_FP ((uiVal),  0,  GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   END Command (CSEND)
N|
N|  Descr  :   The CSEND command must be placed at the end of every command
N|             list. It signals the Command Scheduler that all commands have
N|             been executed. When the Command Scheduler is detecting this
N|             mark, a flag in the status register signals that the command
N|             list was executed. Optionally an interrupt is generated.
N|
N|  Params:    none
N|
N -------------------------------------------------------------------------*/
N#define GA_END() (GA_CMN(GA_SCHED, 0x1u, GA_CMC_END,0x0u))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Wait VSYNC Command (CSWVSYNC)
N|
N|  Descr  :   The CSWVSYNC command can be used to synchronize parts of the
N|             command list with the vertical synchronization signal VSYNC
N|             from the GDC or the Frame Grabber.
N|
N|             When the Command Scheduler is reading the CSWVSYNC command
N|             it waits until the next vertical synchronization of the
N|             display/camera input takes place before executing the next
N|             command.
N|
N|  Params:    module   -  VSYNC select:
N|                         Use: GA_GDC0     - Wait on GDC0
N|                              GA_FG0      - Wait on FG0
N|                              GA_GDC1     - Wait on GDC1
N|                              GA_FG1      - Wait on FG1
N|
N|
N -------------------------------------------------------------------------*/
N#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,        \
N                         GA_FP ((module), 0, GA_MASK2)))
X#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,                                 GA_FP ((module), 0, GA_MASK2)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   User Interrupt Command (CSUIC)
N|
N|  Descr  :   The CSUIC command can be used to signal the MCU that a
N|             certain part of the Command List is already executed or
N|             will now start execution.
N|
N|  Params:    interrupt number:
N|                          Use: 0 - 23
N|                               values > 23 will be ignored
N|
N -------------------------------------------------------------------------*/
N#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,    \
N                                  GA_FP ((number), 0, GA_MASK6)))
X#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,                                      GA_FP ((number), 0, GA_MASK6)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC0 Configuration Command (CSGDC0CC)
N|
N|  Descr  :   The CSGDC0CC command can be used to change the content of GDC0 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC0 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC1 Configuration Command (CSGDC1CC)
N|
N|  Descr  :   The CSGDC1CC command can be used to change the content of GDC1 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC1 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N
N/*======================================
N              Structures
N=======================================*/
N/* Command List Structure */
Ntypedef struct tag_ga_list_st
N{
N    uint64_t  ullCommands[GA_CMD_MAX] ;
X    uint64_t  ullCommands[2048] ;
N    uint64_t* pu64Current;
N    uint32_t  u32UsedDoubleWords; /* used or needed double words for an  GA-API */
N    int32_t   i32FreeSpaceStat;   /* C_SUCCESS: OK no space free error,
N                                     C_FAILED:  No free space for GA-API */
N} ga_list_st ;
N
N/****************************************************************************/
N
N
N#endif /* GA_COMMON_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_common.h
N**  $Revision: 1.14 $
N**  $Date: 2015/07/21 12:30:20 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  : 
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\lldd\inc\ga.h" 2
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_H_REVISION     "$Revision: 1.19 $"
N#define LLDD_GA_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/* Timeout */
N#define GA_TIMEOUT  10000
N
N/* Size of Draw Engine Filter RAM (in doublewords) */
N#define GA_DE_FILTER_SIZE 64
N
N/* GA Interrupt Masks */
N#define GA_IRQ_MASK_CENDIM  0x00000001U    /* GA Command End Interrupt Mask.                          */
N#define GA_IRQ_MASK_CSCEIM  0x00000004U    /* Command Scheduler Command Error Interrupt Mask          */
N#define GA_IRQ_MASK_CSLEIM  0x00000008U    /* Command Scheduler Command List Executed Interrupt Mask  */
N#define GA_IRQ_MASK_WBWIM   0x00000010U    /* GA Write Buffer Write Bus-Error Interrupt Mask          */
N#define GA_IRQ_MASK_WBRIM   0x00000020U    /* GA Write Buffer Read Bus-Error Interrupt Mask           */
N#define GA_IRQ_MASK_CBIM    0x00000040U    /* GA Cache Buffer Bus-Error Interrupt Mask                */
N#define GA_IRQ_MASK_RBIM    0x00000080U    /* GA Read Buffer Bus-Error Interrupt Mask                 */
N#define GA_IRQ_MASK_CSLUIM  0xFFFFFF00U    /* Command List User Interrupt Mask 0 – 23                 */
N
N/*======================================
N                Enums
N=======================================*/
N/****************************************
N*         GAIMR Param.Values
N****************************************/
N/* IRQ Mask */
Ntypedef enum tag_ga_irqen_e
N{
N    GA_IRQ_EN  = 0x1u,     /* Enable IRQ */
N    GA_IRQ_DIS = 0x0u      /* Disable IRQ */
N} ga_irqen_e;
N
N/* Bus type */
Ntypedef enum tag_ga_bus_type_e
N{
N    GA_READ_BUF_BUS        = 0x00U,
N    GA_CACHE_BUF_BUS       = 0x01U,
N    GA_WRITE_BUF_READ_BUS  = 0x02U,
N    GA_WRITE_BUF_WRITE_BUS = 0x03U,
N    GA_MAX_TYPE_BUS        = 0x04U
N} ga_bus_type_e;
N
N/* Read / Write Direction */
Ntypedef enum tag_ga_buserr_dir_e
N{
N    GA_BUSERR_READ_TRANSF   = 0x0U,
N    GA_BUSERR_WRITE_TRANSF  = 0x1U
N} ga_buserr_dir_e;
N
N/* Burs error Type */
Ntypedef enum tag_ga_buserr_bursttype
N{
N    GA_BUSERR_BURST_TYPE_FIXED   = 0x0U,
N    GA_BUSERR_BURST_TYPE_INCR    = 0x1U
N} ga_buserr_bursttype;
N
N/* Burst Size */
Ntypedef enum tag_ga_buserr_burstsize
N{
N    GA_BUSERR_BURST_1BYTE     = 0x0U,
N    GA_BUSERR_BURST_2BYTE     = 0x1U,
N    GA_BUSERR_BURST_4BYTE     = 0x2U,
N    GA_BUSERR_BURST_81BYTE    = 0x3U,
N    GA_BUSERR_BURST_16BYTE    = 0x4U,
N    GA_BUSERR_BURST_32BYTE    = 0x5U,
N    GA_BUSERR_BURST_64BYTE    = 0x6U,
N    GA_BUSERR_BURST_128BYTE   = 0x7U
N} ga_buserr_burstsize;
N
N
N/* Response Type */
Ntypedef enum tag_ga_buserr_resptype
N{
N    GA_BUSERR_RESP_OK        = 0x0U,
N    GA_BUSERR_RESP_EXOKAY    = 0x1U,
N    GA_BUSERR_RESP_SLVERR    = 0x2U,
N    GA_BUSERR_RESP_DECERR    = 0x3U
N} ga_buserr_resptype;
N
N/* Memory Protection Region */
Ntypedef enum tag_ga_memory_region_e
N{
N    GA_MEMORY_PROT_REGION_0   = 0x0U,
N    GA_MEMORY_PROT_REGION_1   = 0x1U,
N    GA_MEMORY_PROT_REGION_MAX = 0x2U
N} ga_memory_region_e;
N
N/*======================================
N              Structures
N=======================================*/
N/* GA bus Error Control Signal-Structure */
Ntypedef struct tag_ga_bus_err_ctrl_st
N{
N    ga_buserr_dir_e      eDirection;       /* Read / Write direction */
N    ga_buserr_bursttype  eBurstType;       /* Burst type */
N    ga_buserr_burstsize  eBurstSize;       /* Burst size */
N    ga_buserr_resptype   eRespType;        /* Response Type */
N    uint8_t              u8ByteEnables;    /* Byte-enables for the erroneous transfer. */
N    uint8_t              u8ID;             /* ID tag of the read/write transaction that triggered an error response. */
N    uint8_t              u8BurstLength;    /* Burst length of the read/write transaction that triggered an error response */
N} ga_bus_err_ctrl_st;
N
N/*======================================
N      Exported Function Prototypes
N=======================================*/
N
N/****************************************************************************
N *
N * Function:      vGA_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8CommonRevision - pointer to common header revision string
N *                pau8CommonTag      - pointer to common header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                    uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                    uint8_t** pau8CommonRevision, uint8_t** pau8CommonTag,
N                    uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetMaxUsedBuffSize
N *
N * Purpose:       Resets the counter for used buffer of command list
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ResetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      u32Ga_GetMaxUsedBuffSize
N *
N * Purpose:       To get max. used size of command buffer. This API can be
N *                used to optimize the need size of "GA_CMD_MAX" in ga_list_st
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_GetLastCmdBuffStatus
N *
N * Purpose:       returns the information if there was enough space free for
N *                command over API
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: space status for command list
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_GetLastCmdBuffStatus(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetLastCmdSize
N *
N * Purpose:       returns the uesed buffer size for last API call (in case it
N *                was enough memory in buffer) or it returns needed size of buffer
N *                for last API call (if there was not enough memory in command buffer)
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: sized of used buffer
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetLastCmdSize(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_CheckList
N *
N * Purpose:       To check whether there is enough space in command buffer
N *                to wrote some doble words 
N *
N * Inputs:        pstCmdList  - pointer to command list
N *                u32NeededDW - needed double words 
N *
N * Outputs:       none
N *
N * Return Values: C_FAILED  requested number of commands will not fit into list
N *                C_SUCCESS requested number of commands will fit into list   
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_CheckList(ga_list_st* pstCmdList, uint32_t u32NeededDW);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetList
N *
N * Purpose:       Resets the Command List
N *
N * Inputs:        pstCmdList - Pointer to command list
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   The pointer to current list position will be reset, the
N *                content of the list will remain un-touched.
N *
N ***************************************************************************/
Nvoid vGA_ResetList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CloseList
N *
N * Purpose:       Closes the given list by inserting CSEND command
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CloseList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SyncList
N *
N * Purpose:       Inserts the VSYNC command in the command list in order to
N *                synchronize the execution of the list with vertical (VSYNC)
N *                signal from the GDC or Frame Grabber. When the command
N *                sceduler reaches this command it will stop the list
N *                execution until next VSYNC signal.
N *
N * Inputs:        eModul     - Modul selection to wait on (GDC/FG)
N *                pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SyncList(ga_modul_e eModule, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetUserInt
N *
N * Purpose:       defines Interrupt to CPU
N *
N * Inputs:        u8Number   - Interrupt number
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetUserInt(uint8_t u8Number, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_Enable
N *
N * Purpose:       Enables/Disables the Graphic Accelerator
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_Enable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ReadAheadEnable
N *
N * Purpose:       Enables/Disables ReadBuffer Read Ahead feature
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ReadAheadEnable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_Reset
N *
N * Purpose:       Resets the Graphic Accelerator
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS - Reset successful
N *                C_FAILED  - Reset timeout (Reset was not completted in
N *                            predefined time interval)
N *
N * Limitations:   The function will wait the reset to complete (it can take
N *                until recent bus cycle execution is finished)
N *
N ***************************************************************************/
Nint32_t i32GA_Reset(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetCmdListAddr
N *
N * Purpose:       Sets the physical address of the current command list
N *
N * Inputs:        u32Addr  - Physical address of the command list
N *                           (Must be 64-bit alligned -> uiAddr[2:0] = 0x0)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Make sure that when calling this function command scheduler
N *                is NOT executing a command list !!! Please note, that after
N *                the address is once written, the GA will automatically
N *                start the command list execution.
N *
N ***************************************************************************/
Nvoid vGA_SetCmdListAddr(uint32_t u32Addr);
N
N
N/****************************************************************************
N *
N * Function:      u8GA_GetStatus
N *
N * Purpose:       Reads the Graphic Accelerator Status register
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA Status Register (GASR) value
N *
N * Limitations:   The caller must parse returned status byte. For this
N *                purpose see the description of GASR Register.
N *
N ***************************************************************************/
Nuint8_t u8GA_GetStatus(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListFinished
N *
N * Purpose:       Indicates that the operation of a command list was finished or
N *                the GA was reset. This bit will be set to zero, when a new pointer
N *                is written.
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  command List Finished (ready to get new values)
N *                C_FALSE: command List is not Finished (not ready to get new values)
N *
N * Limitations: 
N *
N ***************************************************************************/
Nbool_t boGA_CmdListFinished(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListError
N *
N * Purpose:       This function shows if the Command Scheduler detects an invalid command
N *                or not. The Graphics Accelerator halts its operation and has to be reset
N *                if error is any detected. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  any Error detected by command list
N *                C_FALSE: no error detected
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdListError(void);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      boGA_CmdReg_IsBusy
N *
N * Purpose:       This function shows when any of the GA engines is currently operating.
N *                Then also the write access to many registers is prohibited.
N *                NOTE:
N *                  This function should be used from user by using direct comamnd 
N *                  registers instead of command list, before writing new commands. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  GA engine is busy.
N *                C_FALSE: GA engine is ready (not busy).
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdReg_IsBusy(void);
N#endif
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetIrqCause
N *
N * Purpose:       Reads the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA IRQ Cause value
N *
N * Limitations:   The calling function must parse returned IRQ cause byte.
N *                For this purpose see the GAICR register description.
N *                Please note that the funtion will automatically clear
N *                the interrupt source !!!
N *
N ***************************************************************************/
Nuint32_t u32GA_GetIrqCause(void);
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCause
N *
N * Purpose:       Clears the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        u32CauseMask: Mask to clear the bits ("1" in the mask means clear Bit)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCause(uint32_t u32CauseMask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetIrqMask
N *
N * Purpose:       Sets all GA Interrupt masks in one shot
N *
N * Inputs:        u32Mask - Interrupt Mask. For this purpose you may use defines:
N *                         GA_IRQ_MASK_CENDIM, GA_IRQ_MASK_CSCEIM, GA_IRQ_MASK_CSLEIM,
N *                         GA_IRQ_MASK_WBWIM, GA_IRQ_MASK_WBRIM, GA_IRQ_MASK_CBIM,
N *                         GA_IRQ_MASK_RBIM, GA_IRQ_MASK_CSLUIM   
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetIrqMask(uint32_t u32Mask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableUserIrq
N *
N * Purpose:       Enables/Disables interrupt to CPU
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *		  u8Number - interrupt line to be enabled/disabled
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableUserIrq(uint8_t u8Number, ga_en_e eEn);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_EnableIrqCmdEnd
N *
N * Purpose:       Enables/Disables GA Command End Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_EnableIrqCmdEnd(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_ClearIrqCmdEnd
N *
N * Purpose:       Clears GA Command End Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_ClearIrqCmdEnd(void);
N
N
N#endif
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSLEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command List
N *                Executed Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSLEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSLEI
N *
N * Purpose:       Clears Command Scheduler Command List Executed Interrupt. 
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSLEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSCEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command Error IRQ
N *                Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSCEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSCEI
N *
N * Purpose:       Clears GA Command Scheduler Command Error IRQ
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSCEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetGADelay
N *
N * Purpose:       Sets the minimum delay in System Clock cycles between two
N *                consecutive memory accesses performed by any Graphics 
N *                Accelerator engine
N *
N * Inputs:        u16Delay: Delay Value (0x0000 .. 0xFFFF)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetGADelay(uint16_t u16Delay);
N
N
N/****************************************************************************/
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBWI
N *
N * Purpose:       Enables/Disables GA Write Buffer Write Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBWI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBWI
N *
N * Purpose:       Clears GA Write Buffer Write Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBWI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBRI
N *
N * Purpose:       Enables/Disables GA Write Buffer Read Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBRI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBRI
N *
N * Purpose:       Clears GA Write Buffer Read Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBRI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGACBIM
N *
N * Purpose:       Enables/Disables GA Cache Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGACBI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGACBI
N *
N * Purpose:       Clears GA Cache Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGACBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGARBI
N *
N * Purpose:       Enables/Disables GA Read Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGARBI(ga_en_e eEn);
N
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGARBI
N *
N * Purpose:       Clears GA Read Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGARBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearUserIrq
N *
N * Purpose:       Clears GA Command List User Interrupt 0 - 23
N *
N * Inputs:        u8CmdListIntr: No. of Interruot (0..23) to be cleared
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearUserIrq(uint8_t u8CmdListIntr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrAddr
N *
N * Purpose:       Returns the address after bus error on GA 
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       pu32BusErrAddr: Pointer to bus error address
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: NULL pointer
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrAddr(ga_bus_type_e eBusType, uint32_t* pu32BusErrAddr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrCtrlStatus
N *
N * Purpose:       Returns the triggering access’s control status after bus error on GA
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       control status structure
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrCtrlStatus(ga_bus_type_e eBusType, ga_bus_err_ctrl_st* pstCtrlStatus);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetMemoryProtRegionAddr
N *
N * Purpose:       Defines the lower and upper address of the memory region
N *                0 or 1 (primary, secondary) GA is allowed to perform write accesses.
N *                Write accesses outside the memory regions are discarded.
N *                NOTE:
N *                   The memory regions are defined with a granularity of 4Kbyte.
N *
N * Inputs:        eRegion  Related Region (0/1)
N *                u32LowAddress: Lower protected address
N *                u32HighAddress: Higher protected address
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_SetMemoryProtRegionAddr(ga_memory_region_e eRegion, uint32_t u32LowAddress, uint32_t u32HighAddress);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecConfigIrq
N *
N * Purpose:       Enables/Disables interrupt, set if a non-privileged access 
N *                tries to write to GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR,
N *                or GAMPIMR.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecConfigIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecAccessIrq
N *
N * Purpose:       Enables/Disables interrupt, set if GA tries to write to 
N *                memory outside the address range defined by GAMR0L-GAMR0H 
N *                and GAMR1L-GAMR1H.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecAccessIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecConfigIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to have a non-privileged access 
N *                tries to write to protection control registers
N *                (GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR, or GAMPIMR)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecConfigIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecAccessIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to write to memory 
N *                outside the address range defined by GAMR0L-GAMR0H and GAMR1L-GAMR1H
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecAccessIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetMemoryProtecErr_CaptAddr
N *
N * Purpose:       Get the address of the first write access performed by the 
N *                Write Buffer’s write interface that caused a memory protection
N *                violation. The register is automatically set by the Graphics 
N *                Accelerator in case of a protection violation, it is reset to
N *                zero automatically if the corresponding interrupt bit GAMPI is
N *                cleared in the Graphics Accelerator Interrupt Cause Register (GAMPICR).
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: Address caused portection error
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMemoryProtecErr_CaptAddr(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetGeneralPurposeRegister
N *
N * Purpose:       Set one of 32 Purpose Registers of GA, which are used to define  
N *                the required parameters for the triggered engine.
N *                Read access is possible all the time, write access is only allowed
N *                if no engine is currently operating (GASR.BUSY=0). Nevertheless, 
N *                it is recommended to configure these registers using Command Lists.
N *
N * Inputs:        u8RegNo      No. of Register (0..31)
N *                u32RegValue: Register value to be written
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo or GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t u32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetGeneralPurposeRegister
N *
N * Purpose:       Get content of one of 32 Purpose Registers of GA, which are used   
N *                to define the required parameters for the triggered engine.
N *
N * Inputs:        u8RegNo       No. of Register (0..31)
N *                pu32RegValue: Pointer to Register value to be read
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo NULL pointer 
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_GetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t* pu32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetCommandRegisterLowHigh
N *
N * Purpose:       Set command register directly (as alternative to command List).
N *                For this mode, user should take care that GA should be ready 
N *                (not busy) before writng in registers. 
N *
N * Inputs:        u32LowValue:  Lower 32 bits of 64 bits command (0..31)
N *                u32HighValue: Higher 32 bits of 64 bits command (32..63)
N *                NOTE:
N *                  1) API should write first Lowe Part and then higher Part. 
N *                    By writing of higehr word thorugh API GA will be trigegred 
N *                    to execute command if it was not busy before.
N *                  2) Related general purpose registers for command should be
N *                     written before, 
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetCommandRegisterLowHigh (uint32_t u32LowValue,  uint32_t u32HighValue);
N
N
N#endif /* _EXTENDED_GA_APIS_DISABLED_ */
N
N#endif /* GA_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 23 "..\..\..\..\lldd\src\blit.c" 2
N#include "blit.h"
L 1 "..\..\..\..\lldd\inc\blit.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver (Blitting Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Blitting Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.15 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef BLIT_H
N#define BLIT_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "ga_common.h"
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
S
N#endif
N
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_BLIT_H_REVISION     "$Revision: 1.15 $"
N#define LLDD_GA_BLIT_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*--------------------------------------------------------------------------------------------
N|          ------------------------------------------------------                             |
N|         | >>>>>>     BLITTING ENGINE COMMAND INDEX      <<<<<< |                            |
N|          ------------------------------------------------------                             |
N|---------------------------------------------------------------------------------------------|
N|---------------------------------------------------------------------------------------------|
N|                                                                                             |
N|                      ------------------------------                                         |
N|                     |      OPERATION COMMANDS      |                                        |
N|                      ------------------------------                                         |
N|                                                                                             |
N| - Overwrite:                                                                                |
N|   1. BLT_ORGB16       - Blit Overw. 16-bit RGB                                     (BltO16) |
N|   2. BLT_ORGBA32      - Blit Overw. 32-bit RGB                                     (BltO32) |
N|   3. BLT_ORLEI16      - Blit Overw. Run-Len.Enc. 16-bit RGB                    (BltORLEI16) |
N|   4. BLT_ORLEI24      - Blit Overwriting Run-Length Encoded Image 24-bit RGB   (BltORLEI24) |
N|   5. BLT_ORLEI24A     - Blit Overwriting Run-Length Encoded Image 24-bit RGBA (BltORLEI24A) |
N|   6. BLT_ORLEI32      - Blit Overw. Run-Len.Enc. 32-bit RGBA                   (BltORLEI32) |
N|   7. BLT_OPRST_RGB16  - Blit Overw. Preset 16-bit RGB                             (BltOP16) |
N|   8. BLT_OPRST_RGBA32 - Blit Overw. Preset 32-bit RGBA                            (BltOP32) |
N|                                                                                             |
N| - Blending:                                                                                 |
N|   1. BLT_BRGB16       - Blit Blend. 16-bit RGB                                     (BltB16) |
N|   2. BLT_BRGBA32      - Blit Blend. 32-bit RGBA                                    (BltB32) |
N|   3. BLT_BRLEI16      - Blit Blend. Run-Len. Enc.16-bit RGB                    (BltBRLEI16) |
N|   4. BLT_BRLEI24      - Blit Blending Run-Length Encoded Image 24-bit RGB      (BltBRLEI24) |
N|   5. BLT_BRLEI24A     - Blit Blending Run-Length Encoded Image 24A-bit RGBA   (BltBRLEI24A) |
N|   6. BLT_BRLEI32      - Blit Blend. Run-Len. Enc.32-bit RGBA                   (BltBRLEI32) |
N|   7. BLT_BPRST_RGB16  - Blit Blend. Preset 16-bit RGB                             (BltBP16) |
N|   8. BLT_BPRST_RGBA32 - Blit Blend. Preset 32-bit RGBA                            (BltBP32) |
N|                                                                                             |
N|---------------------------------------------------------------------------------------------|
N|                                                                                             |
N|                    ----------------------------------                                       |
N|                   |      LOAD REGISTER COMMANDS      |                                      |
N|                    ----------------------------------                                       |
N|                                                                                             |
N| - Source Regs:                                                                              |
N|    1. BLT_LOAD_SOURCEADDR     -  Load Source Address Reg.                             (SAR) |
N|    2. BLT_LOAD_SRCWIDTH       -  Load Source Memory Width Reg.                       (SMWR) |
N|                                                                                             |
N| - Destination Regs:                                                                         |
N|    3. BLT_LOAD_DESTADDR       -  Load Destination Address Reg.                        (DAR) |
N|    4. BLT_LOAD_DESTWIDTH      -  Load Destination Memory Width Reg.                  (DMWR) |
N|    5. BLT_LOAD_DESTDOTCNT     -  Load Destination Blit DOT Count Reg.               (DBDCR) |
N|    6. BLT_LOAD_DESTLINECNT    -  Load Destination Blit LINE Count Reg.              (DBLCR) |
N|                                                                                             |
N| - Clipping Window Regs:                                                                     |
N|    9. BLT_LOAD_CLIP_STARTADDR - Load Clipp. Wnd. Start Addr. Reg.                   (CWSAR) |
N|   10. BLT_LOAD_CLIP_WIDTH     - Load Clipping Window Width Reg.                      (CWWR) |
N|   11. BLT_LOAD_CLIP_HEIGHT    - Load Clipping Window Height Reg.                     (CWHR) |
N|                                                                                             |
N| - Conversion Regs:                                                                          |
N|   12. BLT_LOAD_SRCALPHA       - Load Source Alpha Value Reg.                         (SAVR) |
N|   13. BLT_LOAD_SRCTRANSPATT   - Load Source Transp. Pattern Reg.                     (STPR) |
N|   14. BLT_LOAD_DESTALPHA      - Load Destination Alpha Value Reg.                    (DAVR) |
N|   15. BLT_LOAD_DESTTRANSPATT  - Load Destination Transparency Reg.                    (DTR) |
N|                                                                                             |
N| - Filling Regs:                                                                             |
N|   16. BLT_LOAD_FILLRGBA       - Load RGBA Fill Preset Reg.                        (RGBAFPR) |
N|   17. BLT_LOAD_FILLRGB        - Load RGB Fill Preset Reg.                          (RGBFPR) |
N|                                                                                             |
N| - Raster/Fading Regs:                                                                       |
N|   19. BLT_LOAD_FADEFACT       - Load Fading Factor Reg.                               (FFR) |
N|   20. BLT_LOAD_RASTOP         - Load Raster Operation Reg.                            (ROR) |
N|                                                                                             |
N --------------------------------------------------------------------------------------------*/
N
N
N
N/*=========================================================================
N|                            OPERATION COMMANDS                             |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting 16-bit RGB (BltO16)
N|
N|  Descr  :   The BltO16 command triggers a blitting operation that transfers
N|             data from a source stored in the 16-bit RGB format to a
N|             destination area stored either in 16-bit RGB or 32-bit RGBA
N|             format.
N|
N|  Params:    destFrmt   - Destination Format
N|                          Use: GA_RGB16       - dest. stored in 16-bit frmt.
N|                               GA_RGBA32      - dest. stored in 32-bit frmt.
N|
N|             trnspColEn - Transparency Color Option
N|                          Use: GA_EN          - Enable Option
N|                               GA_DIS         - Disable Option
N|
N|             fading     - Fading Option
N|                          Use: BLT_NOFADING   - No fading
N|                               BLT_FADE_ALL   - RGB and Alpha will be faded
N|                               BLT_FADE_ALPHA - Only Alpha will be faded
N|                               BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn  - Clipping Window Option
N|                          Use: GA_EN          - Enable Option
N|                               GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_ORGB16(destFrmt, trnspColEn, fading, ClipWndEn)             \
N                   (GA_CMN(GA_BLITING,   1, GA_CMC_BLTO16,              \
N                    GA_FP ((destFrmt),   4, GA_MASK1)          |        \
N                    GA_FP ((trnspColEn), 3, GA_MASK1)          |        \
N                    GA_FP ((fading),     1, GA_MASK2)          |        \
N                    GA_FP ((ClipWndEn),  0, GA_MASK1)))
X#define BLT_ORGB16(destFrmt, trnspColEn, fading, ClipWndEn)                                (GA_CMN(GA_BLITING,   1, GA_CMC_BLTO16,                                  GA_FP ((destFrmt),   4, GA_MASK1)          |                            GA_FP ((trnspColEn), 3, GA_MASK1)          |                            GA_FP ((fading),     1, GA_MASK2)          |                            GA_FP ((ClipWndEn),  0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting 32-bit RGBA (BltO32)
N|
N|  Descr  :   The BltO32 command triggers a blitting operation that transfers
N|             data from a source stored in the 32-bit RGB format to a
N|             destination area stored either in 16-bit RGB or 32-bit RGBA
N|             format.
N|
N|  Params:    destFrmt  - Destination Format
N|                         Use: GA_RGB16       - dest. stored in 16-bit frmt.
N|                              GA_RGBA32      - dest. stored in 32-bit frmt.
N|
N|             fading    - Fading Option
N|                         Use: BLT_NOFADING   - No fading
N|                              BLT_FADE_ALL   - RGB and Alpha will be faded
N|                              BLT_FADE_ALPHA - Only Alpha will be faded
N|                              BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn - Clipping Window Option
N|                         Use: GA_EN          - Enable Option
N|                              GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_ORGBA32(destFrmt, fading, ClipWndEn)                     \
N                    (GA_CMN(GA_BLITING,  1, GA_CMC_BLTO32,           \
N                     GA_FP ((destFrmt),  3, GA_MASK1)       |        \
N                     GA_FP ((fading),    1, GA_MASK2)       |        \
N                     GA_FP ((ClipWndEn), 0, GA_MASK1)))
X#define BLT_ORGBA32(destFrmt, fading, ClipWndEn)                                         (GA_CMN(GA_BLITING,  1, GA_CMC_BLTO32,                                GA_FP ((destFrmt),  3, GA_MASK1)       |                             GA_FP ((fading),    1, GA_MASK2)       |                             GA_FP ((ClipWndEn), 0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting Run-Length Encoded Image 16-bit RGB
N|             (BltORLEI16)
N|
N|  Descr  :   The BltORLEI16 command triggers a blitting operation that
N|             transfers data from a source stored in the run-length encoded
N|             16-bit RGB format to a destination area stored either in 16-bit
N|             RGB or 32-bit RGBA format.
N|
N|  Params:    destFrmt   - Destination Format
N|                          Use: GA_RGB16       - dest. stored in 16-bit frmt.
N|                               GA_RGBA32      - dest. stored in 32-bit frmt.
N|
N|             trnspColEn - Transparency Color Option
N|                          Use: GA_EN          - Enable Option
N|                               GA_DIS         - Disable Option
N|
N|             fading     - Fading Option
N|                          Use: BLT_NOFADING   - No fading
N|                               BLT_FADE_ALL   - RGB and Alpha will be faded
N|                               BLT_FADE_ALPHA - Only Alpha will be faded
N|                               BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn  - Clipping Window Option
N|                          Use: GA_EN          - Enable Option
N|                               GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_ORLEI16(destFrmt, trnspColEn, fading, ClipWndEn)               \
N                      (GA_CMN(GA_BLITING,   1, GA_CMC_BLTORLEI16,          \
N                       GA_FP ((destFrmt),   4, GA_MASK1)        |          \
N                       GA_FP ((trnspColEn), 3, GA_MASK1)        |          \
N                       GA_FP ((fading),     1, GA_MASK2)        |          \
N                       GA_FP ((ClipWndEn),  0, GA_MASK1)))
X#define BLT_ORLEI16(destFrmt, trnspColEn, fading, ClipWndEn)                                     (GA_CMN(GA_BLITING,   1, GA_CMC_BLTORLEI16,                                 GA_FP ((destFrmt),   4, GA_MASK1)        |                                 GA_FP ((trnspColEn), 3, GA_MASK1)        |                                 GA_FP ((fading),     1, GA_MASK2)        |                                 GA_FP ((ClipWndEn),  0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting Run-Length Encoded Image 24-bit RGB
N|             (BltORLEI24)
N|
N|  Descr  :   The BltORLEI24 command triggers a blitting operation that
N|             transfers data from a source stored in the run-length encoded
N|             24-bit RGB format to a destination area stored either in 16-bit
N|             RGB or 32-bit RGBA format.
N|
N|  Params:    destFrmt   - Destination Format
N|                          Use: GA_RGB16       - dest. stored in 16-bit frmt.
N|                               GA_RGBA32      - dest. stored in 32-bit frmt.
N|
N|             trnspColEn - Transparency Color Option
N|                          Use: GA_EN          - Enable Option
N|                               GA_DIS         - Disable Option
N|
N|             fading     - Fading Option
N|                          Use: BLT_NOFADING   - No fading
N|                               BLT_FADE_ALL   - RGB and Alpha will be faded
N|                               BLT_FADE_ALPHA - Only Alpha will be faded
N|                               BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn  - Clipping Window Option
N|                          Use: GA_EN          - Enable Option
N|                               GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_ORLEI24(destFrmt, trnspColEn, fading, ClipWndEn)               \
N                      (GA_CMN(GA_BLITING,   1, GA_CMC_BLTORLEI24,          \
N                       GA_FP ((destFrmt),   4, GA_MASK1)        |          \
N                       GA_FP ((trnspColEn), 3, GA_MASK1)        |          \
N                       GA_FP ((fading),     1, GA_MASK2)        |          \
N                       GA_FP ((ClipWndEn),  0, GA_MASK1)))
X#define BLT_ORLEI24(destFrmt, trnspColEn, fading, ClipWndEn)                                     (GA_CMN(GA_BLITING,   1, GA_CMC_BLTORLEI24,                                 GA_FP ((destFrmt),   4, GA_MASK1)        |                                 GA_FP ((trnspColEn), 3, GA_MASK1)        |                                 GA_FP ((fading),     1, GA_MASK2)        |                                 GA_FP ((ClipWndEn),  0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting Run-Length Encoded Image 24-bit RGBA
N|             (BltORLEI24A)
N|
N|  Descr  :   The BltORLEI32 command triggers a blitting operation that
N|             transfers data from a source stored in the run-length encoded
N|             32-bit RGBA format to a destination area stored in 32-bit RGBA
N|             format.
N|
N|  Params:    destFrmt  - Destination Format
N|                         Use: GA_RGB16      - dest. stored in 16-bit frmt.
N|                              GA_RGBA32     - dest. stored in 32-bit frmt.
N|
N|             fading    - Fading Option
N|                         Use: BLT_NOFADING   - No fading
N|                              BLT_FADE_ALL   - RGB and Alpha will be faded
N|                              BLT_FADE_ALPHA - Only Alpha will be faded
N|                              BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn - Clipping Window Option
N|                         Use: GA_EN          - Enable Option
N|                              GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_ORLEI24A(destFrmt, fading, ClipWndEn)                           \
N                     (GA_CMN(GA_BLITING,  1, GA_CMC_BLTORLEI24A,            \
N                      GA_FP ((destFrmt),  3, GA_MASK1)          |           \
N                      GA_FP ((fading),    1, GA_MASK2)          |           \
N                      GA_FP ((ClipWndEn), 0, GA_MASK1)))
X#define BLT_ORLEI24A(destFrmt, fading, ClipWndEn)                                                (GA_CMN(GA_BLITING,  1, GA_CMC_BLTORLEI24A,                                  GA_FP ((destFrmt),  3, GA_MASK1)          |                                 GA_FP ((fading),    1, GA_MASK2)          |                                 GA_FP ((ClipWndEn), 0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting Run-Length Encoded Image 32-bit RGBA
N|             (BltORLEI32)
N|
N|  Descr  :   The BltORLEI32 command triggers a blitting operation that
N|             transfers data from a source stored in the run-length encoded
N|             32-bit RGBA format to a destination area stored in 32-bit RGBA
N|             format.
N|
N|  Params:    destFrmt  - Destination Format
N|                         Use: GA_RGB16      - dest. stored in 16-bit frmt.
N|                              GA_RGBA32     - dest. stored in 32-bit frmt.
N|
N|             fading    - Fading Option
N|                         Use: BLT_NOFADING   - No fading
N|                              BLT_FADE_ALL   - RGB and Alpha will be faded
N|                              BLT_FADE_ALPHA - Only Alpha will be faded
N|                              BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn - Clipping Window Option
N|                         Use: GA_EN          - Enable Option
N|                              GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_ORLEI32(destFrmt, fading, ClipWndEn)                            \
N                     (GA_CMN(GA_BLITING,  1, GA_CMC_BLTORLEI32,             \
N                      GA_FP ((destFrmt),  3, GA_MASK1)          |           \
N                      GA_FP ((fading),    1, GA_MASK2)          |           \
N                      GA_FP ((ClipWndEn), 0, GA_MASK1)))
X#define BLT_ORLEI32(destFrmt, fading, ClipWndEn)                                                 (GA_CMN(GA_BLITING,  1, GA_CMC_BLTORLEI32,                                   GA_FP ((destFrmt),  3, GA_MASK1)          |                                 GA_FP ((fading),    1, GA_MASK2)          |                                 GA_FP ((ClipWndEn), 0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting Preset 16-bit RGB (BltOP16)
N|
N|  Descr  :   The BltOP16 command triggers a blitting operation that blits
N|             the data from the RGB Fill Preset Register with to the
N|             destination stored in 16-bit RGB format.
N|
N|  Params:    fading    - Fading Option
N|                         Use: BLT_NOFADING   - No fading
N|                              BLT_FADE_ALL   - RGB and Alpha will be faded
N|                              BLT_FADE_ALPHA - Only Alpha will be faded
N|                              BLT_FADE_RGB   - ONly RGB will be faded
N|
N|             ClipWndEn - Clipping Window Option
N|                         Use: GA_EN          - Enable Option
N|                              GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_OPRST_RGB16(fading, ClipWndEn)                                \
N                       (GA_CMN(GA_BLITING,  1, GA_CMC_BLTOP16,            \
N                        GA_FP ((fading),    1, GA_MASK2)    |             \
N                        GA_FP ((ClipWndEn), 0, GA_MASK1)))
X#define BLT_OPRST_RGB16(fading, ClipWndEn)                                                       (GA_CMN(GA_BLITING,  1, GA_CMC_BLTOP16,                                    GA_FP ((fading),    1, GA_MASK2)    |                                     GA_FP ((ClipWndEn), 0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Overwriting Preset 32-bit RGBA (BltOP32)
N|
N|  Descr  :   The BltOP32 command triggers a blitting operation that blits
N|             the data from the RGBA Fill Preset Register to the destination
N|             stored in 32-bit RGBA format.
N|
N|  Params:    fading    - Fading Option
N|                         Use: BLT_NOFADING   - No fading
N|                              BLT_FADE_ALL   - RGB and Alpha will be faded
N|                              BLT_FADE_ALPHA - Only Alpha will be faded
N|                              BLT_FADE_RGB   - Only RGB will be faded
N|
N|             ClipWndEn - Clipping Window Option
N|                         Use: GA_EN          - Enable Option
N|                              GA_DIS         - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_OPRST_RGBA32(fading, ClipWndEn)                              \
N                        (GA_CMN(GA_BLITING,  1, GA_CMC_BLTOP32,          \
N                         GA_FP ((fading),    1, GA_MASK2)    |           \
N                         GA_FP ((ClipWndEn), 0, GA_MASK1)))
X#define BLT_OPRST_RGBA32(fading, ClipWndEn)                                                      (GA_CMN(GA_BLITING,  1, GA_CMC_BLTOP32,                                   GA_FP ((fading),    1, GA_MASK2)    |                                    GA_FP ((ClipWndEn), 0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending 16-bit RGB (BltB16)
N|
N|  Descr  :   The BltB16 command triggers a blitting operation that blends
N|             data from a source stored in the 16-bit RGB format with a
N|             destination area stored in either 16-bit RGB or 32-bit RGBA
N|             format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             destFrmt    - Destination Format
N|                           Use: GA_RGB16        - dest. stored in 16-bit frmt.
N|                                GA_RGBA32       - dest. stored in 32-bit frmt.
N|                         
N|                         
N|             trnspColEn  - Transparency Color Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - ONly RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N -------------------------------------------------------------------------*/
N#define BLT_BRGB16(redChProt,                                           \
N                   greenChProt,                                         \
N                   blueChProt,                                          \
N                   alphaProt,                                           \
N                   rastOpEn,                                            \
N                   destFrmt,                                            \
N                   blndOrder,                                           \
N                   trnspColEn,                                          \
N                   fading,                                              \
N                   ClipWndEn)                                           \
N                   (GA_CMN((GA_BLITING),  1, GA_CMC_BLTB16,             \
N                    GA_FP ((redChProt),  10, GA_MASK1)          |       \
N                    GA_FP ((greenChProt), 9, GA_MASK1)          |       \
N                    GA_FP ((blueChProt),  8, GA_MASK1)          |       \
N                    GA_FP ((alphaProt),   7, GA_MASK1)          |       \
N                    GA_FP ((rastOpEn),    6, GA_MASK1)          |       \
N                    GA_FP ((destFrmt),    5, GA_MASK1)          |       \
N                    GA_FP ((blndOrder),   4, GA_MASK1)          |       \
N                    GA_FP ((trnspColEn),  3, GA_MASK1)          |       \
N                    GA_FP ((fading),      1, GA_MASK2)          |       \
N                    GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BRGB16(redChProt,                                                              greenChProt,                                                            blueChProt,                                                             alphaProt,                                                              rastOpEn,                                                               destFrmt,                                                               blndOrder,                                                              trnspColEn,                                                             fading,                                                                 ClipWndEn)                                                              (GA_CMN((GA_BLITING),  1, GA_CMC_BLTB16,                                 GA_FP ((redChProt),  10, GA_MASK1)          |                           GA_FP ((greenChProt), 9, GA_MASK1)          |                           GA_FP ((blueChProt),  8, GA_MASK1)          |                           GA_FP ((alphaProt),   7, GA_MASK1)          |                           GA_FP ((rastOpEn),    6, GA_MASK1)          |                           GA_FP ((destFrmt),    5, GA_MASK1)          |                           GA_FP ((blndOrder),   4, GA_MASK1)          |                           GA_FP ((trnspColEn),  3, GA_MASK1)          |                           GA_FP ((fading),      1, GA_MASK2)          |                           GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending 32-bit RGBA (BltB32)
N|
N|  Descr  :   The BltB32 command triggers a blitting operation that blends
N|             data from a source stored in the 32-bit RGBA format with a
N|             destination area stored in either 16-bit RGB or 32-bit RGBA
N|             format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             destFrmt    - Destination Format
N|                           Use: GA_RGB16        - dest. stored in 16-bit frmt.
N|                                GA_RGBA32       - dest. stored in 32-bit frmt.
N|                         
N|             trnspColEn  - Transparency Color Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - ONly RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_BRGBA32(redChProt,                                           \
N                    greenChProt,                                         \
N                    blueChProt,                                          \
N                    alphaProt,                                           \
N                    rastOpEn,                                            \
N                    destFrmt,                                            \
N                    blndOrder,                                           \
N                    trnspColEn,                                          \
N                    fading,                                              \
N                    ClipWndEn)                                           \
N                    (GA_CMN(GA_BLITING,    1, GA_CMC_BLTB32,             \
N                     GA_FP ((redChProt),  10, GA_MASK1)        |         \
N                     GA_FP ((greenChProt), 9, GA_MASK1)        |         \
N                     GA_FP ((blueChProt),  8, GA_MASK1)        |         \
N                     GA_FP ((alphaProt),   7, GA_MASK1)        |         \
N                     GA_FP ((rastOpEn),    6, GA_MASK1)        |         \
N                     GA_FP ((destFrmt),    5, GA_MASK1)        |         \
N                     GA_FP ((blndOrder),   4, GA_MASK1)        |         \
N                     GA_FP ((trnspColEn),  3, GA_MASK1)        |         \
N                     GA_FP ((fading),      1, GA_MASK2)        |         \
N                     GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BRGBA32(redChProt,                                                               greenChProt,                                                             blueChProt,                                                              alphaProt,                                                               rastOpEn,                                                                destFrmt,                                                                blndOrder,                                                               trnspColEn,                                                              fading,                                                                  ClipWndEn)                                                               (GA_CMN(GA_BLITING,    1, GA_CMC_BLTB32,                                  GA_FP ((redChProt),  10, GA_MASK1)        |                              GA_FP ((greenChProt), 9, GA_MASK1)        |                              GA_FP ((blueChProt),  8, GA_MASK1)        |                              GA_FP ((alphaProt),   7, GA_MASK1)        |                              GA_FP ((rastOpEn),    6, GA_MASK1)        |                              GA_FP ((destFrmt),    5, GA_MASK1)        |                              GA_FP ((blndOrder),   4, GA_MASK1)        |                              GA_FP ((trnspColEn),  3, GA_MASK1)        |                              GA_FP ((fading),      1, GA_MASK2)        |                              GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending Run-Length Encoded Image 16-bit RGB (BltBRLEI16)
N|
N|  Descr  :   The BltBRLEI16 command triggers a blitting operation that
N|             blends data from a source stored in the run-length encoded
N|             16-bit RGB format with a destination area stored in either
N|             16-bit RGB or 32-bit RGBA format.
N|
N|  Params:    redChProt  - Red Channel Protection
N|                          Use: GA_EN           - Channel Protected
N|                               GA_DIS          - Channel Not Protected
N|
N|             greenChProt- Green Channel Protection
N|                          Use: GA_EN           - Channel Protected
N|                               GA_DIS          - Channel Not Protected
N|
N|             blueChProt - Blue Channel Protection
N|                          Use: GA_EN           - Channel Protected
N|                               GA_DIS          - Channel Not Protected
N|
N|             alphaProt  - Alpha Channel Protection
N|                          Use: GA_EN           - Channel Protected
N|                               GA_DIS          - Channel Not Protected
N|
N|             rastOpEn   - Raster Operation Option
N|                          Use: GA_EN           - Enable Option
N|                               GA_DIS          - Disable Option
N|
N|             blndOrder  - Blending Order
N|                          Use: BLT_ONTO_DEST   - Onto destination
N|                               BLT_BEHIND_DEST - Behind the destination
N|
N|             destFrmt   - Destination Format
N|                          Use: GA_RGB16        - dest. stored in 16-bit frmt.
N|                               GA_RGBA32       - dest. stored in 32-bit frmt.
N|
N|             trnspColEn - Transparency Color Option
N|                          Use: GA_EN           - Enable Option
N|                               GA_DIS          - Disable Option
N|
N|             fading     - Fading Option
N|                          Use: BLT_NOFADING    - No fading
N|                               BLT_FADE_ALL    - RGB and Alpha will be faded
N|                               BLT_FADE_ALPHA  - Only Alpha will be faded
N|                               BLT_FADE_RGB    - Only RGB will be faded
N|
N|             ClipWndEn  - Clipping Window Option
N|                          Use: GA_EN           - Enable Option
N|                               GA_DIS          - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_BRLEI16(redChProt,                                       \
N                    greenChProt,                                     \
N                    blueChProt,                                      \
N                    alphaProt,                                       \
N                    rastOpEn,                                        \
N                    destFrmt,                                        \
N                    blndOrder,                                       \
N                    trnspColEn,                                      \
N                    fading,                                          \
N                    ClipWndEn)                                       \
N                    (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI16,       \
N                     GA_FP ((redChProt),  10, GA_MASK1)        |     \
N                     GA_FP ((greenChProt), 9, GA_MASK1)        |     \
N                     GA_FP ((blueChProt),  8, GA_MASK1)        |     \
N                     GA_FP ((alphaProt),   7, GA_MASK1)        |     \
N                     GA_FP ((rastOpEn),    6, GA_MASK1)        |     \
N                     GA_FP ((destFrmt),    5, GA_MASK1)        |     \
N                     GA_FP ((blndOrder),   4, GA_MASK1)        |     \
N                     GA_FP ((trnspColEn),  3, GA_MASK1)        |     \
N                     GA_FP ((fading),      1, GA_MASK2)        |     \
N                     GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BRLEI16(redChProt,                                                           greenChProt,                                                         blueChProt,                                                          alphaProt,                                                           rastOpEn,                                                            destFrmt,                                                            blndOrder,                                                           trnspColEn,                                                          fading,                                                              ClipWndEn)                                                           (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI16,                            GA_FP ((redChProt),  10, GA_MASK1)        |                          GA_FP ((greenChProt), 9, GA_MASK1)        |                          GA_FP ((blueChProt),  8, GA_MASK1)        |                          GA_FP ((alphaProt),   7, GA_MASK1)        |                          GA_FP ((rastOpEn),    6, GA_MASK1)        |                          GA_FP ((destFrmt),    5, GA_MASK1)        |                          GA_FP ((blndOrder),   4, GA_MASK1)        |                          GA_FP ((trnspColEn),  3, GA_MASK1)        |                          GA_FP ((fading),      1, GA_MASK2)        |                          GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending Run-Length Encoded Image 24-bit RGB (BltBRLEI24)
N|
N|  Descr  :   The BltBRLEI24 command triggers a blitting operation that
N|             blends data from a source stored in the run-length encoded
N|             16-bit RGB format with a destination area stored in either
N|             16-bit RGB or 32-bit RGBA format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             destFrmt    - Destination Format
N|                           Use: GA_RGB16        - dest. stored in 16-bit frmt.
N|                                GA_RGBA32       - dest. stored in 32-bit frmt.
N|                         
N|             trnspColEn  - Transparency Color Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - Only RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_BRLEI24(redChProt,                                       \
N                    greenChProt,                                     \
N                    blueChProt,                                      \
N                    alphaProt,                                       \
N                    rastOpEn,                                        \
N                    destFrmt,                                        \
N                    blndOrder,                                       \
N                    trnspColEn,                                      \
N                    fading,                                          \
N                    ClipWndEn)                                       \
N                    (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI24,       \
N                     GA_FP ((redChProt),  10, GA_MASK1)        |     \
N                     GA_FP ((greenChProt), 9, GA_MASK1)        |     \
N                     GA_FP ((blueChProt),  8, GA_MASK1)        |     \
N                     GA_FP ((alphaProt),   7, GA_MASK1)        |     \
N                     GA_FP ((rastOpEn),    6, GA_MASK1)        |     \
N                     GA_FP ((destFrmt),    5, GA_MASK1)        |     \
N                     GA_FP ((blndOrder),   4, GA_MASK1)        |     \
N                     GA_FP ((trnspColEn),  3, GA_MASK1)        |     \
N                     GA_FP ((fading),      1, GA_MASK2)        |     \
N                     GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BRLEI24(redChProt,                                                           greenChProt,                                                         blueChProt,                                                          alphaProt,                                                           rastOpEn,                                                            destFrmt,                                                            blndOrder,                                                           trnspColEn,                                                          fading,                                                              ClipWndEn)                                                           (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI24,                            GA_FP ((redChProt),  10, GA_MASK1)        |                          GA_FP ((greenChProt), 9, GA_MASK1)        |                          GA_FP ((blueChProt),  8, GA_MASK1)        |                          GA_FP ((alphaProt),   7, GA_MASK1)        |                          GA_FP ((rastOpEn),    6, GA_MASK1)        |                          GA_FP ((destFrmt),    5, GA_MASK1)        |                          GA_FP ((blndOrder),   4, GA_MASK1)        |                          GA_FP ((trnspColEn),  3, GA_MASK1)        |                          GA_FP ((fading),      1, GA_MASK2)        |                          GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending Run-Length Encoded Image 24A-bit RGBA (BltBRLEI24A)
N|
N|  Descr  :   The BltBRLEI24A command triggers a blitting operation that
N|             blends data from a source stored in the run-length encoded
N|             24-bit RGBA format with a destination area stored in 32-bit
N|             RGBA format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             destFrmt    - Destination Format
N|                           Use: GA_RGB16        - dest. stored in 16-bit frmt.
N|                                GA_RGBA32       - dest. stored in 32-bit frmt.
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             trnspColEn  - Transparency Color Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - Only RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N -------------------------------------------------------------------------*/
N#define BLT_BRLEI24A(redChProt,                                       \
N                     greenChProt,                                     \
N                     blueChProt,                                      \
N                     alphaProt,                                       \
N                     rastOpEn,                                        \
N                     destFrmt,                                        \
N                     blndOrder,                                       \
N                     trnspColEn,                                      \
N                     fading,                                          \
N                     ClipWndEn)                                       \
N                     (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI24A,      \
N                      GA_FP ((redChProt),  10, GA_MASK1)        |     \
N                      GA_FP ((greenChProt), 9, GA_MASK1)        |     \
N                      GA_FP ((blueChProt),  8, GA_MASK1)        |     \
N                      GA_FP ((alphaProt),   7, GA_MASK1)        |     \
N                      GA_FP ((rastOpEn),    6, GA_MASK1)        |     \
N                      GA_FP ((destFrmt),    5, GA_MASK1)        |     \
N                      GA_FP ((blndOrder),   4, GA_MASK1)        |     \
N                      GA_FP ((trnspColEn),  3, GA_MASK1)        |     \
N                      GA_FP ((fading),      1, GA_MASK2)        |     \
N                      GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BRLEI24A(redChProt,                                                            greenChProt,                                                          blueChProt,                                                           alphaProt,                                                            rastOpEn,                                                             destFrmt,                                                             blndOrder,                                                            trnspColEn,                                                           fading,                                                               ClipWndEn)                                                            (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI24A,                            GA_FP ((redChProt),  10, GA_MASK1)        |                           GA_FP ((greenChProt), 9, GA_MASK1)        |                           GA_FP ((blueChProt),  8, GA_MASK1)        |                           GA_FP ((alphaProt),   7, GA_MASK1)        |                           GA_FP ((rastOpEn),    6, GA_MASK1)        |                           GA_FP ((destFrmt),    5, GA_MASK1)        |                           GA_FP ((blndOrder),   4, GA_MASK1)        |                           GA_FP ((trnspColEn),  3, GA_MASK1)        |                           GA_FP ((fading),      1, GA_MASK2)        |                           GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending Run-Length Encoded Image 32-bit RGBA (BltBRLEI32)
N|
N|  Descr  :   The BltBRLEI32 command triggers a blitting operation that
N|             blends data from a source stored in the run-length encoded
N|             32-bit RGBA format with a destination area stored in 32-bit
N|             RGBA format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             destFrmt    - Destination Format
N|                           Use: GA_RGB16        - dest. stored in 16-bit frmt.
N|                                GA_RGBA32       - dest. stored in 32-bit frmt.
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             trnspColEn  - Transparency Color Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - Only RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_BRLEI32(redChProt,                                       \
N                    greenChProt,                                     \
N                    blueChProt,                                      \
N                    alphaProt,                                       \
N                    rastOpEn,                                        \
N                    destFrmt,                                        \
N                    blndOrder,                                       \
N                    trnspColEn,                                      \
N                    fading,                                          \
N                    ClipWndEn)                                       \
N                    (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI32,       \
N                     GA_FP ((redChProt),  10, GA_MASK1)        |     \
N                     GA_FP ((greenChProt), 9, GA_MASK1)        |     \
N                     GA_FP ((blueChProt),  8, GA_MASK1)        |     \
N                     GA_FP ((alphaProt),   7, GA_MASK1)        |     \
N                     GA_FP ((rastOpEn),    6, GA_MASK1)        |     \
N                     GA_FP ((destFrmt),    5, GA_MASK1)        |     \
N                     GA_FP ((blndOrder),   4, GA_MASK1)        |     \
N                     GA_FP ((trnspColEn),  3, GA_MASK1)        |     \
N                     GA_FP ((fading),      1, GA_MASK2)        |     \
N                     GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BRLEI32(redChProt,                                                           greenChProt,                                                         blueChProt,                                                          alphaProt,                                                           rastOpEn,                                                            destFrmt,                                                            blndOrder,                                                           trnspColEn,                                                          fading,                                                              ClipWndEn)                                                           (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBRLEI32,                            GA_FP ((redChProt),  10, GA_MASK1)        |                          GA_FP ((greenChProt), 9, GA_MASK1)        |                          GA_FP ((blueChProt),  8, GA_MASK1)        |                          GA_FP ((alphaProt),   7, GA_MASK1)        |                          GA_FP ((rastOpEn),    6, GA_MASK1)        |                          GA_FP ((destFrmt),    5, GA_MASK1)        |                          GA_FP ((blndOrder),   4, GA_MASK1)        |                          GA_FP ((trnspColEn),  3, GA_MASK1)        |                          GA_FP ((fading),      1, GA_MASK2)        |                          GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending Preset 16-bit RGB (BltBP16)
N|
N|  Descr  :   The BltBP16 command triggers a blitting operation that blends
N|             the data from the RGB Fill Preset Register with a destination
N|             stored in 16-bit RGB format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - Only RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_BPRST_RGB16(redChProt,                                        \
N                        greenChProt,                                      \
N                        blueChProt,                                       \
N                        rastOpEn,                                         \
N                        blndOrder,                                        \
N                        fading,                                           \
N                        ClipWndEn)                                        \
N                        (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBP16,           \
N                         GA_FP ((redChProt),  10, GA_MASK1)        |      \
N                         GA_FP ((greenChProt), 9, GA_MASK1)        |      \
N                         GA_FP ((blueChProt),  8, GA_MASK1)        |      \
N                         GA_FP (       0,      7, GA_MASK1)        |      \
N                         GA_FP ((rastOpEn),    6, GA_MASK1)        |      \
N                         GA_FP (       0,      5, GA_MASK1)        |      \
N                         GA_FP (       0,      4, GA_MASK1)        |      \
N                         GA_FP ((blndOrder),   3, GA_MASK1)        |      \
N                         GA_FP ((fading),      1, GA_MASK2)        |      \
N                         GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BPRST_RGB16(redChProt,                                                                greenChProt,                                                              blueChProt,                                                               rastOpEn,                                                                 blndOrder,                                                                fading,                                                                   ClipWndEn)                                                                (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBP16,                                    GA_FP ((redChProt),  10, GA_MASK1)        |                               GA_FP ((greenChProt), 9, GA_MASK1)        |                               GA_FP ((blueChProt),  8, GA_MASK1)        |                               GA_FP (       0,      7, GA_MASK1)        |                               GA_FP ((rastOpEn),    6, GA_MASK1)        |                               GA_FP (       0,      5, GA_MASK1)        |                               GA_FP (       0,      4, GA_MASK1)        |                               GA_FP ((blndOrder),   3, GA_MASK1)        |                               GA_FP ((fading),      1, GA_MASK2)        |                               GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Blit Blending Preset 32-bit RGBA (BltBP32)
N|
N|  Descr  :   The BltBP32 command triggers a blitting operation that blends
N|             the data from the RGBA Fill Preset Register with a destination
N|             stored in 32-bit RGBA format.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             rastOpEn    - Raster Operation Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             trnspColEn  - Transparency Color Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             fading      - Fading Option
N|                           Use: BLT_NOFADING    - No fading
N|                                BLT_FADE_ALL    - RGB and Alpha will be faded
N|                                BLT_FADE_ALPHA  - Only Alpha will be faded
N|                                BLT_FADE_RGB    - Only RGB will be faded
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|
N -------------------------------------------------------------------------*/
N#define BLT_BPRST_RGBA32(redChProt,                                       \
N                         greenChProt,                                     \
N                         blueChProt,                                      \
N                         alphaProt,                                       \
N                         rastOpEn,                                        \
N                         blndOrder,                                       \
N                         fading,                                          \
N                         ClipWndEn)                                       \
N                         (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBP32,          \
N                          GA_FP ((redChProt),  10, GA_MASK1)        |     \
N                          GA_FP ((greenChProt), 9, GA_MASK1)        |     \
N                          GA_FP ((blueChProt),  8, GA_MASK1)        |     \
N                          GA_FP ((alphaProt),   7, GA_MASK1)        |     \
N                          GA_FP ((rastOpEn),    6, GA_MASK1)        |     \
N                          GA_FP (       0,      5, GA_MASK1)        |     \
N                          GA_FP (       0,      4, GA_MASK1)        |     \
N                          GA_FP ((blndOrder),   3, GA_MASK1)        |     \
N                          GA_FP ((fading),      1, GA_MASK2)        |     \
N                          GA_FP ((ClipWndEn),   0, GA_MASK1)))
X#define BLT_BPRST_RGBA32(redChProt,                                                                greenChProt,                                                              blueChProt,                                                               alphaProt,                                                                rastOpEn,                                                                 blndOrder,                                                                fading,                                                                   ClipWndEn)                                                                (GA_CMN(GA_BLITING,  1, GA_CMC_BLTBP32,                                    GA_FP ((redChProt),  10, GA_MASK1)        |                               GA_FP ((greenChProt), 9, GA_MASK1)        |                               GA_FP ((blueChProt),  8, GA_MASK1)        |                               GA_FP ((alphaProt),   7, GA_MASK1)        |                               GA_FP ((rastOpEn),    6, GA_MASK1)        |                               GA_FP (       0,      5, GA_MASK1)        |                               GA_FP (       0,      4, GA_MASK1)        |                               GA_FP ((blndOrder),   3, GA_MASK1)        |                               GA_FP ((fading),      1, GA_MASK2)        |                               GA_FP ((ClipWndEn),   0, GA_MASK1)))
N
N/*=========================================================================
N|                          LOAD REGISTER COMMANDS                           |
N ==========================================================================*/
N/*------------------------------
N|        SOURCE REGISTERS       |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Address Register (SAR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load SAR.
N|             The physical 32-bit address within the source address register
N|             is the pointer to the first dot in memory that should be
N|             transferred from the source (within the source segment).
N|
N|  Params:    addr - Source Address
N|                    The lower 32 physical address bits that point to the
N|                    first dot of the source.
N|
N|  Limit.:    Depending on the source format this address has to be
N|             doubleword, word, halfword or byte aligned. The following
N|             table shows the possible alignments:
N|
N|                ---------------------------------------------
N|               |   Src.Frmt.  |Dword | Word |Halfword | Byte |
N|               |=============================================|
N|               |  32-bit RGBA |  X   |  X   |         |      |
N|               |  16-bit RGB  |  X   |  X   |    X    |      |
N|               |  RLE 32      |  X   |      |         |      |
N|               |  RLE 24      |  X   |      |         |      |
N|               |  RLE 24A     |  X   |      |         |      |
N|               |  RLE 16      |  X   |      |         |      |
N|                ---------------------------------------------
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_SOURCEADDR(addr) (GA_LOAD(GA_GPR9, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Memory Width Register (SMWR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load SMWR.
N|             The source memory width register specifies the memory reserved
N|             for one line within the source image in number of dots.
N|             (Note that this value can be different to the number of dots
N|             to be blitted per line!)
N|
N|
N|  Params:    width - Source Memory Width
N|                     Memory reserved per line within the source in dots
N|                     (1 up to 4095)
N|
N|  Limit.:    The content of this register is not taken into account when the
N|             Blitting Engine is configured to read a run-length encoded
N|             image. When the source is run-length encoded the destinations
N|             dimensions have to match the dimensions of the source exactly
N|             (number of dots).
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_SRCWIDTH(width) (GA_LOAD(GA_GPR10, ((width) & GA_MASK12)))
N
N/*------------------------------
N|     DESTINATION REGISTERS     |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Address Register (DAR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load DAR.
N|             The physical 32-bit address within the destination address
N|             register is the pointer to the first dot in memory that should
N|             be blitted to the destination (within the destination segment).
N|
N|  Params:    addr - Destination Address
N|                    The lower 32 physical address bits that point to the
N|                    first dot of the destination.
N|
N|  Limit.:    Depending on the destination format this address has to be
N|             doubleword, word, halfword or byte aligned. The following
N|             table shows the possible alignments:
N|
N|                --------------------------------------
N|               |  Dest.Frmt.  | Word |Halfword | Byte |
N|               |======================================|
N|               |  32-bit RGBA |  X   |         |      |
N|               |  16-bit RGB  |  X   |    X    |      |
N|                --------------------------------------
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_DESTADDR(addr) (GA_LOAD(GA_GPR4, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Memory Width Register (DMWR)
N|
N|  Descr  :   The destination memory width register specifies the memory
N|             reserved for one line within the destination image in number
N|             of dots.
N|             Note that this value can be greater than the number of dots
N|             to be blitted per line.
N|
N|  Params:    width - Destination Memory Width
N|                     Memory reserved per line within the source in dots
N|                     (1 up to 4095)
N|
N|  Limit.:    The content of this register is not taken into account when the
N|             Blitting Engine is configured to read a run-length encoded
N|             image. When the source is run-length encoded the destinations
N|             dimensions have to match the dimensions of the source exactly
N|             (number of dots).
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_DESTWIDTH(width) (GA_LOAD(GA_GPR5, ((width) & GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Blit DOT Count Register (DBDCR)
N|
N|  Descr  :   The Destination Blit Dot Count Registers specifies the number
N|             of dots per line that should be blitted into the destination.
N|             If a clipping window is defined, the Blitting Engine could
N|             process less dots per line.
N|
N|  Params:    dotCnt - Destination Blit Dot Count
N|                      Number of dots to be blitted into the destination per
N|                      line (1 up to 4095).
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_DESTDOTCNT(dotCnt) (GA_LOAD(GA_GPR6,                      \
N                                     ((dotCnt) & GA_MASK12)))
X#define BLT_LOAD_DESTDOTCNT(dotCnt) (GA_LOAD(GA_GPR6,                                                           ((dotCnt) & GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Blit LINE Count Register (DBLCR)
N|
N|  Descr  :   The Destination Blit Line Count Register specifies the number
N|             if lines that should be transferred to the destination. If a
N|             clipping window is defined the Blitting Engine could process
N|             less lines.
N|
N|  Params:    lineCnt - Destination Blit Line Count
N|                       Number of lines to be blitted into the destination
N|                       (1 up to 4095).
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_DESTLINECNT(lineCnt) (GA_LOAD(GA_GPR7,                    \
N                                       ((lineCnt) & GA_MASK12)))
X#define BLT_LOAD_DESTLINECNT(lineCnt) (GA_LOAD(GA_GPR7,                                                           ((lineCnt) & GA_MASK12)))
N
N/*------------------------------
N|    CLIPPING WND. REGISTERS    |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Clipping Window Start Address Register (CWSAR)
N|
N|  Descr  :   The Clipping Window Start Address Register keeps the pointer
N|             to the first dot within the clipping window. The upper 4
N|             address bits are taken from the Destination Segment Register,
N|             because the clipping window has to be defined with respect to
N|             the destination.
N|
N|  Params:    addr - Clipping Window Start Address
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_CLIP_STARTADDR(addr) (GA_LOAD(GA_GPR0, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Clipping Window Width Register (CWWR)
N|
N|  Descr  :   The Clipping Window Width Register defines the number of dots
N|             within the clipping window in horizontal direction.
N|
N|  Params:    width - Clipping Window Width
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_CLIP_WIDTH(width) (GA_LOAD(GA_GPR1,                       \
N                                    ((width) & GA_MASK12)))
X#define BLT_LOAD_CLIP_WIDTH(width) (GA_LOAD(GA_GPR1,                                                           ((width) & GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Clipping Window Height Register (CWHR)
N|
N|  Descr  :   The Clipping Window Height Register defines the number of
N|             lines within the clipping window.
N|
N|  Params:    height - Clipping Window Height
N|                      Number of lines within the clipping window in
N|                      horizontal direction (1 up to 4095).
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_CLIP_HEIGHT(height) (GA_LOAD(GA_GPR2,                     \
N                                      ((height) & GA_MASK12)))
X#define BLT_LOAD_CLIP_HEIGHT(height) (GA_LOAD(GA_GPR2,                                                           ((height) & GA_MASK12)))
N
N/*------------------------------
N|   CONVERSION CFG. REGISTERS   |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Alpha Value Register (SAVR)
N|
N|  Descr  :   The Source Alpha Value Register keeps the alpha value for
N|             conversion of the source dots from the 16-bit RGB format
N|             to the 32-bit RGBA format for internal processing.
N|
N|  Params:    alpha - Source Alpha Value
N|                     8-bit Alpha Value used for expanding source dots
N|                     during conversion from 16-bit RGB to 32-bit RGBA
N|                     for internal processing.
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_SRCALPHA(alpha) (GA_LOAD(GA_GPR13,                        \
N                                  ((alpha) & GA_MASK8)))
X#define BLT_LOAD_SRCALPHA(alpha) (GA_LOAD(GA_GPR13,                                                          ((alpha) & GA_MASK8)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Transparency Pattern Register (STPR)
N|
N|  Descr  :   When the transparency color option is enabled the value stored
N|             in this register is the comparison pattern during conversion
N|             from 16-bit RGB to 32-bit RGBA format.
N|
N|  Params:    pattern - Source Transparency Pattern
N|                       Pattern for comparison of source dots
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_SRCTRANSPATT(pattern) (GA_LOAD(GA_GPR14,                  \
N                                        ((pattern) & GA_MASK24)))
X#define BLT_LOAD_SRCTRANSPATT(pattern) (GA_LOAD(GA_GPR14,                                                          ((pattern) & GA_MASK24)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Alpha Value Register (DAVR)
N|
N|  Descr  :   The Destination Alpha Value Register keeps the alpha value
N|             used during conversion of the destination dots from the 16-bit
N|             RGB format to the 32-bit RGBA format.
N|
N|  Params:    alpha - Destination Alpha Value
N|                     8-bit alpha value used for expanding destination dots
N|                     during conversion from 16-bit RGB to 32-bit RGBA
N|                     for internal processing.
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_DESTALPHA(alpha) (GA_LOAD(GA_GPR15,                       \
N                                   ((alpha) & GA_MASK8)))
X#define BLT_LOAD_DESTALPHA(alpha) (GA_LOAD(GA_GPR15,                                                          ((alpha) & GA_MASK8)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Transparency Register (DTR)
N|
N|  Descr  :   When the transparency color option is enabled the value stored
N|             in this register is the comparison pattern during conversion
N|             from 16-bit RGB to 32-bit RGBA format.
N|
N|  Params:    pattern - Destination Transparency Pattern
N|                       Pattern for comparison of destination dots.
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_DESTTRANSPATT(pattern) (GA_LOAD(GA_GPR16,                 \
N                                         ((pattern) & GA_MASK16)))
X#define BLT_LOAD_DESTTRANSPATT(pattern) (GA_LOAD(GA_GPR16,                                                          ((pattern) & GA_MASK16)))
N
N/*------------------------------
N|     FILLING CFG. REGISTERS    |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load RGBA Fill Preset Register (RGBAFPR)
N|
N|  Descr  :   The RGBA Fill Preset Register content is used when the filling
N|             option is enabled and the destination is in 32-bit RGBA mode.
N|
N|  Params:    val - RGBA Fill Preset (32-bit)
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_FILLRGBA(Val) (GA_LOAD(GA_GPR17,(Val)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load RGB Fill Preset Register (RGBFPR)
N|
N|  Descr  :   The content of the RGB Fill Preset Register is used, when the
N|             destination is within the 16-bit RGB mode.
N|
N|  Params:    val - RGB Fill Preset (16-bit)
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_FILLRGB(Val) (GA_LOAD(GA_GPR18,((Val) & GA_MASK16)))
N
N/*------------------------------
N|    FADING/RASTER REGISTERS    |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Fading Factor Register (FFR)
N|
N|  Descr  :   The Fading Factor Register holds the fading factor enumerator
N|             (FFE) of the fading factor.
N|
N|  Params:    factor - Fading Factor Enumerator
N|                      These bits specify the enumerator of the fading
N|                      factor FFACT.
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_FADEFACT(factor) (GA_LOAD(GA_GPR20,                       \
N                                   ((factor) & GA_MASK8)))
X#define BLT_LOAD_FADEFACT(factor) (GA_LOAD(GA_GPR20,                                                          ((factor) & GA_MASK8)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Raster Operation Register (ROR)
N|
N|  Descr  :   The Raster Operation Register consists of the Raster Operation
N|             Mode and the Raster Operation Value.
N|
N|  Params:    rastOpMode - Raster Operation Mode
N|                          This setting determines on which channels the
N|                          raster operation takes place.
N|                          Use following parameters:
N|                          BLT_RGBA_CH
N|                          BLT_RGB_CH
N|                          BLT_ALPHA_CH
N|                          BLT_ALPHA_DEST_CH
N|                          BLT_ALPHA_SRC_CH
N|
N|             rastOpVal  - Raster Operation Value
N|
N -------------------------------------------------------------------------*/
N#define BLT_LOAD_RASTOP(rastOpMode, rastOpVal) (GA_LOAD(GA_GPR21,      \
N                        GA_FP ((rastOpMode), 16, GA_MASK3)   |         \
N                        GA_FP ((rastOpVal),   0, GA_MASK4)))
X#define BLT_LOAD_RASTOP(rastOpMode, rastOpVal) (GA_LOAD(GA_GPR21,                              GA_FP ((rastOpMode), 16, GA_MASK3)   |                                 GA_FP ((rastOpVal),   0, GA_MASK4)))
N
N
N/*======================================
N                Enums
N=======================================*/
N/* RLEI Format in RGB mode without alpha channel */
Ntypedef enum tag_blt_rleifmt_rgb_e
N{
N    RLEI_OVRFMT_RGB16       = 0x0u,     /* Source format in format RLEI-16  */
N    RLEI_OVRFMT_RGB24       = 0x1u      /* Source format in format RLEI-24  */
N} blt_rleifmt_rgb_e;
N
N/* RLEI Format in RGBA mode with alpha channel */
Ntypedef enum tag_blt_rleifmt_rgba_e
N{
N    RLEI_OVRFMT_RGBA24      = 0x2u,     /* Source format in format RLEI-24A */
N    RLEI_OVRFMT_RGBA32      = 0x3u      /* Source format in format RLEI-32  */
N} blt_rleifmt_rgba_e;
N
N/* RLEI Format in RGBx mode with and without alpha channel */
Ntypedef enum tag_blt_rleifmt_rgbx_e
N{
N    RLEI_BLNDFMT_RGB16       = 0x0u,     /* Source format in format RLEI-16  */
N    RLEI_BLNDFMT_RGB24       = 0x1u,     /* Source format in format RLEI-24  */
N    RLEI_BLNDFMT_RGBA24      = 0x2u,     /* Source format in format RLEI-24A */
N    RLEI_BLNDFMT_RGBA32      = 0x3u      /* Source format in format RLEI-32  */
N} blt_rleifmt_rgbx_e;
N
N/* Memory Region Selection */
Ntypedef enum tag_blt_memSel_e
N{
N    BLT_MEM_SRC          = 0x1u,     /* Source Memory Parameters */
N    BLT_MEM_DST          = 0x2u,     /* Destination Memory Parameters */
N    BLT_MEM_ALL          = 0x3u      /* Both Source and Destination */
N} ga_memSel_e;
N
N/* Fading Mode Selection */
Ntypedef enum tag_blt_fadeMode_e
N{
N    BLT_NOFADING         = 0x0u,     /* No fading */
N    BLT_FADE_ALL         = 0x1u,     /* RGB and Alpha will be faded */
N    BLT_FADE_ALPHA       = 0x2u,     /* Only Alpha will be faded */
N    BLT_FADE_RGB         = 0x3u      /* Only RGB will be faded */
N} blt_fadeMode_e;
N
N/* Raster Op. Channel selection */
Ntypedef enum tag_blt_rastChSel_e
N{
N    BLT_RGBA_CH          = 0x0u,     /* Rast op. on all channels */
N    BLT_RGB_CH           = 0x1u,     /* Rast op. on RGB channels */
N    BLT_ALPHA_CH         = 0x2u,     /* Rast op. on Alpha ch. only */
N    BLT_ALPHA_DEST_CH    = 0x3u,     /* Rast op. RGB and keep Dst. alpha ch.*/
N    BLT_ALPHA_SRC_CH     = 0x4u      /* Rast op. RGB and keep Src. alpha ch.*/
N} blt_rastChSel_e;
N
N/* Raster Operation Values */
Ntypedef enum tag_blt_rastOpVal_e
N{
N    /* Source ONLY */
N    BLT_RAST_SOURCE      = 0xcu,     /* Source */
N    BLT_RAST_SRC_INV     = 0x3u,     /* Inverts the Source */
N
N    /* Destination ONLY */
N    BLT_RAST_DEST        = 0xau,     /* Destination */
N    BLT_RAST_DEST_ZERO   = 0x0u,     /* Sets destination to 0  */
N    BLT_RAST_DEST_ONE    = 0xfu,     /* Sets destination to 1  */
N    BLT_RAST_DEST_INV    = 0x5u,     /* Inverts the Destination*/
N
N    /* Boolean AND */
N    BLT_RAST_S_AND_D     = 0x8u,     /*  ( Src. AND  Dest.) */
N    BLT_RAST_NS_AND_D    = 0x2u,     /*  (~Src. AND  Dest.) */
N    BLT_RAST_S_AND_ND    = 0x4u,     /*  ( Src. AND ~Dest.) */
N    BLT_RAST_S_AND_D_INV = 0x7u,     /* ~( Src. AND  Dest.) */
N
N    /* Boolean OR */
N    BLT_RAST_S_OR_D      = 0xeu,     /*  ( Src. OR  Dest.) */
N    BLT_RAST_NS_OR_D     = 0xbu,     /*  (~Src. OR  Dest.) */
N    BLT_RAST_S_OR_ND     = 0xdu,     /*  ( Src. OR ~Dest.) */
N    BLT_RAST_S_OR_D_INV  = 0x1u,     /* ~( Src. OR  Dest.) */
N
N    /* Boolean XOR */
N    BLT_RAST_S_XOR_D     = 0x6u,     /*  ( Src. XOR Dest.) */
N    BLT_RAST_S_XOR_D_INV = 0x9u      /* ~( Src. XOR Dest.) */
N} blt_rastOpVal_e;
N
N
N/*======================================
N              Structures
N=======================================*/
N
N/* Memory Blitting structure */
Ntypedef struct tag_blit_mem_st
N{
N    /* Source Mem. Params */
N    uint16_t      u16SrcWidth;      /* Source Memory Width (Dots Per Line) */
N    uint32_t      u32SrcAddr;       /* Source Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    /* Destination Mem. Params */
N    uint16_t      u16DstWidth;      /* Dest. Memory Width (Dots Per Line) */
N    uint32_t      u32DstAddr;       /* Dest. Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    /* Blitting Area Size */
N    uint16_t      u16DotCnt;         /* Dot Number per line to be blitted */
N    uint16_t      u16LineCnt;        /* Line Number to be blitted */
N
N} blit_mem_st;
N
N/* Clipping Window Structure */
Ntypedef struct tag_blit_ClipWnd_st
N{
N    uint32_t       u32ClipAddr;      /* Start Addr.(first dot within C.Wnd) */
N    uint16_t       u16Width;         /* Width (nr. of dots in horiz. dir.)  */
N    uint16_t       u16Height;        /* Height (nr.of dots in vertic. dir.) */
N} blit_ClipWnd_st;
N
N/* RGB/RGBA Operation parameter structure (Overwrite mode) */
Ntypedef struct tag_blit_OvrRgb_st
N{
N    ga_colFmt_e     eSrcFmt;        /* Source Color format */
N    ga_colFmt_e     eDestFmt;       /* Destination Color format */
N    ga_en_e         eTranspColEn;   /* Transparency Color Option
N                                      (avail. only for 16-bit RGB source) */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    uint32_t        u32SrcTransVal; /* Src. Transpar. Pattern (STPR reg.) 
N                                       Pattern for comparison of source dots. For 16-bit RGB to 32bit
N                                       RGBA conversion, the bits 15:0 are regarded. For 24-bit RGB to
N                                       32-bit RGBA conversion, the bits 23:0 are regarded. */    
N    uint16_t        u16DstTransVal; /* Dest. Transp. Pattern (DTR reg.) */
N    uint8_t         u8SrcAlphaVal;  /* Source Alpha Value */
N    uint8_t         u8DstAlphaVal;  /* Destination Alpha Value */
N} blit_OvrRgb_st;
N
N
N/* RLEI Operation parameter structure (Overwrite mode) */
Ntypedef struct tag_blit_OvrRlei_st
N{
N    blt_rleifmt_rgb_e  eRleiFmt; /* RLE Format of source image */ 
N    ga_colFmt_e     eDestFmt;       /* Destination Color format */
N    ga_en_e         eTranspColEn;   /* Transparency Color Option */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    uint32_t        u32SrcTransVal; /* Src. Transpar. Pattern (STPR reg.) 
N                                       Pattern for comparison of source dots. For 16-bit RGB to 32bit
N                                       RGBA conversion, the bits 15:0 are regarded. For 24-bit RGB to
N                                       32-bit RGBA conversion, the bits 23:0 are regarded.  */    
N    uint16_t        u16DstTransVal; /* Dest. Transp. Pattern (DTR reg.) */
N    uint8_t         u8SrcAlphaVal;  /* Source Alpha Value */
N    uint8_t         u8DstAlphaVal;  /* Destination Alpha Value */
N} blit_OvrRlei_st;
N
N/* RLEI24A Operation parameter structure (Overwrite mode) */
Ntypedef struct tag_blit_OvrRleiA_st
N{
N    blt_rleifmt_rgba_e  eRleiFmt; /* RLE Format of source image */
N    ga_colFmt_e     eDestFmt;       /* Destination Color format */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    uint8_t         u8SrcAlphaVal;  /* Source Alpha Value */
N    uint8_t         u8DstAlphaVal;  /* Destination Alpha Value */
N} blit_OvrRleiA_st;
N
N
N/* RGB Preset Operation parameter structure (Overwrite mode) */
Ntypedef struct tag_blit_OvrRgbP_st
N{
N    uint32_t        u32Color;       /* Fill Colour (RGB/RGBA format),
N                                       depending on eSrcFmt setting */
N    ga_colFmt_e     eSrcFmt;        /* Source Color Format */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N} blit_OvrRgbP_st;
N
N
N/* RGB/RGBA Operation parameter structure (Blending mode) */
Ntypedef struct tag_blit_BlndRgb_st
N{
N    ga_colFmt_e     eSrcFmt;        /* Source Color Format */
N    ga_colFmt_e     eDestFmt;       /* Destination Color Format */
N    ga_en_e         eRedChPrtEn;    /* RED channel Protection enable */
N    ga_en_e         eGreenChPrtEn;  /* GREEN channel Protection enable */
N    ga_en_e         eBlueChPrtEn;   /* BLUE channel Protection enable */
N    ga_en_e         eAlphaChPrtEn;  /* ALPHA channel Protection enable */
N    ga_en_e         eRastOpEn;      /* Enabling the Raster Operation */
N    ga_en_e         eTranspColEn;   /* Transp. Col. Opt. (only 16-bit src) */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N    ga_blendOrd_e   eBlndOrder;     /* Blending Order */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    uint32_t        u32SrcTransVal; /* Src. Transpar. Pattern (STPR reg.) 
N                                       Pattern for comparison of source dots. For 16-bit RGB to 32bit
N                                       RGBA conversion, the bits 15:0 are regarded. For 24-bit RGB to
N                                       32-bit RGBA conversion, the bits 23:0 are regarded. */    
N    uint16_t        u16DstTransVal; /* Dest. Transp. Pattern (DTR reg.) */
N    uint8_t         u8SrcAlphaVal;  /* Source Alpha Value */
N    uint8_t         u8DstAlphaVal;  /* Destination Alpha Value */
N    blt_rastChSel_e eRastOpMode;    /* Raster Operation Mode */
N    blt_rastOpVal_e eRastOpValue;   /* Raster Operation Value */
N} blit_BlndRgb_st;
N
N/* Run-Length Encoded 16-bit Operation parameter structure (Blending mode) */
Ntypedef struct tag_blit_BlndRlei_st
N{
N    blt_rleifmt_rgbx_e eRleiFmt;
N    ga_colFmt_e     eDestFmt;       /* Destination Color Format */
N    ga_en_e         eRedChPrtEn;    /* RED channel Protection enable */
N    ga_en_e         eGreenChPrtEn;  /* GREEN channel Protection enable */
N    ga_en_e         eBlueChPrtEn;   /* BLUE channel Protection enable */
N    ga_en_e         eAlphaChPrtEn;  /* ALPHA channel Protection enable */
N    ga_en_e         eRastOpEn;      /* Enabling the Raster Operation */
N    ga_en_e         eTranspColEn;   /* Transp. Col. Opt. (only 16-bit src) */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N    ga_blendOrd_e   eBlndOrder;     /* Blending Order */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    uint32_t        u32SrcTransVal; /* Src. Transpar. Pattern (STPR reg.) 
N                                       Pattern for comparison of source dots. For 16-bit RGB to 32bit
N                                       RGBA conversion, the bits 15:0 are regarded. For 24-bit RGB to
N                                       32-bit RGBA conversion, the bits 23:0 are regarded. */    
N    uint16_t        u16DstTransVal; /* Dest. Transp. Pattern (DTR reg.) */
N    uint8_t         u8SrcAlphaVal;  /* Source Alpha Value */
N    uint8_t         u8DstAlphaVal;  /* Destination Alpha Value */
N    blt_rastChSel_e eRastOpMode;    /* Raster Operation Mode */
N    blt_rastOpVal_e eRastOpValue;   /* Raster Operation Value */
N} blit_BlndRlei_st;
N
N/* 16-bit Fill Operation parameter structure (Blending mode) */
Ntypedef struct tag_blit_BlndFill16_st
N{
N    uint16_t        u16Color;        /* Fill Color RGB - format */
N    ga_en_e         eRedChPrtEn;    /* RED channel Protection enable */
N    ga_en_e         eGreenChPrtEn;  /* GREEN channel Protection enable */
N    ga_en_e         eBlueChPrtEn;   /* BLUE channel Protection enable */
N    ga_en_e         eRastOpEn;      /* Enabling the Raster Operation */
N    ga_blendOrd_e   eBlndOrder;     /* Blending Order */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    uint8_t         u8SrcAlphaVal;  /* Source Alpha Value */
N    uint8_t         u8DstAlphaVal;  /* Destination Alpha Value */
N    blt_rastChSel_e eRastOpMode;    /* Raster Operation Mode */
N    blt_rastOpVal_e eRastOpValue;   /* Raster Operation Value */
N} blit_BlndFill16_st;
N
N/* 32-bit Fill Operation parameter structure (Blending mode) */
Ntypedef struct tag_blit_BlndFill32_st
N{
N    uint32_t        u32Color;       /* Fill Color RGBA - format */
N    ga_en_e         eRedChPrtEn;    /* RED channel Protection enable */
N    ga_en_e         eGreenChPrtEn;  /* GREEN channel Protection enable */
N    ga_en_e         eBlueChPrtEn;   /* BLUE channel Protection enable */
N    ga_en_e         eAlphaChPrtEn;  /* ALPHA channel Protection enable */
N    ga_en_e         eRastOpEn;      /* Enabling the Raster Operation */
N    ga_blendOrd_e   eBlndOrder;     /* Blending Order */
N    blt_fadeMode_e  eFadeMode;      /* Fading Option */
N    ga_en_e         eClipWndEn;     /* Clipping Window Enable */
N
N    /* Optional */
N    uint8_t         u8FadingFctr;   /* Fading factor */
N    blt_rastChSel_e eRastOpMode;    /* Raster Operation Mode */
N    blt_rastOpVal_e eRastOpValue;   /* Raster Operation Value */
N} blit_BlndFill32_st;
N
N/*======================================
N      Exported Function Prototypes
N=======================================*/
N
N/****************************************************************************
N *
N * Function:      vBlit_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vBlit_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                      uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag);
N
N/*-------------------------------------------------------------------------
N|
N|                      B A S I C      O P E R A T I O N S
N|
N --------------------------------------------------------------------------*/
N/****************************************************************************
N *
N * Function:      vBlit_SetClippWnd
N *
N * Purpose:       Sets the Clipping Window (Source/Destination/Size)
N *
N * Inputs:        u32ClipAddr - Start Addr.(first dot within C.Wnd)
N *
N *                usWidth     - Clipping Window Width
N *                              (number of dots in horizontal dir.)
N *
N *                usHeight    - Clipping Window Height
N *                              (number of dots in horizontal dir.)
N *
N *                pstCmdList  - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vBlit_SetClippWnd(uint32_t u32ClipAddr, uint16_t u16Width,
N                       uint16_t  u16Height, ga_list_st* pstCmdList);
N
N
N/*-------------------------------------------------------------------------
N|
N|                  O V E R W R I T E      O P E R A T I O N S
N|
N --------------------------------------------------------------------------*/
N/****************************************************************************
N *
N * Function:      vBlit_OverwriteRGB
N *
N * Purpose:       Inserts the set of commands into a command list, which are
N *                necessary for starting an Overwrite function.
N *                In this case the source/destination is of RGB/RGBA type.
N *
N *                The function inserts the commands for necessary registers
N *                initialization and inserts the  appropriate Blit overwrite
N *                command (BLT_ORGB16/BLT_ORGBA32) depending of the source
N *                data format type .
N *
N *                     --------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB |RLE |
N *                    |=================================
N *                    |  32-bit RGBA |  X   |  X  |    |
N *                    |  16-bit RGB  |  X   |  X  |    |
N *                    |  RLE 32      |      |     |    |
N *                    |  RLE 24A     |      |     |    |
N *                    |  RLE 24      |      |     |    |
N *                    |  RLE 16      |      |     |    |
N *                     --------------------------------
N *
N * Inputs:        tMem      - Pointer to the Source/Destination Memory params
N *                            as well as the blitting area size.
N *                            (for more details please see struct desc.)
N *
N *                tParam    - Pointer to Parameter Structure which specifies all requred
N *                            input data for overwrite blitting operation
N *                            (for more details please see struct desc.)
N *
N *                ptCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   The source and destination address alignment rules,
N *                as descirbed in BLT_LOAD_SOURCEADDR/BLT_LOAD_DESTADDR
N *                command description, MUST always be obeyed!!!
N *
N ***************************************************************************/
Nvoid vBlit_OverwriteRGB(blit_mem_st* pstMem, blit_OvrRgb_st* pstParam,
N                        ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vBlit_OverwriteRLEI_RGB
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an Overwrite function where the source is of
N *                run-length encoded 16-bit RGB type while the destination
N *                is either of RGB or RGBA type.
N *
N *                This function inserts the commands for initialization of
N *                all necessary registers and inserts the appropriate Blit
N *                overwrite command.
N *
N *                     ---------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE |
N *                    |==================================
N *                    |  32-bit RGBA |      |     |     |
N *                    |  16-bit RGB  |      |     |     |
N *                    |  RLE 32      |      |     |     |
N *                    |  RLE 24A     |      |     |     |
N *                    |  RLE 24      |      |     |     |
N *                    |  RLE 16      |  X   |  X  |     |
N *                     ---------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                             (for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite blitting operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vBlit_OverwriteRLEI_RGB(blit_mem_st* pstMem, blit_OvrRlei_st* pstParam,
N                             ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vBlit_OverwriteRLEI_RGBA
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an Overwrite function where the source is of
N *                run-length encoded 24-bit RGBA type, while the destination
N *                is stored in RGBA format.
N *
N *                This function inserts the commands for initialization of
N *                all necessary registers and inserts the appropriate Blit
N *                overwrite command.
N *
N *                     ---------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE |
N *                    |==================================
N *                    |  32-bit RGBA |      |     |     |
N *                    |  16-bit RGB  |      |     |     |
N *                    |  RLE 32      |      |     |     |
N *                    |  RLE 24A     |  X   |  X  |     |
N *                    |  RLE 24      |      |     |     |
N *                    |  RLE 16      |      |     |     |
N *                     ---------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                             (for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite blitting operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vBlit_OverwriteRLEI_RGBA(blit_mem_st* pstMem, blit_OvrRleiA_st* pstParam,
N                              ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vBlit_OverwriteFillRGB
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an Overwrite function where the source is in
N *                RGBFP/RGBAFP Register and the destination is in same format.
N *
N *                This is basically the fill function where the FIll Color
N *                is taken from RGBFPReg.
N *
N *                     ---------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE |
N *                    |==================================
N *                    |  32-bit RGBA |      |     |     |
N *                    |  16-bit RGB  |      |     |     |
N *                    |  RLE 32      |      |     |     |
N *                    |  RLE 16      |      |     |     |
N *                    |  RLE 24A     |      |     |     |
N *                    |  RLE 24      |      |     |     |
N *                    |  RGBFPReg    |      |  X  |     |
N *                    |  RGBAFPReg   |  X   |     |     |
N *                     ---------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                             (for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite filling operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Please notice that the conversion between RGB and RGBA is
N *                not possible. The source format is ALWAYS equal to the
N *                destination format.
N *
N ***************************************************************************/
Nvoid vBlit_OverwriteFillRGB(blit_mem_st* pstMem, blit_OvrRgbP_st* pstParam,
N                            ga_list_st* pstCmdList);
N
N/*--------------------------------------------------------------------------
N|
N|                    B L E N D I N G      O P E R A T I O N S
N|
N --------------------------------------------------------------------------*/
N
N/****************************************************************************
N *
N * Function:      i32Blit_BlendRGB
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an blit blend function where the src/dst. is
N *                of 16/32-bit RGB/RGBA type.
N *
N *
N *                     ----------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE  |
N *                    |===================================
N *                    |  32-bit RGBA |  X   |  X  |      |
N *                    |  16-bit RGB  |  X   |  X  |      |
N *                    |  RLE 32      |      |     |      |
N *                    |  RLE 24A     |      |     |      |
N *                    |  RLE 24      |      |     |      |
N *                    |  RLE 16      |      |     |      |
N *                     ----------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                             (for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite blitting operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS - All conditions are fulfilled (See. Limitations)
N *                C_FAILED  - All conditions are not met (See. Limitations)
N *
N * Limitations: 1) When Raster Operation is enabled, the Source format MUST
N *                 be the SAME as Destination format. Please have in mind
N *                 that this function will prevent any illegal combination
N *                 to be executed. For this reason, always check the return
N *                 result of this function.
N 
N *              2) When Raster Operation is enabled, then the options 
N *                 Transparency Color and Fading will be assumed as disabled and
N *                 the features in pstParam will be ignored.
N *
N *              3) Please note that Alpha Channel Protection value is ONLY
N *                 used when the destination is in 32-bit RGBA format.
N *
N ***************************************************************************/
Nint32_t i32Blit_BlendRGB(blit_mem_st* pstMem, blit_BlndRgb_st* pstParam,
N                         ga_list_st* pstCmdList);
N	                        
N/****************************************************************************
N *
N * Function:      vBlit_BlendRLEI
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an blit blend function where the src is
N *                stored in run-length encoded 16-bit RGB format, while
N *                a destination is stored in 16-bit RGB or 32-bit RGBA
N *                format.
N *
N *                This function inserts the commands for initialization of
N *                all necessary registers and inserts the appropriate Blit
N *                Blend command.
N *
N *                     ----------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE  |
N *                    |===================================
N *                    |  RLE 32      |  X   |  X  |      |
N *                    |  RLE 24A     |  X   |  X  |      |
N *                    |  RLE 24      |  X   |  X  |      |
N *                    |  RLE 16      |  X   |  X  |      |
N *                     ----------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                             (for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite blitting operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:    When Raster Operation is enabled, then the options Transparency
N *                 Color and Fading will be assumed as disabled and the features 
N *                 in pstParam will be ignored.
N 
N*
N ***************************************************************************/
Nvoid vBlit_BlendRLEI(blit_mem_st* pstMem, blit_BlndRlei_st* pstParam,
N                     ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vBlit_BlendFillRGB
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an Overwrite function where the source is in
N *                RGBFPReg Register and the destination is in 16-bit RGB
N *                format.
N *
N *                This function inserts the commands for initialization of
N *                all necessary registers and inserts the appropriate Blit
N *                overwrite command.
N *
N *                     ---------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE |
N *                    |==================================
N *                    |  32-bit RGBA |      |     |     |
N *                    |  16-bit RGB  |      |     |     |
N *                    |  RLE 32      |      |     |     |
N *                    |  RLE 24A     |      |     |     |
N *                    |  RLE 24      |      |     |     |
N *                    |  RLE 16      |      |     |     |
N *                    |  RGBFPReg    |      |  X  |     |
N *                    |  RGBAFPReg   |      |     |     |
N *                     ---------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                            ( for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite filling operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:    When Raster Operation is enabled, then the option Fading
N *                 will be assumed as disabled and the feature in pstParam
N *                 will be ognored. 
N *
N ***************************************************************************/
Nvoid vBlit_BlendFillRGB(blit_mem_st* pstMem, blit_BlndFill16_st* pstParam,
N                        ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vBlit_BlendFillRGBA
N *
N * Purpose:       Inserts the commands into command list which are necessary
N *                for starting an Overwrite function where the source is in
N *                RGBAFP Register and the destination is in 32-bit RGBA
N *                format.
N *
N *                This function inserts the commands for initialization of
N *                all necessary registers and inserts the appropriate Blit
N *                overwrite command.
N *
N *                     ---------------------------------
N *                    |  Src.\ Dest  | RGBA | RGB | RLE |
N *                    |==================================
N *                    |  32-bit RGBA |      |     |     |
N *                    |  16-bit RGB  |      |     |     |
N *                    |  RLE 32      |      |     |     |
N *                    |  RLE 24A     |      |     |     |
N *                    |  RLE 24      |      |     |     |
N *                    |  RLE 16      |      |     |     |
N *                    |  RGBFPReg    |      |     |     |
N *                    |  RGBAFPReg   |  X   |     |     |
N *                     ----------------------------------
N *
N * Inputs:        stMem      - Pointer to the Source/Destination Memory params
N *                             as well as the blitting area size.
N *                             (for more details please see struct desc.)
N *
N *                stParam    - Pointer to Parameter Structure which specifies all requred
N *                             input data for overwrite filling operation
N *                             (for more details please see struct desc.)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:    When Raster Operation is enabled, then then the option Fading
N *                 will be assumed as disabled and this feature in pstParam will
N *                 be ignored. 
N *
N ***************************************************************************/
Nvoid vBlit_BlendFillRGBA(blit_mem_st* pstMem, blit_BlndFill32_st* pstParam,
N                         ga_list_st* pstCmdList);
N
N/****************************************************************************/
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N#endif /* BLIT_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: blit.h
N**  $Revision: 1.15 $
N**  $Date: 2015/05/04 09:07:14 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  :
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\blit.c" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1858  /* Rule 17.4 [R] : subscript operator may only be applied to objects declared as an array type */
S  #pragma ghs nowarning 1879  /* Rule 10.3 [R] : Restrict explicit casts for integer type expressions */
S  #pragma ghs nowarning 1878  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to wider type "type" not allowed */
S
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S
N#endif
N/*======================================
N    Stat. Var and Func. Prototypes
N=======================================*/
N
N
N/*======================================
N    Glob. Var and Func. Prototypes
N=======================================*/
N
N/*======================================
N                Macros
N=======================================*/
N
N#define LLDD_GA_BLIT_C_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_BLIT_C_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*======================================
N Static variables and forward declarations
N=======================================*/
N
Nstatic uint8_t au8LLDD_GA_BLIT_C_REVISION[] = LLDD_GA_BLIT_C_REVISION;
Xstatic uint8_t au8LLDD_GA_BLIT_C_REVISION[] = "$Revision: 1.14 $";
Nstatic uint8_t au8LLDD_GA_BLIT_C_TAG[]      = LLDD_GA_BLIT_C_TAG;
Xstatic uint8_t au8LLDD_GA_BLIT_C_TAG[]      = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GA_BLIT_H_REVISION[] = LLDD_GA_BLIT_H_REVISION;
Xstatic uint8_t au8LLDD_GA_BLIT_H_REVISION[] = "$Revision: 1.15 $";
Nstatic uint8_t au8LLDD_GA_BLIT_H_TAG[]      = LLDD_GA_BLIT_H_TAG;
Xstatic uint8_t au8LLDD_GA_BLIT_H_TAG[]      = "$Name: LLDD_1_7_GFX $";
N
N
N/*======================================
N          Function definitions
N=======================================*/
N
Nvoid vBlit_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                      uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag)
N{
N     *pau8ModuleRevision = &au8LLDD_GA_BLIT_C_REVISION[0];
N     *pau8ModuleTag      = &au8LLDD_GA_BLIT_C_TAG[0];
N     *pau8HeaderRevision = &au8LLDD_GA_BLIT_H_REVISION[0];
N     *pau8HeaderTag      = &au8LLDD_GA_BLIT_H_TAG[0];
N}
N/* ....................................................................... */
Nvoid vBlit_SetClippWnd(uint32_t u32ClipAddr, uint16_t u16Width,
N                       uint16_t u16Height, ga_list_st* pstCmdList)
N{
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW  = 3U;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S    
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pu64Curr[0] = BLT_LOAD_CLIP_STARTADDR(u32ClipAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((0)) & (0x1fu)) << (32)) | (((uint64_t)(((u32ClipAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_CLIP_WIDTH(u16Width);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((1)) & (0x1fu)) << (32)) | (((uint64_t)((((u16Width) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[2] = BLT_LOAD_CLIP_HEIGHT(u16Height);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((2)) & (0x1fu)) << (32)) | (((uint64_t)((((u16Height) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    pstCmdList->pu64Current = &pu64Curr[3];
N
N    pstCmdList->u32UsedDoubleWords = 3U;
N}
N
N/* ....................................................................... */
Nvoid vBlit_OverwriteRGB(blit_mem_st* pstMem, blit_OvrRgb_st* pstParam, ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 6U;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW;
S    
S    u32NeededDW = u8Curr + 2U; /* 2 for Src/Dst Alpha */
S    if(pstParam->eFadeMode != BLT_NOFADING)
S    {
S        u32NeededDW++;  /* for fade factor */
S    }
S    if(pstParam->eSrcFmt == GA_RGB16 && pstParam->eTranspColEn == GA_EN)
S    {
S        u32NeededDW+=2; /* for Src/Dst Transparency */
S    }
S    u32NeededDW++; /* for command itself */
S    
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    /* Source Memory Params */
N    pu64Curr[0] = BLT_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16SrcWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Destination Memory Params */
N    pu64Curr[2] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[4] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[5] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /*** Operation Specific Params ***/
N
N    /* Fading Factor Setup */
N    if(pstParam->eFadeMode != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N   /* Source Alpha Blending Value */
N   pu64Curr[u8Curr] = BLT_LOAD_SRCALPHA(pstParam->u8SrcAlphaVal);
X   pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N   u8Curr++;
N
N   /* Destination Alpha Blending Value */
N   pu64Curr[u8Curr] = BLT_LOAD_DESTALPHA(pstParam->u8DstAlphaVal);
X   pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N   u8Curr++;
N
N    /* Source Type Selection */
N    if(pstParam->eSrcFmt == GA_RGB16)
N    {
N        /** 16-bit RGB Source **/
N
N        /* Transparency Color Option */
N        if(pstParam->eTranspColEn == GA_EN)
N        {
N            pu64Curr[u8Curr] = BLT_LOAD_SRCTRANSPATT(pstParam->u32SrcTransVal);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u32SrcTransVal) & 0xffffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N            pu64Curr[u8Curr] = BLT_LOAD_DESTTRANSPATT(pstParam->u16DstTransVal);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u16DstTransVal) & 0xffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N
N        }
N
N        /* Overwrite 16-bit RGB */
N        pu64Curr[u8Curr] = BLT_ORGB16(pstParam->eDestFmt,
N                                      pstParam->eTranspColEn,
N                                      pstParam->eFadeMode,
N                                      pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x02u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eTranspColEn)) & (0x1u)) << (3)) | (((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    else
N    {
N        /** 32-bit RGBA Source **/
N        pu64Curr[u8Curr] = BLT_ORGBA32(pstParam->eDestFmt,
N                                       pstParam->eFadeMode,
N                                       pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x04u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (3)) | (((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N
N    u8Curr++;    
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N}    
N
N/* ....................................................................... */
Nvoid vBlit_OverwriteRLEI_RGB(blit_mem_st* pstMem, blit_OvrRlei_st* pstParam,
N                             ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 6U;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr + 2; /* 2 for Src/Dst Alpha */
S    if(pstParam->eFadeMode != BLT_NOFADING)
S    {
S        u32NeededDW++;  /* for fade factor */
S    }
S    if(pstParam->eTranspColEn == GA_EN)
S    {
S        u32NeededDW+=2; /* for Src/Dst Transparency */
S    }
S    u32NeededDW++; /* for command itself */
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Source Memory Params */
N    pu64Curr[0] = BLT_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16SrcWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Destination Memory Params */
N    pu64Curr[2] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[4] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[5] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Source Alpha Blending Value */
N    pu64Curr[u8Curr] = BLT_LOAD_SRCALPHA(pstParam->u8SrcAlphaVal);
X    pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    u8Curr++;
N
N    /* Destination Alpha Blending Value */
N    pu64Curr[u8Curr] = BLT_LOAD_DESTALPHA(pstParam->u8DstAlphaVal);
X    pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    u8Curr++;
N
N    /*** Operation Specific Params ***/
N
N    if(pstParam->eTranspColEn == GA_EN)
N    {
N        /* Transparency Color Option */
N        pu64Curr[u8Curr] = BLT_LOAD_SRCTRANSPATT(pstParam->u32SrcTransVal);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u32SrcTransVal) & 0xffffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N        pu64Curr[u8Curr] = BLT_LOAD_DESTTRANSPATT(pstParam->u16DstTransVal);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u16DstTransVal) & 0xffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Fading Factor Setup */
N    if(pstParam->eFadeMode != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N    if (pstParam->eRleiFmt == RLEI_OVRFMT_RGB16)
N    {
N        /* Run-Length 16-bit RGB */
N        pu64Curr[u8Curr] = BLT_ORLEI16(pstParam->eDestFmt,
N                                       pstParam->eTranspColEn,
N                                       pstParam->eFadeMode,
N                                       pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x0au))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eTranspColEn)) & (0x1u)) << (3)) | (((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    else
N    {
N        /* Run-Length 16-bit RGB */
N        pu64Curr[u8Curr] = BLT_ORLEI24(pstParam->eDestFmt,
N                                       pstParam->eTranspColEn,
N                                       pstParam->eFadeMode,
N                                       pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x06u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eTranspColEn)) & (0x1u)) << (3)) | (((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    u8Curr++;
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N}
N
N/* ....................................................................... */
Nvoid vBlit_OverwriteRLEI_RGBA(blit_mem_st* pstMem, blit_OvrRleiA_st* pstParam,
N                              ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 6U;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr;    
S    if(pstParam->eFadeMode != BLT_NOFADING)
S    {
S        u32NeededDW++;  /* for fade factor*/
S    }
S    u32NeededDW++; /* for command itself */
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Source Memory Params */
N    pu64Curr[0] = BLT_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16SrcWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Destination Memory Params */
N    pu64Curr[2] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[4] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[5] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /*** Operation Specific Params ***/
N
N    /* Fading Factor Setup */
N    if(pstParam->eFadeMode != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    if (pstParam->eRleiFmt == RLEI_OVRFMT_RGBA24)
N    {
N        /* Run-Length 32-bit RGB */
N        pu64Curr[u8Curr] = BLT_ORLEI24A(pstParam->eDestFmt,
N                                        pstParam->eFadeMode,
N                                        pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x0Eu))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (3)) | (((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    else
N    {
N        /* Run-Length 32-bit RGB */
N        pu64Curr[u8Curr] = BLT_ORLEI32(pstParam->eDestFmt,
N                                       pstParam->eFadeMode,
N                                       pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x0cu))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (3)) | (((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    u8Curr++;
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N}
N
N/* ....................................................................... */
Nvoid vBlit_OverwriteFillRGB(blit_mem_st* pstMem, blit_OvrRgbP_st* pstParam,
N                            ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 4U;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr;
S    
S    if(pstParam->eFadeMode != BLT_NOFADING)
S    {
S        u32NeededDW++;  /* for fade factor*/
S    }
S    u32NeededDW+=2; /* for color and command itself */
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Destination Memory Params */
N    pu64Curr[0] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[2] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /*** Operation Specific Params ***/
N
N    /* Fading Factor Setup */
N    if(pstParam->eFadeMode != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Source Format Selection */
N    if(pstParam->eSrcFmt == GA_RGB16)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FILLRGB(pstParam->u32Color);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((18)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u32Color) & 0xffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N        pu64Curr[u8Curr] = BLT_OPRST_RGB16(pstParam->eFadeMode, pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x12u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N    else
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FILLRGBA(pstParam->u32Color);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((17)) & (0x1fu)) << (32)) | (((uint64_t)(((pstParam->u32Color))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N        pu64Curr[u8Curr] = BLT_OPRST_RGBA32(pstParam->eFadeMode, pstParam->eClipWndEn);
X        pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x14u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eFadeMode)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    }
N
N    u8Curr++;
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N}
N
N/* ....................................................................... */
Nint32_t i32Blit_BlendRGB(blit_mem_st* pstMem, blit_BlndRgb_st* pstParam,
N                         ga_list_st* pstCmdList)
N{
N    int32_t i32Res = C_FAILED;
X    int32_t i32Res = (-1);
N    uint8_t u8Curr = 6U;
N    uint64_t* pu64Curr;
N    ga_en_e         eTranspColEn_valid;
N    blt_fadeMode_e  eFadeMode_valid;
N
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        /* Raster option requires disabled Fading and Transp. Col. Opt. 
N         * If it is enabled Transparency Color and Fade mode will be
N         * assuemed as disbaled */
N        eTranspColEn_valid = GA_DIS;
N        eFadeMode_valid    = BLT_NOFADING;
N    }
N    else
N    {
N        eTranspColEn_valid = pstParam->eTranspColEn;
N        eFadeMode_valid    = pstParam->eFadeMode;
N    }
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr;
S    u32NeededDW += 2; /* 2 for Src/Dst Alpha */
S    if(pstParam->eRastOpEn == GA_EN)
S    {
S        u32NeededDW++; /* for raster value */
S    }
S    else
S    {
S        if(eFadeMode_valid != BLT_NOFADING)
S        {
S            u32NeededDW++;  /* for fade factor*/
S        }
S        if(eTranspColEn_valid == GA_EN)
S        {
S            u32NeededDW+=2; /* for Src/Dst Transparency */
S        }
S    }
S    u32NeededDW++; /* for command itself */
S
S    if(pstParam->eRastOpEn == GA_EN && pstParam->eSrcFmt != pstParam->eDestFmt)    
S    {
S      /* in this case no command will be writen : */
S      u32NeededDW = u8Curr;
S    }
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return C_FAILED;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Check Whether Raster Operation is enabled */
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        /* Source and Destination must have the same Format */
N        if(pstParam->eSrcFmt == pstParam->eDestFmt)
N        {
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_SUCCESS;
X        i32Res = (0);
N    }
N
N    /* Check if all conditions are met */
N    if(i32Res == C_SUCCESS)
X    if(i32Res == (0))
N    {
N        /* Update Pointer */
N        pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N        /* Source Memory Params */
N        pu64Curr[0] = BLT_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X        pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        pu64Curr[1] = BLT_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X        pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16SrcWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N        /* Destination Memory Params */
N        pu64Curr[2] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X        pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        pu64Curr[3] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X        pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N        /* Blitting Area Size */
N        pu64Curr[4] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X        pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        pu64Curr[5] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X        pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N        /*** Operation Specific Params ***/
N
N        /* Raster Parameter Setup */
N        if(pstParam->eRastOpEn == GA_EN)
N        {
N            pu64Curr[u8Curr] = BLT_LOAD_RASTOP(pstParam->eRastOpMode, pstParam->eRastOpValue);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((21)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstParam->eRastOpMode)) & (0x7u)) << (16)) | (((uint64_t)((pstParam->eRastOpValue)) & (0xfu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N        /* Fading Parameter Setup */
N        if(eFadeMode_valid != BLT_NOFADING)
N        {
N            pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N
N        /* Source Alpha Blending Value */
N        pu64Curr[u8Curr] = BLT_LOAD_SRCALPHA(pstParam->u8SrcAlphaVal);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        /* Destination Alpha Blending Value */
N        pu64Curr[u8Curr] = BLT_LOAD_DESTALPHA(pstParam->u8DstAlphaVal);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        /* Transparency Parameters */
N        if(eTranspColEn_valid == GA_EN)
N        {
N            /* Transparency Color Option */
N            pu64Curr[u8Curr] = BLT_LOAD_SRCTRANSPATT(pstParam->u32SrcTransVal);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u32SrcTransVal) & 0xffffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N            pu64Curr[u8Curr] = BLT_LOAD_DESTTRANSPATT(pstParam->u16DstTransVal);
X            pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u16DstTransVal) & 0xffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N            u8Curr++;
N        }
N
N        /* Source Selection */
N        if(pstParam->eSrcFmt == GA_RGB16)
N        {
N            /* Blit Blend. 16-bit RGB */
N            pu64Curr[u8Curr] = BLT_BRGB16(pstParam->eRedChPrtEn,
N                                          pstParam->eGreenChPrtEn,
N                                          pstParam->eBlueChPrtEn,
N                                          pstParam->eAlphaChPrtEn,
N                                          pstParam->eRastOpEn,
N                                          pstParam->eDestFmt,
N                                          pstParam->eBlndOrder,
N                                          eTranspColEn_valid ,  /* if eRastOpEn is enabled then this parameter will be disabled */ 
N                                          eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                          pstParam->eClipWndEn);
X            pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)((((0x1u)))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x03u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (4)) | (((uint64_t)((eTranspColEn_valid)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        }
N        else
N        {
N            /* Blit Blend. 32-bit RGBA */
N            pu64Curr[u8Curr] = BLT_BRGBA32(pstParam->eRedChPrtEn,
N                                           pstParam->eGreenChPrtEn,
N                                           pstParam->eBlueChPrtEn,
N                                           pstParam->eAlphaChPrtEn,
N                                           pstParam->eRastOpEn,
N                                           pstParam->eDestFmt,
N                                           pstParam->eBlndOrder,
N                                           eTranspColEn_valid ,  /* if eRastOpEn is enabled then this parameter will be disabled */ 
N                                           eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                           pstParam->eClipWndEn);
X            pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x07u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (4)) | (((uint64_t)((eTranspColEn_valid)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N        }
N
N        u8Curr++;
N
N        /* Update List Pointer */
N        pstCmdList->pu64Current = &pu64Curr[u8Curr];
N    }
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N    return i32Res;
N}
N
N/* ....................................................................... */
Nvoid vBlit_BlendRLEI(blit_mem_st* pstMem, blit_BlndRlei_st* pstParam,
N                     ga_list_st* pstCmdList)
N{
N    uint8_t         u8Curr = 6U;
N    ga_en_e         eTranspColEn_valid;
N    blt_fadeMode_e  eFadeMode_valid;
N    uint64_t*       pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        /* Raster option requires disabled Fading and Transp. Col. Opt. 
N         * If it is enabled Transparency Color and Fade mode will be
N         * assuemed as disbaled */
N        eTranspColEn_valid = GA_DIS;
N        eFadeMode_valid    = BLT_NOFADING;
N    }
N    else
N    {
N        eTranspColEn_valid = pstParam->eTranspColEn;
N        eFadeMode_valid    = pstParam->eFadeMode;
N    }
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr + 2; /* 2 for Src/Dst Alpha */
S    if(pstParam->eRastOpEn == GA_EN)
S    {
S        u32NeededDW++; /* for raster value */
S    }
S    else
S    {
S        if(eFadeMode_valid != BLT_NOFADING)
S        {
S            u32NeededDW++;  /* for fade factor*/
S        }
S        if(eTranspColEn_valid == GA_EN)
S        {
S            u32NeededDW+=2; /* for Src/Dst Transparency */
S        }
S    }
S    u32NeededDW++; /* for command itself */
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Source Memory Params */
N    pu64Curr[0] = BLT_LOAD_SOURCEADDR(pstMem->u32SrcAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((9)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32SrcAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_SRCWIDTH(pstMem->u16SrcWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((10)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16SrcWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Destination Memory Params */
N    pu64Curr[2] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[4] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[5] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /*** Operation Specific Params ***/
N
N    /* Raster Parameter Setup */
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_RASTOP(pstParam->eRastOpMode, pstParam->eRastOpValue);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((21)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstParam->eRastOpMode)) & (0x7u)) << (16)) | (((uint64_t)((pstParam->eRastOpValue)) & (0xfu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Fading Parameter Setup */
N    if(eFadeMode_valid != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    pu64Curr[u8Curr] = BLT_LOAD_SRCALPHA(pstParam->u8SrcAlphaVal);
X    pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    u8Curr++;
N
N    pu64Curr[u8Curr] = BLT_LOAD_DESTALPHA(pstParam->u8DstAlphaVal);
X    pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    u8Curr++;    
N    
N    /* Transparency Parameters */
N    if(eTranspColEn_valid == GA_EN)
N    {
N        /* Transparency Color Option */
N        pu64Curr[u8Curr] = BLT_LOAD_SRCTRANSPATT(pstParam->u32SrcTransVal);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((14)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u32SrcTransVal) & 0xffffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N
N        pu64Curr[u8Curr] = BLT_LOAD_DESTTRANSPATT(pstParam->u16DstTransVal);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((16)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u16DstTransVal) & 0xffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N    switch( pstParam->eRleiFmt )
N    {
N        case RLEI_BLNDFMT_RGB16:
N            /* Blit Blend. Run-Len. Enc. 16-bit RGB */
N            pu64Curr[u8Curr] = BLT_BRLEI16(pstParam->eRedChPrtEn,
N                                           pstParam->eGreenChPrtEn,
N                                           pstParam->eBlueChPrtEn,
N                                           pstParam->eAlphaChPrtEn,
N                                           pstParam->eRastOpEn,
N                                           pstParam->eDestFmt,
N                                           pstParam->eBlndOrder,
N                                           eTranspColEn_valid ,  /* if eRastOpEn is enabled then this parameter will be disabled */ 
N                                           eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                           pstParam->eClipWndEn);
X            pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x0bu))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (4)) | (((uint64_t)((eTranspColEn_valid)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N            break;
N        case RLEI_BLNDFMT_RGB24:
N            /* Blit Blend. Run-Len. Enc. 24bit RGB */
N            pu64Curr[u8Curr] = BLT_BRLEI24(pstParam->eRedChPrtEn,
N                                           pstParam->eGreenChPrtEn,
N                                           pstParam->eBlueChPrtEn,
N                                           pstParam->eAlphaChPrtEn,
N                                           pstParam->eRastOpEn,
N                                           pstParam->eDestFmt,
N                                           pstParam->eBlndOrder,
N                                           eTranspColEn_valid ,  /* if eRastOpEn is enabled then this parameter will be disabled */ 
N                                           eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                           pstParam->eClipWndEn);
X            pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x05u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (4)) | (((uint64_t)((eTranspColEn_valid)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N            break;
N        case RLEI_BLNDFMT_RGBA24:
N            /* Blit Blend. Run-Len. Enc. 24-bit RGBA */
N            pu64Curr[u8Curr] = BLT_BRLEI24A(pstParam->eRedChPrtEn,
N                                           pstParam->eGreenChPrtEn,
N                                           pstParam->eBlueChPrtEn,
N                                           pstParam->eAlphaChPrtEn,
N                                           pstParam->eRastOpEn,
N                                           pstParam->eDestFmt,
N                                           pstParam->eBlndOrder,
N                                           eTranspColEn_valid ,  /* if eRastOpEn is enabled then this parameter will be disabled */ 
N                                           eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                           pstParam->eClipWndEn);
X            pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x0fu))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (4)) | (((uint64_t)((eTranspColEn_valid)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N            break;
N        default:
N            /* Blit Blend. Run-Len. Enc. 32-bit RGBA */
N            pu64Curr[u8Curr] = BLT_BRLEI32(pstParam->eRedChPrtEn,
N                                           pstParam->eGreenChPrtEn,
N                                           pstParam->eBlueChPrtEn,
N                                           pstParam->eAlphaChPrtEn,
N                                           pstParam->eRastOpEn,
N                                           pstParam->eDestFmt,
N                                           pstParam->eBlndOrder,
N                                           eTranspColEn_valid ,  /* if eRastOpEn is enabled then this parameter will be disabled */ 
N                                           eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                           pstParam->eClipWndEn);
X            pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x0du))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)((pstParam->eDestFmt)) & (0x1u)) << (5)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (4)) | (((uint64_t)((eTranspColEn_valid)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N            break;
N         
N    }
N    u8Curr++;
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N}
N
N/* ....................................................................... */
Nvoid vBlit_BlendFillRGB(blit_mem_st* pstMem, blit_BlndFill16_st* pstParam,
N                        ga_list_st* pstCmdList)
N{
N    uint8_t         u8Curr = 7U;
N    blt_fadeMode_e  eFadeMode_valid;
N    uint64_t*       pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N    
N
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        /* Raster option requires disabled Fading Opt. 
N         * If it is enabled Fade mode will be  assuemed as disbaled */
N        eFadeMode_valid = BLT_NOFADING;
N    }
N    else
N    {
N        eFadeMode_valid = pstParam->eFadeMode;
N    }
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr;
S    if(pstParam->eRastOpEn == GA_EN)
S    {
S        u32NeededDW++; /* for raster value */
S    }
S    else
S    {
S        if(eFadeMode_valid != BLT_NOFADING)
S        {
S            u32NeededDW++;  /* for fade factor*/
S        }
S    }
S    u32NeededDW++; /* for command itself */
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Destination Memory Params */
N    pu64Curr[0] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[2] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /*** Operation Specific Params ***/
N
N    /* Fill Color */
N    pu64Curr[4] = BLT_LOAD_FILLRGB(pstParam->u16Color);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((18)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u16Color) & 0xffffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Source and Destination Alpha Blending */
N    pu64Curr[5] = BLT_LOAD_SRCALPHA(pstParam->u8SrcAlphaVal);
X    pu64Curr[5] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((13)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8SrcAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[6] = BLT_LOAD_DESTALPHA(pstParam->u8DstAlphaVal);
X    pu64Curr[6] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((15)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8DstAlphaVal) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Raster Parameter Setup */
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_RASTOP(pstParam->eRastOpMode, pstParam->eRastOpValue);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((21)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstParam->eRastOpMode)) & (0x7u)) << (16)) | (((uint64_t)((pstParam->eRastOpValue)) & (0xfu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Fading Factor Setup */
N    if(eFadeMode_valid != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Blit Blend. Preset 16-bit RGB  */
N    pu64Curr[u8Curr] = BLT_BPRST_RGB16(pstParam->eRedChPrtEn,
N                                       pstParam->eGreenChPrtEn,
N                                       pstParam->eBlueChPrtEn,
N                                       pstParam->eRastOpEn,
N                                       pstParam->eBlndOrder,
N                                       eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                       pstParam->eClipWndEn);
X    pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x13u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)(0) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)(0) & (0x1u)) << (5)) | (((uint64_t)(0) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    u8Curr++;
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N}
N
N/* ....................................................................... */
Nvoid vBlit_BlendFillRGBA(blit_mem_st* pstMem, blit_BlndFill32_st* pstParam,
N                         ga_list_st* pstCmdList)
N{
N    uint8_t u8Curr = 5U;
N    blt_fadeMode_e  eFadeMode_valid;
N    uint64_t* pu64Curr = (uint64_t*) pstCmdList->pu64Current;
N
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        /* Raster option requires disabled Fading Opt. 
N         * If it is enabled Fade mode will be  assuemed as disbaled */
N        eFadeMode_valid = BLT_NOFADING;
N    }
N    else
N    {
N        eFadeMode_valid = pstParam->eFadeMode;
N    }
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW ;
S    
S    u32NeededDW = u8Curr;
S    if(pstParam->eRastOpEn == GA_EN)
S    {
S        u32NeededDW++; /* for raster value */
S    }
S    else
S    {
S        if(eFadeMode_valid != BLT_NOFADING)
S        {
S            u32NeededDW++;  /* for fade factor*/
S        }
S    }
S    u32NeededDW++; /* for command itself */
S
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif 
N
N    /* Destination Memory Params */
N    pu64Curr[0] = BLT_LOAD_DESTADDR(pstMem->u32DstAddr);
X    pu64Curr[0] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((4)) & (0x1fu)) << (32)) | (((uint64_t)(((pstMem->u32DstAddr))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[1] = BLT_LOAD_DESTWIDTH(pstMem->u16DstWidth);
X    pu64Curr[1] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((5)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DstWidth) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Blitting Area Size */
N    pu64Curr[2] = BLT_LOAD_DESTDOTCNT(pstMem->u16DotCnt);
X    pu64Curr[2] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((6)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16DotCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N    pu64Curr[3] = BLT_LOAD_DESTLINECNT(pstMem->u16LineCnt);
X    pu64Curr[3] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((7)) & (0x1fu)) << (32)) | (((uint64_t)((((pstMem->u16LineCnt) & 0xfffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /* Fill Color */
N    pu64Curr[4] = BLT_LOAD_FILLRGBA(pstParam->u32Color);
X    pu64Curr[4] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((17)) & (0x1fu)) << (32)) | (((uint64_t)(((pstParam->u32Color))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N
N    /*** Operation Specific Params ***/
N
N    /* Raster Parameter Setup */
N    if(pstParam->eRastOpEn == GA_EN)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_RASTOP(pstParam->eRastOpMode, pstParam->eRastOpValue);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((21)) & (0x1fu)) << (32)) | (((uint64_t)(((((uint64_t)((pstParam->eRastOpMode)) & (0x7u)) << (16)) | (((uint64_t)((pstParam->eRastOpValue)) & (0xfu)) << (0)))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Fading Factor Setup */
N    if(eFadeMode_valid != BLT_NOFADING)
N    {
N        pu64Curr[u8Curr] = BLT_LOAD_FADEFACT(pstParam->u8FadingFctr);
X        pu64Curr[u8Curr] = ((((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x1u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((20)) & (0x1fu)) << (32)) | (((uint64_t)((((pstParam->u8FadingFctr) & 0xffu))) & (0xffffffffu)) << (0))))) & ((0xffffffffffffull))) << (0))))));
N        u8Curr++;
N    }
N
N    /* Blit Blend. Preset 16-bit RGB  */
N    pu64Curr[u8Curr] = BLT_BPRST_RGBA32(pstParam->eRedChPrtEn,
N                                        pstParam->eGreenChPrtEn,
N                                        pstParam->eBlueChPrtEn,
N                                        pstParam->eAlphaChPrtEn,
N                                        pstParam->eRastOpEn,
N                                        pstParam->eBlndOrder,
N                                        eFadeMode_valid,      /* if eRastOpEn is enabled then this parameter will be disabled */
N                                        pstParam->eClipWndEn);
X    pu64Curr[u8Curr] = (((uint64_t)0x0ull | ((((uint64_t)(((0x1u))) & ((0x7u))) << (60))) | ((((uint64_t)(((1))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x17u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((pstParam->eRedChPrtEn)) & (0x1u)) << (10)) | (((uint64_t)((pstParam->eGreenChPrtEn)) & (0x1u)) << (9)) | (((uint64_t)((pstParam->eBlueChPrtEn)) & (0x1u)) << (8)) | (((uint64_t)((pstParam->eAlphaChPrtEn)) & (0x1u)) << (7)) | (((uint64_t)((pstParam->eRastOpEn)) & (0x1u)) << (6)) | (((uint64_t)(0) & (0x1u)) << (5)) | (((uint64_t)(0) & (0x1u)) << (4)) | (((uint64_t)((pstParam->eBlndOrder)) & (0x1u)) << (3)) | (((uint64_t)((eFadeMode_valid)) & (0x3u)) << (1)) | (((uint64_t)((pstParam->eClipWndEn)) & (0x1u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N    u8Curr++;
N
N    /* Update List Pointer */
N    pstCmdList->pu64Current = &pu64Curr[u8Curr];
N
N    pstCmdList->u32UsedDoubleWords = u8Curr;
N
N}
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: blit.c
N**  $Revision: 1.14 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1858 /17.4  - subscript operator may only be applied to objects 
N** |                        declared as an array type
N** | CONS.  : allow
N** | REASON : to handle array of data by usage of pointer 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1879 /10.3  - 	 cast of complex integer expression with underlying
N** |                           type "type" to same width type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as macros in io header file
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1878 /10.3  -   cast of complex integer expression with underlying 
N** |                          type "type" to wider type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as variables in io 
N** |          header file or to allow shift operation
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
