; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\smc.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\smc.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\smc.crf ..\..\..\..\lldd\src\smc.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vSMC_GetVersion PROC
;;;77     
;;;78     void vSMC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
000000  e92d4070          PUSH     {r4-r6,lr}
;;;79                          uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
;;;80                          uint8_t** pau8IORevision, uint8_t** pau8IOTag)
;;;81     {
000004  e1cd41d0          LDRD     r4,r5,[sp,#0x10]
;;;82        *pau8ModuleRevision = &au8LLDD_SMC_C_REVISION[0];
000008  e59f6df8          LDR      r6,|L1.3592|
00000c  e5806000          STR      r6,[r0,#0]
;;;83        *pau8ModuleTag      = &au8LLDD_SMC_C_TAG[0];
000010  e59f6df4          LDR      r6,|L1.3596|
000014  e5816000          STR      r6,[r1,#0]
;;;84        *pau8HeaderRevision = &au8LLDD_SMC_H_REVISION[0];
000018  e59f6df0          LDR      r6,|L1.3600|
00001c  e5826000          STR      r6,[r2,#0]
;;;85        *pau8HeaderTag      = &au8LLDD_SMC_H_TAG[0];
000020  e59f6dec          LDR      r6,|L1.3604|
000024  e5836000          STR      r6,[r3,#0]
;;;86        *pau8IORevision     = &au8LLDD_SMC_IO_H_REVISION[0];
000028  e59f6de8          LDR      r6,|L1.3608|
00002c  e5846000          STR      r6,[r4,#0]
;;;87        *pau8IOTag          = &au8LLDD_SMC_IO_H_TAG[0];
000030  e59f6de4          LDR      r6,|L1.3612|
000034  e5856000          STR      r6,[r5,#0]
;;;88     }
000038  e8bd8070          POP      {r4-r6,pc}
;;;89     
                          ENDP

                  boSMC_SetPrescaler PROC
;;;91     
;;;92     bool_t boSMC_SetPrescaler(uint8_t u8Value)
00003c  e1a01000          MOV      r1,r0
;;;93     {
;;;94         bool_t boRes = C_TRUE;
000040  e3a00001          MOV      r0,#1
;;;95         if ( (u8Value >= ((uint8_t)SMC_SCLFAK_MIN)) && (u8Value <= ((uint8_t)SMC_SCLFAK_MAX)) )
000044  e3510001          CMP      r1,#1
000048  ba000007          BLT      |L1.108|
00004c  e351000a          CMP      r1,#0xa
000050  ca000005          BGT      |L1.108|
;;;96         {
;;;97             vSetSMCCLK_CTRL_PRE_SCALE(u8Value);
000054  e59f2dc4          LDR      r2,|L1.3616|
000058  e5d22000          LDRB     r2,[r2,#0]
00005c  e7c32011          BFI      r2,r1,#0,#4
000060  e59f3db8          LDR      r3,|L1.3616|
000064  e5c32000          STRB     r2,[r3,#0]
000068  ea000000          B        |L1.112|
                  |L1.108|
;;;98         }
;;;99         else
;;;100        {
;;;101            boRes = C_FALSE;
00006c  e3a00000          MOV      r0,#0
                  |L1.112|
;;;102        }
;;;103        return boRes;
;;;104    }
000070  e12fff1e          BX       lr
;;;105    
                          ENDP

                  u8SMC_GetPrescaler PROC
;;;107    
;;;108    uint8_t u8SMC_GetPrescaler(void)
000074  e59f0da4          LDR      r0,|L1.3616|
;;;109    {
;;;110       return biGetSMCCLK_CTRL_PRE_SCALE();
000078  e5d00000          LDRB     r0,[r0,#0]
00007c  e200000f          AND      r0,r0,#0xf
;;;111    }
000080  e12fff1e          BX       lr
;;;112    
                          ENDP

                  eSMC_GetIntConfigReg PROC
;;;114    
;;;115    smc_enable_e eSMC_GetIntConfigReg(void)
000084  e59f1d94          LDR      r1,|L1.3616|
;;;116    {
;;;117        smc_enable_e eResult;
;;;118        
;;;119        eResult = ( 0x01U == biGetSMCINT_CRAUM() ) ? SMC_ENABLE : SMC_DISABLE;
000088  e5911004          LDR      r1,[r1,#4]
00008c  e7e00c51          UBFX     r0,r1,#24,#1
;;;120        
;;;121        return eResult;
;;;122    }
000090  e12fff1e          BX       lr
;;;123    
                          ENDP

                  boSMC_GetIntSingle PROC
;;;125    
;;;126    bool_t boSMC_GetIntSingle(smc_dev_e eDevice, smc_motint_types_e eIntMask, smc_enable_e* peEnable)
000094  e92d4030          PUSH     {r4,r5,lr}
;;;127    {
000098  e1a03000          MOV      r3,r0
00009c  e1a04001          MOV      r4,r1
;;;128        bool_t  boResult = C_TRUE;
0000a0  e3a00001          MOV      r0,#1
;;;129        uint8_t u8Value;
;;;130       
;;;131        if (( C_NULL != peEnable) && (eDevice <= SMC4) )
0000a4  e3520000          CMP      r2,#0
0000a8  0a00001b          BEQ      |L1.284|
0000ac  e3530004          CMP      r3,#4
0000b0  ca000019          BGT      |L1.284|
;;;132        {
;;;133            switch(eIntMask)
0000b4  e3540000          CMP      r4,#0
0000b8  0a000004          BEQ      |L1.208|
0000bc  e3540001          CMP      r4,#1
0000c0  0a000007          BEQ      |L1.228|
0000c4  e3540002          CMP      r4,#2
0000c8  1a00000f          BNE      |L1.268|
0000cc  ea000009          B        |L1.248|
                  |L1.208|
;;;134            {
;;;135                case SMC_INT_PPE:
0000d0  e320f000          NOP      
;;;136                    {
;;;137                        u8Value = (uint8_t) biGetSMCINT_PPE();
0000d4  e59f5d44          LDR      r5,|L1.3616|
0000d8  e5955004          LDR      r5,[r5,#4]
0000dc  e205101f          AND      r1,r5,#0x1f
;;;138                    }
;;;139                    break;
0000e0  ea00000c          B        |L1.280|
                  |L1.228|
;;;140                case SMC_INT_MOW_END:
0000e4  e320f000          NOP      
;;;141                    {
;;;142                        u8Value = (uint8_t) biGetSMCINT_MOV_END(); 
0000e8  e59f5d30          LDR      r5,|L1.3616|
0000ec  e5955004          LDR      r5,[r5,#4]
0000f0  e7e41455          UBFX     r1,r5,#8,#5
;;;143                    }
;;;144                    break;
0000f4  ea000007          B        |L1.280|
                  |L1.248|
;;;145                case SMC_INT_ZPD:
0000f8  e320f000          NOP      
;;;146                    {
;;;147                        u8Value = (uint8_t) biGetSMCINT_ZPDD();
0000fc  e59f5d1c          LDR      r5,|L1.3616|
000100  e5955004          LDR      r5,[r5,#4]
000104  e7e41855          UBFX     r1,r5,#16,#5
;;;148                    }
;;;149                    break;
000108  ea000002          B        |L1.280|
                  |L1.268|
;;;150                default:
00010c  e320f000          NOP      
;;;151                    {
;;;152                        boResult = C_FALSE;
000110  e3a00000          MOV      r0,#0
;;;153                    }
;;;154    		            break;
000114  e320f000          NOP      
                  |L1.280|
000118  e320f000          NOP                            ;139
                  |L1.284|
;;;155            }
;;;156       }
;;;157    
;;;158       if (C_TRUE == boResult)
00011c  e3500001          CMP      r0,#1
000120  1a000007          BNE      |L1.324|
;;;159       {
;;;160           *peEnable = ( (0x01U<<eDevice)& u8Value) ? SMC_ENABLE : SMC_DISABLE;
000124  e3a05001          MOV      r5,#1
000128  e0015315          AND      r5,r1,r5,LSL r3
00012c  e3550000          CMP      r5,#0
000130  0a000001          BEQ      |L1.316|
000134  e3a05001          MOV      r5,#1
000138  ea000000          B        |L1.320|
                  |L1.316|
00013c  e3a05000          MOV      r5,#0
                  |L1.320|
000140  e5c25000          STRB     r5,[r2,#0]
                  |L1.324|
;;;161       }
;;;162       return boResult;
;;;163    }
000144  e8bd8030          POP      {r4,r5,pc}
;;;164    
                          ENDP

                  u32SMC_GetIntAll PROC
;;;166    
;;;167    uint32_t u32SMC_GetIntAll(void)
000148  e59f0cd0          LDR      r0,|L1.3616|
;;;168    {
;;;169        return u32GetSMCINT();
00014c  e5900004          LDR      r0,[r0,#4]
;;;170    }
000150  e12fff1e          BX       lr
;;;171    
                          ENDP

                  vSMC_ClearIntConfigReg PROC
;;;172    /****************************************************************************/
;;;173    void vSMC_ClearIntConfigReg(void)
000154  e59f0cc4          LDR      r0,|L1.3616|
;;;174    {
;;;175        vClrSMCINT_CRAUM();
000158  e5900004          LDR      r0,[r0,#4]
00015c  e3c00401          BIC      r0,r0,#0x1000000
000160  e2800401          ADD      r0,r0,#0x1000000
000164  e59f1cb4          LDR      r1,|L1.3616|
000168  e5810004          STR      r0,[r1,#4]
;;;176    }
00016c  e12fff1e          BX       lr
;;;177    
                          ENDP

                  boSMC_ClearIntSingle PROC
;;;178    /****************************************************************************/
;;;179    bool_t boSMC_ClearIntSingle(smc_dev_e eDevice, smc_motint_types_e eIntType)
000170  e92d4010          PUSH     {r4,lr}
;;;180    {
000174  e1a02000          MOV      r2,r0
;;;181        bool_t  boResult = C_TRUE;
000178  e3a00001          MOV      r0,#1
;;;182        
;;;183        if (eDevice <= SMC4)
00017c  e3520004          CMP      r2,#4
000180  ca000025          BGT      |L1.540|
;;;184        {
;;;185            switch(eIntType)
000184  e3510000          CMP      r1,#0
000188  0a000004          BEQ      |L1.416|
00018c  e3510001          CMP      r1,#1
000190  0a00000b          BEQ      |L1.452|
000194  e3510002          CMP      r1,#2
000198  1a00001b          BNE      |L1.524|
00019c  ea000011          B        |L1.488|
                  |L1.416|
;;;186            {
;;;187                case SMC_INT_PPE:
0001a0  e320f000          NOP      
;;;188                    vClrSMCINT_PPE((uint8_t)eDevice);
0001a4  e3a03001          MOV      r3,#1
0001a8  e1a03213          LSL      r3,r3,r2
0001ac  e59f4c6c          LDR      r4,|L1.3616|
0001b0  e5944004          LDR      r4,[r4,#4]
0001b4  e7c44013          BFI      r4,r3,#0,#5
0001b8  e59f3c60          LDR      r3,|L1.3616|
0001bc  e5834004          STR      r4,[r3,#4]
;;;189                    break;
0001c0  ea000014          B        |L1.536|
                  |L1.452|
;;;190    
;;;191                case SMC_INT_MOW_END:
0001c4  e320f000          NOP      
;;;192                    vClrSMCINT_MOV_END((uint8_t)eDevice);
0001c8  e3a03001          MOV      r3,#1
0001cc  e1a03213          LSL      r3,r3,r2
0001d0  e59f4c48          LDR      r4,|L1.3616|
0001d4  e5944004          LDR      r4,[r4,#4]
0001d8  e7cc4413          BFI      r4,r3,#8,#5
0001dc  e59f3c3c          LDR      r3,|L1.3616|
0001e0  e5834004          STR      r4,[r3,#4]
;;;193                    break;
0001e4  ea00000b          B        |L1.536|
                  |L1.488|
;;;194    
;;;195                case SMC_INT_ZPD:
0001e8  e320f000          NOP      
;;;196                    vClrSMCINT_ZPDD((uint8_t)eDevice);
0001ec  e3a03001          MOV      r3,#1
0001f0  e1a03213          LSL      r3,r3,r2
0001f4  e59f4c24          LDR      r4,|L1.3616|
0001f8  e5944004          LDR      r4,[r4,#4]
0001fc  e7d44813          BFI      r4,r3,#16,#5
000200  e59f3c18          LDR      r3,|L1.3616|
000204  e5834004          STR      r4,[r3,#4]
;;;197                    break;
000208  ea000002          B        |L1.536|
                  |L1.524|
;;;198    
;;;199                default:
00020c  e320f000          NOP      
;;;200                    boResult = C_FALSE;
000210  e3a00000          MOV      r0,#0
;;;201    		            break;
000214  e320f000          NOP      
                  |L1.536|
000218  ea000000          B        |L1.544|
                  |L1.540|
;;;202            }
;;;203        }
;;;204        else
;;;205        {
;;;206            boResult = C_FALSE;
00021c  e3a00000          MOV      r0,#0
                  |L1.544|
;;;207        }
;;;208         return boResult;
;;;209    }
000220  e8bd8010          POP      {r4,pc}
;;;210     
                          ENDP

                  vSMC_ClearIntAll PROC
;;;212     
;;;213    void vSMC_ClearIntAll(uint32_t u32Value)
000224  e59f1bf4          LDR      r1,|L1.3616|
;;;214    {
;;;215        vSetSMCINT(u32Value);
000228  e5810004          STR      r0,[r1,#4]
;;;216    }
00022c  e12fff1e          BX       lr
;;;217    
                          ENDP

                  vSetIntConfReg PROC
;;;218    /****************************************************************************/
;;;219    void vSetIntConfReg(smc_enable_e eEnable)
000230  e59f1be8          LDR      r1,|L1.3616|
;;;220    {
;;;221        vSetSMCINT_MASK_MASK_CRAUM((uint32_t)eEnable);
000234  e5911008          LDR      r1,[r1,#8]
000238  e7d81c10          BFI      r1,r0,#24,#1
00023c  e59f2bdc          LDR      r2,|L1.3616|
000240  e5821008          STR      r1,[r2,#8]
;;;222    }
000244  e12fff1e          BX       lr
;;;223    
                          ENDP

                  boSMC_SetIntMaskSingle PROC
;;;225    
;;;226    bool_t boSMC_SetIntMaskSingle(smc_dev_e eDevice, smc_motint_types_e eIntType, smc_enable_e eEnable)
000248  e92d4070          PUSH     {r4-r6,lr}
;;;227    {
00024c  e1a03000          MOV      r3,r0
000250  e1a04001          MOV      r4,r1
;;;228        bool_t boRes = C_TRUE;
000254  e3a00001          MOV      r0,#1
;;;229        uint32_t u32Mask;
;;;230        if (eDevice <= SMC4 )
000258  e3530004          CMP      r3,#4
00025c  ca00003d          BGT      |L1.856|
;;;231        {
;;;232            switch(eIntType)
000260  e3540000          CMP      r4,#0
000264  0a000004          BEQ      |L1.636|
000268  e3540001          CMP      r4,#1
00026c  0a000013          BEQ      |L1.704|
000270  e3540002          CMP      r4,#2
000274  1a000033          BNE      |L1.840|
000278  ea000021          B        |L1.772|
                  |L1.636|
;;;233            {
;;;234                case SMC_INT_PPE:
00027c  e320f000          NOP      
;;;235                    /* read bit fields: */
;;;236                    u32Mask = (uint32_t)biGetSMCINT_MASK_MASK_PPE();
000280  e59f5b98          LDR      r5,|L1.3616|
000284  e5955008          LDR      r5,[r5,#8]
000288  e205101f          AND      r1,r5,#0x1f
;;;237                    if (SMC_ENABLE == eEnable)
00028c  e3520001          CMP      r2,#1
000290  1a000002          BNE      |L1.672|
;;;238                    {
;;;239                        /* set related bit: */
;;;240                        u32Mask |= ((uint32_t)0x01U << (uint8_t)eDevice);
000294  e3a05001          MOV      r5,#1
000298  e1811315          ORR      r1,r1,r5,LSL r3
00029c  ea000001          B        |L1.680|
                  |L1.672|
;;;241                    }
;;;242                    else
;;;243                    {
;;;244                        /* reset related bit: */
;;;245                        u32Mask &= (~((uint32_t)0x01U << (uint8_t)eDevice));
0002a0  e3a05001          MOV      r5,#1
0002a4  e1c11315          BIC      r1,r1,r5,LSL r3
                  |L1.680|
;;;246                    }
;;;247                    /* write back bit fields: */
;;;248                    vSetSMCINT_MASK_MASK_PPE(u32Mask);
0002a8  e59f5b70          LDR      r5,|L1.3616|
0002ac  e5955008          LDR      r5,[r5,#8]
0002b0  e7c45011          BFI      r5,r1,#0,#5
0002b4  e59f6b64          LDR      r6,|L1.3616|
0002b8  e5865008          STR      r5,[r6,#8]
;;;249                    break;
0002bc  ea000024          B        |L1.852|
                  |L1.704|
;;;250                    
;;;251                case SMC_INT_MOW_END:
0002c0  e320f000          NOP      
;;;252                    u32Mask = biGetSMCINT_MASK_MASK_MOV_END();
0002c4  e59f5b54          LDR      r5,|L1.3616|
0002c8  e5955008          LDR      r5,[r5,#8]
0002cc  e7e41455          UBFX     r1,r5,#8,#5
;;;253                    if (SMC_ENABLE == eEnable)
0002d0  e3520001          CMP      r2,#1
0002d4  1a000002          BNE      |L1.740|
;;;254                    {
;;;255                        /* set related bit: */
;;;256                        u32Mask |= ((uint32_t)0x01U << (uint8_t)eDevice);
0002d8  e3a05001          MOV      r5,#1
0002dc  e1811315          ORR      r1,r1,r5,LSL r3
0002e0  ea000001          B        |L1.748|
                  |L1.740|
;;;257                    }
;;;258                    else
;;;259                    {
;;;260                        /* reset related bit: */
;;;261                        u32Mask &= (~((uint32_t)0x01U << (uint8_t)eDevice));
0002e4  e3a05001          MOV      r5,#1
0002e8  e1c11315          BIC      r1,r1,r5,LSL r3
                  |L1.748|
;;;262                    }
;;;263                    vSetSMCINT_MASK_MASK_MOV_END(u32Mask);
0002ec  e59f5b2c          LDR      r5,|L1.3616|
0002f0  e5955008          LDR      r5,[r5,#8]
0002f4  e7cc5411          BFI      r5,r1,#8,#5
0002f8  e59f6b20          LDR      r6,|L1.3616|
0002fc  e5865008          STR      r5,[r6,#8]
;;;264                    break;
000300  ea000013          B        |L1.852|
                  |L1.772|
;;;265                    
;;;266                case SMC_INT_ZPD:
000304  e320f000          NOP      
;;;267                    u32Mask = biGetSMCINT_MASK_MASK_ZPDD();
000308  e59f5b10          LDR      r5,|L1.3616|
00030c  e5955008          LDR      r5,[r5,#8]
000310  e7e41855          UBFX     r1,r5,#16,#5
;;;268                    if (SMC_ENABLE == eEnable)
000314  e3520001          CMP      r2,#1
000318  1a000002          BNE      |L1.808|
;;;269                    {
;;;270                        /* set related bit: */
;;;271                        u32Mask |= ((uint32_t)0x01U << (uint8_t)eDevice);
00031c  e3a05001          MOV      r5,#1
000320  e1811315          ORR      r1,r1,r5,LSL r3
000324  ea000001          B        |L1.816|
                  |L1.808|
;;;272                    }
;;;273                    else
;;;274                    {
;;;275                        /* reset related bit: */
;;;276                        u32Mask &= (~((uint32_t)0x01U << (uint8_t)eDevice));
000328  e3a05001          MOV      r5,#1
00032c  e1c11315          BIC      r1,r1,r5,LSL r3
                  |L1.816|
;;;277                    }
;;;278                   vSetSMCINT_MASK_MASK_ZPDD(u32Mask);
000330  e59f5ae8          LDR      r5,|L1.3616|
000334  e5955008          LDR      r5,[r5,#8]
000338  e7d45811          BFI      r5,r1,#16,#5
00033c  e59f6adc          LDR      r6,|L1.3616|
000340  e5865008          STR      r5,[r6,#8]
;;;279                    break;
000344  ea000002          B        |L1.852|
                  |L1.840|
;;;280    
;;;281                default:
000348  e320f000          NOP      
;;;282                    boRes = C_FALSE;
00034c  e3a00000          MOV      r0,#0
;;;283    		            break;
000350  e320f000          NOP      
                  |L1.852|
000354  ea000000          B        |L1.860|
                  |L1.856|
;;;284            }
;;;285        }
;;;286        else
;;;287        {
;;;288            boRes = C_FALSE;
000358  e3a00000          MOV      r0,#0
                  |L1.860|
;;;289        }
;;;290    
;;;291    
;;;292        return boRes;
;;;293    }
00035c  e8bd8070          POP      {r4-r6,pc}
;;;294    
                          ENDP

                  vSMC_SetIntMaskAll PROC
;;;296    
;;;297    void vSMC_SetIntMaskAll(uint32_t u32Mask)
000360  e59f1ab8          LDR      r1,|L1.3616|
;;;298    {
;;;299       vSetSMCINT_MASK(u32Mask);
000364  e5810008          STR      r0,[r1,#8]
;;;300    }
000368  e12fff1e          BX       lr
;;;301    
                          ENDP

                  u32SMC_GetIntMaskAll PROC
;;;303    
;;;304    uint32_t u32SMC_GetIntMaskAll(void)
00036c  e59f0aac          LDR      r0,|L1.3616|
;;;305    {
;;;306        return u32GetSMCINT_MASK();
000370  e5900008          LDR      r0,[r0,#8]
;;;307    }
000374  e12fff1e          BX       lr
;;;308    
                          ENDP

                  eSMC_GetChannelMode PROC
;;;310    
;;;311    smc_channel_mode_e eSMC_GetChannelMode(smc_dev_e eDevice)
000378  e1a01000          MOV      r1,r0
;;;312    {
;;;313       return (smc_channel_mode_e)biGetSMCCTRL_MSEL(eDevice);
00037c  e1a00101          LSL      r0,r1,#2
000380  e280020d          ADD      r0,r0,#0xd0000000
000384  e24006fd          SUB      r0,r0,#0xfd00000
000388  e590000c          LDR      r0,[r0,#0xc]
00038c  e2000003          AND      r0,r0,#3
;;;314    }
000390  e12fff1e          BX       lr
;;;315    
                          ENDP

                  vSMC_SetChannelMode PROC
;;;317    
;;;318    void vSMC_SetChannelMode(smc_dev_e eDevice, smc_channel_mode_e eMode)
000394  e1a02100          LSL      r2,r0,#2
;;;319    {
;;;320       vSetSMCCTRL_MSEL(eDevice, (uint32_t)eMode);
000398  e282220d          ADD      r2,r2,#0xd0000000
00039c  e24226fd          SUB      r2,r2,#0xfd00000
0003a0  e592200c          LDR      r2,[r2,#0xc]
0003a4  e7c12011          BFI      r2,r1,#0,#2
0003a8  e1a03100          LSL      r3,r0,#2
0003ac  e283320d          ADD      r3,r3,#0xd0000000
0003b0  e24336fd          SUB      r3,r3,#0xfd00000
0003b4  e583200c          STR      r2,[r3,#0xc]
;;;321    }
0003b8  e12fff1e          BX       lr
;;;322    
                          ENDP

                  eSMC_GetPinStatus PROC
;;;324    
;;;325    smc_enable_e eSMC_GetPinStatus(smc_dev_e eDevice)
0003bc  e1a01000          MOV      r1,r0
;;;326    {
;;;327       return (smc_enable_e)biGetSMCCTRL_OUTEN(eDevice);
0003c0  e1a00101          LSL      r0,r1,#2
0003c4  e280020d          ADD      r0,r0,#0xd0000000
0003c8  e24006fd          SUB      r0,r0,#0xfd00000
0003cc  e590000c          LDR      r0,[r0,#0xc]
0003d0  e7e00150          UBFX     r0,r0,#2,#1
;;;328    }
0003d4  e12fff1e          BX       lr
;;;329    
                          ENDP

                  vSMC_SetPinStatus PROC
;;;331    
;;;332    void vSMC_SetPinStatus(smc_dev_e eDevice, smc_enable_e eEnable)
0003d8  e1a02100          LSL      r2,r0,#2
;;;333    {
;;;334       vSetSMCCTRL_OUTEN(eDevice, (uint32_t)eEnable);
0003dc  e282220d          ADD      r2,r2,#0xd0000000
0003e0  e24226fd          SUB      r2,r2,#0xfd00000
0003e4  e592200c          LDR      r2,[r2,#0xc]
0003e8  e7c22111          BFI      r2,r1,#2,#1
0003ec  e1a03100          LSL      r3,r0,#2
0003f0  e283320d          ADD      r3,r3,#0xd0000000
0003f4  e24336fd          SUB      r3,r3,#0xfd00000
0003f8  e583200c          STR      r2,[r3,#0xc]
;;;335    }
0003fc  e12fff1e          BX       lr
;;;336    
                          ENDP

                  u8SMC_GetOutputDelayCycleCount PROC
;;;338    
;;;339    uint8_t u8SMC_GetOutputDelayCycleCount(smc_dev_e eDevice)
000400  e1a01000          MOV      r1,r0
;;;340    {
;;;341       return ((uint8_t)biGetSMCCTRL_DELAY_CYCLES(eDevice));
000404  e1a00101          LSL      r0,r1,#2
000408  e280020d          ADD      r0,r0,#0xd0000000
00040c  e24006fd          SUB      r0,r0,#0xfd00000
000410  e590000c          LDR      r0,[r0,#0xc]
000414  e7e401d0          UBFX     r0,r0,#3,#5
;;;342    }
000418  e12fff1e          BX       lr
;;;343    
                          ENDP

                  vSMC_SetOutputDelayCycleCount PROC
;;;345    
;;;346    void vSMC_SetOutputDelayCycleCount(smc_dev_e eDevice, uint8_t u8Value)
00041c  e1a02100          LSL      r2,r0,#2
;;;347    {
;;;348       vSetSMCCTRL_DELAY_CYCLES(eDevice, u8Value);
000420  e282220d          ADD      r2,r2,#0xd0000000
000424  e24226fd          SUB      r2,r2,#0xfd00000
000428  e592200c          LDR      r2,[r2,#0xc]
00042c  e7c72191          BFI      r2,r1,#3,#5
000430  e1a03100          LSL      r3,r0,#2
000434  e283320d          ADD      r3,r3,#0xd0000000
000438  e24336fd          SUB      r3,r3,#0xfd00000
00043c  e583200c          STR      r2,[r3,#0xc]
;;;349    }
000440  e12fff1e          BX       lr
;;;350    
                          ENDP

                  u8SMC_GetPeriodExtension PROC
;;;352    
;;;353    uint8_t u8SMC_GetPeriodExtension(smc_dev_e eDevice)
000444  e1a01000          MOV      r1,r0
;;;354    {
;;;355       return ((uint8_t)biGetSMCCTRL_PERIOD_EXT(eDevice));
000448  e1a00101          LSL      r0,r1,#2
00044c  e280020d          ADD      r0,r0,#0xd0000000
000450  e24006fd          SUB      r0,r0,#0xfd00000
000454  e590000c          LDR      r0,[r0,#0xc]
000458  e7e60450          UBFX     r0,r0,#8,#7
;;;356    }
00045c  e12fff1e          BX       lr
;;;357    
                          ENDP

                  vSMC_SetPeriodExtension PROC
;;;359    
;;;360    void vSMC_SetPeriodExtension(smc_dev_e eDevice, uint8_t u8Value)
000460  e1a02100          LSL      r2,r0,#2
;;;361    {
;;;362       vSetSMCCTRL_PERIOD_EXT(eDevice, u8Value);
000464  e282220d          ADD      r2,r2,#0xd0000000
000468  e24226fd          SUB      r2,r2,#0xfd00000
00046c  e592200c          LDR      r2,[r2,#0xc]
000470  e7ce2411          BFI      r2,r1,#8,#7
000474  e1a03100          LSL      r3,r0,#2
000478  e283320d          ADD      r3,r3,#0xd0000000
00047c  e24336fd          SUB      r3,r3,#0xfd00000
000480  e583200c          STR      r2,[r3,#0xc]
;;;363    }
000484  e12fff1e          BX       lr
;;;364    
                          ENDP

                  u8SMC_GetSlewRate PROC
;;;366    
;;;367    uint8_t u8SMC_GetSlewRate(smc_dev_e eDevice)
000488  e1a01000          MOV      r1,r0
;;;368    {
;;;369       return ((uint8_t)biGetSMCCTRL_SLEW_RATE(eDevice));
00048c  e1a00101          LSL      r0,r1,#2
000490  e280020d          ADD      r0,r0,#0xd0000000
000494  e24006fd          SUB      r0,r0,#0xfd00000
000498  e590000c          LDR      r0,[r0,#0xc]
00049c  e7e20850          UBFX     r0,r0,#16,#3
;;;370    }
0004a0  e12fff1e          BX       lr
;;;371    
                          ENDP

                  vSMC_SetSlewRate PROC
;;;373    
;;;374    void vSMC_SetSlewRate(smc_dev_e eDevice, uint8_t u8Value)
0004a4  e1a02100          LSL      r2,r0,#2
;;;375    {
;;;376       vSetSMCCTRL_SLEW_RATE(eDevice, u8Value);
0004a8  e282220d          ADD      r2,r2,#0xd0000000
0004ac  e24226fd          SUB      r2,r2,#0xfd00000
0004b0  e592200c          LDR      r2,[r2,#0xc]
0004b4  e7d22811          BFI      r2,r1,#16,#3
0004b8  e1a03100          LSL      r3,r0,#2
0004bc  e283320d          ADD      r3,r3,#0xd0000000
0004c0  e24336fd          SUB      r3,r3,#0xfd00000
0004c4  e583200c          STR      r2,[r3,#0xc]
;;;377    }
0004c8  e12fff1e          BX       lr
;;;378    
                          ENDP

                  u8SMC_GetISMDampingFactorK PROC
;;;380    
;;;381    uint8_t u8SMC_GetISMDampingFactorK(smc_dev_e eDevice)
0004cc  e1a01000          MOV      r1,r0
;;;382    {
;;;383       return ((uint8_t)biGetSMCISM_CTRL_DAMP_K(eDevice));
0004d0  e1a00101          LSL      r0,r1,#2
0004d4  e280020d          ADD      r0,r0,#0xd0000000
0004d8  e24006fd          SUB      r0,r0,#0xfd00000
0004dc  e5900020          LDR      r0,[r0,#0x20]
0004e0  e2000007          AND      r0,r0,#7
;;;384    }
0004e4  e12fff1e          BX       lr
;;;385    
                          ENDP

                  vSMC_SetISMDampingFactorK PROC
;;;387    
;;;388    void vSMC_SetISMDampingFactorK(smc_dev_e eDevice, uint8_t u8Value)
0004e8  e1a02100          LSL      r2,r0,#2
;;;389    {
;;;390       vSetSMCISM_CTRL_DAMP_K(eDevice, u8Value);
0004ec  e282220d          ADD      r2,r2,#0xd0000000
0004f0  e24226fd          SUB      r2,r2,#0xfd00000
0004f4  e5922020          LDR      r2,[r2,#0x20]
0004f8  e7c22011          BFI      r2,r1,#0,#3
0004fc  e1a03100          LSL      r3,r0,#2
000500  e283320d          ADD      r3,r3,#0xd0000000
000504  e24336fd          SUB      r3,r3,#0xfd00000
000508  e5832020          STR      r2,[r3,#0x20]
;;;391    }
00050c  e12fff1e          BX       lr
;;;392    
                          ENDP

                  u8SMC_GetISMDampingFactorL PROC
;;;394    
;;;395    uint8_t u8SMC_GetISMDampingFactorL(smc_dev_e eDevice)
000510  e1a01000          MOV      r1,r0
;;;396    {
;;;397       return ((uint8_t)biGetSMCISM_CTRL_DAMP_L(eDevice));
000514  e1a00101          LSL      r0,r1,#2
000518  e280020d          ADD      r0,r0,#0xd0000000
00051c  e24006fd          SUB      r0,r0,#0xfd00000
000520  e5900020          LDR      r0,[r0,#0x20]
000524  e7e20450          UBFX     r0,r0,#8,#3
;;;398    }
000528  e12fff1e          BX       lr
;;;399    
                          ENDP

                  vSMC_SetISMDampingFactorL PROC
;;;401    
;;;402    void vSMC_SetISMDampingFactorL(smc_dev_e eDevice, uint8_t u8Value)
00052c  e1a02100          LSL      r2,r0,#2
;;;403    {
;;;404       vSetSMCISM_CTRL_DAMP_L(eDevice, u8Value);
000530  e282220d          ADD      r2,r2,#0xd0000000
000534  e24226fd          SUB      r2,r2,#0xfd00000
000538  e5922020          LDR      r2,[r2,#0x20]
00053c  e7ca2411          BFI      r2,r1,#8,#3
000540  e1a03100          LSL      r3,r0,#2
000544  e283320d          ADD      r3,r3,#0xd0000000
000548  e24336fd          SUB      r3,r3,#0xfd00000
00054c  e5832020          STR      r2,[r3,#0x20]
;;;405    }
000550  e12fff1e          BX       lr
;;;406    
                          ENDP

                  eSMC_GetISMTableMode PROC
;;;408    
;;;409    smc_ism_table_mode_e eSMC_GetISMTableMode(smc_dev_e eDevice)
000554  e1a01000          MOV      r1,r0
;;;410    {
;;;411       return (smc_ism_table_mode_e)biGetSMCISM_CTRL_ISM_TABLE_MODE(eDevice);
000558  e1a00101          LSL      r0,r1,#2
00055c  e280020d          ADD      r0,r0,#0xd0000000
000560  e24006fd          SUB      r0,r0,#0xfd00000
000564  e5900020          LDR      r0,[r0,#0x20]
000568  e7e00850          UBFX     r0,r0,#16,#1
;;;412    }
00056c  e12fff1e          BX       lr
;;;413    
                          ENDP

                  vSMC_SetISMTableMode PROC
;;;415    
;;;416    void vSMC_SetISMTableMode(smc_dev_e eDevice, smc_ism_table_mode_e eValue)
000570  e59f28ac          LDR      r2,|L1.3620|
;;;417    {
;;;418       eTableModeVal[eDevice] = eValue;
000574  e7c21000          STRB     r1,[r2,r0]
;;;419       vSetSMCISM_CTRL_ISM_TABLE_MODE(eDevice, (uint32_t)eValue);
000578  e1a02100          LSL      r2,r0,#2
00057c  e282220d          ADD      r2,r2,#0xd0000000
000580  e24226fd          SUB      r2,r2,#0xfd00000
000584  e5922020          LDR      r2,[r2,#0x20]
000588  e7d02811          BFI      r2,r1,#16,#1
00058c  e1a03100          LSL      r3,r0,#2
000590  e283320d          ADD      r3,r3,#0xd0000000
000594  e24336fd          SUB      r3,r3,#0xfd00000
000598  e5832020          STR      r2,[r3,#0x20]
;;;420    }
00059c  e12fff1e          BX       lr
;;;421    
                          ENDP

                  eSMC_GetISMTableIndex PROC
;;;423    
;;;424    smc_table_index_e eSMC_GetISMTableIndex(smc_dev_e eDevice)
0005a0  e1a01000          MOV      r1,r0
;;;425    {
;;;426       return (smc_table_index_e)biGetSMCISM_CTRL_TABLE_IDX(eDevice);
0005a4  e1a00101          LSL      r0,r1,#2
0005a8  e280020d          ADD      r0,r0,#0xd0000000
0005ac  e24006fd          SUB      r0,r0,#0xfd00000
0005b0  e5900020          LDR      r0,[r0,#0x20]
0005b4  e7e008d0          UBFX     r0,r0,#17,#1
;;;427    }
0005b8  e12fff1e          BX       lr
;;;428    
                          ENDP

                  vSMC_SetISMTableIndex PROC
;;;430    
;;;431    void vSMC_SetISMTableIndex(smc_dev_e eDevice, smc_table_index_e eValue)
0005bc  e1a02100          LSL      r2,r0,#2
;;;432    {
;;;433       vSetSMCISM_CTRL_TABLE_IDX(eDevice, (uint32_t)eValue);
0005c0  e282220d          ADD      r2,r2,#0xd0000000
0005c4  e24226fd          SUB      r2,r2,#0xfd00000
0005c8  e5922020          LDR      r2,[r2,#0x20]
0005cc  e7d12891          BFI      r2,r1,#17,#1
0005d0  e1a03100          LSL      r3,r0,#2
0005d4  e283320d          ADD      r3,r3,#0xd0000000
0005d8  e24336fd          SUB      r3,r3,#0xfd00000
0005dc  e5832020          STR      r2,[r3,#0x20]
;;;434    }
0005e0  e12fff1e          BX       lr
;;;435    
                          ENDP

                  eSMC_IsISMDampingCurveHardwareEnabled PROC
;;;437    
;;;438    smc_enable_e eSMC_IsISMDampingCurveHardwareEnabled(smc_dev_e eDevice)
0005e4  e1a01000          MOV      r1,r0
;;;439    {
;;;440       /*return (smc_enable_e)(1-biGetSMCISM_CTRL_DIS_DAMP(eDevice));*/
;;;441       return ( SMC_ENABLE==((smc_enable_e)biGetSMCISM_CTRL_DIS_DAMP(eDevice)) ) ? SMC_DISABLE : SMC_ENABLE;
0005e8  e1a00101          LSL      r0,r1,#2
0005ec  e280020d          ADD      r0,r0,#0xd0000000
0005f0  e24006fd          SUB      r0,r0,#0xfd00000
0005f4  e5900020          LDR      r0,[r0,#0x20]
0005f8  e7e00950          UBFX     r0,r0,#18,#1
0005fc  e2200001          EOR      r0,r0,#1
;;;442    }
000600  e12fff1e          BX       lr
;;;443    
                          ENDP

                  vSMC_EnableISMDampingCurveHardware PROC
;;;445    
;;;446    void vSMC_EnableISMDampingCurveHardware(smc_dev_e eDevice, smc_enable_e eValue)
000604  e3510001          CMP      r1,#1
;;;447    {
;;;448       vSetSMCISM_CTRL_DIS_DAMP(eDevice, ((eValue == SMC_ENABLE)? (uint32_t)SMC_DISABLE : (uint32_t)SMC_ENABLE));
000608  0a000001          BEQ      |L1.1556|
00060c  e3a03001          MOV      r3,#1
000610  ea000000          B        |L1.1560|
                  |L1.1556|
000614  e3a03000          MOV      r3,#0
                  |L1.1560|
000618  e1a02100          LSL      r2,r0,#2
00061c  e282220d          ADD      r2,r2,#0xd0000000
000620  e24226fd          SUB      r2,r2,#0xfd00000
000624  e5922020          LDR      r2,[r2,#0x20]
000628  e7d22913          BFI      r2,r3,#18,#1
00062c  e1a03100          LSL      r3,r0,#2
000630  e283320d          ADD      r3,r3,#0xd0000000
000634  e24336fd          SUB      r3,r3,#0xfd00000
000638  e5832020          STR      r2,[r3,#0x20]
;;;449    }
00063c  e12fff1e          BX       lr
;;;450    
                          ENDP

                  eSMC_GetISMReadRequestStatus PROC
;;;452    
;;;453    smc_enable_e eSMC_GetISMReadRequestStatus(smc_dev_e eDevice)
000640  e1a01000          MOV      r1,r0
;;;454    {
;;;455       return (smc_enable_e)biGetSMCISM_CTRL_RD_REQ(eDevice);
000644  e1a00101          LSL      r0,r1,#2
000648  e280020d          ADD      r0,r0,#0xd0000000
00064c  e24006fd          SUB      r0,r0,#0xfd00000
000650  e5900020          LDR      r0,[r0,#0x20]
000654  e7e00a50          UBFX     r0,r0,#20,#1
;;;456    }
000658  e12fff1e          BX       lr
;;;457    
                          ENDP

                  vSMC_SetISMReadRequest PROC
;;;459    
;;;460    void vSMC_SetISMReadRequest(smc_dev_e eDevice, smc_enable_e eValue)
00065c  e1a02100          LSL      r2,r0,#2
;;;461    {
;;;462       vSetSMCISM_CTRL_RD_REQ(eDevice, (uint32_t)eValue);
000660  e282220d          ADD      r2,r2,#0xd0000000
000664  e24226fd          SUB      r2,r2,#0xfd00000
000668  e5922020          LDR      r2,[r2,#0x20]
00066c  e7d42a11          BFI      r2,r1,#20,#1
000670  e1a03100          LSL      r3,r0,#2
000674  e283320d          ADD      r3,r3,#0xd0000000
000678  e24336fd          SUB      r3,r3,#0xfd00000
00067c  e5832020          STR      r2,[r3,#0x20]
;;;463    }
000680  e12fff1e          BX       lr
;;;464    
                          ENDP

                  eSMC_GetISMReadRequestFlagStatus PROC
;;;466    
;;;467    smc_enable_e eSMC_GetISMReadRequestFlagStatus(smc_dev_e eDevice)
000684  e1a01000          MOV      r1,r0
;;;468    {
;;;469       return (smc_enable_e)biGetSMCISM_CTRL_RD_FLAG(eDevice);
000688  e1a00101          LSL      r0,r1,#2
00068c  e280020d          ADD      r0,r0,#0xd0000000
000690  e24006fd          SUB      r0,r0,#0xfd00000
000694  e5900020          LDR      r0,[r0,#0x20]
000698  e7e00ad0          UBFX     r0,r0,#21,#1
;;;470    }
00069c  e12fff1e          BX       lr
;;;471    
                          ENDP

                  eSMC_GetISMFreezeRequestStatus PROC
;;;473    
;;;474    smc_enable_e eSMC_GetISMFreezeRequestStatus(smc_dev_e eDevice)
0006a0  e1a01000          MOV      r1,r0
;;;475    {
;;;476       return (smc_enable_e)biGetSMCISM_CTRL_FREEZE_REQ(eDevice);
0006a4  e1a00101          LSL      r0,r1,#2
0006a8  e280020d          ADD      r0,r0,#0xd0000000
0006ac  e24006fd          SUB      r0,r0,#0xfd00000
0006b0  e5900020          LDR      r0,[r0,#0x20]
0006b4  e7e00c50          UBFX     r0,r0,#24,#1
;;;477    }
0006b8  e12fff1e          BX       lr
;;;478    
                          ENDP

                  vSMC_SetISMFreezeRequest PROC
;;;480    
;;;481    void vSMC_SetISMFreezeRequest(smc_dev_e eDevice, smc_enable_e eValue)
0006bc  e1a02100          LSL      r2,r0,#2
;;;482    {
;;;483       vSetSMCISM_CTRL_FREEZE_REQ(eDevice, (uint32_t)eValue);
0006c0  e282220d          ADD      r2,r2,#0xd0000000
0006c4  e24226fd          SUB      r2,r2,#0xfd00000
0006c8  e5922020          LDR      r2,[r2,#0x20]
0006cc  e7d82c11          BFI      r2,r1,#24,#1
0006d0  e1a03100          LSL      r3,r0,#2
0006d4  e283320d          ADD      r3,r3,#0xd0000000
0006d8  e24336fd          SUB      r3,r3,#0xfd00000
0006dc  e5832020          STR      r2,[r3,#0x20]
;;;484    }
0006e0  e12fff1e          BX       lr
;;;485    
                          ENDP

                  eSMC_GetISMFreezeRequestFlagStatus PROC
;;;487    
;;;488    smc_enable_e eSMC_GetISMFreezeRequestFlagStatus(smc_dev_e eDevice)
0006e4  e1a01000          MOV      r1,r0
;;;489    {
;;;490       return (smc_enable_e)biGetSMCISM_CTRL_FREEZE_FLAG(eDevice);
0006e8  e1a00101          LSL      r0,r1,#2
0006ec  e280020d          ADD      r0,r0,#0xd0000000
0006f0  e24006fd          SUB      r0,r0,#0xfd00000
0006f4  e5900020          LDR      r0,[r0,#0x20]
0006f8  e7e00cd0          UBFX     r0,r0,#25,#1
;;;491    }
0006fc  e12fff1e          BX       lr
;;;492    
                          ENDP

                  f32RegToFloat PROC
;;;494    
;;;495    static float32_t f32RegToFloat(uint32_t u32Value, float32_t f32DegreePerFullstepLocal, smc_ism_table_mode_e eTableModeLocal)
000700  e92d4ffe          PUSH     {r1-r11,lr}
;;;496    {
000704  e1a04000          MOV      r4,r0
000708  e1a06001          MOV      r6,r1
00070c  e1a07002          MOV      r7,r2
;;;497        float32_t fInteger;
;;;498        float32_t fFraction;
;;;499        float32_t fValue;
;;;500        uint32_t  u32MoveIntegerPart = 13U;
000710  e3a0800d          MOV      r8,#0xd
;;;501        float32_t f32ScaleFractionalPart = (float32_t)8192.0;
000714  e3a09446          MOV      r9,#0x46000000
;;;502        uint32_t  u32IntMask = 0x3FFU;
000718  e300a3ff          MOV      r10,#0x3ff
;;;503        uint32_t  u32FracMask = 0x1FFFU;
00071c  e301bfff          MOV      r11,#0x1fff
;;;504    
;;;505        if (eTableModeLocal == SMC_ISM_TABLE_MODE_PRECISE)
000720  e3570001          CMP      r7,#1
000724  1a000003          BNE      |L1.1848|
;;;506        {
;;;507            u32MoveIntegerPart = 15U;
000728  e3a0800f          MOV      r8,#0xf
;;;508            f32ScaleFractionalPart = (float32_t)32768.0;
00072c  e3a09447          MOV      r9,#0x47000000
;;;509            u32IntMask = 0xFFU;
000730  e3a0a0ff          MOV      r10,#0xff
;;;510            u32FracMask = 0x7FFFU;
000734  e307bfff          MOV      r11,#0x7fff
                  |L1.1848|
;;;511        }
;;;512    
;;;513        fInteger = (float32_t)((u32Value >> u32MoveIntegerPart) & u32IntMask);
000738  e1a01834          LSR      r1,r4,r8
00073c  e001000a          AND      r0,r1,r10
000740  ebfffffe          BL       __aeabi_ui2f
000744  e58d0008          STR      r0,[sp,#8]
;;;514        fFraction = (float32_t)(u32Value & u32FracMask);
000748  e004000b          AND      r0,r4,r11
00074c  ebfffffe          BL       __aeabi_ui2f
000750  e58d0004          STR      r0,[sp,#4]
;;;515        fValue = fInteger + (fFraction/f32ScaleFractionalPart);
000754  e1a01009          MOV      r1,r9
000758  e59d0004          LDR      r0,[sp,#4]
00075c  ebfffffe          BL       __aeabi_fdiv
000760  e58d0000          STR      r0,[sp,#0]
000764  e59d1008          LDR      r1,[sp,#8]
000768  ebfffffe          BL       __aeabi_fadd
00076c  e1a05000          MOV      r5,r0
;;;516        if ((u32Value & 0x01000000U) > 0U)
000770  e2040401          AND      r0,r4,#0x1000000
000774  e3500000          CMP      r0,#0
000778  0a000003          BEQ      |L1.1932|
;;;517        {
;;;518            fValue = (float32_t)(-1.0) * fValue;
00077c  e1a01005          MOV      r1,r5
000780  e59f06a0          LDR      r0,|L1.3624|
000784  ebfffffe          BL       __aeabi_fmul
000788  e1a05000          MOV      r5,r0
                  |L1.1932|
;;;519        }
;;;520    
;;;521        return (f32DegreePerFullstepLocal * fValue);
00078c  e1a01005          MOV      r1,r5
000790  e1a00006          MOV      r0,r6
000794  ebfffffe          BL       __aeabi_fmul
;;;522    }
000798  e8bd8ffe          POP      {r1-r11,pc}
;;;523    
                          ENDP

                  u32SMC_FloatToReg PROC
;;;525    
;;;526    static uint32_t u32SMC_FloatToReg(float32_t f32Value, float32_t f32DegreePerFullstepLocal, smc_ism_table_mode_e eTableModeLocal)
00079c  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;527    {
0007a0  e24dd010          SUB      sp,sp,#0x10
0007a4  e1a05000          MOV      r5,r0
0007a8  e1a06002          MOV      r6,r2
;;;528        uint32_t  u32Sign = 0U;
0007ac  e3a0b000          MOV      r11,#0
;;;529        uint32_t  u32IntegerPart;
;;;530        uint32_t  u32FractionalPart;
;;;531        uint32_t  u32Value;
;;;532        uint32_t  u32MoveIntegerPart = 13U;
0007b0  e3a0000d          MOV      r0,#0xd
0007b4  e58d000c          STR      r0,[sp,#0xc]
;;;533        float32_t f32ScaleFractionalPart = (float32_t)8192.0;
0007b8  e3a00446          MOV      r0,#0x46000000
0007bc  e58d0008          STR      r0,[sp,#8]
;;;534    
;;;535        if (eTableModeLocal == SMC_ISM_TABLE_MODE_PRECISE)
0007c0  e3560001          CMP      r6,#1
0007c4  1a000003          BNE      |L1.2008|
;;;536        {
;;;537            u32MoveIntegerPart = 15U;
0007c8  e3a0000f          MOV      r0,#0xf
0007cc  e58d000c          STR      r0,[sp,#0xc]
;;;538            f32ScaleFractionalPart = (float32_t)32768.0;
0007d0  e3a00447          MOV      r0,#0x47000000
0007d4  e58d0008          STR      r0,[sp,#8]
                  |L1.2008|
;;;539        }
;;;540        if (f32Value < 0.0)
0007d8  e1a00005          MOV      r0,r5
0007dc  ebfffffe          BL       __aeabi_f2d
0007e0  e1a07000          MOV      r7,r0
0007e4  e3a02000          MOV      r2,#0
0007e8  e1a03002          MOV      r3,r2
0007ec  ebfffffe          BL       __aeabi_cdcmple
0007f0  2a000004          BCS      |L1.2056|
;;;541        {
;;;542            u32Sign  = 1U;
0007f4  e3a0b001          MOV      r11,#1
;;;543            f32Value = (float32_t)-1.0 * f32Value;
0007f8  e59f1628          LDR      r1,|L1.3624|
0007fc  e1a00005          MOV      r0,r5
000800  ebfffffe          BL       __aeabi_fmul
000804  e1a05000          MOV      r5,r0
                  |L1.2056|
;;;544        }
;;;545        f32Value          = f32Value / f32DegreePerFullstepLocal;
000808  e1a00005          MOV      r0,r5
00080c  e59d1014          LDR      r1,[sp,#0x14]
000810  ebfffffe          BL       __aeabi_fdiv
000814  e1a05000          MOV      r5,r0
;;;546        u32IntegerPart    = (uint32_t)f32Value;
000818  e1a00005          MOV      r0,r5
00081c  ebfffffe          BL       __aeabi_f2uiz
000820  e1a04000          MOV      r4,r0
;;;547        u32FractionalPart = (uint32_t)(f32ScaleFractionalPart * (f32Value - (float32_t)u32IntegerPart));
000824  e1a00004          MOV      r0,r4
000828  ebfffffe          BL       __aeabi_ui2f
00082c  e1a01005          MOV      r1,r5
000830  e58d0004          STR      r0,[sp,#4]
000834  ebfffffe          BL       __aeabi_frsub
000838  e1a08000          MOV      r8,r0
00083c  e59d1008          LDR      r1,[sp,#8]
000840  ebfffffe          BL       __aeabi_fmul
000844  e1a07000          MOV      r7,r0
000848  ebfffffe          BL       __aeabi_f2uiz
00084c  e1a09000          MOV      r9,r0
;;;548        u32Value          = (u32Sign << 24) + (u32IntegerPart << u32MoveIntegerPart) + u32FractionalPart;
000850  e59d000c          LDR      r0,[sp,#0xc]
000854  e1a00014          LSL      r0,r4,r0
000858  e0800c0b          ADD      r0,r0,r11,LSL #24
00085c  e080a009          ADD      r10,r0,r9
;;;549    
;;;550        return u32Value;
000860  e1a0000a          MOV      r0,r10
000864  e28dd01c          ADD      sp,sp,#0x1c
;;;551    }
000868  e8bd8ff0          POP      {r4-r11,pc}
;;;552    
                          ENDP

                  fSMC_GetISMPosition PROC
;;;554    
;;;555    float32_t fSMC_GetISMPosition(smc_dev_e eDevice)
00086c  e92d47f0          PUSH     {r4-r10,lr}
;;;556    {
000870  e1a04000          MOV      r4,r0
;;;557        float32_t fValue;
;;;558        uint32_t u32Value;
;;;559    
;;;560        u32Value = u32GetSMCPOS_Dest(eDevice);
000874  e1a00104          LSL      r0,r4,#2
000878  e280020d          ADD      r0,r0,#0xd0000000
00087c  e24006fd          SUB      r0,r0,#0xfd00000
000880  e5906034          LDR      r6,[r0,#0x34]
;;;561    
;;;562        fValue = f32RegToFloat((uint32_t)((float32_t)u32Value - f32ISMQuadrantOffset[eDevice]), f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
000884  e1a00006          MOV      r0,r6
000888  ebfffffe          BL       __aeabi_ui2f
00088c  e1a09000          MOV      r9,r0
000890  e59f0594          LDR      r0,|L1.3628|
000894  e7901104          LDR      r1,[r0,r4,LSL #2]
000898  e1a00009          MOV      r0,r9
00089c  ebfffffe          BL       __aeabi_fsub
0008a0  e1a08000          MOV      r8,r0
0008a4  ebfffffe          BL       __aeabi_f2uiz
0008a8  e1a07000          MOV      r7,r0
0008ac  e59f0570          LDR      r0,|L1.3620|
0008b0  e7d02004          LDRB     r2,[r0,r4]
0008b4  e59f0574          LDR      r0,|L1.3632|
0008b8  e7901104          LDR      r1,[r0,r4,LSL #2]
0008bc  e1a00007          MOV      r0,r7
0008c0  ebfffffe          BL       f32RegToFloat
0008c4  e1a05000          MOV      r5,r0
;;;563    
;;;564        return fValue;
0008c8  e1a00005          MOV      r0,r5
;;;565    }
0008cc  e8bd87f0          POP      {r4-r10,pc}
;;;566    
                          ENDP

                  vSMC_SetISMPosition PROC
;;;568    
;;;569    void vSMC_SetISMPosition(smc_dev_e eDevice, float32_t f32Value)
0008d0  e92d41f0          PUSH     {r4-r8,lr}
;;;570    {
0008d4  e1a04000          MOV      r4,r0
0008d8  e1a05001          MOV      r5,r1
;;;571        uint32_t u32Value;
;;;572    
;;;573        u32Value = u32SMC_FloatToReg(f32Value + f32ISMQuadrantOffset[eDevice], f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
0008dc  e59f0548          LDR      r0,|L1.3628|
0008e0  e7901104          LDR      r1,[r0,r4,LSL #2]
0008e4  e1a00005          MOV      r0,r5
0008e8  ebfffffe          BL       __aeabi_fadd
0008ec  e1a07000          MOV      r7,r0
0008f0  e59f052c          LDR      r0,|L1.3620|
0008f4  e7d02004          LDRB     r2,[r0,r4]
0008f8  e59f0530          LDR      r0,|L1.3632|
0008fc  e7901104          LDR      r1,[r0,r4,LSL #2]
000900  e1a00007          MOV      r0,r7
000904  ebfffffe          BL       u32SMC_FloatToReg
000908  e1a06000          MOV      r6,r0
;;;574    
;;;575        vSetSMCPOS_Dest(eDevice, u32Value);
00090c  e1a00104          LSL      r0,r4,#2
000910  e280020d          ADD      r0,r0,#0xd0000000
000914  e24006fd          SUB      r0,r0,#0xfd00000
000918  e5806034          STR      r6,[r0,#0x34]
;;;576    }
00091c  e8bd81f0          POP      {r4-r8,pc}
;;;577    
                          ENDP

                  u16SMC_GetPWMCosDuty PROC
;;;579    
;;;580    uint16_t u16SMC_GetPWMCosDuty(smc_dev_e eDevice)
000920  e1a01000          MOV      r1,r0
;;;581    {
;;;582        return ((uint16_t)biGetSMCPWM_COSDUTY(eDevice));
000924  e1a00101          LSL      r0,r1,#2
000928  e280020d          ADD      r0,r0,#0xd0000000
00092c  e24006fd          SUB      r0,r0,#0xfd00000
000930  e5900048          LDR      r0,[r0,#0x48]
000934  e7df051f          BFC      r0,#10,#22
;;;583    }
000938  e12fff1e          BX       lr
;;;584    
                          ENDP

                  vSMC_SetPWMCosDuty PROC
;;;586    
;;;587    void vSMC_SetPWMCosDuty(smc_dev_e eDevice, uint16_t u16Value)
00093c  e1a02100          LSL      r2,r0,#2
;;;588    {
;;;589        vSetSMCPWM_COSDUTY(eDevice, u16Value);
000940  e282220d          ADD      r2,r2,#0xd0000000
000944  e24226fd          SUB      r2,r2,#0xfd00000
000948  e5922048          LDR      r2,[r2,#0x48]
00094c  e7c92011          BFI      r2,r1,#0,#10
000950  e1a03100          LSL      r3,r0,#2
000954  e283320d          ADD      r3,r3,#0xd0000000
000958  e24336fd          SUB      r3,r3,#0xfd00000
00095c  e5832048          STR      r2,[r3,#0x48]
;;;590    }
000960  e12fff1e          BX       lr
;;;591    
                          ENDP

                  u16SMC_GetPWMSinDuty PROC
;;;593    
;;;594    uint16_t u16SMC_GetPWMSinDuty(smc_dev_e eDevice)
000964  e1a01000          MOV      r1,r0
;;;595    {
;;;596        return ((uint16_t)biGetSMCPWM_SINDUTY(eDevice));
000968  e1a00101          LSL      r0,r1,#2
00096c  e280020d          ADD      r0,r0,#0xd0000000
000970  e24006fd          SUB      r0,r0,#0xfd00000
000974  e5900048          LDR      r0,[r0,#0x48]
000978  e7e90550          UBFX     r0,r0,#10,#10
;;;597    }
00097c  e12fff1e          BX       lr
;;;598    
                          ENDP

                  vSMC_SetPWMSinDuty PROC
;;;600    
;;;601    void vSMC_SetPWMSinDuty(smc_dev_e eDevice, uint16_t u16Value)
000980  e1a02100          LSL      r2,r0,#2
;;;602    {
;;;603        vSetSMCPWM_SINDUTY(eDevice, u16Value);
000984  e282220d          ADD      r2,r2,#0xd0000000
000988  e24226fd          SUB      r2,r2,#0xfd00000
00098c  e5922048          LDR      r2,[r2,#0x48]
000990  e7d32511          BFI      r2,r1,#10,#10
000994  e1a03100          LSL      r3,r0,#2
000998  e283320d          ADD      r3,r3,#0xd0000000
00099c  e24336fd          SUB      r3,r3,#0xfd00000
0009a0  e5832048          STR      r2,[r3,#0x48]
;;;604    }
0009a4  e12fff1e          BX       lr
;;;605    
                          ENDP

                  eSMC_GetPWMQuadrant PROC
;;;607    
;;;608    smc_quadrant_e eSMC_GetPWMQuadrant(smc_dev_e eDevice)
0009a8  e1a01000          MOV      r1,r0
;;;609    {
;;;610        return (smc_quadrant_e)biGetSMCPWM_QUADR(eDevice);
0009ac  e1a00101          LSL      r0,r1,#2
0009b0  e280020d          ADD      r0,r0,#0xd0000000
0009b4  e24006fd          SUB      r0,r0,#0xfd00000
0009b8  e5900048          LDR      r0,[r0,#0x48]
0009bc  e7e10a50          UBFX     r0,r0,#20,#2
;;;611    }
0009c0  e12fff1e          BX       lr
;;;612    
                          ENDP

                  vSMC_SetPWM32BitData PROC
;;;614    
;;;615    void vSMC_SetPWM32BitData(smc_dev_e eDevice, smc_quadrant_e wQuadr, 
0009c4  e92d4030          PUSH     {r4,r5,lr}
;;;616                              uint16_t u16Sin, uint16_t u16Cos)
;;;617    {
;;;618       uint32_t u32Value;
;;;619    
;;;620       u32Value = ((uint32_t) wQuadr << 20) | (u16Sin<<10) | u16Cos;
0009c8  e1a05a01          LSL      r5,r1,#20
0009cc  e1855502          ORR      r5,r5,r2,LSL #10
0009d0  e1854003          ORR      r4,r5,r3
;;;621       vSetSMCPWM(eDevice, u32Value);
0009d4  e1a05100          LSL      r5,r0,#2
0009d8  e285520d          ADD      r5,r5,#0xd0000000
0009dc  e24556fd          SUB      r5,r5,#0xfd00000
0009e0  e5854048          STR      r4,[r5,#0x48]
;;;622    }
0009e4  e8bd8030          POP      {r4,r5,pc}
;;;623    
                          ENDP

                  vSMC_SetPWMQuadrant PROC
;;;625    
;;;626    void vSMC_SetPWMQuadrant(smc_dev_e eDevice, smc_quadrant_e eValue)
0009e8  e1a02100          LSL      r2,r0,#2
;;;627    {
;;;628       vSetSMCPWM_QUADR(eDevice, (uint32_t)eValue);
0009ec  e282220d          ADD      r2,r2,#0xd0000000
0009f0  e24226fd          SUB      r2,r2,#0xfd00000
0009f4  e5922048          LDR      r2,[r2,#0x48]
0009f8  e7d52a11          BFI      r2,r1,#20,#2
0009fc  e1a03100          LSL      r3,r0,#2
000a00  e283320d          ADD      r3,r3,#0xd0000000
000a04  e24336fd          SUB      r3,r3,#0xfd00000
000a08  e5832048          STR      r2,[r3,#0x48]
;;;629    }
000a0c  e12fff1e          BX       lr
;;;630    
                          ENDP

                  u32SMC_GetDCAIntermediateAngle PROC
;;;632    
;;;633    uint32_t u32SMC_GetDCAIntermediateAngle(smc_dev_e eDevice)
000a10  e92d4070          PUSH     {r4-r6,lr}
;;;634    {
000a14  e1a04000          MOV      r4,r0
;;;635        float32_t fValue;
;;;636        uint32_t u32Value;
;;;637    
;;;638        u32Value = biGetSMCDCA_PT1_PT1(eDevice);
000a18  e1a00104          LSL      r0,r4,#2
000a1c  e280020d          ADD      r0,r0,#0xd0000000
000a20  e24006fd          SUB      r0,r0,#0xfd00000
000a24  e590005c          LDR      r0,[r0,#0x5c]
000a28  e3c054fe          BIC      r5,r0,#0xfe000000
;;;639    
;;;640        fValue = f32RegToFloat(u32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
000a2c  e59f03f0          LDR      r0,|L1.3620|
000a30  e7d02004          LDRB     r2,[r0,r4]
000a34  e59f03f4          LDR      r0,|L1.3632|
000a38  e7901104          LDR      r1,[r0,r4,LSL #2]
000a3c  e1a00005          MOV      r0,r5
000a40  ebfffffe          BL       f32RegToFloat
000a44  e1a06000          MOV      r6,r0
;;;641    
;;;642        return (uint32_t)fValue;
000a48  e1a00006          MOV      r0,r6
000a4c  ebfffffe          BL       __aeabi_f2uiz
;;;643    }
000a50  e8bd8070          POP      {r4-r6,pc}
;;;644    
                          ENDP

                  vSMC_SetDCAIntermediateAngle PROC
;;;646    
;;;647    void vSMC_SetDCAIntermediateAngle(smc_dev_e eDevice, float32_t f32Value)
000a54  e92d4070          PUSH     {r4-r6,lr}
;;;648    {
000a58  e1a04000          MOV      r4,r0
000a5c  e1a05001          MOV      r5,r1
;;;649        uint32_t u32Value;
;;;650    
;;;651        u32Value = u32SMC_FloatToReg(f32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
000a60  e59f03bc          LDR      r0,|L1.3620|
000a64  e7d02004          LDRB     r2,[r0,r4]
000a68  e59f03c0          LDR      r0,|L1.3632|
000a6c  e7901104          LDR      r1,[r0,r4,LSL #2]
000a70  e1a00005          MOV      r0,r5
000a74  ebfffffe          BL       u32SMC_FloatToReg
000a78  e1a06000          MOV      r6,r0
;;;652    
;;;653        vSetSMCDCA_PT1_PT1(eDevice, u32Value);
000a7c  e1a00104          LSL      r0,r4,#2
000a80  e280020d          ADD      r0,r0,#0xd0000000
000a84  e24006fd          SUB      r0,r0,#0xfd00000
000a88  e590005c          LDR      r0,[r0,#0x5c]
000a8c  e7d80016          BFI      r0,r6,#0,#25
000a90  e1a01104          LSL      r1,r4,#2
000a94  e281120d          ADD      r1,r1,#0xd0000000
000a98  e24116fd          SUB      r1,r1,#0xfd00000
000a9c  e581005c          STR      r0,[r1,#0x5c]
;;;654    }
000aa0  e8bd8070          POP      {r4-r6,pc}
;;;655    
                          ENDP

                  u32SMC_GetDCAActualAngle PROC
;;;657    
;;;658    uint32_t u32SMC_GetDCAActualAngle(smc_dev_e eDevice)
000aa4  e92d4070          PUSH     {r4-r6,lr}
;;;659    {
000aa8  e1a04000          MOV      r4,r0
;;;660        float32_t fValue;
;;;661        uint32_t u32Value;
;;;662    
;;;663        u32Value = biGetSMCDCA_PT2_PT2(eDevice);
000aac  e1a00104          LSL      r0,r4,#2
000ab0  e280020d          ADD      r0,r0,#0xd0000000
000ab4  e24006fd          SUB      r0,r0,#0xfd00000
000ab8  e5900070          LDR      r0,[r0,#0x70]
000abc  e3c054fe          BIC      r5,r0,#0xfe000000
;;;664    
;;;665        fValue = f32RegToFloat(u32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
000ac0  e59f035c          LDR      r0,|L1.3620|
000ac4  e7d02004          LDRB     r2,[r0,r4]
000ac8  e59f0360          LDR      r0,|L1.3632|
000acc  e7901104          LDR      r1,[r0,r4,LSL #2]
000ad0  e1a00005          MOV      r0,r5
000ad4  ebfffffe          BL       f32RegToFloat
000ad8  e1a06000          MOV      r6,r0
;;;666    
;;;667        return (uint32_t)fValue;
000adc  e1a00006          MOV      r0,r6
000ae0  ebfffffe          BL       __aeabi_f2uiz
;;;668    }
000ae4  e8bd8070          POP      {r4-r6,pc}
;;;669    
                          ENDP

                  vSMC_SetDCAActualAngle PROC
;;;671    
;;;672    void vSMC_SetDCAActualAngle(smc_dev_e eDevice, float32_t f32Value)
000ae8  e92d4070          PUSH     {r4-r6,lr}
;;;673    {
000aec  e1a04000          MOV      r4,r0
000af0  e1a05001          MOV      r5,r1
;;;674        uint32_t u32Value;
;;;675    
;;;676        u32Value = u32SMC_FloatToReg(f32Value, f32DegreePerFullstepVal[eDevice], eTableModeVal[eDevice]);
000af4  e59f0328          LDR      r0,|L1.3620|
000af8  e7d02004          LDRB     r2,[r0,r4]
000afc  e59f032c          LDR      r0,|L1.3632|
000b00  e7901104          LDR      r1,[r0,r4,LSL #2]
000b04  e1a00005          MOV      r0,r5
000b08  ebfffffe          BL       u32SMC_FloatToReg
000b0c  e1a06000          MOV      r6,r0
;;;677    
;;;678        vSetSMCDCA_PT2_PT2(eDevice, u32Value);
000b10  e1a00104          LSL      r0,r4,#2
000b14  e280020d          ADD      r0,r0,#0xd0000000
000b18  e24006fd          SUB      r0,r0,#0xfd00000
000b1c  e5900070          LDR      r0,[r0,#0x70]
000b20  e7d80016          BFI      r0,r6,#0,#25
000b24  e1a01104          LSL      r1,r4,#2
000b28  e281120d          ADD      r1,r1,#0xd0000000
000b2c  e24116fd          SUB      r1,r1,#0xfd00000
000b30  e5810070          STR      r0,[r1,#0x70]
;;;679    }
000b34  e8bd8070          POP      {r4-r6,pc}
;;;680    
                          ENDP

                  u32SMC_GetDCAVelocity PROC
;;;682    
;;;683    uint32_t u32SMC_GetDCAVelocity(smc_dev_e eDevice)
000b38  e1a01000          MOV      r1,r0
;;;684    {
;;;685        return biGetSMCDCA_V_OLD_V_OLD(eDevice);
000b3c  e1a00101          LSL      r0,r1,#2
000b40  e280020d          ADD      r0,r0,#0xd0000000
000b44  e24006fd          SUB      r0,r0,#0xfd00000
000b48  e5900084          LDR      r0,[r0,#0x84]
000b4c  e3c004fe          BIC      r0,r0,#0xfe000000
;;;686    }
000b50  e12fff1e          BX       lr
;;;687    
                          ENDP

                  vSMC_SetDCAVelocity PROC
;;;689    
;;;690    void vSMC_SetDCAVelocity(smc_dev_e eDevice, uint32_t u32Value)
000b54  e1a02100          LSL      r2,r0,#2
;;;691    {
;;;692        vSetSMCDCA_V_OLD_V_OLD(eDevice, u32Value);
000b58  e282220d          ADD      r2,r2,#0xd0000000
000b5c  e24226fd          SUB      r2,r2,#0xfd00000
000b60  e5922084          LDR      r2,[r2,#0x84]
000b64  e7d82011          BFI      r2,r1,#0,#25
000b68  e1a03100          LSL      r3,r0,#2
000b6c  e283320d          ADD      r3,r3,#0xd0000000
000b70  e24336fd          SUB      r3,r3,#0xfd00000
000b74  e5832084          STR      r2,[r3,#0x84]
;;;693    }
000b78  e12fff1e          BX       lr
;;;694    
                          ENDP

                  u32SMC_GetDCAVelocityLimit PROC
;;;696    
;;;697    uint32_t u32SMC_GetDCAVelocityLimit(smc_dev_e eDevice)
000b7c  e1a01000          MOV      r1,r0
;;;698    {
;;;699        return biGetSMCDCA_V_MAX_V_MAX(eDevice);
000b80  e1a00101          LSL      r0,r1,#2
000b84  e280020d          ADD      r0,r0,#0xd0000000
000b88  e24006fd          SUB      r0,r0,#0xfd00000
000b8c  e5900098          LDR      r0,[r0,#0x98]
000b90  e3c004fe          BIC      r0,r0,#0xfe000000
;;;700    }
000b94  e12fff1e          BX       lr
;;;701    
                          ENDP

                  vSMC_SetDCAVelocityLimit PROC
;;;703    
;;;704    void vSMC_SetDCAVelocityLimit(smc_dev_e eDevice, uint32_t u32Value)
000b98  e1a02100          LSL      r2,r0,#2
;;;705    {
;;;706        vSetSMCDCA_V_MAX_V_MAX(eDevice, u32Value);
000b9c  e282220d          ADD      r2,r2,#0xd0000000
000ba0  e24226fd          SUB      r2,r2,#0xfd00000
000ba4  e5922098          LDR      r2,[r2,#0x98]
000ba8  e7d82011          BFI      r2,r1,#0,#25
000bac  e1a03100          LSL      r3,r0,#2
000bb0  e283320d          ADD      r3,r3,#0xd0000000
000bb4  e24336fd          SUB      r3,r3,#0xfd00000
000bb8  e5832098          STR      r2,[r3,#0x98]
;;;707    }
000bbc  e12fff1e          BX       lr
;;;708    
                          ENDP

                  u32SMC_GetDCAAcceleration PROC
;;;710    
;;;711    uint32_t u32SMC_GetDCAAcceleration(smc_dev_e eDevice)
000bc0  e1a01000          MOV      r1,r0
;;;712    {
;;;713        return biGetSMCDCA_ACC_ACC(eDevice);
000bc4  e1a00101          LSL      r0,r1,#2
000bc8  e280020d          ADD      r0,r0,#0xd0000000
000bcc  e24006fd          SUB      r0,r0,#0xfd00000
000bd0  e59000ac          LDR      r0,[r0,#0xac]
000bd4  e3c004fe          BIC      r0,r0,#0xfe000000
;;;714    }
000bd8  e12fff1e          BX       lr
;;;715    
                          ENDP

                  u32SMC_GetDCAAccelerationLimit PROC
;;;717    
;;;718    uint32_t u32SMC_GetDCAAccelerationLimit(smc_dev_e eDevice)
000bdc  e1a01000          MOV      r1,r0
;;;719    {
;;;720        return biGetSMCDCA_A_MAX_A_MAX(eDevice);
000be0  e1a00101          LSL      r0,r1,#2
000be4  e280020d          ADD      r0,r0,#0xd0000000
000be8  e24006fd          SUB      r0,r0,#0xfd00000
000bec  e59000c0          LDR      r0,[r0,#0xc0]
000bf0  e3c004fe          BIC      r0,r0,#0xfe000000
;;;721    }
000bf4  e12fff1e          BX       lr
;;;722    
                          ENDP

                  vSMC_SetDCAAccelerationLimit PROC
;;;724    
;;;725    void vSMC_SetDCAAccelerationLimit(smc_dev_e eDevice, uint32_t u32Value)
000bf8  e1a02100          LSL      r2,r0,#2
;;;726    {
;;;727        vSetSMCDCA_A_MAX_A_MAX(eDevice, u32Value);
000bfc  e282220d          ADD      r2,r2,#0xd0000000
000c00  e24226fd          SUB      r2,r2,#0xfd00000
000c04  e59220c0          LDR      r2,[r2,#0xc0]
000c08  e7d82011          BFI      r2,r1,#0,#25
000c0c  e1a03100          LSL      r3,r0,#2
000c10  e283320d          ADD      r3,r3,#0xd0000000
000c14  e24336fd          SUB      r3,r3,#0xfd00000
000c18  e58320c0          STR      r2,[r3,#0xc0]
;;;728    }
000c1c  e12fff1e          BX       lr
;;;729    
                          ENDP

                  u32SMC_GetDCADecelerationLimit PROC
;;;731    
;;;732    uint32_t u32SMC_GetDCADecelerationLimit(smc_dev_e eDevice)
000c20  e1a01000          MOV      r1,r0
;;;733    {
;;;734        return biGetSMCDCA_D_MAX_D_MAX(eDevice);
000c24  e1a00101          LSL      r0,r1,#2
000c28  e280020d          ADD      r0,r0,#0xd0000000
000c2c  e24006fd          SUB      r0,r0,#0xfd00000
000c30  e59000d4          LDR      r0,[r0,#0xd4]
000c34  e3c004fe          BIC      r0,r0,#0xfe000000
;;;735    }
000c38  e12fff1e          BX       lr
;;;736    
                          ENDP

                  vSMC_SetDCADecelerationLimit PROC
;;;738    
;;;739    void vSMC_SetDCADecelerationLimit(smc_dev_e eDevice, uint32_t u32Value)
000c3c  e1a02100          LSL      r2,r0,#2
;;;740    {
;;;741        vSetSMCDCA_D_MAX_D_MAX(eDevice, u32Value);
000c40  e282220d          ADD      r2,r2,#0xd0000000
000c44  e24226fd          SUB      r2,r2,#0xfd00000
000c48  e59220d4          LDR      r2,[r2,#0xd4]
000c4c  e7d82011          BFI      r2,r1,#0,#25
000c50  e1a03100          LSL      r3,r0,#2
000c54  e283320d          ADD      r3,r3,#0xd0000000
000c58  e24336fd          SUB      r3,r3,#0xfd00000
000c5c  e58320d4          STR      r2,[r3,#0xd4]
;;;742    }
000c60  e12fff1e          BX       lr
;;;743    
                          ENDP

                  u32SMC_GetDCASpeedThreshold1 PROC
;;;745    
;;;746    uint32_t u32SMC_GetDCASpeedThreshold1(smc_dev_e eDevice)
000c64  e1a01000          MOV      r1,r0
;;;747    {
;;;748        return biGetSMCDCA_V1_V1TH(eDevice);
000c68  e1a00101          LSL      r0,r1,#2
000c6c  e280020d          ADD      r0,r0,#0xd0000000
000c70  e24006fd          SUB      r0,r0,#0xfd00000
000c74  e59000e8          LDR      r0,[r0,#0xe8]
000c78  e3c004fe          BIC      r0,r0,#0xfe000000
;;;749    }
000c7c  e12fff1e          BX       lr
;;;750    
                          ENDP

                  vSMC_SetDCASpeedThreshold1 PROC
;;;752    
;;;753    void vSMC_SetDCASpeedThreshold1(smc_dev_e eDevice, uint32_t u32Value)
000c80  e1a02100          LSL      r2,r0,#2
;;;754    {
;;;755        vSetSMCDCA_V1_V1TH(eDevice, u32Value);
000c84  e282220d          ADD      r2,r2,#0xd0000000
000c88  e24226fd          SUB      r2,r2,#0xfd00000
000c8c  e59220e8          LDR      r2,[r2,#0xe8]
000c90  e7d82011          BFI      r2,r1,#0,#25
000c94  e1a03100          LSL      r3,r0,#2
000c98  e283320d          ADD      r3,r3,#0xd0000000
000c9c  e24336fd          SUB      r3,r3,#0xfd00000
000ca0  e58320e8          STR      r2,[r3,#0xe8]
;;;756    }
000ca4  e12fff1e          BX       lr
;;;757    
                          ENDP

                  u32SMC_GetDCASpeedThreshold2 PROC
;;;759    
;;;760    uint32_t u32SMC_GetDCASpeedThreshold2(smc_dev_e eDevice)
000ca8  e1a01000          MOV      r1,r0
;;;761    {
;;;762        return biGetSMCDCA_V2_V2TH(eDevice);
000cac  e1a00101          LSL      r0,r1,#2
000cb0  e280020d          ADD      r0,r0,#0xd0000000
000cb4  e24006fd          SUB      r0,r0,#0xfd00000
000cb8  e59000fc          LDR      r0,[r0,#0xfc]
000cbc  e3c004fe          BIC      r0,r0,#0xfe000000
;;;763    }
000cc0  e12fff1e          BX       lr
;;;764    
                          ENDP

                  vSMC_SetDCASpeedThreshold2 PROC
;;;766    
;;;767    void vSMC_SetDCASpeedThreshold2(smc_dev_e eDevice, uint32_t u32Value)
000cc4  e1a02100          LSL      r2,r0,#2
;;;768    {
;;;769        vSetSMCDCA_V2_V2TH(eDevice, u32Value);
000cc8  e282220d          ADD      r2,r2,#0xd0000000
000ccc  e24226fd          SUB      r2,r2,#0xfd00000
000cd0  e59220fc          LDR      r2,[r2,#0xfc]
000cd4  e7d82011          BFI      r2,r1,#0,#25
000cd8  e1a03100          LSL      r3,r0,#2
000cdc  e283320d          ADD      r3,r3,#0xd0000000
000ce0  e24336fd          SUB      r3,r3,#0xfd00000
000ce4  e58320fc          STR      r2,[r3,#0xfc]
;;;770    }
000ce8  e12fff1e          BX       lr
;;;771    
                          ENDP

                  eSMC_GetDCATableDataSelection PROC
;;;773    
;;;774    smc_table_data_selection_e eSMC_GetDCATableDataSelection(smc_dev_e eDevice)
000cec  e1a01000          MOV      r1,r0
;;;775    {
;;;776       return (smc_table_data_selection_e)biGetSMCDCA_TS_TS_SEL(eDevice);
000cf0  e59f213c          LDR      r2,|L1.3636|
000cf4  e0820101          ADD      r0,r2,r1,LSL #2
000cf8  e1d001b0          LDRH     r0,[r0,#0x10]
000cfc  e2000001          AND      r0,r0,#1
;;;777    }
000d00  e12fff1e          BX       lr
;;;778    
                          ENDP

                  vSMC_SetDCATableDataSelection PROC
;;;780    
;;;781    void vSMC_SetDCATableDataSelection(smc_dev_e eDevice, smc_table_data_selection_e eValue)
000d04  e92d4010          PUSH     {r4,lr}
;;;782    {
;;;783       vSetSMCDCA_TS_TS_SEL(eDevice, (uint16_t)eValue);
000d08  e59f3124          LDR      r3,|L1.3636|
000d0c  e0832100          ADD      r2,r3,r0,LSL #2
000d10  e1d221b0          LDRH     r2,[r2,#0x10]
000d14  e7c02011          BFI      r2,r1,#0,#1
000d18  e1a04003          MOV      r4,r3
000d1c  e0843100          ADD      r3,r4,r0,LSL #2
000d20  e1c321b0          STRH     r2,[r3,#0x10]
;;;784    }
000d24  e8bd8010          POP      {r4,pc}
;;;785    
                          ENDP

                  eSMC_GetDCATableDataDirection PROC
;;;787    
;;;788    smc_table_data_direction_e eSMC_GetDCATableDataDirection(smc_dev_e eDevice)
000d28  e1a01000          MOV      r1,r0
;;;789    {
;;;790       return (smc_table_data_direction_e)biGetSMCDCA_TS_TD_SEL(eDevice);
000d2c  e59f2100          LDR      r2,|L1.3636|
000d30  e0820101          ADD      r0,r2,r1,LSL #2
000d34  e1d001b0          LDRH     r0,[r0,#0x10]
000d38  e7e00450          UBFX     r0,r0,#8,#1
;;;791    }
000d3c  e12fff1e          BX       lr
;;;792    
                          ENDP

                  vSMC_SetDCATableDataDirection PROC
;;;794    
;;;795    void vSMC_SetDCATableDataDirection(smc_dev_e eDevice, smc_table_data_direction_e eValue)
000d40  e92d4010          PUSH     {r4,lr}
;;;796    {
;;;797       vSetSMCDCA_TS_TD_SEL(eDevice, (uint16_t)eValue);
000d44  e59f30e8          LDR      r3,|L1.3636|
000d48  e0832100          ADD      r2,r3,r0,LSL #2
000d4c  e1d221b0          LDRH     r2,[r2,#0x10]
000d50  e7c82411          BFI      r2,r1,#8,#1
000d54  e1a04003          MOV      r4,r3
000d58  e0843100          ADD      r3,r4,r0,LSL #2
000d5c  e1c321b0          STRH     r2,[r3,#0x10]
;;;798    }
000d60  e8bd8010          POP      {r4,pc}
;;;799    
                          ENDP

                  u8SMC_GetZPDIndexIncrement PROC
;;;801    
;;;802    uint8_t u8SMC_GetZPDIndexIncrement(smc_dev_e eDevice)
000d64  e1a01000          MOV      r1,r0
;;;803    {
;;;804       return ((uint8_t)biGetSMCZPD_CTRL_IDX_INC_N(eDevice));
000d68  e1a00101          LSL      r0,r1,#2
000d6c  e280020d          ADD      r0,r0,#0xd0000000
000d70  e24006fd          SUB      r0,r0,#0xfd00000
000d74  e5900124          LDR      r0,[r0,#0x124]
000d78  e200007f          AND      r0,r0,#0x7f
;;;805    }
000d7c  e12fff1e          BX       lr
;;;806    
                          ENDP

                  vSMC_SetZPDIndexIncrement PROC
;;;808    
;;;809    void vSMC_SetZPDIndexIncrement(smc_dev_e eDevice, uint8_t u8Value)
000d80  e1a02100          LSL      r2,r0,#2
;;;810    {
;;;811       vSetSMCZPD_CTRL_IDX_INC_N(eDevice, u8Value);
000d84  e282220d          ADD      r2,r2,#0xd0000000
000d88  e24226fd          SUB      r2,r2,#0xfd00000
000d8c  e5922124          LDR      r2,[r2,#0x124]
000d90  e7c62011          BFI      r2,r1,#0,#7
000d94  e1a03100          LSL      r3,r0,#2
000d98  e283320d          ADD      r3,r3,#0xd0000000
000d9c  e24336fd          SUB      r3,r3,#0xfd00000
000da0  e5832124          STR      r2,[r3,#0x124]
;;;812    }
000da4  e12fff1e          BX       lr
;;;813    
                          ENDP

                  eSMC_GetZPDQuadrantZPDIsIn PROC
;;;815    
;;;816    smc_quadrant_e eSMC_GetZPDQuadrantZPDIsIn(smc_dev_e eDevice)
000da8  e1a01000          MOV      r1,r0
;;;817    {
;;;818       return (smc_quadrant_e)biGetSMCZPD_CTRL_QUAD(eDevice);
000dac  e1a00101          LSL      r0,r1,#2
000db0  e280020d          ADD      r0,r0,#0xd0000000
000db4  e24006fd          SUB      r0,r0,#0xfd00000
000db8  e5900124          LDR      r0,[r0,#0x124]
000dbc  e7e10450          UBFX     r0,r0,#8,#2
;;;819    }
000dc0  e12fff1e          BX       lr
;;;820    
                          ENDP

                  u8SMC_GetZPDScanningFrequency PROC
;;;822    
;;;823    uint8_t u8SMC_GetZPDScanningFrequency(smc_dev_e eDevice)
000dc4  e1a01000          MOV      r1,r0
;;;824    {
;;;825       return ((uint8_t)biGetSMCZPD_CTRL_FREQ_N(eDevice));
000dc8  e1a00101          LSL      r0,r1,#2
000dcc  e280020d          ADD      r0,r0,#0xd0000000
000dd0  e24006fd          SUB      r0,r0,#0xfd00000
000dd4  e5900124          LDR      r0,[r0,#0x124]
000dd8  e7e30850          UBFX     r0,r0,#16,#4
;;;826    }
000ddc  e12fff1e          BX       lr
;;;827    
                          ENDP

                  vSMC_SetZPDScanningFrequency PROC
;;;829    
;;;830    void vSMC_SetZPDScanningFrequency(smc_dev_e eDevice, uint8_t u8Value)
000de0  e1a02100          LSL      r2,r0,#2
;;;831    {
;;;832       vSetSMCZPD_CTRL_FREQ_N(eDevice, u8Value);
000de4  e282220d          ADD      r2,r2,#0xd0000000
000de8  e24226fd          SUB      r2,r2,#0xfd00000
000dec  e5922124          LDR      r2,[r2,#0x124]
000df0  e7d32811          BFI      r2,r1,#16,#4
000df4  e1a03100          LSL      r3,r0,#2
000df8  e283320d          ADD      r3,r3,#0xd0000000
000dfc  e24336fd          SUB      r3,r3,#0xfd00000
000e00  e5832124          STR      r2,[r3,#0x124]
;;;833    }
000e04  e12fff1e          BX       lr
                  |L1.3592|
                          DCD      au8LLDD_SMC_C_REVISION
                  |L1.3596|
                          DCD      au8LLDD_SMC_C_TAG
                  |L1.3600|
                          DCD      au8LLDD_SMC_H_REVISION
                  |L1.3604|
                          DCD      au8LLDD_SMC_H_TAG
                  |L1.3608|
                          DCD      au8LLDD_SMC_IO_H_REVISION
                  |L1.3612|
                          DCD      au8LLDD_SMC_IO_H_TAG
                  |L1.3616|
                          DCD      0xc0300000
                  |L1.3620|
                          DCD      eTableModeVal
                  |L1.3624|
                          DCD      0xbf800000
                  |L1.3628|
                          DCD      f32ISMQuadrantOffset
                  |L1.3632|
                          DCD      f32DegreePerFullstepVal
                  |L1.3636|
                          DCD      0xc0300100
                          ENDP

                  u8SMC_GetZPDVoltageThreshold PROC
;;;836    
;;;837    uint8_t u8SMC_GetZPDVoltageThreshold(smc_dev_e eDevice)
000e38  e1a01000          MOV      r1,r0
;;;838    {
;;;839       return ((uint8_t)biGetSMCZPD_CTRL_VOLT_REF(eDevice));
000e3c  e1a00101          LSL      r0,r1,#2
000e40  e280020d          ADD      r0,r0,#0xd0000000
000e44  e24006fd          SUB      r0,r0,#0xfd00000
000e48  e5900124          LDR      r0,[r0,#0x124]
000e4c  e7e50c50          UBFX     r0,r0,#24,#6
;;;840    }
000e50  e12fff1e          BX       lr
;;;841    
                          ENDP

                  vSMC_SetZPDVoltageThreshold PROC
;;;843    
;;;844    void vSMC_SetZPDVoltageThreshold(smc_dev_e eDevice, uint8_t u8Value)
000e54  e1a02100          LSL      r2,r0,#2
;;;845    {
;;;846       vSetSMCZPD_CTRL_VOLT_REF(eDevice, u8Value);
000e58  e282220d          ADD      r2,r2,#0xd0000000
000e5c  e24226fd          SUB      r2,r2,#0xfd00000
000e60  e5922124          LDR      r2,[r2,#0x124]
000e64  e7dd2c11          BFI      r2,r1,#24,#6
000e68  e1a03100          LSL      r3,r0,#2
000e6c  e283320d          ADD      r3,r3,#0xd0000000
000e70  e24336fd          SUB      r3,r3,#0xfd00000
000e74  e5832124          STR      r2,[r3,#0x124]
;;;847    }
000e78  e12fff1e          BX       lr
;;;848    
                          ENDP

                  vSMC_WriteZPDTable PROC
;;;850    
;;;851    void vSMC_WriteZPDTable(smc_dev_e eDevice, uint8_t u8Length, const uint32_t * u32TableValues)
000e7c  e92d4030          PUSH     {r4,r5,lr}
;;;852    {
000e80  e1a03000          MOV      r3,r0
;;;853       uint32_t u32Counter;
;;;854       
;;;855       for (u32Counter=0U; u32Counter<(uint32_t)u8Length; u32Counter++)
000e84  e3a00000          MOV      r0,#0
000e88  ea000008          B        |L1.3760|
                  |L1.3724|
;;;856       {
;;;857          vSetSMCZPD_TABLE( (32U*(uint32_t)eDevice) + u32Counter, *(u32TableValues+u32Counter));
000e8c  e7924100          LDR      r4,[r2,r0,LSL #2]
000e90  e3a05020          MOV      r5,#0x20
000e94  e0250395          MLA      r5,r5,r3,r0
000e98  e1a05805          LSL      r5,r5,#16
000e9c  e1a05725          LSR      r5,r5,#14
000ea0  e285520d          ADD      r5,r5,#0xd0000000
000ea4  e24556fd          SUB      r5,r5,#0xfd00000
000ea8  e5854c00          STR      r4,[r5,#0xc00]
000eac  e2800001          ADD      r0,r0,#1              ;855
                  |L1.3760|
000eb0  e1500001          CMP      r0,r1                 ;855
000eb4  3afffff4          BCC      |L1.3724|
;;;858       }
;;;859    }
000eb8  e8bd8030          POP      {r4,r5,pc}
;;;860    
                          ENDP

                  vSMC_WriteISMTable PROC
;;;862    
;;;863    void vSMC_WriteISMTable(const uint32_t * u32TableValues)
000ebc  e1a01000          MOV      r1,r0
;;;864    {
;;;865       uint32_t u32Counter;
;;;866       
;;;867       for (u32Counter=0U; u32Counter<1024U; u32Counter++)
000ec0  e3a00000          MOV      r0,#0
000ec4  ea000006          B        |L1.3812|
                  |L1.3784|
;;;868       {
;;;869          vSetSMCISM_TABLE(u32Counter, *(u32TableValues+u32Counter));
000ec8  e7912100          LDR      r2,[r1,r0,LSL #2]
000ecc  e1a03800          LSL      r3,r0,#16
000ed0  e1a03723          LSR      r3,r3,#14
000ed4  e24335ff          SUB      r3,r3,#0x3fc00000
000ed8  e2433aff          SUB      r3,r3,#0xff000
000edc  e5832000          STR      r2,[r3,#0]
000ee0  e2800001          ADD      r0,r0,#1              ;867
                  |L1.3812|
000ee4  e3500b01          CMP      r0,#0x400             ;867
000ee8  3afffff6          BCC      |L1.3784|
;;;870       }
;;;871    }
000eec  e12fff1e          BX       lr
;;;872    
                          ENDP

                  f32SMC_GetDegreePerFullstep PROC
;;;873    /****************************************************************************/
;;;874    float32_t f32SMC_GetDegreePerFullstep(smc_dev_e eDevice)
000ef0  e1a01000          MOV      r1,r0
;;;875    {
;;;876        return f32DegreePerFullstepVal[eDevice];
000ef4  e51f00cc          LDR      r0,|L1.3632|
000ef8  e7900101          LDR      r0,[r0,r1,LSL #2]
;;;877    }
000efc  e12fff1e          BX       lr
;;;878    
                          ENDP

                  vSMC_SetDegreePerFullstep PROC
;;;879    /****************************************************************************/
;;;880    void vSMC_SetDegreePerFullstep(smc_dev_e eDevice, float32_t f32Value)
000f00  e51f20d8          LDR      r2,|L1.3632|
;;;881    {
;;;882        f32DegreePerFullstepVal[eDevice] = f32Value;
000f04  e7821100          STR      r1,[r2,r0,LSL #2]
;;;883    }
000f08  e12fff1e          BX       lr
;;;884    
                          ENDP

                  vSMC_GeneralConfig PROC
;;;886    
;;;887    void vSMC_GeneralConfig(smc_dev_e eDevice, const smc_generalconfig_st * pstGeneralConfig)
000f0c  e5d13000          LDRB     r3,[r1,#0]
;;;888    {
;;;889       vSetSMCCTRL_DELAY_CYCLES(eDevice, pstGeneralConfig->u8DelayCycleCount);
000f10  e1a02100          LSL      r2,r0,#2
000f14  e282220d          ADD      r2,r2,#0xd0000000
000f18  e24226fd          SUB      r2,r2,#0xfd00000
000f1c  e592200c          LDR      r2,[r2,#0xc]
000f20  e7c72193          BFI      r2,r3,#3,#5
000f24  e1a03100          LSL      r3,r0,#2
000f28  e283320d          ADD      r3,r3,#0xd0000000
000f2c  e24336fd          SUB      r3,r3,#0xfd00000
000f30  e583200c          STR      r2,[r3,#0xc]
;;;890       vSetSMCCTRL_PERIOD_EXT(eDevice, pstGeneralConfig->u8PeriodExtension);
000f34  e5d13001          LDRB     r3,[r1,#1]
000f38  e1a02100          LSL      r2,r0,#2
000f3c  e282220d          ADD      r2,r2,#0xd0000000
000f40  e24226fd          SUB      r2,r2,#0xfd00000
000f44  e592200c          LDR      r2,[r2,#0xc]
000f48  e7ce2413          BFI      r2,r3,#8,#7
000f4c  e1a03100          LSL      r3,r0,#2
000f50  e283320d          ADD      r3,r3,#0xd0000000
000f54  e24336fd          SUB      r3,r3,#0xfd00000
000f58  e583200c          STR      r2,[r3,#0xc]
;;;891       vSetSMCCTRL_SLEW_RATE(eDevice, pstGeneralConfig->u8SlewRate);
000f5c  e5d13002          LDRB     r3,[r1,#2]
000f60  e1a02100          LSL      r2,r0,#2
000f64  e282220d          ADD      r2,r2,#0xd0000000
000f68  e24226fd          SUB      r2,r2,#0xfd00000
000f6c  e592200c          LDR      r2,[r2,#0xc]
000f70  e7d22813          BFI      r2,r3,#16,#3
000f74  e1a03100          LSL      r3,r0,#2
000f78  e283320d          ADD      r3,r3,#0xd0000000
000f7c  e24336fd          SUB      r3,r3,#0xfd00000
000f80  e583200c          STR      r2,[r3,#0xc]
;;;892    }
000f84  e12fff1e          BX       lr
;;;893    
                          ENDP

                  vSMC_IsmConfig PROC
;;;895    
;;;896    void vSMC_IsmConfig(smc_dev_e eDevice, const smc_ismconfig_st * pstIsmConfig)
000f88  e92d4070          PUSH     {r4-r6,lr}
;;;897    {
000f8c  e1a04000          MOV      r4,r0
000f90  e1a05001          MOV      r5,r1
;;;898       /* internal parameter */
;;;899       f32DegreePerFullstepVal[eDevice] = pstIsmConfig->f32DegreePerFullstep;
000f94  e51f116c          LDR      r1,|L1.3632|
000f98  e5950024          LDR      r0,[r5,#0x24]
000f9c  e7810104          STR      r0,[r1,r4,LSL #2]
;;;900       eTableModeVal[eDevice] = pstIsmConfig->eTableMode;
000fa0  e5d50028          LDRB     r0,[r5,#0x28]
000fa4  e51f1188          LDR      r1,|L1.3620|
000fa8  e7c10004          STRB     r0,[r1,r4]
;;;901    
;;;902       /* DCA config */
;;;903       vSMC_SetDCAIntermediateAngle(eDevice, pstIsmConfig->f32IntermediateAngle);
000fac  e1a00004          MOV      r0,r4
000fb0  e5951000          LDR      r1,[r5,#0]
000fb4  ebfffffe          BL       vSMC_SetDCAIntermediateAngle
;;;904       vSMC_SetDCAActualAngle(eDevice, pstIsmConfig->f32ActualAngle);
000fb8  e1a00004          MOV      r0,r4
000fbc  e5951004          LDR      r1,[r5,#4]
000fc0  ebfffffe          BL       vSMC_SetDCAActualAngle
;;;905       vSetSMCDCA_V_OLD_V_OLD(eDevice, pstIsmConfig->u32Velocity);
000fc4  e1a00104          LSL      r0,r4,#2
000fc8  e280020d          ADD      r0,r0,#0xd0000000
000fcc  e24006fd          SUB      r0,r0,#0xfd00000
000fd0  e5951008          LDR      r1,[r5,#8]
000fd4  e5900084          LDR      r0,[r0,#0x84]
000fd8  e7d80011          BFI      r0,r1,#0,#25
000fdc  e1a01104          LSL      r1,r4,#2
000fe0  e281120d          ADD      r1,r1,#0xd0000000
000fe4  e24116fd          SUB      r1,r1,#0xfd00000
000fe8  e5810084          STR      r0,[r1,#0x84]
;;;906       vSetSMCDCA_V_MAX_V_MAX(eDevice, pstIsmConfig->u32VelocityLimit);
000fec  e1a00104          LSL      r0,r4,#2
000ff0  e280020d          ADD      r0,r0,#0xd0000000
000ff4  e24006fd          SUB      r0,r0,#0xfd00000
000ff8  e595100c          LDR      r1,[r5,#0xc]
000ffc  e5900098          LDR      r0,[r0,#0x98]
001000  e7d80011          BFI      r0,r1,#0,#25
001004  e1a01104          LSL      r1,r4,#2
001008  e281120d          ADD      r1,r1,#0xd0000000
00100c  e24116fd          SUB      r1,r1,#0xfd00000
001010  e5810098          STR      r0,[r1,#0x98]
;;;907       vSetSMCDCA_A_MAX_A_MAX(eDevice, pstIsmConfig->u32AccelerationLimit);
001014  e1a00104          LSL      r0,r4,#2
001018  e280020d          ADD      r0,r0,#0xd0000000
00101c  e24006fd          SUB      r0,r0,#0xfd00000
001020  e5951010          LDR      r1,[r5,#0x10]
001024  e59000c0          LDR      r0,[r0,#0xc0]
001028  e7d80011          BFI      r0,r1,#0,#25
00102c  e1a01104          LSL      r1,r4,#2
001030  e281120d          ADD      r1,r1,#0xd0000000
001034  e24116fd          SUB      r1,r1,#0xfd00000
001038  e58100c0          STR      r0,[r1,#0xc0]
;;;908       vSetSMCDCA_D_MAX_D_MAX(eDevice, pstIsmConfig->u32DecelerationLimit);
00103c  e1a00104          LSL      r0,r4,#2
001040  e280020d          ADD      r0,r0,#0xd0000000
001044  e24006fd          SUB      r0,r0,#0xfd00000
001048  e5951014          LDR      r1,[r5,#0x14]
00104c  e59000d4          LDR      r0,[r0,#0xd4]
001050  e7d80011          BFI      r0,r1,#0,#25
001054  e1a01104          LSL      r1,r4,#2
001058  e281120d          ADD      r1,r1,#0xd0000000
00105c  e24116fd          SUB      r1,r1,#0xfd00000
001060  e58100d4          STR      r0,[r1,#0xd4]
;;;909       vSetSMCDCA_V1_V1TH(eDevice,     pstIsmConfig->u32SpeedThreshold1);
001064  e1a00104          LSL      r0,r4,#2
001068  e280020d          ADD      r0,r0,#0xd0000000
00106c  e24006fd          SUB      r0,r0,#0xfd00000
001070  e5951018          LDR      r1,[r5,#0x18]
001074  e59000e8          LDR      r0,[r0,#0xe8]
001078  e7d80011          BFI      r0,r1,#0,#25
00107c  e1a01104          LSL      r1,r4,#2
001080  e281120d          ADD      r1,r1,#0xd0000000
001084  e24116fd          SUB      r1,r1,#0xfd00000
001088  e58100e8          STR      r0,[r1,#0xe8]
;;;910       vSetSMCDCA_V2_V2TH(eDevice,     pstIsmConfig->u32SpeedThreshold2);
00108c  e1a00104          LSL      r0,r4,#2
001090  e280020d          ADD      r0,r0,#0xd0000000
001094  e24006fd          SUB      r0,r0,#0xfd00000
001098  e595101c          LDR      r1,[r5,#0x1c]
00109c  e59000fc          LDR      r0,[r0,#0xfc]
0010a0  e7d80011          BFI      r0,r1,#0,#25
0010a4  e1a01104          LSL      r1,r4,#2
0010a8  e281120d          ADD      r1,r1,#0xd0000000
0010ac  e24116fd          SUB      r1,r1,#0xfd00000
0010b0  e58100fc          STR      r0,[r1,#0xfc]
;;;911    
;;;912       /* ISM config */
;;;913       vSetSMCISM_CTRL_DAMP_K(eDevice, pstIsmConfig->u8DampingFactorK);
0010b4  e5d51020          LDRB     r1,[r5,#0x20]
0010b8  e1a00104          LSL      r0,r4,#2
0010bc  e280020d          ADD      r0,r0,#0xd0000000
0010c0  e24006fd          SUB      r0,r0,#0xfd00000
0010c4  e5900020          LDR      r0,[r0,#0x20]
0010c8  e7c20011          BFI      r0,r1,#0,#3
0010cc  e1a01104          LSL      r1,r4,#2
0010d0  e281120d          ADD      r1,r1,#0xd0000000
0010d4  e24116fd          SUB      r1,r1,#0xfd00000
0010d8  e5810020          STR      r0,[r1,#0x20]
;;;914       vSetSMCISM_CTRL_DAMP_L(eDevice, pstIsmConfig->u8DampingFactorL);
0010dc  e5d51021          LDRB     r1,[r5,#0x21]
0010e0  e1a00104          LSL      r0,r4,#2
0010e4  e280020d          ADD      r0,r0,#0xd0000000
0010e8  e24006fd          SUB      r0,r0,#0xfd00000
0010ec  e5900020          LDR      r0,[r0,#0x20]
0010f0  e7ca0411          BFI      r0,r1,#8,#3
0010f4  e1a01104          LSL      r1,r4,#2
0010f8  e281120d          ADD      r1,r1,#0xd0000000
0010fc  e24116fd          SUB      r1,r1,#0xfd00000
001100  e5810020          STR      r0,[r1,#0x20]
;;;915       vSetSMCISM_CTRL_ISM_TABLE_MODE(eDevice, (uint32_t) pstIsmConfig->eTableMode);
001104  e5d51028          LDRB     r1,[r5,#0x28]
001108  e1a00104          LSL      r0,r4,#2
00110c  e280020d          ADD      r0,r0,#0xd0000000
001110  e24006fd          SUB      r0,r0,#0xfd00000
001114  e5900020          LDR      r0,[r0,#0x20]
001118  e7d00811          BFI      r0,r1,#16,#1
00111c  e1a01104          LSL      r1,r4,#2
001120  e281120d          ADD      r1,r1,#0xd0000000
001124  e24116fd          SUB      r1,r1,#0xfd00000
001128  e5810020          STR      r0,[r1,#0x20]
;;;916       vSetSMCISM_CTRL_TABLE_IDX     (eDevice, (uint32_t) pstIsmConfig->eTableIndex);
00112c  e5d51029          LDRB     r1,[r5,#0x29]
001130  e1a00104          LSL      r0,r4,#2
001134  e280020d          ADD      r0,r0,#0xd0000000
001138  e24006fd          SUB      r0,r0,#0xfd00000
00113c  e5900020          LDR      r0,[r0,#0x20]
001140  e7d10891          BFI      r0,r1,#17,#1
001144  e1a01104          LSL      r1,r4,#2
001148  e281120d          ADD      r1,r1,#0xd0000000
00114c  e24116fd          SUB      r1,r1,#0xfd00000
001150  e5810020          STR      r0,[r1,#0x20]
;;;917       vSetSMCDCA_TS_TS_SEL          (eDevice, (uint16_t) pstIsmConfig->eTableData);
001154  e5d5102a          LDRB     r1,[r5,#0x2a]
001158  e51f232c          LDR      r2,|L1.3636|
00115c  e0820104          ADD      r0,r2,r4,LSL #2
001160  e1d001b0          LDRH     r0,[r0,#0x10]
001164  e7c00011          BFI      r0,r1,#0,#1
001168  e0821104          ADD      r1,r2,r4,LSL #2
00116c  e1c101b0          STRH     r0,[r1,#0x10]
;;;918       vSetSMCISM_CTRL_DIS_DAMP      (eDevice, ((SMC_ENABLE== pstIsmConfig->eUseDampingCurveHardware)? (uint32_t)SMC_DISABLE : (uint32_t)SMC_ENABLE) );
001170  e5d5002b          LDRB     r0,[r5,#0x2b]
001174  e3500001          CMP      r0,#1
001178  0a000001          BEQ      |L1.4484|
00117c  e3a01001          MOV      r1,#1
001180  ea000000          B        |L1.4488|
                  |L1.4484|
001184  e3a01000          MOV      r1,#0
                  |L1.4488|
001188  e1a00104          LSL      r0,r4,#2
00118c  e280020d          ADD      r0,r0,#0xd0000000
001190  e24006fd          SUB      r0,r0,#0xfd00000
001194  e5900020          LDR      r0,[r0,#0x20]
001198  e7d20911          BFI      r0,r1,#18,#1
00119c  e1a01104          LSL      r1,r4,#2
0011a0  e281120d          ADD      r1,r1,#0xd0000000
0011a4  e24116fd          SUB      r1,r1,#0xfd00000
0011a8  e5810020          STR      r0,[r1,#0x20]
;;;919    }
0011ac  e8bd8070          POP      {r4-r6,pc}
;;;920    
                          ENDP

                  vSMC_PwmConfig PROC
;;;922    
;;;923    void vSMC_PwmConfig(smc_dev_e eDevice, const smc_pwmvalue_st * pstPwmConfig)
0011b0  e92d4030          PUSH     {r4,r5,lr}
;;;924    {
0011b4  e1a05000          MOV      r5,r0
0011b8  e1a04001          MOV      r4,r1
;;;925       vSMC_SetPWM32BitData(eDevice, pstPwmConfig->eQuadrant, pstPwmConfig->u16SinDuty, pstPwmConfig->u16CosDuty);
0011bc  e1d430b4          LDRH     r3,[r4,#4]
0011c0  e1d420b2          LDRH     r2,[r4,#2]
0011c4  e5d41000          LDRB     r1,[r4,#0]
0011c8  e1a00005          MOV      r0,r5
0011cc  ebfffffe          BL       vSMC_SetPWM32BitData
;;;926    }
0011d0  e8bd8030          POP      {r4,r5,pc}
;;;927    
                          ENDP

                  vSMC_ZPDConfig PROC
;;;929    
;;;930    void vSMC_ZPDConfig(smc_dev_e eDevice, const smc_zpdconfig_st * pstZpdConfig)
0011d4  e5d13000          LDRB     r3,[r1,#0]
;;;931    {
;;;932       vSetSMCZPD_CTRL_IDX_INC_N(eDevice, pstZpdConfig->u8IndexIncrement);
0011d8  e1a02100          LSL      r2,r0,#2
0011dc  e282220d          ADD      r2,r2,#0xd0000000
0011e0  e24226fd          SUB      r2,r2,#0xfd00000
0011e4  e5922124          LDR      r2,[r2,#0x124]
0011e8  e7c62013          BFI      r2,r3,#0,#7
0011ec  e1a03100          LSL      r3,r0,#2
0011f0  e283320d          ADD      r3,r3,#0xd0000000
0011f4  e24336fd          SUB      r3,r3,#0xfd00000
0011f8  e5832124          STR      r2,[r3,#0x124]
;;;933       vSetSMCZPD_CTRL_FREQ_N(eDevice, pstZpdConfig->u8ScanningFrequency);
0011fc  e5d13001          LDRB     r3,[r1,#1]
001200  e1a02100          LSL      r2,r0,#2
001204  e282220d          ADD      r2,r2,#0xd0000000
001208  e24226fd          SUB      r2,r2,#0xfd00000
00120c  e5922124          LDR      r2,[r2,#0x124]
001210  e7d32813          BFI      r2,r3,#16,#4
001214  e1a03100          LSL      r3,r0,#2
001218  e283320d          ADD      r3,r3,#0xd0000000
00121c  e24336fd          SUB      r3,r3,#0xfd00000
001220  e5832124          STR      r2,[r3,#0x124]
;;;934       vSetSMCZPD_CTRL_VOLT_REF(eDevice, pstZpdConfig->u8VoltageThreshold);
001224  e5d13002          LDRB     r3,[r1,#2]
001228  e1a02100          LSL      r2,r0,#2
00122c  e282220d          ADD      r2,r2,#0xd0000000
001230  e24226fd          SUB      r2,r2,#0xfd00000
001234  e5922124          LDR      r2,[r2,#0x124]
001238  e7dd2c13          BFI      r2,r3,#24,#6
00123c  e1a03100          LSL      r3,r0,#2
001240  e283320d          ADD      r3,r3,#0xd0000000
001244  e24336fd          SUB      r3,r3,#0xfd00000
001248  e5832124          STR      r2,[r3,#0x124]
;;;935    }
00124c  e12fff1e          BX       lr
;;;936    
                          ENDP

                  boSMC_WaitForZPDEnd PROC
;;;938    
;;;939    bool_t boSMC_WaitForZPDEnd(smc_dev_e eDevice)
001250  e1a01000          MOV      r1,r0
;;;940    {
;;;941        bool_t   boResult = C_TRUE;
001254  e3a00001          MOV      r0,#1
;;;942        uint32_t u32Mask;
;;;943        
;;;944        if (eDevice <= SMC4)
001258  e3510004          CMP      r1,#4
00125c  ca000009          BGT      |L1.4744|
;;;945        {
;;;946            u32Mask = (0x01U<<eDevice);
001260  e3a03001          MOV      r3,#1
001264  e1a02113          LSL      r2,r3,r1
;;;947            while((u32Mask & biGetSMCINT_ZPDD()) == 0U)
001268  e320f000          NOP      
                  |L1.4716|
00126c  e51f3454          LDR      r3,|L1.3616|
001270  e5933004          LDR      r3,[r3,#4]
001274  e7e43853          UBFX     r3,r3,#16,#5
001278  e0033002          AND      r3,r3,r2
00127c  e3530000          CMP      r3,#0
001280  0afffff9          BEQ      |L1.4716|
001284  ea000000          B        |L1.4748|
                  |L1.4744|
;;;948            {
;;;949                ;
;;;950            }
;;;951        }
;;;952        else
;;;953        {
;;;954            boResult = C_FALSE;
001288  e3a00000          MOV      r0,#0
                  |L1.4748|
;;;955        }
;;;956        return boResult;
;;;957    }
00128c  e12fff1e          BX       lr
;;;958    
                          ENDP

                  boSMC_MoveToZeroPosition PROC
;;;960    
;;;961    bool_t boSMC_MoveToZeroPosition(smc_dev_e eDevice)
001290  e92d4010          PUSH     {r4,lr}
;;;962    {
001294  e1a01000          MOV      r1,r0
;;;963        bool_t   boResult = C_TRUE;
001298  e3a00001          MOV      r0,#1
;;;964        uint32_t u32Mask;
;;;965    
;;;966        if (eDevice <= SMC4)
00129c  e3510004          CMP      r1,#4
0012a0  ca000034          BGT      |L1.4984|
;;;967        {
;;;968            u32Mask = (0x01U<<eDevice);
0012a4  e3a03001          MOV      r3,#1
0012a8  e1a02113          LSL      r2,r3,r1
;;;969            /* set mode of channel */
;;;970            vSetSMCCTRL_MSEL(eDevice, (uint32_t)SMC_ZPD_MODE);
0012ac  e1a03101          LSL      r3,r1,#2
0012b0  e283320d          ADD      r3,r3,#0xd0000000
0012b4  e24336fd          SUB      r3,r3,#0xfd00000
0012b8  e593300c          LDR      r3,[r3,#0xc]
0012bc  e3c33003          BIC      r3,r3,#3
0012c0  e2833002          ADD      r3,r3,#2
0012c4  e1a04101          LSL      r4,r1,#2
0012c8  e284420d          ADD      r4,r4,#0xd0000000
0012cc  e24446fd          SUB      r4,r4,#0xfd00000
0012d0  e584300c          STR      r3,[r4,#0xc]
;;;971            
;;;972            /* clear interrupt */
;;;973            vClrSMCINT_ZPDD(eDevice);
0012d4  e3a03001          MOV      r3,#1
0012d8  e1a03113          LSL      r3,r3,r1
0012dc  e51f44c4          LDR      r4,|L1.3616|
0012e0  e5944004          LDR      r4,[r4,#4]
0012e4  e7d44813          BFI      r4,r3,#16,#5
0012e8  e51f34d0          LDR      r3,|L1.3616|
0012ec  e5834004          STR      r4,[r3,#4]
;;;974            
;;;975            /* set interrupt mask */
;;;976            vSetSMCINT_MASK_MASK_ZPDD(u32Mask & (uint32_t)SMC_ENABLE);
0012f0  e2024001          AND      r4,r2,#1
0012f4  e5933008          LDR      r3,[r3,#8]
0012f8  e7d43814          BFI      r3,r4,#16,#5
0012fc  e51f44e4          LDR      r4,|L1.3616|
001300  e5843008          STR      r3,[r4,#8]
;;;977            
;;;978            /* enable pins */
;;;979            vSetSMCCTRL_OUTEN(eDevice, (uint32_t)SMC_ENABLE);
001304  e1a03101          LSL      r3,r1,#2
001308  e0833004          ADD      r3,r3,r4
00130c  e593300c          LDR      r3,[r3,#0xc]
001310  e3c33004          BIC      r3,r3,#4
001314  e2833004          ADD      r3,r3,#4
001318  e1a04101          LSL      r4,r1,#2
00131c  e284420d          ADD      r4,r4,#0xd0000000
001320  e24446fd          SUB      r4,r4,#0xfd00000
001324  e584300c          STR      r3,[r4,#0xc]
;;;980            
;;;981            /* wait for end of movement */
;;;982            while((u32Mask & biGetSMCINT_ZPDD()) > 0U){}
001328  e320f000          NOP      
                  |L1.4908|
00132c  e51f3514          LDR      r3,|L1.3616|
001330  e5933004          LDR      r3,[r3,#4]
001334  e7e43853          UBFX     r3,r3,#16,#5
001338  e0033002          AND      r3,r3,r2
00133c  e3530000          CMP      r3,#0
001340  1afffff9          BNE      |L1.4908|
;;;983            
;;;984            /* set interrupt mask */
;;;985            vSetSMCINT_MASK_MASK_ZPDD(u32Mask & (uint32_t)SMC_DISABLE);
001344  e3a04000          MOV      r4,#0
001348  e51f3530          LDR      r3,|L1.3616|
00134c  e5933008          LDR      r3,[r3,#8]
001350  e7d43814          BFI      r3,r4,#16,#5
001354  e51f453c          LDR      r4,|L1.3616|
001358  e5843008          STR      r3,[r4,#8]
;;;986            
;;;987            /* clear interrupt */
;;;988            vClrSMCINT_ZPDD(eDevice);
00135c  e3a03001          MOV      r3,#1
001360  e1a03113          LSL      r3,r3,r1
001364  e5944004          LDR      r4,[r4,#4]
001368  e7d44813          BFI      r4,r3,#16,#5
00136c  e51f3554          LDR      r3,|L1.3616|
001370  e5834004          STR      r4,[r3,#4]
001374  ea000000          B        |L1.4988|
                  |L1.4984|
;;;989        }
;;;990       else
;;;991       {
;;;992           boResult = C_FALSE;
001378  e3a00000          MOV      r0,#0
                  |L1.4988|
;;;993       }
;;;994       return boResult;
;;;995    }
00137c  e8bd8010          POP      {r4,pc}
;;;996    
                          ENDP

                  vSMC_ISMUpdateVariablesBeforeRead PROC
;;;998    
;;;999    void vSMC_ISMUpdateVariablesBeforeRead(smc_dev_e eDevice)
001380  e1a01100          LSL      r1,r0,#2
;;;1000   {
;;;1001      vSetSMCISM_CTRL_RD_REQ(eDevice, (uint32_t)SMC_ENABLE);
001384  e281120d          ADD      r1,r1,#0xd0000000
001388  e24116fd          SUB      r1,r1,#0xfd00000
00138c  e5911020          LDR      r1,[r1,#0x20]
001390  e3c11601          BIC      r1,r1,#0x100000
001394  e2811601          ADD      r1,r1,#0x100000
001398  e1a02100          LSL      r2,r0,#2
00139c  e282220d          ADD      r2,r2,#0xd0000000
0013a0  e24226fd          SUB      r2,r2,#0xfd00000
0013a4  e5821020          STR      r1,[r2,#0x20]
;;;1002      while(SMC_ENABLE != (smc_enable_e)biGetSMCISM_CTRL_RD_FLAG(eDevice)) {}
0013a8  e320f000          NOP      
                  |L1.5036|
0013ac  e1a01100          LSL      r1,r0,#2
0013b0  e281120d          ADD      r1,r1,#0xd0000000
0013b4  e24116fd          SUB      r1,r1,#0xfd00000
0013b8  e5911020          LDR      r1,[r1,#0x20]
0013bc  e7e01ad1          UBFX     r1,r1,#21,#1
0013c0  e3510000          CMP      r1,#0
0013c4  0afffff8          BEQ      |L1.5036|
;;;1003   }
0013c8  e12fff1e          BX       lr
;;;1004   
                          ENDP

                  vSMC_SwitchFromZPDToISM PROC
;;;1006   
;;;1007   void vSMC_SwitchFromZPDToISM(smc_dev_e eDevice)
0013cc  e92d4070          PUSH     {r4-r6,lr}
;;;1008   {
0013d0  e1a04000          MOV      r4,r0
;;;1009       uint32_t u32Quadrant;
;;;1010   
;;;1011       vSMC_SetISMFreezeRequest(eDevice, SMC_ENABLE);
0013d4  e3a01001          MOV      r1,#1
0013d8  e1a00004          MOV      r0,r4
0013dc  ebfffffe          BL       vSMC_SetISMFreezeRequest
;;;1012       while (SMC_DISABLE == eSMC_GetISMFreezeRequestFlagStatus(eDevice)) {}
0013e0  e320f000          NOP      
                  |L1.5092|
0013e4  e1a00004          MOV      r0,r4
0013e8  ebfffffe          BL       eSMC_GetISMFreezeRequestFlagStatus
0013ec  e3500000          CMP      r0,#0
0013f0  0afffffb          BEQ      |L1.5092|
;;;1013   
;;;1014       u32Quadrant = biGetSMCZPD_CTRL_QUAD(eDevice);
0013f4  e1a00104          LSL      r0,r4,#2
0013f8  e280020d          ADD      r0,r0,#0xd0000000
0013fc  e24006fd          SUB      r0,r0,#0xfd00000
001400  e5900124          LDR      r0,[r0,#0x124]
001404  e7e15450          UBFX     r5,r0,#8,#2
;;;1015       f32ISMQuadrantOffset[eDevice] = f32DegreePerFullstepVal[eDevice] * (float32_t)(4U - u32Quadrant);
001408  e2650004          RSB      r0,r5,#4
00140c  ebfffffe          BL       __aeabi_ui2f
001410  e1a06000          MOV      r6,r0
001414  e51f05ec          LDR      r0,|L1.3632|
001418  e7901104          LDR      r1,[r0,r4,LSL #2]
00141c  e1a00006          MOV      r0,r6
001420  ebfffffe          BL       __aeabi_fmul
001424  e51f1600          LDR      r1,|L1.3628|
001428  e7810104          STR      r0,[r1,r4,LSL #2]
;;;1016   
;;;1017       vSMC_SetISMPosition(eDevice, (float32_t)0.0);
00142c  e3a01000          MOV      r1,#0
001430  e1a00004          MOV      r0,r4
001434  ebfffffe          BL       vSMC_SetISMPosition
;;;1018   
;;;1019       vSMC_SetChannelMode(eDevice, SMC_ISM_MODE);
001438  e3a01000          MOV      r1,#0
00143c  e1a00004          MOV      r0,r4
001440  ebfffffe          BL       vSMC_SetChannelMode
;;;1020       vSMC_SetISMFreezeRequest(eDevice, SMC_DISABLE);
001444  e3a01000          MOV      r1,#0
001448  e1a00004          MOV      r0,r4
00144c  ebfffffe          BL       vSMC_SetISMFreezeRequest
;;;1021   }
001450  e8bd8070          POP      {r4-r6,pc}
;;;1022   
                          ENDP

                  u32SMC_SwitchFromZPDToPWM PROC
;;;1024   
;;;1025   uint32_t u32SMC_SwitchFromZPDToPWM(smc_dev_e eDevice)
001454  e92d4030          PUSH     {r4,r5,lr}
;;;1026   {
001458  e1a04000          MOV      r4,r0
;;;1027       uint32_t u32Quadrant;
;;;1028   
;;;1029       u32Quadrant = biGetSMCZPD_CTRL_QUAD(eDevice);
00145c  e1a00104          LSL      r0,r4,#2
001460  e280020d          ADD      r0,r0,#0xd0000000
001464  e24006fd          SUB      r0,r0,#0xfd00000
001468  e5900124          LDR      r0,[r0,#0x124]
00146c  e7e15450          UBFX     r5,r0,#8,#2
;;;1030   
;;;1031       vSMC_SetChannelMode(eDevice, SMC_PWM_MODE);
001470  e3a01001          MOV      r1,#1
001474  e1a00004          MOV      r0,r4
001478  ebfffffe          BL       vSMC_SetChannelMode
;;;1032   
;;;1033       return u32Quadrant;
00147c  e1a00005          MOV      r0,r5
;;;1034   }
001480  e8bd8030          POP      {r4,r5,pc}
;;;1035   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  f32DegreePerFullstepVal
                          %        20
                  f32ISMQuadrantOffset
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  au8LLDD_SMC_C_REVISION
000000  24526576          DCB      0x24,0x52,0x65,0x76
000004  6973696f          DCB      0x69,0x73,0x69,0x6f
000008  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00000c  2e313320          DCB      0x2e,0x31,0x33,0x20
000010  2400              DCB      0x24,0x00
                  au8LLDD_SMC_C_TAG
000012  244e              DCB      0x24,0x4e
000014  616d653a          DCB      0x61,0x6d,0x65,0x3a
000018  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00001c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000020  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_SMC_H_REVISION
000024  24526576          DCB      0x24,0x52,0x65,0x76
000028  6973696f          DCB      0x69,0x73,0x69,0x6f
00002c  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000030  2e313420          DCB      0x2e,0x31,0x34,0x20
000034  2400              DCB      0x24,0x00
                  au8LLDD_SMC_H_TAG
000036  244e              DCB      0x24,0x4e
000038  616d653a          DCB      0x61,0x6d,0x65,0x3a
00003c  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000040  445f315f          DCB      0x44,0x5f,0x31,0x5f
000044  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_SMC_IO_H_REVISION
000048  24526576          DCB      0x24,0x52,0x65,0x76
00004c  6973696f          DCB      0x69,0x73,0x69,0x6f
000050  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000054  2e313020          DCB      0x2e,0x31,0x30,0x20
000058  2400              DCB      0x24,0x00
                  au8LLDD_SMC_IO_H_TAG
00005a  244e              DCB      0x24,0x4e
00005c  616d653a          DCB      0x61,0x6d,0x65,0x3a
000060  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000064  445f315f          DCB      0x44,0x5f,0x31,0x5f
000068  36202400          DCB      0x36,0x20,0x24,0x00
                  eTableModeVal
                          DCDU     0x00000000
000070  00                DCB      0x00
