L 1 "..\..\..\..\lldd\src\qspic.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : QSPI controler low level register access
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : QSPI
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.40 $
N*   DATE        : $Date: 2015/05/18 13:49:55 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "qspic_io.h"                   /* Own definitions */
L 1 "..\..\..\..\lldd\hdr\qspic_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : QSPIC 
N/  Date of creation (y-m-d:time): 2015-01-20+01:00  :  09:50:23.19+01:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.25 $ 
N/  Excel Sheet ver.             : v1.21
N/  Excel Sheet date             : 2015-Jan-12
N/  Excel Sheet author           : ALN
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : QSPI low level driver io-header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : QSPI
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.25 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef QSPICIO_H
N#define QSPICIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 40 "..\..\..\..\lldd\hdr\qspic_io.h" 2
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_QSPIC_IO_H_REVISION     "$Revision: 1.25 $"
N#define LLDD_QSPIC_IO_H_TAG          "$Name: LLDD_1_6 $"
N
N/* disable following Misra errors for io files */
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1840   /* Rule 5.7   [A] : No reuse of identifiers  */
S  #pragma ghs nowarning 230    /* Rule 6.4   [R] : Bitfields can only have `unsigned int' or `signed int' types */
S  #pragma ghs nowarning 1829   /* Rule 19.10 [R] : 	In function-like macro definition, wrap each parameter reference in parentheses */
N#endif
N
N/****************************************************************************
N*                          CONTROLER SELECTION MACROS
N*             (Please use these macros to select module instances)
N*****************************************************************************/
Ntypedef enum tag_qspic_cntrl_def_e
N{
N  QSPIC_CNTRL_0__ = 0,
N  QSPIC_CNTRL_1__ = 0xAF8000,
N  QSPIC_CNTRL_2__ = 0x1000 
N} qspic_cntrl_def_e; 
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_FlshMemMap0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109000                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_FlshMemMap0_REG__       0xC0109000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   RE	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   RSRVD1	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   FDEN	:4; 	 /* 2..5  bit(s) R/W */
N  uint32_t   RSRVD6	:10; 	 /* 6..15  bit(s) R */ 
N  uint32_t   FBA	:16; 	 /* 16..31  bit(s) R/W */                    
N} QSPIC_FlshMemMap0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_FlshMemMap0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_FlshMemMap0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_FlshMemMap0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_FlshMemMap0(ctrlr)     ((volatile QSPIC_FlshMemMap0_bit_view_st *)\
N(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_FlshMemMap0(ctrlr)     ((volatile QSPIC_FlshMemMap0_bit_view_st *)(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_FlshMemMap0(ctrlr)     ((volatile QSPIC_FlshMemMap0_byte_view_st *)\
N(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_FlshMemMap0(ctrlr)     ((volatile QSPIC_FlshMemMap0_byte_view_st *)(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_FlshMemMap0(ctrlr)     ((volatile QSPIC_FlshMemMap0_halfword_view_st *)\
N(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_FlshMemMap0(ctrlr)     ((volatile QSPIC_FlshMemMap0_halfword_view_st *)(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_FlshMemMap0(ctrlr)     ((volatile u32QSPIC_FlshMemMap0_word_view *)\
N(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_FlshMemMap0(ctrlr)     ((volatile u32QSPIC_FlshMemMap0_word_view *)(QSPIC_FlshMemMap0_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_FlshMemMap0_RE(ctrlr) (pst_bitQSPIC_FlshMemMap0(ctrlr) -> RE)
N#define vSetQSPIC_FlshMemMap0_RE(ctrlr,ParValue)  (pst_bitQSPIC_FlshMemMap0(ctrlr) -> RE=(ParValue))            
N#define biGetQSPIC_FlshMemMap0_RSRVD1(ctrlr) (pst_bitQSPIC_FlshMemMap0(ctrlr) -> RSRVD1)
N#define biGetQSPIC_FlshMemMap0_FDEN(ctrlr) (pst_bitQSPIC_FlshMemMap0(ctrlr) -> FDEN)
N#define vSetQSPIC_FlshMemMap0_FDEN(ctrlr,ParValue)  (pst_bitQSPIC_FlshMemMap0(ctrlr) -> FDEN=(ParValue))            
N#define biGetQSPIC_FlshMemMap0_RSRVD6(ctrlr) (pst_bitQSPIC_FlshMemMap0(ctrlr) -> RSRVD6)
N#define biGetQSPIC_FlshMemMap0_FBA(ctrlr) (pst_bitQSPIC_FlshMemMap0(ctrlr) -> FBA)
N#define vSetQSPIC_FlshMemMap0_FBA(ctrlr,ParValue)  (pst_bitQSPIC_FlshMemMap0(ctrlr) -> FBA=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetQSPIC_FlshMemMap0LL(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_FlshMemMap0LL(ctrlr) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_FlshMemMap0LH(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_FlshMemMap0LH(ctrlr) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_FlshMemMap0HL(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_FlshMemMap0HL(ctrlr) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_FlshMemMap0HH(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_FlshMemMap0HH(ctrlr) (pst_u8QSPIC_FlshMemMap0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_FlshMemMap0L(ctrlr,ParValue) (pst_u16QSPIC_FlshMemMap0(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_FlshMemMap0L(ctrlr) (pst_u16QSPIC_FlshMemMap0(ctrlr) -> u16L)
N#define vSetQSPIC_FlshMemMap0H(ctrlr,ParValue) (pst_u16QSPIC_FlshMemMap0(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_FlshMemMap0H(ctrlr) (pst_u16QSPIC_FlshMemMap0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_FlshMemMap0(ctrlr,ParValue)  (*pu32QSPIC_FlshMemMap0(ctrlr) = (ParValue))
N#define u32GetQSPIC_FlshMemMap0(ctrlr)  (*pu32QSPIC_FlshMemMap0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_FlshMemMap1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109004                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_FlshMemMap1_REG__       0xC0109004U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   RE	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   RSRVD1	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   FDEN	:4; 	 /* 2..5  bit(s) R/W */
N  uint32_t   RSRVD6	:10; 	 /* 6..15  bit(s) R */ 
N  uint32_t   FBA	:16; 	 /* 16..31  bit(s) R/W */                    
N} QSPIC_FlshMemMap1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_FlshMemMap1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_FlshMemMap1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_FlshMemMap1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_FlshMemMap1(ctrlr)     ((volatile QSPIC_FlshMemMap1_bit_view_st *)\
N(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_FlshMemMap1(ctrlr)     ((volatile QSPIC_FlshMemMap1_bit_view_st *)(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_FlshMemMap1(ctrlr)     ((volatile QSPIC_FlshMemMap1_byte_view_st *)\
N(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_FlshMemMap1(ctrlr)     ((volatile QSPIC_FlshMemMap1_byte_view_st *)(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_FlshMemMap1(ctrlr)     ((volatile QSPIC_FlshMemMap1_halfword_view_st *)\
N(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_FlshMemMap1(ctrlr)     ((volatile QSPIC_FlshMemMap1_halfword_view_st *)(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_FlshMemMap1(ctrlr)     ((volatile u32QSPIC_FlshMemMap1_word_view *)\
N(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_FlshMemMap1(ctrlr)     ((volatile u32QSPIC_FlshMemMap1_word_view *)(QSPIC_FlshMemMap1_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_FlshMemMap1_RE(ctrlr) (pst_bitQSPIC_FlshMemMap1(ctrlr) -> RE)
N#define vSetQSPIC_FlshMemMap1_RE(ctrlr,ParValue)  (pst_bitQSPIC_FlshMemMap1(ctrlr) -> RE=(ParValue))            
N#define biGetQSPIC_FlshMemMap1_RSRVD1(ctrlr) (pst_bitQSPIC_FlshMemMap1(ctrlr) -> RSRVD1)
N#define biGetQSPIC_FlshMemMap1_FDEN(ctrlr) (pst_bitQSPIC_FlshMemMap1(ctrlr) -> FDEN)
N#define vSetQSPIC_FlshMemMap1_FDEN(ctrlr,ParValue)  (pst_bitQSPIC_FlshMemMap1(ctrlr) -> FDEN=(ParValue))            
N#define biGetQSPIC_FlshMemMap1_RSRVD6(ctrlr) (pst_bitQSPIC_FlshMemMap1(ctrlr) -> RSRVD6)
N#define biGetQSPIC_FlshMemMap1_FBA(ctrlr) (pst_bitQSPIC_FlshMemMap1(ctrlr) -> FBA)
N#define vSetQSPIC_FlshMemMap1_FBA(ctrlr,ParValue)  (pst_bitQSPIC_FlshMemMap1(ctrlr) -> FBA=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetQSPIC_FlshMemMap1LL(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_FlshMemMap1LL(ctrlr) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_FlshMemMap1LH(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_FlshMemMap1LH(ctrlr) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_FlshMemMap1HL(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_FlshMemMap1HL(ctrlr) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_FlshMemMap1HH(ctrlr,ParValue) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_FlshMemMap1HH(ctrlr) (pst_u8QSPIC_FlshMemMap1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_FlshMemMap1L(ctrlr,ParValue) (pst_u16QSPIC_FlshMemMap1(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_FlshMemMap1L(ctrlr) (pst_u16QSPIC_FlshMemMap1(ctrlr) -> u16L)
N#define vSetQSPIC_FlshMemMap1H(ctrlr,ParValue) (pst_u16QSPIC_FlshMemMap1(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_FlshMemMap1H(ctrlr) (pst_u16QSPIC_FlshMemMap1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_FlshMemMap1(ctrlr,ParValue)  (*pu32QSPIC_FlshMemMap1(ctrlr) = (ParValue))
N#define u32GetQSPIC_FlshMemMap1(ctrlr)  (*pu32QSPIC_FlshMemMap1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_DirAccCtrl0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109008                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_DirAccCtrl0_REG__       0xC0109008U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SMOD	:2; 	 /* 0..1  bit(s) R */
N  uint32_t   RSRVD2	:2; 	 /* 2..3  bit(s) R */
N  uint32_t   SDCE	:2; 	 /* 4..5  bit(s) R/W */
N  uint32_t   PollWIP	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   RSRVD7	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   SCSD	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   RSRVD16	:5; 	 /* 16..20  bit(s) R */ 
N  uint32_t   RSRVD21	:11; 	 /* 21..31  bit(s) R */
N} QSPIC_DirAccCtrl0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_DirAccCtrl0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_DirAccCtrl0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_DirAccCtrl0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_DirAccCtrl0(ctrlr)     ((volatile QSPIC_DirAccCtrl0_bit_view_st *)\
N(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_DirAccCtrl0(ctrlr)     ((volatile QSPIC_DirAccCtrl0_bit_view_st *)(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_DirAccCtrl0(ctrlr)     ((volatile QSPIC_DirAccCtrl0_byte_view_st *)\
N(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_DirAccCtrl0(ctrlr)     ((volatile QSPIC_DirAccCtrl0_byte_view_st *)(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_DirAccCtrl0(ctrlr)     ((volatile QSPIC_DirAccCtrl0_halfword_view_st *)\
N(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_DirAccCtrl0(ctrlr)     ((volatile QSPIC_DirAccCtrl0_halfword_view_st *)(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_DirAccCtrl0(ctrlr)     ((volatile u32QSPIC_DirAccCtrl0_word_view *)\
N(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_DirAccCtrl0(ctrlr)     ((volatile u32QSPIC_DirAccCtrl0_word_view *)(QSPIC_DirAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetQSPIC_DirAccCtrl0_SMOD(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> SMOD)            
N#define biGetQSPIC_DirAccCtrl0_RSRVD2(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> RSRVD2)
N#define biGetQSPIC_DirAccCtrl0_SDCE(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> SDCE)
N#define vSetQSPIC_DirAccCtrl0_SDCE(ctrlr,ParValue)  (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> SDCE=(ParValue))
N#define biGetQSPIC_DirAccCtrl0_PollWIP(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> PollWIP)
N#define vSetQSPIC_DirAccCtrl0_PollWIP(ctrlr,ParValue)  (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> PollWIP=(ParValue))            
N#define biGetQSPIC_DirAccCtrl0_RSRVD7(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> RSRVD7)
N#define biGetQSPIC_DirAccCtrl0_SCSD(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> SCSD)
N#define vSetQSPIC_DirAccCtrl0_SCSD(ctrlr,ParValue)  (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> SCSD=(ParValue))            
N#define biGetQSPIC_DirAccCtrl0_RSRVD16(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> RSRVD16)            
N#define biGetQSPIC_DirAccCtrl0_RSRVD21(ctrlr) (pst_bitQSPIC_DirAccCtrl0(ctrlr) -> RSRVD21)
N            
N/* LL-struct byte access */
N#define vSetQSPIC_DirAccCtrl0LL(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_DirAccCtrl0LL(ctrlr) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_DirAccCtrl0LH(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_DirAccCtrl0LH(ctrlr) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_DirAccCtrl0HL(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_DirAccCtrl0HL(ctrlr) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_DirAccCtrl0HH(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_DirAccCtrl0HH(ctrlr) (pst_u8QSPIC_DirAccCtrl0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_DirAccCtrl0L(ctrlr,ParValue) (pst_u16QSPIC_DirAccCtrl0(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_DirAccCtrl0L(ctrlr) (pst_u16QSPIC_DirAccCtrl0(ctrlr) -> u16L)
N#define vSetQSPIC_DirAccCtrl0H(ctrlr,ParValue) (pst_u16QSPIC_DirAccCtrl0(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_DirAccCtrl0H(ctrlr) (pst_u16QSPIC_DirAccCtrl0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_DirAccCtrl0(ctrlr,ParValue)  (*pu32QSPIC_DirAccCtrl0(ctrlr) = (ParValue))
N#define u32GetQSPIC_DirAccCtrl0(ctrlr)  (*pu32QSPIC_DirAccCtrl0(ctrlr) )                 
N
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_DirAccCtrl1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010900C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_DirAccCtrl1_REG__       0xC010900CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SMOD	:2; 	 /* 0..1  bit(s) R */
N  uint32_t   RSRVD2	:2; 	 /* 2..3  bit(s) R */
N  uint32_t   SDCE	:2; 	 /* 4..5  bit(s) R/W */
N  uint32_t   PollWIP	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   RSRVD7	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   SCSD	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   RSRVD16	:5; 	 /* 16..20  bit(s) R */ 
N  uint32_t   RSRVD21	:11; 	 /* 21..31  bit(s) R */                                        
N} QSPIC_DirAccCtrl1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_DirAccCtrl1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_DirAccCtrl1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_DirAccCtrl1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_DirAccCtrl1(ctrlr)     ((volatile QSPIC_DirAccCtrl1_bit_view_st *)\
N(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_DirAccCtrl1(ctrlr)     ((volatile QSPIC_DirAccCtrl1_bit_view_st *)(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_DirAccCtrl1(ctrlr)     ((volatile QSPIC_DirAccCtrl1_byte_view_st *)\
N(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_DirAccCtrl1(ctrlr)     ((volatile QSPIC_DirAccCtrl1_byte_view_st *)(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_DirAccCtrl1(ctrlr)     ((volatile QSPIC_DirAccCtrl1_halfword_view_st *)\
N(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_DirAccCtrl1(ctrlr)     ((volatile QSPIC_DirAccCtrl1_halfword_view_st *)(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_DirAccCtrl1(ctrlr)     ((volatile u32QSPIC_DirAccCtrl1_word_view *)\
N(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_DirAccCtrl1(ctrlr)     ((volatile u32QSPIC_DirAccCtrl1_word_view *)(QSPIC_DirAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetQSPIC_DirAccCtrl1_SMOD(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> SMOD)            
N#define biGetQSPIC_DirAccCtrl1_RSRVD2(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> RSRVD2)
N#define biGetQSPIC_DirAccCtrl1_SDCE(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> SDCE)
N#define vSetQSPIC_DirAccCtrl1_SDCE(ctrlr,ParValue)  (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> SDCE=(ParValue))
N#define biGetQSPIC_DirAccCtrl1_PollWIP(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> PollWIP)
N#define vSetQSPIC_DirAccCtrl1_PollWIP(ctrlr,ParValue)  (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> PollWIP=(ParValue))            
N#define biGetQSPIC_DirAccCtrl1_RSRVD7(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> RSRVD7)
N#define biGetQSPIC_DirAccCtrl1_SCSD(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> SCSD)
N#define vSetQSPIC_DirAccCtrl1_SCSD(ctrlr,ParValue)  (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> SCSD=(ParValue))            
N#define biGetQSPIC_DirAccCtrl1_RSRVD16(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> RSRVD16)            
N#define biGetQSPIC_DirAccCtrl1_RSRVD21(ctrlr) (pst_bitQSPIC_DirAccCtrl1(ctrlr) -> RSRVD21)
N            
N/* LL-struct byte access */
N#define vSetQSPIC_DirAccCtrl1LL(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_DirAccCtrl1LL(ctrlr) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_DirAccCtrl1LH(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_DirAccCtrl1LH(ctrlr) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_DirAccCtrl1HL(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_DirAccCtrl1HL(ctrlr) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_DirAccCtrl1HH(ctrlr,ParValue) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_DirAccCtrl1HH(ctrlr) (pst_u8QSPIC_DirAccCtrl1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_DirAccCtrl1L(ctrlr,ParValue) (pst_u16QSPIC_DirAccCtrl1(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_DirAccCtrl1L(ctrlr) (pst_u16QSPIC_DirAccCtrl1(ctrlr) -> u16L)
N#define vSetQSPIC_DirAccCtrl1H(ctrlr,ParValue) (pst_u16QSPIC_DirAccCtrl1(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_DirAccCtrl1H(ctrlr) (pst_u16QSPIC_DirAccCtrl1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_DirAccCtrl1(ctrlr,ParValue)  (*pu32QSPIC_DirAccCtrl1(ctrlr) = (ParValue))
N#define u32GetQSPIC_DirAccCtrl1(ctrlr)  (*pu32QSPIC_DirAccCtrl1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_DirRdCtrl0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_DirRdCtrl0_REG__       0xC0109010U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SpiCmdIOCtrl	:2; 	 /* 0..1  bit(s) R */
N  uint32_t   SpiAdrIOCtrl	:2; 	 /* 2..3  bit(s) R/W */
N  uint32_t   SpiDmyIOCtrl	:2; 	 /* 4..5  bit(s) R/W */
N  uint32_t   SpiDatIOCtrl	:2; 	 /* 6..7  bit(s) R/W */
N  uint32_t   RSRVD8	:3; 	 /* 8..10  bit(s) R */
N  uint32_t   SpiAddrByteCnt	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   SpiDmyByteCnt	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   RSRVD16	:8; 	 /* 16..23  bit(s) R */ 
N  uint32_t   SpiRdCmdOp	:8; 	 /* 24..31  bit(s) R/W */                                        
N} QSPIC_DirRdCtrl0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_DirRdCtrl0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_DirRdCtrl0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_DirRdCtrl0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_DirRdCtrl0(ctrlr)     ((volatile QSPIC_DirRdCtrl0_bit_view_st *)\
N(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_DirRdCtrl0(ctrlr)     ((volatile QSPIC_DirRdCtrl0_bit_view_st *)(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_DirRdCtrl0(ctrlr)     ((volatile QSPIC_DirRdCtrl0_byte_view_st *)\
N(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_DirRdCtrl0(ctrlr)     ((volatile QSPIC_DirRdCtrl0_byte_view_st *)(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_DirRdCtrl0(ctrlr)     ((volatile QSPIC_DirRdCtrl0_halfword_view_st *)\
N(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_DirRdCtrl0(ctrlr)     ((volatile QSPIC_DirRdCtrl0_halfword_view_st *)(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_DirRdCtrl0(ctrlr)     ((volatile u32QSPIC_DirRdCtrl0_word_view *)\
N(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_DirRdCtrl0(ctrlr)     ((volatile u32QSPIC_DirRdCtrl0_word_view *)(QSPIC_DirRdCtrl0_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetQSPIC_DirRdCtrl0_SpiCmdIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiCmdIOCtrl)
N#define biGetQSPIC_DirRdCtrl0_SpiAdrIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiAdrIOCtrl)
N#define vSetQSPIC_DirRdCtrl0_SpiAdrIOCtrl(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiAdrIOCtrl=(ParValue))
N#define biGetQSPIC_DirRdCtrl0_SpiDmyIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiDmyIOCtrl)
N#define vSetQSPIC_DirRdCtrl0_SpiDmyIOCtrl(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiDmyIOCtrl=(ParValue))
N#define biGetQSPIC_DirRdCtrl0_SpiDatIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiDatIOCtrl)
N#define vSetQSPIC_DirRdCtrl0_SpiDatIOCtrl(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiDatIOCtrl=(ParValue))            
N#define biGetQSPIC_DirRdCtrl0_RSRVD8(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> RSRVD8)
N#define biGetQSPIC_DirRdCtrl0_SpiAddrByteCnt(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiAddrByteCnt)
N#define vSetQSPIC_DirRdCtrl0_SpiAddrByteCnt(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiAddrByteCnt=(ParValue))
N#define biGetQSPIC_DirRdCtrl0_SpiDmyByteCnt(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiDmyByteCnt)
N#define vSetQSPIC_DirRdCtrl0_SpiDmyByteCnt(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiDmyByteCnt=(ParValue))            
N#define biGetQSPIC_DirRdCtrl0_RSRVD16(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> RSRVD16)
N#define biGetQSPIC_DirRdCtrl0_SpiRdCmdOp(ctrlr) (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiRdCmdOp)
N#define vSetQSPIC_DirRdCtrl0_SpiRdCmdOp(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl0(ctrlr) -> SpiRdCmdOp=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetQSPIC_DirRdCtrl0LL(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_DirRdCtrl0LL(ctrlr) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_DirRdCtrl0LH(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_DirRdCtrl0LH(ctrlr) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_DirRdCtrl0HL(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_DirRdCtrl0HL(ctrlr) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_DirRdCtrl0HH(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_DirRdCtrl0HH(ctrlr) (pst_u8QSPIC_DirRdCtrl0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_DirRdCtrl0L(ctrlr,ParValue) (pst_u16QSPIC_DirRdCtrl0(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_DirRdCtrl0L(ctrlr) (pst_u16QSPIC_DirRdCtrl0(ctrlr) -> u16L)
N#define vSetQSPIC_DirRdCtrl0H(ctrlr,ParValue) (pst_u16QSPIC_DirRdCtrl0(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_DirRdCtrl0H(ctrlr) (pst_u16QSPIC_DirRdCtrl0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_DirRdCtrl0(ctrlr,ParValue)  (*pu32QSPIC_DirRdCtrl0(ctrlr) = (ParValue))
N#define u32GetQSPIC_DirRdCtrl0(ctrlr)  (*pu32QSPIC_DirRdCtrl0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_DirRdCtrl1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109014                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_DirRdCtrl1_REG__       0xC0109014U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SpiCmdIOCtrl	:2; 	 /* 0..1  bit(s) R */
N  uint32_t   SpiAdrIOCtrl	:2; 	 /* 2..3  bit(s) R/W */
N  uint32_t   SpiDmyIOCtrl	:2; 	 /* 4..5  bit(s) R/W */
N  uint32_t   SpiDatIOCtrl	:2; 	 /* 6..7  bit(s) R/W */
N  uint32_t   RSRVD8	:3; 	 /* 8..10  bit(s) R */
N  uint32_t   SpiAddrByteCnt	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   SpiDmyByteCnt	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   RSRVD16	:8; 	 /* 16..23  bit(s) R */ 
N  uint32_t   SpiRdCmdOp	:8; 	 /* 24..31  bit(s) R/W */ 
N} QSPIC_DirRdCtrl1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_DirRdCtrl1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_DirRdCtrl1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_DirRdCtrl1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_DirRdCtrl1(ctrlr)     ((volatile QSPIC_DirRdCtrl1_bit_view_st *)\
N(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_DirRdCtrl1(ctrlr)     ((volatile QSPIC_DirRdCtrl1_bit_view_st *)(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_DirRdCtrl1(ctrlr)     ((volatile QSPIC_DirRdCtrl1_byte_view_st *)\
N(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_DirRdCtrl1(ctrlr)     ((volatile QSPIC_DirRdCtrl1_byte_view_st *)(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_DirRdCtrl1(ctrlr)     ((volatile QSPIC_DirRdCtrl1_halfword_view_st *)\
N(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_DirRdCtrl1(ctrlr)     ((volatile QSPIC_DirRdCtrl1_halfword_view_st *)(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_DirRdCtrl1(ctrlr)     ((volatile u32QSPIC_DirRdCtrl1_word_view *)\
N(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_DirRdCtrl1(ctrlr)     ((volatile u32QSPIC_DirRdCtrl1_word_view *)(QSPIC_DirRdCtrl1_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetQSPIC_DirRdCtrl1_SpiCmdIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiCmdIOCtrl)
N#define biGetQSPIC_DirRdCtrl1_SpiAdrIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiAdrIOCtrl)
N#define vSetQSPIC_DirRdCtrl1_SpiAdrIOCtrl(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiAdrIOCtrl=(ParValue))
N#define biGetQSPIC_DirRdCtrl1_SpiDmyIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiDmyIOCtrl)
N#define vSetQSPIC_DirRdCtrl1_SpiDmyIOCtrl(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiDmyIOCtrl=(ParValue))
N#define biGetQSPIC_DirRdCtrl1_SpiDatIOCtrl(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiDatIOCtrl)
N#define vSetQSPIC_DirRdCtrl1_SpiDatIOCtrl(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiDatIOCtrl=(ParValue))            
N#define biGetQSPIC_DirRdCtrl1_RSRVD8(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> RSRVD8)
N#define biGetQSPIC_DirRdCtrl1_SpiAddrByteCnt(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiAddrByteCnt)
N#define vSetQSPIC_DirRdCtrl1_SpiAddrByteCnt(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiAddrByteCnt=(ParValue))
N#define biGetQSPIC_DirRdCtrl1_SpiDmyByteCnt(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiDmyByteCnt)
N#define vSetQSPIC_DirRdCtrl1_SpiDmyByteCnt(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiDmyByteCnt=(ParValue))            
N#define biGetQSPIC_DirRdCtrl1_RSRVD16(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> RSRVD16)
N#define biGetQSPIC_DirRdCtrl1_SpiRdCmdOp(ctrlr) (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiRdCmdOp)
N#define vSetQSPIC_DirRdCtrl1_SpiRdCmdOp(ctrlr,ParValue)  (pst_bitQSPIC_DirRdCtrl1(ctrlr) -> SpiRdCmdOp=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetQSPIC_DirRdCtrl1LL(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_DirRdCtrl1LL(ctrlr) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_DirRdCtrl1LH(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_DirRdCtrl1LH(ctrlr) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_DirRdCtrl1HL(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_DirRdCtrl1HL(ctrlr) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_DirRdCtrl1HH(ctrlr,ParValue) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_DirRdCtrl1HH(ctrlr) (pst_u8QSPIC_DirRdCtrl1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_DirRdCtrl1L(ctrlr,ParValue) (pst_u16QSPIC_DirRdCtrl1(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_DirRdCtrl1L(ctrlr) (pst_u16QSPIC_DirRdCtrl1(ctrlr) -> u16L)
N#define vSetQSPIC_DirRdCtrl1H(ctrlr,ParValue) (pst_u16QSPIC_DirRdCtrl1(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_DirRdCtrl1H(ctrlr) (pst_u16QSPIC_DirRdCtrl1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_DirRdCtrl1(ctrlr,ParValue)  (*pu32QSPIC_DirRdCtrl1(ctrlr) = (ParValue))
N#define u32GetQSPIC_DirRdCtrl1(ctrlr)  (*pu32QSPIC_DirRdCtrl1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_PrgAccCtrl0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109400                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_PrgAccCtrl0_REG__       0xC0109400U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SMOD	:2; 	 /* 0..1  bit(s) R */
N  uint32_t   RSRVD2	:2; 	 /* 2..3  bit(s) R */
N  uint32_t   SDCE	:2; 	 /* 4..5  bit(s) R/W */
N  uint32_t   RSRVD6	:2; 	 /* 6..7  bit(s) R */
N  uint32_t   SCSD	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   RSRVD16	:5; 	 /* 16..20  bit(s) R */ 
N  uint32_t   RSRVD21	:11; 	 /* 21..31  bit(s) R */
N} QSPIC_PrgAccCtrl0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_PrgAccCtrl0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_PrgAccCtrl0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_PrgAccCtrl0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_PrgAccCtrl0(ctrlr)     ((volatile QSPIC_PrgAccCtrl0_bit_view_st *)\
N(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_PrgAccCtrl0(ctrlr)     ((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_PrgAccCtrl0(ctrlr)     ((volatile QSPIC_PrgAccCtrl0_byte_view_st *)\
N(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_PrgAccCtrl0(ctrlr)     ((volatile QSPIC_PrgAccCtrl0_byte_view_st *)(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_PrgAccCtrl0(ctrlr)     ((volatile QSPIC_PrgAccCtrl0_halfword_view_st *)\
N(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_PrgAccCtrl0(ctrlr)     ((volatile QSPIC_PrgAccCtrl0_halfword_view_st *)(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_PrgAccCtrl0(ctrlr)     ((volatile u32QSPIC_PrgAccCtrl0_word_view *)\
N(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_PrgAccCtrl0(ctrlr)     ((volatile u32QSPIC_PrgAccCtrl0_word_view *)(QSPIC_PrgAccCtrl0_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetQSPIC_PrgAccCtrl0_SMOD(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> SMOD)            
N#define biGetQSPIC_PrgAccCtrl0_RSRVD2(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> RSRVD2)
N#define biGetQSPIC_PrgAccCtrl0_SDCE(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> SDCE)
N#define vSetQSPIC_PrgAccCtrl0_SDCE(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> SDCE=(ParValue))            
N#define biGetQSPIC_PrgAccCtrl0_RSRVD6(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> RSRVD6)
N#define biGetQSPIC_PrgAccCtrl0_SCSD(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> SCSD)
N#define vSetQSPIC_PrgAccCtrl0_SCSD(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> SCSD=(ParValue))
N#define biGetQSPIC_PrgAccCtrl0_RSRVD16(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> RSRVD16)
N#define biGetQSPIC_PrgAccCtrl0_RSRVD21(ctrlr) (pst_bitQSPIC_PrgAccCtrl0(ctrlr) -> RSRVD21)
N            
N/* LL-struct byte access */
N#define vSetQSPIC_PrgAccCtrl0LL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl0LL(ctrlr) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_PrgAccCtrl0LH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl0LH(ctrlr) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_PrgAccCtrl0HL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl0HL(ctrlr) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_PrgAccCtrl0HH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl0HH(ctrlr) (pst_u8QSPIC_PrgAccCtrl0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_PrgAccCtrl0L(ctrlr,ParValue) (pst_u16QSPIC_PrgAccCtrl0(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_PrgAccCtrl0L(ctrlr) (pst_u16QSPIC_PrgAccCtrl0(ctrlr) -> u16L)
N#define vSetQSPIC_PrgAccCtrl0H(ctrlr,ParValue) (pst_u16QSPIC_PrgAccCtrl0(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_PrgAccCtrl0H(ctrlr) (pst_u16QSPIC_PrgAccCtrl0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_PrgAccCtrl0(ctrlr,ParValue)  (*pu32QSPIC_PrgAccCtrl0(ctrlr) = (ParValue))
N#define u32GetQSPIC_PrgAccCtrl0(ctrlr)  (*pu32QSPIC_PrgAccCtrl0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_PrgAccCtrl1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109404                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_PrgAccCtrl1_REG__       0xC0109404U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SpiCycGo	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   SpiCsNum	:1; 	 /* 1..1  bit(s) R/W */
N  uint32_t   RSRVD2	:2; 	 /* 2..3  bit(s) R */
N  uint32_t   PriBufEn	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   SecBufEn	:1; 	 /* 5..5  bit(s) R/W */
N  uint32_t   RSRVD6	:10; 	 /* 6..15  bit(s) R */
N  uint32_t   PriBufDatByteCnt	:3; 	 /* 16..18  bit(s) R/W */
N  uint32_t   RSRVD19	:5; 	 /* 19..23  bit(s) R */ 
N  uint32_t   SecBufDatByteCnt	:8; 	 /* 24..31  bit(s) R/W */                    
N} QSPIC_PrgAccCtrl1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_PrgAccCtrl1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_PrgAccCtrl1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_PrgAccCtrl1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_PrgAccCtrl1(ctrlr)     ((volatile QSPIC_PrgAccCtrl1_bit_view_st *)\
N(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_PrgAccCtrl1(ctrlr)     ((volatile QSPIC_PrgAccCtrl1_bit_view_st *)(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_PrgAccCtrl1(ctrlr)     ((volatile QSPIC_PrgAccCtrl1_byte_view_st *)\
N(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_PrgAccCtrl1(ctrlr)     ((volatile QSPIC_PrgAccCtrl1_byte_view_st *)(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_PrgAccCtrl1(ctrlr)     ((volatile QSPIC_PrgAccCtrl1_halfword_view_st *)\
N(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_PrgAccCtrl1(ctrlr)     ((volatile QSPIC_PrgAccCtrl1_halfword_view_st *)(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_PrgAccCtrl1(ctrlr)     ((volatile u32QSPIC_PrgAccCtrl1_word_view *)\
N(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_PrgAccCtrl1(ctrlr)     ((volatile u32QSPIC_PrgAccCtrl1_word_view *)(QSPIC_PrgAccCtrl1_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_PrgAccCtrl1_SpiCycGo(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SpiCycGo)
N#define vSetQSPIC_PrgAccCtrl1_SpiCycGo(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SpiCycGo=(ParValue))
N#define biGetQSPIC_PrgAccCtrl1_SpiCsNum(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SpiCsNum)
N#define vSetQSPIC_PrgAccCtrl1_SpiCsNum(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SpiCsNum=(ParValue))            
N#define biGetQSPIC_PrgAccCtrl1_RSRVD2(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> RSRVD2)
N#define biGetQSPIC_PrgAccCtrl1_PriBufEn(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> PriBufEn)
N#define vSetQSPIC_PrgAccCtrl1_PriBufEn(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> PriBufEn=(ParValue))
N#define biGetQSPIC_PrgAccCtrl1_SecBufEn(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SecBufEn)
N#define vSetQSPIC_PrgAccCtrl1_SecBufEn(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SecBufEn=(ParValue))            
N#define biGetQSPIC_PrgAccCtrl1_RSRVD6(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> RSRVD6)
N#define biGetQSPIC_PrgAccCtrl1_PriBufDatByteCnt(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> PriBufDatByteCnt)
N#define vSetQSPIC_PrgAccCtrl1_PriBufDatByteCnt(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> PriBufDatByteCnt=(ParValue))            
N#define biGetQSPIC_PrgAccCtrl1_RSRVD19(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> RSRVD19)
N#define biGetQSPIC_PrgAccCtrl1_SecBufDatByteCnt(ctrlr) (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SecBufDatByteCnt)
N#define vSetQSPIC_PrgAccCtrl1_SecBufDatByteCnt(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccCtrl1(ctrlr) -> SecBufDatByteCnt=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetQSPIC_PrgAccCtrl1LL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl1LL(ctrlr) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_PrgAccCtrl1LH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl1LH(ctrlr) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_PrgAccCtrl1HL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl1HL(ctrlr) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_PrgAccCtrl1HH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_PrgAccCtrl1HH(ctrlr) (pst_u8QSPIC_PrgAccCtrl1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_PrgAccCtrl1L(ctrlr,ParValue) (pst_u16QSPIC_PrgAccCtrl1(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_PrgAccCtrl1L(ctrlr) (pst_u16QSPIC_PrgAccCtrl1(ctrlr) -> u16L)
N#define vSetQSPIC_PrgAccCtrl1H(ctrlr,ParValue) (pst_u16QSPIC_PrgAccCtrl1(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_PrgAccCtrl1H(ctrlr) (pst_u16QSPIC_PrgAccCtrl1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_PrgAccCtrl1(ctrlr,ParValue)  (*pu32QSPIC_PrgAccCtrl1(ctrlr) = (ParValue))
N#define u32GetQSPIC_PrgAccCtrl1(ctrlr)  (*pu32QSPIC_PrgAccCtrl1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_PrgAccIntEn                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0109408                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_PrgAccIntEn_REG__       0xC0109408U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SpiIntEn	:1; 	 /* 0..0  bit(s) R/W */ 
N  uint32_t   RSRVD1	:31; 	 /* 1..31  bit(s) R */                    
N} QSPIC_PrgAccIntEn_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_PrgAccIntEn_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_PrgAccIntEn_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_PrgAccIntEn_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_PrgAccIntEn(ctrlr)     ((volatile QSPIC_PrgAccIntEn_bit_view_st *)\
N(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_PrgAccIntEn(ctrlr)     ((volatile QSPIC_PrgAccIntEn_bit_view_st *)(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_PrgAccIntEn(ctrlr)     ((volatile QSPIC_PrgAccIntEn_byte_view_st *)\
N(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_PrgAccIntEn(ctrlr)     ((volatile QSPIC_PrgAccIntEn_byte_view_st *)(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_PrgAccIntEn(ctrlr)     ((volatile QSPIC_PrgAccIntEn_halfword_view_st *)\
N(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_PrgAccIntEn(ctrlr)     ((volatile QSPIC_PrgAccIntEn_halfword_view_st *)(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_PrgAccIntEn(ctrlr)     ((volatile u32QSPIC_PrgAccIntEn_word_view *)\
N(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_PrgAccIntEn(ctrlr)     ((volatile u32QSPIC_PrgAccIntEn_word_view *)(QSPIC_PrgAccIntEn_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_PrgAccIntEn_SpiIntEn(ctrlr) (pst_bitQSPIC_PrgAccIntEn(ctrlr) -> SpiIntEn)
N#define vSetQSPIC_PrgAccIntEn_SpiIntEn(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccIntEn(ctrlr) -> SpiIntEn=(ParValue))            
N#define biGetQSPIC_PrgAccIntEn_RSRVD1(ctrlr) (pst_bitQSPIC_PrgAccIntEn(ctrlr) -> RSRVD1)
N            
N/* LL-struct byte access */
N#define vSetQSPIC_PrgAccIntEnLL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_PrgAccIntEnLL(ctrlr) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_PrgAccIntEnLH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_PrgAccIntEnLH(ctrlr) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_PrgAccIntEnHL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_PrgAccIntEnHL(ctrlr) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_PrgAccIntEnHH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_PrgAccIntEnHH(ctrlr) (pst_u8QSPIC_PrgAccIntEn(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_PrgAccIntEnL(ctrlr,ParValue) (pst_u16QSPIC_PrgAccIntEn(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_PrgAccIntEnL(ctrlr) (pst_u16QSPIC_PrgAccIntEn(ctrlr) -> u16L)
N#define vSetQSPIC_PrgAccIntEnH(ctrlr,ParValue) (pst_u16QSPIC_PrgAccIntEn(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_PrgAccIntEnH(ctrlr) (pst_u16QSPIC_PrgAccIntEn(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_PrgAccIntEn(ctrlr,ParValue)  (*pu32QSPIC_PrgAccIntEn(ctrlr) = (ParValue))
N#define u32GetQSPIC_PrgAccIntEn(ctrlr)  (*pu32QSPIC_PrgAccIntEn(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_PrgAccStat                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010940C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_PrgAccStat_REG__       0xC010940CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SpiCycDone	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   SpiCycInPrgrs	:1; 	 /* 1..1  bit(s) R/W */ 
N  uint32_t   RSRVD2	:30; 	 /* 2..31  bit(s) R */                    
N} QSPIC_PrgAccStat_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} QSPIC_PrgAccStat_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} QSPIC_PrgAccStat_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32QSPIC_PrgAccStat_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_PrgAccStat(ctrlr)     ((volatile QSPIC_PrgAccStat_bit_view_st *)\
N(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
X#define pst_bitQSPIC_PrgAccStat(ctrlr)     ((volatile QSPIC_PrgAccStat_bit_view_st *)(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8QSPIC_PrgAccStat(ctrlr)     ((volatile QSPIC_PrgAccStat_byte_view_st *)\
N(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
X#define pst_u8QSPIC_PrgAccStat(ctrlr)     ((volatile QSPIC_PrgAccStat_byte_view_st *)(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16QSPIC_PrgAccStat(ctrlr)     ((volatile QSPIC_PrgAccStat_halfword_view_st *)\
N(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
X#define pst_u16QSPIC_PrgAccStat(ctrlr)     ((volatile QSPIC_PrgAccStat_halfword_view_st *)(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
N            
N/* Pointer to WORD  */ 
N#define pu32QSPIC_PrgAccStat(ctrlr)     ((volatile u32QSPIC_PrgAccStat_word_view *)\
N(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
X#define pu32QSPIC_PrgAccStat(ctrlr)     ((volatile u32QSPIC_PrgAccStat_word_view *)(QSPIC_PrgAccStat_REG__  + ((int32_t)(ctrlr))))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_PrgAccStat_SpiCycDone(ctrlr) (pst_bitQSPIC_PrgAccStat(ctrlr) -> SpiCycDone)
N#define vSetQSPIC_PrgAccStat_SpiCycDone(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccStat(ctrlr) -> SpiCycDone=(ParValue))
N#define biGetQSPIC_PrgAccStat_SpiCycInPrgrs(ctrlr) (pst_bitQSPIC_PrgAccStat(ctrlr) -> SpiCycInPrgrs)
N#define vSetQSPIC_PrgAccStat_SpiCycInPrgrs(ctrlr,ParValue)  (pst_bitQSPIC_PrgAccStat(ctrlr) -> SpiCycInPrgrs=(ParValue))            
N#define biGetQSPIC_PrgAccStat_RSRVD2(ctrlr) (pst_bitQSPIC_PrgAccStat(ctrlr) -> RSRVD2)
N            
N/* LL-struct byte access */
N#define vSetQSPIC_PrgAccStatLL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8LL = (ParValue))
N#define u8GetQSPIC_PrgAccStatLL(ctrlr) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetQSPIC_PrgAccStatLH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8LH = (ParValue))
N#define u8GetQSPIC_PrgAccStatLH(ctrlr) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetQSPIC_PrgAccStatHL(ctrlr,ParValue) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8HL = (ParValue))
N#define u8GetQSPIC_PrgAccStatHL(ctrlr) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetQSPIC_PrgAccStatHH(ctrlr,ParValue) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8HH = (ParValue))
N#define u8GetQSPIC_PrgAccStatHH(ctrlr) (pst_u8QSPIC_PrgAccStat(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetQSPIC_PrgAccStatL(ctrlr,ParValue) (pst_u16QSPIC_PrgAccStat(ctrlr) -> u16L = (ParValue))
N#define u16GetQSPIC_PrgAccStatL(ctrlr) (pst_u16QSPIC_PrgAccStat(ctrlr) -> u16L)
N#define vSetQSPIC_PrgAccStatH(ctrlr,ParValue) (pst_u16QSPIC_PrgAccStat(ctrlr) -> u16H = (ParValue))
N#define u16GetQSPIC_PrgAccStatH(ctrlr) (pst_u16QSPIC_PrgAccStat(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetQSPIC_PrgAccStat(ctrlr,ParValue)  (*pu32QSPIC_PrgAccStat(ctrlr) = (ParValue))
N#define u32GetQSPIC_PrgAccStat(ctrlr)  (*pu32QSPIC_PrgAccStat(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_PriBufDatN                                
N*       SIZE    : 8-bits                        
N*       ADDRESS : 0xC0109500                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_PriBufDatN_REG__       0xC0109500U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint8_t   PriBufDatN	:8; 	 /* 0..7  bit(s) R/W */                    
N} QSPIC_PriBufDatN_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8QSPIC_PriBufDatN_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_PriBufDatN(ctrlr,ch)     ((volatile QSPIC_PriBufDatN_bit_view_st *)\
N(QSPIC_PriBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
X#define pst_bitQSPIC_PriBufDatN(ctrlr,ch)     ((volatile QSPIC_PriBufDatN_bit_view_st *)(QSPIC_PriBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
N        
N/* Pointer to BYTE  */
N#define pu8QSPIC_PriBufDatN(ctrlr,ch)     ((volatile u8QSPIC_PriBufDatN_byte_view *)\
N(QSPIC_PriBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
X#define pu8QSPIC_PriBufDatN(ctrlr,ch)     ((volatile u8QSPIC_PriBufDatN_byte_view *)(QSPIC_PriBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_PriBufDatN_PriBufDatN(ctrlr,ch) (pst_bitQSPIC_PriBufDatN(ctrlr,ch) -> PriBufDatN)
N#define vSetQSPIC_PriBufDatN_PriBufDatN(ctrlr,ch,ParValue)  (pst_bitQSPIC_PriBufDatN(ctrlr,ch) -> PriBufDatN=(ParValue))
N            
N/* byte access */
N#define vSetQSPIC_PriBufDatN(ctrlr,ch,ParValue) (*pu8QSPIC_PriBufDatN(ctrlr,ch) = (ParValue))
N#define u8GetQSPIC_PriBufDatN(ctrlr,ch) (*pu8QSPIC_PriBufDatN(ctrlr,ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: QSPIC_SecBufDatN                                
N*       SIZE    : 8-bits                        
N*       ADDRESS : 0xC0109600                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define QSPIC_SecBufDatN_REG__       0xC0109600U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint8_t   SecBufDatN	:8; 	 /* 0..7  bit(s) R/W */                    
N} QSPIC_SecBufDatN_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8QSPIC_SecBufDatN_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitQSPIC_SecBufDatN(ctrlr,ch)     ((volatile QSPIC_SecBufDatN_bit_view_st *)\
N(QSPIC_SecBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
X#define pst_bitQSPIC_SecBufDatN(ctrlr,ch)     ((volatile QSPIC_SecBufDatN_bit_view_st *)(QSPIC_SecBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
N        
N/* Pointer to BYTE  */
N#define pu8QSPIC_SecBufDatN(ctrlr,ch)     ((volatile u8QSPIC_SecBufDatN_byte_view *)\
N(QSPIC_SecBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
X#define pu8QSPIC_SecBufDatN(ctrlr,ch)     ((volatile u8QSPIC_SecBufDatN_byte_view *)(QSPIC_SecBufDatN_REG__  + ((int32_t)(ctrlr)) + ((int32_t)(ch) * 0x001U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetQSPIC_SecBufDatN_SecBufDatN(ctrlr,ch) (pst_bitQSPIC_SecBufDatN(ctrlr,ch) -> SecBufDatN)
N#define vSetQSPIC_SecBufDatN_SecBufDatN(ctrlr,ch,ParValue)  (pst_bitQSPIC_SecBufDatN(ctrlr,ch) -> SecBufDatN=(ParValue))
N            
N/* byte access */
N#define vSetQSPIC_SecBufDatN(ctrlr,ch,ParValue) (*pu8QSPIC_SecBufDatN(ctrlr,ch) = (ParValue))
N#define u8GetQSPIC_SecBufDatN(ctrlr,ch) (*pu8QSPIC_SecBufDatN(ctrlr,ch) )
N
N/******************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */ 
N/******************************************************************************/
N
N/****************************************************************************/	
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :   Deactivated:
N** |     Not requested Rules: 
N** |         Rule 5.7  [A] : disable No reuse of identifiers
N** |
N** |     Requested Rules:
N** |
N** |         Rule 6.4  [R]   : Bitfields can only have `unsigned int' or `signed int' types
N** |                           Used for bit definitons generated by converter tool
N** |         Rule 19.10 [R] : In function-like macro definition, wrap each parameter reference in parentheses
N** |                          Used to call macros generated by converter tool
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************/
N/****************************************************************************/
N
N#endif /* QSPICIO_H */ 
N    
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 23 "..\..\..\..\lldd\src\qspic.c" 2
N#include "qspic.h"                      /* Own definitions */
L 1 "..\..\..\..\lldd\inc\qspic.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : QSPI controler low level register access
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : QSPI
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.35 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef QSPIC_H
N#define QSPIC_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N
N/*********************************************/
N
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_QSPIC_H_REVISION     "$Revision: 1.35 $"
N#define LLDD_QSPIC_H_TAG          "$Name: LLDD_1_6 $"
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : disable No reuse of identifiers */
N#endif
N/****************************************************************************
N*                          CONTROLER SELECTION MACROS
N*             (Please use these macros to select module instances)
N*****************************************************************************/
Ntypedef enum tag_qspic_cntrl_e
N{
N#ifdef FPGA
S  QSPIC_CNTRL_0 = 0x0U,
S  QSPIC_CNTRL_1 = 0x800U,
S  QSPIC_CNTRL_2 = 0x1000
N#else
N  QSPIC_CNTRL_0 = 0,
N  QSPIC_CNTRL_1 = 0xAF8000,  
N  QSPIC_CNTRL_2 = 0x1000
N#endif   
N} qspic_cntrl_e;
N
N/*********************************************/
N
N
N/**********************************************
N*                    Macros                   *
N**********************************************/
Nextern void    read_burst4(int32_t i32addr, uint32_t * pu32Data);
Nextern void    read_burst8(int32_t i32addr, uint32_t * pu32Data);
Nextern void    word_write(int32_t i32addr, int32_t data);
Nextern void    hword_write(int32_t i32addr, int32_t data);
Nextern void    byte_write(int32_t i32addr, int32_t data);
Nextern int32_t word_read(int32_t i32addr);
Nextern int32_t hword_read(int32_t i32addr);
Nextern int32_t byte_read(int32_t i32addr);
N
N/*********************************************/
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N/* Command Operation Code */
Ntypedef enum tag_qspic_CmdOp_e
N{
N  QSPI_CMD_READ_SINGLE        = 0x03,
N  QSPI_CMD_FAST_READ_SINGLE   = 0x0B,
N  QSPI_CMD_FAST_READ_DUAL_OUT = 0x3B,
N  QSPI_CMD_FAST_READ_DUAL_IO  = 0xBB,
N  QSPI_CMD_FAST_READ_QUAD_OUT = 0x6B,
N  QSPI_CMD_FAST_READ_QUAD_IO  = 0xEB
N} qspi_CmdOp_e;
N
N/* SPI I/O Control */
Ntypedef enum tag_qspic_IOCtrl_e
N{
N  QSPI_SINGLE = 0,
N  QSPI_DUAL   = 1,
N  QSPI_QUAD   = 2
N} qspi_IOCtrl_e;
N
N/* Address byte count */
Ntypedef enum tag_qspic_AddrByte_e
N{
N  QSPI_ADDR_3BYTE = 0,
N  QSPI_ADDR_4BYTE = 1
N} qspi_AddrByte_e;
N
N/* QSPI flash device no. */
Ntypedef enum tag_qspic_dev_e
N{
N    QSPIC_DEV_0 = 0,                         /* QSPI flash on CS0 */
N    QSPIC_DEV_1 = 1                          /* QSPI flash on CS1 */
N} qspic_dev_e;
N
N/* SPI flash density */
Ntypedef enum tag_qspic_density_e
N{
N    /* dependant on SI_AddrByte */
N    /* SI_AddrByte = 0 */
N    QSPIC_64KB   = 0,                         /*  64 KB */
N    QSPIC_128KB  = 1,                         /* 128 KB */
N    QSPIC_256KB  = 2,                         /* 256 KB */
N    QSPIC_512KB  = 3,                         /* 512 KB */
N    QSPIC_1MB    = 4,                         /*   1 MB */
N    QSPIC_2MB    = 5,                         /*   2 MB */
N    QSPIC_4MB    = 6,                         /*   4 MB */
N    QSPIC_8MB    = 7,                         /*   8 MB */
N    QSPIC_16MB   = 8,                         /*  16 MB */
N    /* SI_AddrByte = 1 */
N    QSPIC_32MB   = 9,                         /*  32 MB */
N    QSPIC_64MB   = 10,                        /*  64 MB */
N    QSPIC_128MB  = 11,                        /* 128 MB */
N    QSPIC_256MB  = 12                         /* 256 MB */
N} qspic_density_e;
N
N/* SPI data capture edge */
Ntypedef enum tag_qspic_sdce_e
N{
N    QSPIC_1ST_POS_EDGE = 0x00,              /* data capture @ 1st positive edge */
N    QSPIC_1ST_NEG_EDGE = 0x01,              /* data capture @ 1st negative edge */ 
N    QSPIC_2ND_POS_EDGE = 0x02,              /* data capture @ 2nd positive edge */
N    QSPIC_2ND_NEG_EDGE = 0x03               /* data capture @ 2nd negative edge */ 
N} qspic_sdce_e;
N
N/* SPI program access opcode */
Ntypedef enum tag_qspic_opcode_e
N{
N    /* read */
N    QSPIC_OPCODE_FAST_READ   = 0x0B,            /* Fast READ opcode */
N    QSPIC_OPCODE_READ_ID     = 0x90,            /* Read ID */   
N    QSPIC_OPCODE_READ_EXTID  = 0x9F,            /* Read Extended ID */
N    /* write control */
N    QSPIC_OPCODE_WRITE_EN    = 0x06,            /* WRITE enable */
N    QSPIC_OPCODE_WRITE_DIS   = 0x04,            /* WRITE disable */
N    /* erase */
N    QSPIC_OPCODE_4KBS_ERASE  = 0x20,            /* 4kB sector ERASE */
N    QSPIC_OPCODE_8KBS_ERASE  = 0x40,            /* 8kB sector ERASE */
N    QSPIC_OPCODE_64KBS_ERASE = 0xD8,            /* 64kB sector ERASE */
N    QSPIC_OPCODE_CHIP_ERASE  = 0xC7,            /* full chip ERASE opcode */
N    /* program */
N    QSPIC_OPCODE_PAGE_PGRM   = 0x02,            /* Page PROGRAM opcode */
N    /* Status */
N    QSPIC_OPCODE_RFST_READ   = 0x70,            /* Read Flag status register */
N    QSPIC_OPCODE_STS_READ    = 0x05,            /* Status read opcode */
N    QSPIC_OPCODE_STS_CLEAR   = 0x30,            /* Status clear */
N    /* Configuration read */
N    QSPIC_OPCODE_CFG_READ    = 0x35,            /* Configuration register read */
N    QSPIC_OPCODE_CFGM_READ   = 0x15,            /* Configuration register read */
N    /* Register write */
N    QSPIC_OPCODE_WRITE_REG   = 0x01,            /* Write Configuration & Status register opcode */
N    /* Release deep power down */
N    QSPIC_OPCODE_RELEASE_DP  = 0xAB,            /* Release from deep power down mode */
N    /* set 3/4 byte mode */
N    QSPIC_OPCODE_3_BYTE_MODE  = 0xE9,           /* Enable 3-byte mode */
N    QSPIC_OPCODE_4_BYTE_MODE  = 0xB7            /* Enable 4-byte mode */
N} qspic_opcode_e;
N
N/* Enable/disable */
Ntypedef enum tag_qspic_en_e
N{
N    QSPIC_DISABLE = 0x0U,                       /* Disable */
N    QSPIC_ENABLE  = 0x1U                        /* Enable */
N} qspic_en_e;
N
N/*********************************************/
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N/* SPI direct read control strucutre */
Ntypedef struct tag_qspic_direct_rd_ctrl_st
N{
N    qspi_CmdOp_e     eCmd;                  /* Quad-SPI command code   */
N    uint32_t         u32DummyByteCnt;       /* Number of dummy bytes   */
N    qspi_AddrByte_e  eAddrByteCnt;          /* Address mode 3-/4-Byte  */
N    qspi_IOCtrl_e    eSpiDatIOCtrl;         /* SPI Data I/O control    */
N    qspi_IOCtrl_e    eSpiDmyIOCtrl;         /* SPI Dummy I/O control   */
N    qspi_IOCtrl_e    eSpiAdrIOCtrl;         /* SPI Address I/O control */
N} qspic_direct_rd_ctrl_st;
N
Ntypedef struct tag_qspic_directconfig_st
N{
N    uint16_t                u16FlashBaseAddress;   /* physical base address (bits [31:16]), upper 4 bits are fixed and don't care */
N    qspic_density_e         eFlashDensity;         /* flash density */
N    qspic_en_e              eEnableMemMapRd;       /* enable memory map read */
N    qspic_direct_rd_ctrl_st stRdCtrl;              /* SPI mode read */
N    qspic_en_e              eWIPEnable;            /* WIP bit enable */
N    uint8_t                 u8CSTime;              /* deassertion time */
N    qspic_sdce_e            eEdge;                 /* capture edge */
N} qspic_directconfig_st;
N
Ntypedef struct tag_qspic_prgconfig_st
N{
N    uint8_t             u8CSTime;           /* deassertion time */
N    qspic_sdce_e        eEdge;              /* capture edge */
N    qspi_AddrByte_e     eAddrByteCnt;       /* Address mode 3-/4-Byte  */
N} qspic_prgconfig_st;
N
N/*********************************************/
N
N/**********************************************
N*            Forward declarations             *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      vQSPIC_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vQSPIC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                       uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                       uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_ConfigureDirectControl
N *
N * Purpose:       does complete configuration for direct access
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *                pstDirConf     pointer to configuration for direct access
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   The base address must be aligned on a boundary that is an integer
N *                 multiple of the density of the SPI Flash selected
N *                otherwise, correct operation is not guaranteed
N *
N ***************************************************************************/
Nint32_t i32QSPIC_ConfigureDirectControl(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_directconfig_st *pstDirConf);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_ConfigurePrgControl
N *
N * Purpose:       does complete configuration for program access
N *
N * Inputs:        eController     flash controller no.
N *                pstPrgConf      pointer to configuration for program access
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_ConfigurePrgControl(qspic_cntrl_e eController, qspic_prgconfig_st *pstPrgConf);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_SetDirectFlashBaseAddress
N *
N * Purpose:       set memory mapping and flash size
N *
N * Inputs:        eController           flash controller no.
N *                eDevice               device no.
N *                u16FlashBaseAddress   physical base address (bits [31:16]), upper 4 bits are fixed and don't care
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   Specifies the base address of a CPU memory space to which SPI Flash #0/1
N *                should be mapped.
N *                The base address must be aligned on a boundary that is an integer
N *                multiple of the density of the SPI Flash selected
N *                otherwise, correct operation is not guaranteed
N *
N ***************************************************************************/
Nint32_t i32QSPIC_SetDirectFlashBaseAddress(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t u16FlashBaseAddress);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_GetDirectFlashBaseAddress 
N *
N * Purpose:       Reads memory base address of flash.
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       physical base address (bits [31:16]), upper 4 bits are fixed and don't care
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_GetDirectFlashBaseAddress(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t * u16FlashBaseAddress);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_SetDirectFlashDensity
N *
N * Purpose:       set flash size
N *
N * Inputs:        eController      flash controller no.
N *                eDevice          device no.
N *                eFlashDensity    flash density (size)
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_SetDirectFlashDensity(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_density_e eFlashDensity);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_GetDirectFlashDensity 
N *
N * Purpose:       Reads flash density.
N *
N * Inputs:        eController      flash controller no.
N *                eDevice          device no.
N *
N * Outputs:       flash density (size)
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_GetDirectFlashDensity(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_density_e * eFlashDensity);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_EnableDirectMemMapRd 
N *
N * Purpose:       Enables and disables read access.
N *                If disabled, the SPI Flash device is not memory-mapped.
N *
N * Inputs:        eController      flash controller no.
N *                eDevice          device no.
N *                eEnableMemMap    enable/disable
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_EnableDirectMemMapRd(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e eEnableMemMap);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_GetDirectMemMapStatusRd 
N *
N * Purpose:       Reads status of direct memory map read.
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       enable/disable
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_GetDirectMemMapStatusRd(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e * eEnableMemMap);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_SetDirectFlashMemMap
N *
N * Purpose:       set memory mapping and flash size
N *
N * Inputs:        eController            flash controller no.
N *                eDevice                device no.
N *                u16FlashBaseAddress    physical base address (bits [31:16]), upper 4 bits are fixed and don't care
N *                eFlashDensity          flash density (size)
N *                eEnableMemMapRd        enable/disable read
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   Specifies the base address of a CPU memory space to which SPI Flash #0/1
N *                should be mapped.
N *                The base address must be aligned on a boundary that is an integer
N *                multiple of the density of the SPI Flash selected
N *                otherwise, correct operation is not guaranteed
N *
N ***************************************************************************/
Nint32_t i32QSPIC_SetDirectFlashMemMap(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t u16FlashBaseAddress,
N                                      qspic_density_e eFlashDensity, qspic_en_e eEnableMemMapRd);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectSetReadCtrl  
N *
N * Purpose:       specifies the configuration of the read command 
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *                u32Ctrl        read control value 
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   specifies the configuration of the read command
N *                that the hardware sequencer should issue to an
N *                SPI Flash device for direct read accesses.
N *                It affects Dual I/O and Quad I/O reads
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectSetReadCtrl(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32Ctrl);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectGetReadCtrl 
N *
N * Purpose:       Reads the configuration of the read command.
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       read control value
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectGetReadCtrl(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t * u32Ctrl);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectEnableWIPPolling      
N *
N * Purpose:       Enables and disables the polling of the WIP bit of the
N *                status register in the SPI Flash (until the SPI Flash write
N *                is completed) before issuing a read command to it. 
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *                eEnable        enable/disable 
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectEnableWIPPolling(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e eEnable);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectGetStatusWIPPolling 
N *
N * Purpose:       Reads Status of WIP polling bit.
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       enable/disable
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectGetStatusWIPPolling(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e * eEnable);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectSetCSDeassertionTime
N *
N * Purpose:       Specifies the deassertion time of SPI_CS_N for direct access
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *                u8CSTime       numerical value = (CSTime / HBUS cycle time)
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectSetCSDeassertionTime(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8CSTime);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectGetCSDeassertionTime 
N *
N * Purpose:       Reads Direct Deassertion Time.
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       numerical value = (CSTime / HBUS cycle time)
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectGetCSDeassertionTime(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t * u8CSTime);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmSetCSDeassertionTime
N *
N * Purpose:       specifies the deassertion time of SPI_CS_0/1 for program access
N *
N * Inputs:        eController    flash controller no.
N *                u8CSTime       numerical value = (CSTime / HBUS cycle time) 
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmSetCSDeassertionTime(qspic_cntrl_e eController, uint8_t u8CSTime);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmGetCSDeassertionTime 
N *
N * Purpose:       Reads Program Deassertion Time.
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       numerical value = (CSTime / HBUS cycle time)
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmGetCSDeassertionTime(qspic_cntrl_e eController, uint8_t * u8CSTime);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectSetDataCaptureEdge
N *
N * Purpose:       Selects the active edge of SPI_CLK used to capture
N *                data on the SPI bus for direct access
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *                eEdge          1st pos. edge / 1st neg. edge 
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectSetDataCaptureEdge(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_sdce_e eEdge);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_DirectGetDataCaptureEdge 
N *
N * Purpose:       Reads Direct Capture Edge.
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       1st pos. edge / 1st neg. edge
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_DirectGetDataCaptureEdge(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_sdce_e * eEdge);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmSetDataCaptureEdge
N *
N * Purpose:       Selects the active edge of SPI_CLK used to capture
N *                data on the SPI bus for programm access
N *
N * Inputs:        eController    flash controller no.
N *                eEdge          capture edge: 1st pos. edge / 1st neg. edge
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmSetDataCaptureEdge(qspic_cntrl_e eController, qspic_sdce_e eEdge);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmGetDataCaptureEdge 
N *
N * Purpose:       Reads Program Capture Edge.
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       Capture edge: 1st pos. edge / 1st neg. edge
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmGetDataCaptureEdge(qspic_cntrl_e eController, qspic_sdce_e * eEdge);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_EnableInterrupt      
N *
N * Purpose:       Enables and disables SPI interrupts generated on completion
N *                of a program register access cycle 
N *
N * Inputs:        eController    flash controller no.
N *                eEnable        enable/disable 
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   If enabled, generates an interrupt when the
N *                SPI Cycle Done bit is set to 1.
N *
N ***************************************************************************/
Nint32_t i32QSPIC_EnableInterrupt(qspic_cntrl_e eController, qspic_en_e eEnable);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_GetInterruptStatus 
N *
N * Purpose:       Reads Interrupt status.
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       Interrupt Status
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_GetInterruptStatus(qspic_cntrl_e eController, qspic_en_e * eEnable);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_IsSpiCycleDone 
N *
N * Purpose:       checks if SPI cycle is in progress and clears the cycle
N *                done flag.
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       C_TRUE or C_FALSE
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_IsSpiCycleDone(qspic_cntrl_e eController, bool_t * bResult);
N
N/****************************************************************************
N *
N * Function:      boQSPIC_IsSpiCycleInPgrs 
N *
N * Purpose:       checks if SPI cycle is in progress 
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boQSPIC_IsSpiCycleInPgrs(qspic_cntrl_e eController);
N
N/****************************************************************************
N *
N * Function:      boQSPIC_IsSpiCycleDone 
N *
N * Purpose:       checks if SPI cycle is in progress and clears the cycle
N *                done flag.
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       none
N *
N * Return Values: CC_TRUE or C_FALSE
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boQSPIC_IsSpiCycleDone(qspic_cntrl_e eController);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_WaitForCompletion 
N *
N * Purpose:       Wait for cycle completion of previous program access
N *
N * Inputs:        eController    flash controller no.
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_WaitForCompletion(qspic_cntrl_e eController);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmStatusRead 
N *
N * Purpose:       Retrieve the value of the status register
N *                in the addressed SPI Flash device
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       *pu8Status    status register of SPI Flash device
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmStatusRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Status);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmStatusFlagRead 
N *
N * Purpose:       Retrieve the value of the status register
N *                in the addressed SPI Flash device for Micron
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       *pu8Status    status register of SPI Flash device
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmStatusFlagRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Status);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmClearStatus 
N *
N * Purpose:       Clear the status register
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       None
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   None
N *
N ***************************************************************************/
Nextern int32_t i32QSPIC_PgrmClearStatus(qspic_cntrl_e eController, qspic_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmReleaseDP 
N *
N * Purpose:       Release from deep sleep power mode
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       None
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   None
N *
N ***************************************************************************/
Nextern int32_t i32QSPIC_PgrmReleaseDP(qspic_cntrl_e eController, qspic_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmConfigurationRead 
N *
N * Purpose:       Retrieve the current value of the configuration register
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       pu8Configuration Handle to the current configuration value
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   None
N *
N ***************************************************************************/
Nextern int32_t i32QSPIC_PgrmConfigurationRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Configuration);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmConfigurationWrite 
N *
N * Purpose:       Modify the value of the Status and Configuration registers
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *                u8Status       Desired value of the Status register  
N *                u8Conf         Desired value of the Configuration register  
N *
N * Outputs:       pu8Configuration Handle to the current configuration value
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   None
N *
N ***************************************************************************/
Nextern int32_t i32QSPIC_PgrmConfigurationWrite(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Status,  uint8_t u8Conf);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmWriteEnable
N *
N * Purpose:       Enable writing
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmWriteEnable(qspic_cntrl_e eController, qspic_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmWriteDisable
N *
N * Purpose:       Disable writing
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmWriteDisable(qspic_cntrl_e eController, qspic_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmSectErase
N *
N * Purpose:       SPI Flash Sector Erase
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *                eOpcode           Sector erase opcode
N *                u32SpiPhysAddr    addr [23:0] of phys. SPI flash device
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmSectErase(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_opcode_e eOpcode, uint32_t u32SpiPhysAddr);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmChipErase
N *
N * Purpose:       Full Chip Erase
N *
N * Inputs:        eController    flash controller no.
N *                eDevice        device no.
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmChipErase(qspic_cntrl_e eController, qspic_dev_e eDevice);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmPagePgrm
N *
N * Purpose:       Programming 256 bytes of data
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *                u32SpiPhysAddr    addr [23:0] of phys. SPI flash device
N *                u16DataCount      number of bytes to be written
N *                pu8Data           pointer to data buffer to be written into
N *                                  flash device
N *
N * Outputs:       
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmPagePgrm(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32SpiPhysAddr, uint16_t u16DataCount, uint8_t* const pu8Data);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmFastRead 
N *
N * Purpose:       Perform fast reading of 256 byte of data
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *                u32SpiPhysAddr    addr [23:0] of phys. SPI flash device
N *                u16DataCount      number of bytes to be written
N *
N * Outputs:       pu8Data           pointer to data buffer 
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmFastRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32SpiPhysAddr, uint16_t u16DataCount, uint8_t* const pu8Data);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmGetID 
N *
N * Purpose:       Retrieve device identification
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *
N * Outputs:       pu8ManID          Manufacturer ID
N *                pu8DevID          Device ID
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmGetID(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8ManID, uint8_t* const pu8DevID);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmGetExtendedID 
N *
N * Purpose:       Retrieve extended device identification
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *
N * Outputs:       pu8Information    Handle to the infromation buffer
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmGetExtendedID(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Information);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_WriteByte 
N *
N * Purpose:       Write one Byte to the device
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *                u8Value           value to be send
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_WriteByte(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmGetRegister 
N *
N * Purpose:       Retrieve content of register
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *                u8Command         command to be issued
N *                u16Count          number of bytes to be read
N *
N * Outputs:       pu8Information    Handle to the infromation buffer
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmGetRegister(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Command, uint16_t u16Count, uint8_t* pu8Information);
N
N/****************************************************************************
N *
N * Function:      i32QSPIC_PgrmWriteRegister 
N *
N * Purpose:       Write data
N *
N * Inputs:        eController       flash controller no.
N *                eDevice           device no.
N *                u8Command         command to be issued
N *                u16Count          number of bytes to be read
N *                pu8Information    Handle to the infromation buffer
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32QSPIC_PgrmWriteRegister(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Command, uint16_t u16Count, uint8_t* pu8Information);
N
N/****************************************************************************
N *
N * Function:      u32QSPIC_DirectReadWord
N *
N * Purpose:       Perform reading of one word from QSPI
N *
N * Inputs:        u32SpiPhysAddr    addr [23:0] of phys. SPI flash device
N *
N * Outputs:       none
N *
N * Return Values: read word
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32QSPIC_DirectReadWord(uint32_t u32SpiPhysAddr);
N
N/****************************************************************************
N *
N * Function:      vQSPIC_DirectReadBurst4
N *
N * Purpose:       Perform reading 4 words in burst from QSPI
N *
N * Inputs:        u32SpiPhysAddr    addr [23:0] of phys. SPI flash device
N *                pu32Data          pointer to return memory
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vQSPIC_DirectReadBurst4(uint32_t u32SpiPhysAddr, uint32_t * pu32Data);
N
N/****************************************************************************
N *
N * Function:      vQSPIC_DirectReadBurst8
N *
N * Purpose:       Perform reading 8 words in burst from QSPI
N *
N * Inputs:        u32SpiPhysAddr    addr [23:0] of phys. SPI flash device
N *                pu32Data          pointer to return memory
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vQSPIC_DirectReadBurst8(uint32_t u32SpiPhysAddr, uint32_t * pu32Data);
N
N/****************************************************************************/
N
N
N#endif /* QSPIC_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\qspic.c" 2
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_QSPIC_C_REVISION     "$Revision: 1.40 $"
N#define LLDD_QSPIC_C_TAG          "$Name: LLDD_1_6 $"
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1771  /* Rule 2.4  [A] : No `commented out' sections of code */
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */
S  #pragma ghs nowarning 1834  /* Rule 11.3 [A] : disable casting error */
S  #pragma ghs nowarning 1835  /* Rule 11.4 [A] :  allow cast from type "type" to type "type" */
S  #pragma ghs nowarning 1877  /* Rule 11.3 [A] : disable casting error */
S
S  #pragma ghs nowarning 1864  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
S  #pragma ghs nowarning 1865  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
S  #pragma ghs nowarning 1867  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
S  #pragma ghs nowarning 1847  /* Rule 10.3 [R] : disable casting error */
S  #pragma ghs nowarning 1752  /* Rule 17.4 [R] : disable "pointer arithmetic not allowed"  for usage of io header files */
S  #pragma ghs nowarning 1858  /* Rule 17.4 [R] : allow access to data under pointer by array (used forc copy) */
N #endif
N
N
N/* definitions used for setting the Program Access Control Register 1 */
N#define QSPIC_PACTRL_SEC_BUF_CNT_MASK          0xFF000000U
N#define QSPIC_PACTRL_SEC_BUF_CNT_SHIFT         24U
N#define QSPIC_PACTRL_PRI_BUF_CNT_MASK          0x00070000U
N#define QSPIC_PACTRL_PRI_BUF_CNT_SHIFT         16U
N#define QSPIC_PACTRL_SEC_BUF_EN_BIT            0x00000020U
N#define QSPIC_PACTRL_PRI_EN_BIT                0x00000010U
N#define QSPIC_PACTRL_SPI_CS_DEV1_BIT           0x2U
N#define QSPIC_PACTRL_SPI_CYC_GO_BIT            0x00000001U
N
N#define QSPIC_PACTRL_PRI_BUF_CNT_1             0x00010000U
N#define QSPIC_PACTRL_PRI_BUF_CNT_2             0x00020000U
N#define QSPIC_PACTRL_PRI_BUF_CNT_3             0x00030000U
N#define QSPIC_PACTRL_PRI_BUF_CNT_4             0x00040000U
N#define QSPIC_PACTRL_PRI_BUF_CNT_5             0x00050000U
N#define QSPIC_PACTRL_SEC_BUF_CNT_1             0x01000000U
N#define QSPIC_PACTRL_SEC_BUF_CNT_2             0x02000000U
N#define QSPIC_PACTRL_SEC_BUF_CNT_3             0x03000000U
N
N/*********************************************/
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
Nstatic uint8_t au8LLDD_QSPIC_C_REVISION[]    = LLDD_QSPIC_C_REVISION;
Xstatic uint8_t au8LLDD_QSPIC_C_REVISION[]    = "$Revision: 1.40 $";
Nstatic uint8_t au8LLDD_QSPIC_C_TAG[]         = LLDD_QSPIC_C_TAG;
Xstatic uint8_t au8LLDD_QSPIC_C_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_QSPIC_H_REVISION[]    = LLDD_QSPIC_H_REVISION;
Xstatic uint8_t au8LLDD_QSPIC_H_REVISION[]    = "$Revision: 1.35 $";
Nstatic uint8_t au8LLDD_QSPIC_H_TAG[]         = LLDD_QSPIC_H_TAG;
Xstatic uint8_t au8LLDD_QSPIC_H_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_QSPIC_IO_H_REVISION[] = LLDD_QSPIC_IO_H_REVISION;
Xstatic uint8_t au8LLDD_QSPIC_IO_H_REVISION[] = "$Revision: 1.25 $";
Nstatic uint8_t au8LLDD_QSPIC_IO_H_TAG[]      = LLDD_QSPIC_IO_H_TAG;
Xstatic uint8_t au8LLDD_QSPIC_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N/*********************************************/
N
Nstatic qspi_AddrByte_e ePrgAddressByteCnt = QSPI_ADDR_3BYTE;
N
N/**********************************************
N*        Exported function definition         *
N**********************************************/
N
Nvoid vQSPIC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                       uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                       uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N   *pau8ModuleRevision = &au8LLDD_QSPIC_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_QSPIC_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_QSPIC_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_QSPIC_H_TAG[0];
N   *pau8IORevision     = &au8LLDD_QSPIC_IO_H_REVISION[0];
N   *pau8IOTag          = &au8LLDD_QSPIC_IO_H_TAG[0];
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_ConfigureDirectControl(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_directconfig_st *pstDirConf)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_FlshMemMap0_FBA(eController,     pstDirConf->u16FlashBaseAddress);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA=(pstDirConf->u16FlashBaseAddress));
N                    vSetQSPIC_FlshMemMap0_FDEN(eController,    pstDirConf->eFlashDensity);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FDEN=(pstDirConf->eFlashDensity));
N                    vSetQSPIC_FlshMemMap0_RE(eController,      pstDirConf->eEnableMemMapRd);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> RE=(pstDirConf->eEnableMemMapRd));
N                    vSetQSPIC_DirAccCtrl0_PollWIP(eController, pstDirConf->eWIPEnable);
X                    (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> PollWIP=(pstDirConf->eWIPEnable));
N                    vSetQSPIC_DirAccCtrl0_SCSD(eController,    pstDirConf->u8CSTime);
X                    (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> SCSD=(pstDirConf->u8CSTime));
N                    vSetQSPIC_DirAccCtrl0_SDCE(eController,    pstDirConf->eEdge);
X                    (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> SDCE=(pstDirConf->eEdge));
N
N                    /* Direct read Control Register */
N                    vSetQSPIC_DirRdCtrl0_SpiRdCmdOp    (eController, pstDirConf->stRdCtrl.eCmd);
X                    (((volatile QSPIC_DirRdCtrl0_bit_view_st *)(0xC0109010U + ((int32_t)(eController)))) -> SpiRdCmdOp=(pstDirConf->stRdCtrl . eCmd));
N                    vSetQSPIC_DirRdCtrl0_SpiDmyByteCnt (eController, pstDirConf->stRdCtrl.u32DummyByteCnt);
X                    (((volatile QSPIC_DirRdCtrl0_bit_view_st *)(0xC0109010U + ((int32_t)(eController)))) -> SpiDmyByteCnt=(pstDirConf->stRdCtrl . u32DummyByteCnt));
N                    vSetQSPIC_DirRdCtrl0_SpiAddrByteCnt(eController, pstDirConf->stRdCtrl.eAddrByteCnt);
X                    (((volatile QSPIC_DirRdCtrl0_bit_view_st *)(0xC0109010U + ((int32_t)(eController)))) -> SpiAddrByteCnt=(pstDirConf->stRdCtrl . eAddrByteCnt));
N                    vSetQSPIC_DirRdCtrl0_SpiDatIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDatIOCtrl);
X                    (((volatile QSPIC_DirRdCtrl0_bit_view_st *)(0xC0109010U + ((int32_t)(eController)))) -> SpiDatIOCtrl=(pstDirConf->stRdCtrl . eSpiDatIOCtrl));
N                    vSetQSPIC_DirRdCtrl0_SpiDmyIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDmyIOCtrl);
X                    (((volatile QSPIC_DirRdCtrl0_bit_view_st *)(0xC0109010U + ((int32_t)(eController)))) -> SpiDmyIOCtrl=(pstDirConf->stRdCtrl . eSpiDmyIOCtrl));
N                    vSetQSPIC_DirRdCtrl0_SpiAdrIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiAdrIOCtrl);
X                    (((volatile QSPIC_DirRdCtrl0_bit_view_st *)(0xC0109010U + ((int32_t)(eController)))) -> SpiAdrIOCtrl=(pstDirConf->stRdCtrl . eSpiAdrIOCtrl));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_FlshMemMap1_FBA(eController,     pstDirConf->u16FlashBaseAddress);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FBA=(pstDirConf->u16FlashBaseAddress));
N                    vSetQSPIC_FlshMemMap1_FDEN(eController,    pstDirConf->eFlashDensity);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FDEN=(pstDirConf->eFlashDensity));
N                    vSetQSPIC_FlshMemMap1_RE(eController,      pstDirConf->eEnableMemMapRd);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> RE=(pstDirConf->eEnableMemMapRd));
N                    vSetQSPIC_DirAccCtrl1_PollWIP(eController, pstDirConf->eWIPEnable);
X                    (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> PollWIP=(pstDirConf->eWIPEnable));
N                    vSetQSPIC_DirAccCtrl1_SCSD(eController,    pstDirConf->u8CSTime);
X                    (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> SCSD=(pstDirConf->u8CSTime));
N                    vSetQSPIC_DirAccCtrl1_SDCE(eController,    pstDirConf->eEdge);
X                    (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> SDCE=(pstDirConf->eEdge));
N
N                    /* Direct read Control Register */
N                    vSetQSPIC_DirRdCtrl1_SpiRdCmdOp    (eController, pstDirConf->stRdCtrl.eCmd);
X                    (((volatile QSPIC_DirRdCtrl1_bit_view_st *)(0xC0109014U + ((int32_t)(eController)))) -> SpiRdCmdOp=(pstDirConf->stRdCtrl . eCmd));
N                    vSetQSPIC_DirRdCtrl1_SpiDmyByteCnt (eController, pstDirConf->stRdCtrl.u32DummyByteCnt);
X                    (((volatile QSPIC_DirRdCtrl1_bit_view_st *)(0xC0109014U + ((int32_t)(eController)))) -> SpiDmyByteCnt=(pstDirConf->stRdCtrl . u32DummyByteCnt));
N                    vSetQSPIC_DirRdCtrl1_SpiAddrByteCnt(eController, pstDirConf->stRdCtrl.eAddrByteCnt);
X                    (((volatile QSPIC_DirRdCtrl1_bit_view_st *)(0xC0109014U + ((int32_t)(eController)))) -> SpiAddrByteCnt=(pstDirConf->stRdCtrl . eAddrByteCnt));
N                    vSetQSPIC_DirRdCtrl1_SpiDatIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDatIOCtrl);
X                    (((volatile QSPIC_DirRdCtrl1_bit_view_st *)(0xC0109014U + ((int32_t)(eController)))) -> SpiDatIOCtrl=(pstDirConf->stRdCtrl . eSpiDatIOCtrl));
N                    vSetQSPIC_DirRdCtrl1_SpiDmyIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDmyIOCtrl);
X                    (((volatile QSPIC_DirRdCtrl1_bit_view_st *)(0xC0109014U + ((int32_t)(eController)))) -> SpiDmyIOCtrl=(pstDirConf->stRdCtrl . eSpiDmyIOCtrl));
N                    vSetQSPIC_DirRdCtrl1_SpiAdrIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiAdrIOCtrl);
X                    (((volatile QSPIC_DirRdCtrl1_bit_view_st *)(0xC0109014U + ((int32_t)(eController)))) -> SpiAdrIOCtrl=(pstDirConf->stRdCtrl . eSpiAdrIOCtrl));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_ConfigurePrgControl(qspic_cntrl_e eController, qspic_prgconfig_st *pstPrgConf)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        vSetQSPIC_PrgAccCtrl0_SCSD(eController, pstPrgConf->u8CSTime);
X        (((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(0xC0109400U + ((int32_t)(eController)))) -> SCSD=(pstPrgConf->u8CSTime));
N        vSetQSPIC_PrgAccCtrl0_SDCE(eController, pstPrgConf->eEdge);
X        (((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(0xC0109400U + ((int32_t)(eController)))) -> SDCE=(pstPrgConf->eEdge));
N
N        ePrgAddressByteCnt = pstPrgConf->eAddrByteCnt;
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_SetDirectFlashBaseAddress(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t u16FlashBaseAddress)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_FlshMemMap0_FBA(eController, u16FlashBaseAddress);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA=(u16FlashBaseAddress));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_FlshMemMap1_FBA(eController, u16FlashBaseAddress);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FBA=(u16FlashBaseAddress));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_GetDirectFlashBaseAddress(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t * u16FlashBaseAddress)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *u16FlashBaseAddress = biGetQSPIC_FlshMemMap0_FBA(eController);
X                    *u16FlashBaseAddress = (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA);
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *u16FlashBaseAddress = biGetQSPIC_FlshMemMap1_FBA(eController);
X                    *u16FlashBaseAddress = (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FBA);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_SetDirectFlashDensity(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_density_e eFlashDensity)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_FlshMemMap0_FDEN(eController, eFlashDensity);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FDEN=(eFlashDensity));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_FlshMemMap1_FDEN(eController, eFlashDensity);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FDEN=(eFlashDensity));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_GetDirectFlashDensity(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_density_e * eFlashDensity)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *eFlashDensity = (qspic_density_e) biGetQSPIC_FlshMemMap0_FDEN(eController);
X                    *eFlashDensity = (qspic_density_e) (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FDEN);
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *eFlashDensity = (qspic_density_e) biGetQSPIC_FlshMemMap1_FDEN(eController);
X                    *eFlashDensity = (qspic_density_e) (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FDEN);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_EnableDirectMemMapRd(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e eEnableMemMap)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_FlshMemMap0_RE(eController, eEnableMemMap);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> RE=(eEnableMemMap));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_FlshMemMap1_RE(eController, eEnableMemMap);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> RE=(eEnableMemMap));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_GetDirectMemMapStatusRd(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e * eEnableMemMap)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *eEnableMemMap = (qspic_en_e) biGetQSPIC_FlshMemMap0_RE(eController);
X                    *eEnableMemMap = (qspic_en_e) (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> RE);
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *eEnableMemMap = (qspic_en_e) biGetQSPIC_FlshMemMap1_RE(eController);
X                    *eEnableMemMap = (qspic_en_e) (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> RE);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_SetDirectFlashMemMap(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t u16FlashBaseAddress,
N                                      qspic_density_e eFlashDensity, qspic_en_e eEnableMemMapRd)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_FlshMemMap0_FBA(eController, u16FlashBaseAddress);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA=(u16FlashBaseAddress));
N                    vSetQSPIC_FlshMemMap0_FDEN(eController, eFlashDensity);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FDEN=(eFlashDensity));
N                    vSetQSPIC_FlshMemMap0_RE(eController, eEnableMemMapRd);
X                    (((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> RE=(eEnableMemMapRd));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_FlshMemMap1_FBA(eController, u16FlashBaseAddress);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FBA=(u16FlashBaseAddress));
N                    vSetQSPIC_FlshMemMap1_FDEN(eController, eFlashDensity);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> FDEN=(eFlashDensity));
N                    vSetQSPIC_FlshMemMap1_RE(eController, eEnableMemMapRd);
X                    (((volatile QSPIC_FlshMemMap1_bit_view_st *)(0xC0109004U + ((int32_t)(eController)))) -> RE=(eEnableMemMapRd));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectSetReadCtrl(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32Ctrl)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_DirRdCtrl0(eController, u32Ctrl);
X                    (*((volatile u32QSPIC_DirRdCtrl0_word_view *)(0xC0109010U + ((int32_t)(eController)))) = (u32Ctrl));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_DirRdCtrl1(eController, u32Ctrl);
X                    (*((volatile u32QSPIC_DirRdCtrl1_word_view *)(0xC0109014U + ((int32_t)(eController)))) = (u32Ctrl));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectGetReadCtrl(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t * u32Ctrl)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *u32Ctrl = u32GetQSPIC_DirRdCtrl0(eController);
X                    *u32Ctrl = (*((volatile u32QSPIC_DirRdCtrl0_word_view *)(0xC0109010U + ((int32_t)(eController)))) );
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *u32Ctrl = u32GetQSPIC_DirRdCtrl1(eController);
X                    *u32Ctrl = (*((volatile u32QSPIC_DirRdCtrl1_word_view *)(0xC0109014U + ((int32_t)(eController)))) );
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectEnableWIPPolling(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e eEnable)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_DirAccCtrl0_PollWIP(eController, eEnable);
X                    (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> PollWIP=(eEnable));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_DirAccCtrl1_PollWIP(eController, eEnable);
X                    (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> PollWIP=(eEnable));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectGetStatusWIPPolling(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e * eEnable)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *eEnable = (qspic_en_e) biGetQSPIC_DirAccCtrl0_PollWIP(eController);
X                    *eEnable = (qspic_en_e) (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> PollWIP);
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *eEnable = (qspic_en_e) biGetQSPIC_DirAccCtrl1_PollWIP(eController);
X                    *eEnable = (qspic_en_e) (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> PollWIP);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectSetCSDeassertionTime(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8CSTime)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_DirAccCtrl0_SCSD(eController, u8CSTime);
X                    (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> SCSD=(u8CSTime));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_DirAccCtrl1_SCSD(eController, u8CSTime);
X                    (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> SCSD=(u8CSTime));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectGetCSDeassertionTime(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t * u8CSTime)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *u8CSTime = biGetQSPIC_DirAccCtrl0_SCSD(eController);
X                    *u8CSTime = (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> SCSD);
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *u8CSTime = biGetQSPIC_DirAccCtrl1_SCSD(eController);
X                    *u8CSTime = (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> SCSD);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmSetCSDeassertionTime(qspic_cntrl_e eController, uint8_t u8CSTime)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        vSetQSPIC_PrgAccCtrl0_SCSD(eController, u8CSTime);
X        (((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(0xC0109400U + ((int32_t)(eController)))) -> SCSD=(u8CSTime));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmGetCSDeassertionTime(qspic_cntrl_e eController, uint8_t * u8CSTime)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        *u8CSTime = biGetQSPIC_PrgAccCtrl0_SCSD(eController);
X        *u8CSTime = (((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(0xC0109400U + ((int32_t)(eController)))) -> SCSD);
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectSetDataCaptureEdge(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_sdce_e eEdge)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    vSetQSPIC_DirAccCtrl0_SDCE(eController, eEdge);
X                    (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> SDCE=(eEdge));
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    vSetQSPIC_DirAccCtrl1_SDCE(eController, eEdge);
X                    (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> SDCE=(eEdge));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_DirectGetDataCaptureEdge(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_sdce_e * eEdge)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        switch (eDevice)
N        {
N            case QSPIC_DEV_0:
N                {
N                    *eEdge = (qspic_sdce_e) biGetQSPIC_DirAccCtrl0_SDCE(eController);
X                    *eEdge = (qspic_sdce_e) (((volatile QSPIC_DirAccCtrl0_bit_view_st *)(0xC0109008U + ((int32_t)(eController)))) -> SDCE);
N                }
N                break;
N            case QSPIC_DEV_1:
N                {
N                    *eEdge = (qspic_sdce_e) biGetQSPIC_DirAccCtrl1_SDCE(eController);
X                    *eEdge = (qspic_sdce_e) (((volatile QSPIC_DirAccCtrl1_bit_view_st *)(0xC010900CU + ((int32_t)(eController)))) -> SDCE);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmSetDataCaptureEdge(qspic_cntrl_e eController, qspic_sdce_e eEdge)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        vSetQSPIC_PrgAccCtrl0_SDCE(eController, eEdge);
X        (((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(0xC0109400U + ((int32_t)(eController)))) -> SDCE=(eEdge));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmGetDataCaptureEdge(qspic_cntrl_e eController, qspic_sdce_e * eEdge)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        *eEdge = (qspic_sdce_e) biGetQSPIC_PrgAccCtrl0_SDCE(eController);
X        *eEdge = (qspic_sdce_e) (((volatile QSPIC_PrgAccCtrl0_bit_view_st *)(0xC0109400U + ((int32_t)(eController)))) -> SDCE);
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_EnableInterrupt(qspic_cntrl_e eController, qspic_en_e eEnable)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        vSetQSPIC_PrgAccIntEn_SpiIntEn(eController, eEnable);
X        (((volatile QSPIC_PrgAccIntEn_bit_view_st *)(0xC0109408U + ((int32_t)(eController)))) -> SpiIntEn=(eEnable));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_GetInterruptStatus(qspic_cntrl_e eController, qspic_en_e * eEnable)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        *eEnable = (qspic_en_e) biGetQSPIC_PrgAccIntEn_SpiIntEn(eController);
X        *eEnable = (qspic_en_e) (((volatile QSPIC_PrgAccIntEn_bit_view_st *)(0xC0109408U + ((int32_t)(eController)))) -> SpiIntEn);
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_IsSpiCycleDone(qspic_cntrl_e eController, bool_t * bResult)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        if ( 1==biGetQSPIC_PrgAccStat_SpiCycDone(eController) )
X        if ( 1==(((volatile QSPIC_PrgAccStat_bit_view_st *)(0xC010940CU + ((int32_t)(eController)))) -> SpiCycDone) )
N        {
N            /* reset the cycle done flag */
N            vSetQSPIC_PrgAccStat_SpiCycDone(eController, 0);
X            (((volatile QSPIC_PrgAccStat_bit_view_st *)(0xC010940CU + ((int32_t)(eController)))) -> SpiCycDone=(0));
N            *bResult = C_TRUE;
X            *bResult = (1);
N        }
N        else
N        {
N            *bResult = C_FALSE;
X            *bResult = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nbool_t boQSPIC_IsSpiCycleInPgrs(qspic_cntrl_e eController)
N{
N    bool_t bResult = C_FALSE;
X    bool_t bResult = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        if ( 1==biGetQSPIC_PrgAccStat_SpiCycInPrgrs(eController) )
X        if ( 1==(((volatile QSPIC_PrgAccStat_bit_view_st *)(0xC010940CU + ((int32_t)(eController)))) -> SpiCycInPrgrs) )
N        {
N            bResult = C_TRUE;
X            bResult = (1);
N        }
N    }
N    return bResult;
N}
N
N
N/****************************************************************************/
N
Nbool_t boQSPIC_IsSpiCycleDone(qspic_cntrl_e eController)
N{
N    bool_t bResult = C_FALSE;
X    bool_t bResult = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        if ( 1==biGetQSPIC_PrgAccStat_SpiCycDone(eController) )
X        if ( 1==(((volatile QSPIC_PrgAccStat_bit_view_st *)(0xC010940CU + ((int32_t)(eController)))) -> SpiCycDone) )
N        {
N            /* reset the cycle done flag */
N            vSetQSPIC_PrgAccStat_SpiCycDone(eController, 0);
X            (((volatile QSPIC_PrgAccStat_bit_view_st *)(0xC010940CU + ((int32_t)(eController)))) -> SpiCycDone=(0));
N            bResult = C_TRUE;
X            bResult = (1);
N        }
N    }
N
N    return bResult;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_WaitForCompletion(qspic_cntrl_e eController)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
N    {
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) )
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) )
N        {
N            ;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmStatusRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Status)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* default values for Prg Access Ctrl value is as follows:
N     * Primary and secondary buffer size = 0, both buffers are disabled
N     * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N     * SpiCycGo = Program Register Access is initiated.
N     */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                    (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
N        || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid status pointer */
N        if (C_NULL == pu8Status)
X        if (((void*)0) == pu8Status)
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            /* set up STATUS READ opcode */
N            vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_STS_READ);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_STS_READ));
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            if ( QSPIC_CNTRL_2 == eController )
N            {
N                /* for QSPIC_CNTRL_2 the data is always transmitted in secondary buffer */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N            }
N            else
N            {
N                /* for other controllers the data is transmitted in primary buffer */
N                /* set primary buffer byte counter 1 */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00010000U;
N            }
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            if ( QSPIC_CNTRL_2 == eController )
N            {
N                /* retrieve the status */
N                *pu8Status = u8GetQSPIC_SecBufDatN(eController, 0);
X                *pu8Status = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) );
N            }
N            else
N            {
N                /* retrieve the status */
N                *pu8Status = u8GetQSPIC_PriBufDatN(eController, 1);
X                *pu8Status = (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) );
N            }
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmStatusFlagRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Status)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* default values for Prg Access Ctrl value is as follows:
N     * Primary and secondary buffer size = 0, both buffers are disabled
N     * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N     * SpiCycGo = Program Register Access is initiated.
N     */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                    (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
N        || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid status pointer */
N        if (C_NULL == pu8Status)
X        if (((void*)0) == pu8Status)
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            /* set up STATUS READ opcode */
N            vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_RFST_READ);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_RFST_READ));
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            if ( QSPIC_CNTRL_2 == eController )
N            {
N                /* for QSPIC_CNTRL_2 the data is always transmitted in secondary buffer */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N            }
N            else
N            {
N                /* for other controllers the data is transmitted in primary buffer */
N                /* set primary buffer byte counter 1 */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00010000U;
N            }
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            if ( QSPIC_CNTRL_2 == eController )
N            {
N                /* retrieve the status */
N                *pu8Status = u8GetQSPIC_SecBufDatN(eController, 0);
X                *pu8Status = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) );
N            }
N            else
N            {
N                /* retrieve the status */
N                *pu8Status = u8GetQSPIC_PriBufDatN(eController, 1);
X                *pu8Status = (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) );
N            }
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmClearStatus(qspic_cntrl_e eController, qspic_dev_e eDevice)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                    (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
N        || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up WRITE ENABLE opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_STS_CLEAR);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_STS_CLEAR));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmReleaseDP(qspic_cntrl_e eController, qspic_dev_e eDevice)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                    ((eDevice==QSPIC_DEV_0) || ( eDevice==QSPIC_DEV_1)) )
N        || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up WRITE ENABLE opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_RELEASE_DP);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_RELEASE_DP));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmConfigurationRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Configuration)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    uint8_t u8ManID = 0;
N    uint8_t u8DevID = 0;
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                    (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
N        || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid status pointer */
N        if( C_NULL == pu8Configuration )
X        if( ((void*)0) == pu8Configuration )
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            i32Res = i32QSPIC_PgrmGetID(eController, eDevice, &u8ManID, &u8DevID);
N            if( C_SUCCESS == i32Res )
X            if( (0) == i32Res )
N            {
N                switch( u8ManID )
N                {
N                    /* Macronix */
N                    case 0xC2:
N                        /* wait for cycle completion of previous program access */
N                        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X                        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N                        /* set up STATUS READ opcode */
N                        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_CFGM_READ);
X                        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_CFGM_READ));
N
N                        if (QSPIC_DEV_1 == eDevice )
N                        {
N                            /* set SPI_CS1_N accordingly */
N                            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N                        }
N                        if ( QSPIC_CNTRL_2 == eController )
N                        {
N                            /* for QSPIC_CNTRL_2 the data is always transmitted in secondary buffer */
N                            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X                            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N                        }
N                        else
N                        {
N                          /* for other controllers the data is transmitted in primary buffer */
N                          /* set primary buffer byte counter 1 */
N                          u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
X                          u32PrgAccCtrl = u32PrgAccCtrl | 0x00010000U;
N                        }
N                        /* enable primary buffer */
N                        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X                        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N                        /* write value to register */
N                        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X                        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N                        /* wait until current program access cycle is completed */
N                        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X                        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N                        if ( QSPIC_CNTRL_2 == eController )
N                        {
N                           /* retrieve the status */
N                           *pu8Configuration = u8GetQSPIC_SecBufDatN(eController, 0);
X                           *pu8Configuration = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) );
N                        }
N                        else
N                        {
N                           /* retrieve the status */
N                           *pu8Configuration = u8GetQSPIC_PriBufDatN(eController, 1);
X                           *pu8Configuration = (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) );
N                        }
N                        i32Res = C_SUCCESS;
X                        i32Res = (0);
N
N                        break;
N
N                    /* Spansion */
N                    case 0x01:
N                        /* wait for cycle completion of previous program access */
N                        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X                        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N                        /* set up STATUS READ opcode */
N                        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_CFG_READ);
X                        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_CFG_READ));
N
N                        if (QSPIC_DEV_1 == eDevice )
N                        {
N                            /* set SPI_CS1_N accordingly */
N                            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N                        }
N                        /* set primary buffer byte counter 1 */
N                        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
X                        u32PrgAccCtrl = u32PrgAccCtrl | 0x00010000U;
N
N                        /* enable primary buffer */
N                        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X                        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N                        /* write value to register */
N                        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X                        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N                        /* wait until current program access cycle is completed */
N                        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X                        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N                        /* retrieve the status */
N                        *pu8Configuration = u8GetQSPIC_PriBufDatN(eController, 1);
X                        *pu8Configuration = (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) );
N
N                        i32Res = C_SUCCESS;
X                        i32Res = (0);
N                        break;
N
N                    default:
N                        i32Res = C_FAILED;
X                        i32Res = (-1);
N                        break;
N                }
N            }
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmConfigurationWrite(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Status,  uint8_t u8Conf)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                    (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
N        || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up WRITE REGISTER (WRR) opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_WRITE_REG);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_WRITE_REG));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        vSetQSPIC_SecBufDatN(eController, 0, u8Status);
X        (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (u8Status));
N        vSetQSPIC_SecBufDatN(eController, 1, u8Conf);
X        (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = (u8Conf));
N
N        /* set secondary buffer byte counter */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_CNT_1;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x01000000U;
N
N        /* enable secondary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N        i32Res = C_SUCCESS;
X        i32Res = (0);
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmWriteEnable(qspic_cntrl_e eController, qspic_dev_e eDevice)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up WRITE ENABLE opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_WRITE_EN);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_WRITE_EN));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmWriteDisable(qspic_cntrl_e eController, qspic_dev_e eDevice)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up WRITE DISABLE opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_WRITE_DIS);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_WRITE_DIS));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmSectErase(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_opcode_e eOpcode, uint32_t u32SpiPhysAddr)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    uint32_t u32Mask;
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        vSetQSPIC_PriBufDatN(eController, 0, eOpcode);                                      /* set up ERASE opcode */
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (eOpcode));                                       
N
N        /* check address byte count and set address accordingly */
N        if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
N        {
N            vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU)));      
N            vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 8) & 0xFFU)));      
N            vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 0) & 0xFFU)));      
N
N            /* set primary buffer byte counter */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_3;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00030000U;
N       }
N        else
N        {
N            u32Mask = ~(biGetQSPIC_FlshMemMap0_FBA(eController) >> 8);
X            u32Mask = ~((((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA) >> 8);
N            vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 24) & u32Mask));   /* SPI physical addr[31:23] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 24) & u32Mask)));    
N            vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU)));      
N            vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 8) & 0xFFU)));      
N            vSetQSPIC_PriBufDatN(eController, 4, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(4) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 0) & 0xFFU)));      
N
N            /* set primary buffer byte counter */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00040000U;
N        }
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N         /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmChipErase(qspic_cntrl_e eController, qspic_dev_e eDevice)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up FULL CHIP ERASE opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_CHIP_ERASE);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_CHIP_ERASE));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N         /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmPagePgrm(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32SpiPhysAddr, uint16_t u16DataCount, uint8_t* const pu8Data)
N{
N    uint16_t u16DataIndex;
N    uint32_t u32Cnt;
N    uint8_t  *pu8Buffer;
N    int32_t  i32Res;
N    uint32_t u32Mask;
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* get result buffer pointer */
N        pu8Buffer = pu8Data;
N
N        /* check for valid data buffer pointer */
N        if (C_NULL == pu8Buffer)
X        if (((void*)0) == pu8Buffer)
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_PAGE_PGRM);                       /* set up PAGE PROGRAM opcode */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_PAGE_PGRM));                        
N
N            if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
N            {
N                vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 8) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 0) & 0xFFU)));      
N
N                /* set primary buffer byte counter */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_3;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00030000U;
N            }
N            else
N            {
N                u32Mask = ~(biGetQSPIC_FlshMemMap0_FBA(eController) >> 8);
X                u32Mask = ~((((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA) >> 8);
N                vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 24) & u32Mask));   /* SPI physical addr[31:23] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 24) & u32Mask)));    
N                vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 8) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 4, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(4) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 0) & 0xFFU)));      
N
N                /* set primary buffer byte counter */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00040000U;
N            }
N
N            for (u16DataIndex = 0; u16DataIndex < u16DataCount; u16DataIndex++)
N            {
N                vSetQSPIC_SecBufDatN(eController, u16DataIndex, pu8Buffer[u16DataIndex]);
X                (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(u16DataIndex) * 0x001U))) = (pu8Buffer[u16DataIndex]));
N            }
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* set secondary buffer byte counter */
N            /* follwoing code simplified:
N             * u32PrgAccCtrl = u32PrgAccCtrl | ( (((uint32_t) (u16DataCount-1U) ) << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
N             * */
N            u32Cnt = ((uint32_t) u16DataCount) -1U;
N            u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
X            u32Cnt = u32Cnt << 24U;
N            u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
X            u32PrgAccCtrl |=  ( u32Cnt &  0xFF000000U );
N
N            /* enable secondary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmFastRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32SpiPhysAddr, uint16_t u16DataCount, uint8_t* const pu8Data)
N{
N    uint16_t u16DataIndex;
N    int32_t  i32Res;
N    uint32_t u32Cnt;
N    uint32_t u32Mask;
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid data buffer pointer */
N        if (C_NULL == pu8Data)
X        if (((void*)0) == pu8Data)
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_FAST_READ);                       /* set up FAST READ opcode */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_FAST_READ));                        
N
N            if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
N            {
N                vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 8) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 0) & 0xFFU)));      
N
N                /* set primary buffer byte counter (3 byte address plus 1 dummy byte) */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00040000U;
N            }
N            else
N            {
N                u32Mask = ~(biGetQSPIC_FlshMemMap0_FBA(eController) >> 8);
X                u32Mask = ~((((volatile QSPIC_FlshMemMap0_bit_view_st *)(0xC0109000U + ((int32_t)(eController)))) -> FBA) >> 8);
N                vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 24) & u32Mask));   /* SPI physical addr[31:23] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 24) & u32Mask)));    
N                vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 8) & 0xFFU)));      
N                vSetQSPIC_PriBufDatN(eController, 4, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(4) * 0x001U))) = ((uint8_t)((u32SpiPhysAddr >> 0) & 0xFFU)));      
N
N                /* set primary buffer byte counter (4 byte address plus 1 dummy byte) */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_5;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00050000U;
N            }
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* set secondary buffer byte counter */
N            /* follwoing code simplified:
N             *   u32PrgAccCtrl = u32PrgAccCtrl | (  (((uint32_t ) (u16DataCount-1) )  << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
N             */
N            u32Cnt = ((uint32_t) u16DataCount) -1U;
N            u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
X            u32Cnt = u32Cnt << 24U;
N            u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
X            u32PrgAccCtrl |=  ( u32Cnt &  0xFF000000U );
N
N            /* enable secondary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            /* copy reading result into result buffer array */
N            for (u16DataIndex = 0; u16DataIndex < u16DataCount; u16DataIndex++)
N            {
N                pu8Data[u16DataIndex] = u8GetQSPIC_SecBufDatN(eController, u16DataIndex);
X                pu8Data[u16DataIndex] = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(u16DataIndex) * 0x001U))) );
N            }
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32QSPIC_PgrmGetID(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8ManID, uint8_t* const pu8DevID)
N{
N    int32_t i32Res;
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N    uint32_t u32Address1, u32Address2;
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid data buffer pointer */
N        if( (C_NULL == pu8ManID) || (C_NULL == pu8DevID) )
X        if( (((void*)0) == pu8ManID) || (((void*)0) == pu8DevID) )
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_READ_ID);     /* set up READ ID opcode */
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_READ_ID));      
N
N            if (QSPIC_CNTRL_2 == eController)
N            {
N                u32Address1 = 0x12;
N                u32Address2 = 0x08;
N            }
N            else
N            {
N                u32Address1 = 0x0;
N                u32Address2 = 0x0;
N            }
N
N            if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
N            {
N                vSetQSPIC_PriBufDatN(eController, 1, u32Address1);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = (u32Address1));
N                vSetQSPIC_PriBufDatN(eController, 2, u32Address2);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = (u32Address2));
N                vSetQSPIC_PriBufDatN(eController, 3, 0x00);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = (0x00));
N
N                /* set primary buffer byte counter (3 byte addres plus 1 byte dummy byte) */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_3;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00030000U;
N            }
N            else
N            {
N                vSetQSPIC_PriBufDatN(eController, 1, u32Address1);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = (u32Address1));
N                vSetQSPIC_PriBufDatN(eController, 2, u32Address2);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = (u32Address2));
N                vSetQSPIC_PriBufDatN(eController, 3, 0x00);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = (0x00));
N                vSetQSPIC_PriBufDatN(eController, 4, 0x00);
X                (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(4) * 0x001U))) = (0x00));
N
N                /* set primary buffer byte counter (4 byte address plus 1 byte dummy byte) */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x00040000U;
N
N            }
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* set secondary buffer byte counter */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_CNT_1;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x01000000U;
N
N            /* enable secondary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            *pu8ManID = u8GetQSPIC_SecBufDatN(eController, 0);
X            *pu8ManID = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) );
N            *pu8DevID = u8GetQSPIC_SecBufDatN(eController, 1);
X            *pu8DevID = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) );
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmGetExtendedID(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Information)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid status pointer */
N        if( C_NULL == pu8Information )
X        if( ((void*)0) == pu8Information )
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            /* set up STATUS READ opcode */
N            vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_READ_EXTID);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (QSPIC_OPCODE_READ_EXTID));
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* set secondary buffer byte counter */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_CNT_3;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x03000000U;
N
N
N            /* enable secondary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            /* Retrieve the status */
N            pu8Information[0] = u8GetQSPIC_SecBufDatN(eController, 0);
X            pu8Information[0] = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) );
N            pu8Information[1] = u8GetQSPIC_SecBufDatN(eController, 1);
X            pu8Information[1] = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) );
N            pu8Information[2] = u8GetQSPIC_SecBufDatN(eController, 2);
X            pu8Information[2] = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) );
N            pu8Information[3] = u8GetQSPIC_SecBufDatN(eController, 3);
X            pu8Information[3] = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) );
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_WriteByte(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Value)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* wait for cycle completion of previous program access */
N        while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X        while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N        /* set up WRITE DISABLE opcode */
N        vSetQSPIC_PriBufDatN(eController, 0, u8Value);
X        (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (u8Value));
N
N        if (QSPIC_DEV_1 == eDevice )
N        {
N            /* set SPI_CS1_N accordingly */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N        }
N
N        /* enable primary buffer */
N        u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X        u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N        /* write value to register */
N        vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X        (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N        /* wait until current program access cycle is completed */
N        while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X        while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmGetRegister(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Command, uint16_t u16Count, uint8_t* pu8Information)
N{
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N    uint16_t u16Counter;
N    uint32_t u32Cnt;
N
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid status pointer */
N        if( C_NULL == pu8Information )
X        if( ((void*)0) == pu8Information )
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            /* set up STATUS READ opcode */
N            vSetQSPIC_PriBufDatN(eController, 0, u8Command);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (u8Command));
N            vSetQSPIC_PriBufDatN(eController, 1, 0x00);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = (0x00));
N            vSetQSPIC_PriBufDatN(eController, 2, 0x00);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = (0x00));
N            vSetQSPIC_PriBufDatN(eController, 3, 0x00);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = (0x00));
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N            /* set secondary buffer byte counter */
N            /* follwoing code simplified:
N             *   u32PrgAccCtrl = u32PrgAccCtrl | ( (((uint32_t) (u16Count-1) ) << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK);
N             */
N            u32Cnt = ((uint32_t) u16Count) -1U;
N            u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
X            u32Cnt = u32Cnt << 24U;
N            u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
X            u32PrgAccCtrl |=  ( u32Cnt &  0xFF000000U );
N
N            /* enable secondary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000020U;
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) ){}
N
N            /* Retrieve the status */
N            for (u16Counter=0; u16Counter<u16Count; u16Counter++)
N            {
N                *(pu8Information + u16Counter) = u8GetQSPIC_SecBufDatN(eController, u16Counter);
X                *(pu8Information + u16Counter) = (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(u16Counter) * 0x001U))) );
N            }
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N
Nint32_t i32QSPIC_PgrmWriteRegister(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Command, uint16_t u16Count, uint8_t* pu8Information)
N{
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N    uint16_t u16DataIndex;
N    uint32_t u32Cnt;
N
N    /* default values for Prg Access Ctrl value is as follows:
N      * Primary and secondary buffer size = 0, both buffers are disabled
N      * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
N      * SpiCycGo = Program Register Access is initiated.
N    */
N    uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
X    uint32_t u32PrgAccCtrl = 0x00000001U;
N
N
N    if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
N                        ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
N            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
N    {
N        /* check for valid status pointer */
N        if( C_NULL == pu8Information )
X        if( ((void*)0) == pu8Information )
N        {
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        }
N        else
N        {
N            /* wait for cycle completion of previous program access */
N            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
X            while ( (1) == boQSPIC_IsSpiCycleInPgrs(eController) ){}
N
N            /* set up STATUS READ opcode */
N            vSetQSPIC_PriBufDatN(eController, 0, u8Command);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(0) * 0x001U))) = (u8Command));
N            vSetQSPIC_PriBufDatN(eController, 1, 0x00);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(1) * 0x001U))) = (0x00));
N            vSetQSPIC_PriBufDatN(eController, 2, 0x00);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(2) * 0x001U))) = (0x00));
N            vSetQSPIC_PriBufDatN(eController, 3, 0x00);
X            (*((volatile u8QSPIC_PriBufDatN_byte_view *)(0xC0109500U + ((int32_t)(eController)) + ((int32_t)(3) * 0x001U))) = (0x00));
N
N            for (u16DataIndex = 0; u16DataIndex < u16Count; u16DataIndex++)
N            {
N                vSetQSPIC_SecBufDatN(eController, u16DataIndex, pu8Information[u16DataIndex]);
X                (*((volatile u8QSPIC_SecBufDatN_byte_view *)(0xC0109600U + ((int32_t)(eController)) + ((int32_t)(u16DataIndex) * 0x001U))) = (pu8Information[u16DataIndex]));
N            }
N
N            if (QSPIC_DEV_1 == eDevice )
N            {
N                /* set SPI_CS1_N accordingly */
N                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
X                u32PrgAccCtrl = u32PrgAccCtrl | 0x2U;
N            }
N
N            /* enable primary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
X            u32PrgAccCtrl = u32PrgAccCtrl | 0x00000010U;
N
N            /* set secondary buffer byte counter */
N            /* follwoing code simplified:
N             *   u32PrgAccCtrl = u32PrgAccCtrl | ( (((uint32_t) (u16Count-1) ) << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK);
N             */
N            u32Cnt = ((uint32_t) u16Count) -1U;
N            u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
X            u32Cnt = u32Cnt << 24U;
N            u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
X            u32PrgAccCtrl |=  ( u32Cnt &  0xFF000000U );
N
N            /* enable secondary buffer */
N            u32PrgAccCtrl = u32PrgAccCtrl | ( QSPIC_PACTRL_SEC_BUF_EN_BIT);
X            u32PrgAccCtrl = u32PrgAccCtrl | ( 0x00000020U);
N
N            /* write value to register */
N            vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
X            (*((volatile u32QSPIC_PrgAccCtrl1_word_view *)(0xC0109404U + ((int32_t)(eController)))) = (u32PrgAccCtrl));
N
N            /* wait until current program access cycle is completed */
N            while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) )
X            while ( (0) == boQSPIC_IsSpiCycleDone(eController) )
N            {
N                ;
N            }
N
N            /* Retrieve the status */
N/*            for (u16DataIndex=0; u16DataIndex<=u16Count; u16DataIndex++)
N            {
N                *(pu8Information + u16DataIndex) = u8GetQSPIC_SecBufDatN(eController, u16DataIndex);
N            }
N*/
N
N            i32Res = C_SUCCESS;
X            i32Res = (0);
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N
N/****************************************************************************/
N
Nuint32_t u32QSPIC_DirectReadWord(uint32_t u32SpiPhysAddr)
N{
N    return (uint32_t) word_read((int32_t)u32SpiPhysAddr);
N}
N
N
N/****************************************************************************/
N
Nvoid vQSPIC_DirectReadBurst4(uint32_t u32SpiPhysAddr, uint32_t * pu32Data)
N{
N    read_burst4((int32_t)u32SpiPhysAddr, pu32Data);
N}
N
N
N/****************************************************************************/
N
Nvoid vQSPIC_DirectReadBurst8(uint32_t u32SpiPhysAddr, uint32_t * pu32Data)
N{
N    read_burst8((int32_t)u32SpiPhysAddr, pu32Data);
N}
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N/****************************************************************************/
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: qspic.c
N**  $Revision: 1.40 $
N**  $Date: 2015/05/18 13:49:55 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :  5 (0286) String literal contains character which is not a
N** |                    member of the basic source character set.
N** |           5 (0288) Source file '<TEXT>' has comments containing characters
N** |                    which are not members of the basic source character set.
N** |          22 (3218) File scope static, '<TEXT>', only accessed in one
N** |                    function.
N** |          45 (0303) Cast between a pointer to volatile object and an
N** |                    integral type.
N** |          52 (1503) The function '%1s' is defined but is not used within
N** |                    this project.
N** |
N** | REASON : This is neccessary because of driver version control.
N** |
N** |
N** | RULE   : 52 (2018) This switch default label is unreachable.
N** |
N** | REASON : This is neccessary because of default statement in case.
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
N
