; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\pl353nand.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\pl353nand.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\pl353nand.crf ..\..\..\..\lldd\src\pl353nand.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  u16CRCGEN_CalculateCrc16 PROC
;;;173    /*..........................................................................*/
;;;174    uint16_t u16CRCGEN_CalculateCrc16 (const uint8_t pu8DataBuf[],
000000  e92d40f0          PUSH     {r4-r7,lr}
;;;175                                       uint32_t u32BufferLength)
;;;176    {
000004  e1a02000          MOV      r2,r0
000008  e1a03001          MOV      r3,r1
;;;177       const uint16_t u16GenPolynom = CRCGEN_POLYNOMIAL;
00000c  e3086005          MOV      r6,#0x8005
;;;178    
;;;179       const uint16_t u16TopBit = CRCGEN_TOP_BIT;
000010  e3087000          MOVW     r7,#0x8000
;;;180    
;;;181       uint16_t u16CRC = CRCGEN_INIT_VALUE;
000014  e3040f4e          MOV      r0,#0x4f4e
;;;182    
;;;183       uint32_t u32BufIdx;
;;;184    
;;;185       uint32_t u32BitIdx;
;;;186    
;;;187       /* Loop for each byte in the buffer */
;;;188       for (u32BufIdx = 0; u32BufIdx < u32BufferLength; u32BufIdx++)
000018  e3a01000          MOV      r1,#0
00001c  ea000012          B        |L1.108|
                  |L1.32|
;;;189       {
;;;190          uint16_t u16BufValue;
;;;191    
;;;192          u16BufValue = pu8DataBuf[u32BufIdx];
000020  e7d25001          LDRB     r5,[r2,r1]
;;;193          u16BufValue = (u16BufValue << 8);
000024  e30fcfff          MOV      r12,#0xffff
000028  e00c5405          AND      r5,r12,r5,LSL #8
;;;194          u16CRC = (u16CRC ^ u16BufValue);
00002c  e0200005          EOR      r0,r0,r5
;;;195    
;;;196          /* Loop for each bit in the byte */
;;;197          for (u32BitIdx = 0; u32BitIdx < 8; u32BitIdx++)
000030  e3a04000          MOV      r4,#0
000034  ea000009          B        |L1.96|
                  |L1.56|
;;;198          {
;;;199             if ((u16CRC & u16TopBit) != 0x0000U)
000038  e200c902          AND      r12,r0,#0x8000
00003c  e35c0000          CMP      r12,#0
000040  0a000003          BEQ      |L1.84|
;;;200             {
;;;201                u16CRC = ((u16CRC << 1) ^ u16GenPolynom);
000044  e308c005          MOV      r12,#0x8005
000048  e02cc080          EOR      r12,r12,r0,LSL #1
00004c  e6ff007c          UXTH     r0,r12
000050  ea000001          B        |L1.92|
                  |L1.84|
;;;202             }
;;;203             else
;;;204             {
;;;205                u16CRC = (u16CRC << 1);
000054  e30fcfff          MOV      r12,#0xffff
000058  e00c0080          AND      r0,r12,r0,LSL #1
                  |L1.92|
00005c  e2844001          ADD      r4,r4,#1              ;197
                  |L1.96|
000060  e3540008          CMP      r4,#8                 ;197
000064  3afffff3          BCC      |L1.56|
000068  e2811001          ADD      r1,r1,#1              ;188
                  |L1.108|
00006c  e1510003          CMP      r1,r3                 ;188
000070  3affffea          BCC      |L1.32|
;;;206             }
;;;207          }
;;;208       }
;;;209    
;;;210       return u16CRC;
;;;211    }
000074  e8bd80f0          POP      {r4-r7,pc}
;;;212    
                          ENDP

                  eNF_ConfigVerify PROC
;;;213    /*..........................................................................*/
;;;214    static NandFlashStatus_e eNF_ConfigVerify (const NandFlashCfg_st *
000078  e1a01000          MOV      r1,r0
;;;215                                               const pstNandCfg)
;;;216    {
;;;217       NandFlashStatus_e eResult;
;;;218    
;;;219    /***
;;;220    * MESSAGE: MISRA-C:2004 Rule 13.7 The result of this logical operation is always
;;;221    *          'false'.
;;;222    *
;;;223    * DESC   : The check below is required for enum types since NANDFLASH_BUS_WIDTH_16
;;;224    *          and NANDFLASH_EXTRA_BLOCK_32_BYTES values might contain values
;;;225    *          specified at the "run-time" and by out-of-range of the respective
;;;226    *          enumerations.
;;;227    ****/
;;;228       if ((pstNandCfg->u32ReadCycleTime < (NANDFLASH_RD_CYCLE_MIN)) ||
00007c  e5912024          LDR      r2,[r1,#0x24]
000080  e3520002          CMP      r2,#2
000084  3a000023          BCC      |L1.280|
;;;229           (pstNandCfg->u32ReadCycleTime > (NANDFLASH_RD_CYCLE_MAX)) ||
000088  e5912024          LDR      r2,[r1,#0x24]
00008c  e352000f          CMP      r2,#0xf
000090  8a000020          BHI      |L1.280|
;;;230           (pstNandCfg->u32WriteCycleTime < (NANDFLASH_WR_CYCLE_MIN)) ||
000094  e5912020          LDR      r2,[r1,#0x20]
000098  e3520002          CMP      r2,#2
00009c  3a00001d          BCC      |L1.280|
;;;231           (pstNandCfg->u32WriteCycleTime > (NANDFLASH_WR_CYCLE_MAX)) ||
0000a0  e5912020          LDR      r2,[r1,#0x20]
0000a4  e352000f          CMP      r2,#0xf
0000a8  8a00001a          BHI      |L1.280|
;;;232           (pstNandCfg->u32AssertDelayReN < (NANDFLASH_ASSERT_REN_MIN)) ||
0000ac  e5912030          LDR      r2,[r1,#0x30]
0000b0  e3520000          CMP      r2,#0
0000b4  0a000017          BEQ      |L1.280|
;;;233           (pstNandCfg->u32AssertDelayReN > (NANDFLASH_ASSERT_REN_MAX)) ||
0000b8  e5912030          LDR      r2,[r1,#0x30]
0000bc  e3520007          CMP      r2,#7
0000c0  8a000014          BHI      |L1.280|
;;;234           (pstNandCfg->u32DeAssertDelayWeN < (NANDFLASH_DEASSERT_WEN_MIN)) ||
0000c4  e591202c          LDR      r2,[r1,#0x2c]
0000c8  e3520000          CMP      r2,#0
0000cc  0a000011          BEQ      |L1.280|
;;;235           (pstNandCfg->u32DeAssertDelayWeN > (NANDFLASH_DEASSERT_WEN_MAX)) ||
0000d0  e591202c          LDR      r2,[r1,#0x2c]
0000d4  e3520007          CMP      r2,#7
0000d8  8a00000e          BHI      |L1.280|
;;;236           (pstNandCfg->u32StatusRdTime > (NANDFLASH_STATUS_RD_MAX)) ||
0000dc  e591201c          LDR      r2,[r1,#0x1c]
0000e0  e3520007          CMP      r2,#7
0000e4  8a00000b          BHI      |L1.280|
;;;237           (pstNandCfg->u32IdRdTime > (NANDFLASH_ID_RD_MAX)) ||
0000e8  e5912018          LDR      r2,[r1,#0x18]
0000ec  e3520007          CMP      r2,#7
0000f0  8a000008          BHI      |L1.280|
;;;238           (pstNandCfg->u32BusyCycleToReN > (NANDFLASH_BUSY_TO_REN_MAX)) ||
0000f4  e5912028          LDR      r2,[r1,#0x28]
0000f8  e352000f          CMP      r2,#0xf
0000fc  8a000005          BHI      |L1.280|
;;;239           (pstNandCfg->eBusWidth > (NANDFLASH_BUS_WIDTH_16)) ||               /* PRQA S 3356 */
000100  e5d12005          LDRB     r2,[r1,#5]
000104  e3520001          CMP      r2,#1
000108  ca000002          BGT      |L1.280|
;;;240           (pstNandCfg->eExtraBlockCfg > (NANDFLASH_EXTRA_BLOCK_32_BYTES)))    /* PRQA S 3356 */
00010c  e5d12006          LDRB     r2,[r1,#6]
000110  e3520003          CMP      r2,#3
000114  da000001          BLE      |L1.288|
                  |L1.280|
;;;241       {
;;;242          eResult = NANDFLASH_STATUS_CFG_ERR;   /* Invalid Parameter(s)! */
000118  e3a00005          MOV      r0,#5
00011c  ea000000          B        |L1.292|
                  |L1.288|
;;;243       }
;;;244       else
;;;245       {
;;;246          eResult = NANDFLASH_STATUS_OK;        /* All Parameters OK */
000120  e3a00000          MOV      r0,#0
                  |L1.292|
;;;247       }
;;;248       return eResult;
;;;249    }
000124  e12fff1e          BX       lr
;;;250    
                          ENDP

                  vNF_CopyConfigToRegs PROC
;;;252    /* TESTED */
;;;253    static void vNF_CopyConfigToRegs (const NandFlashCfg_st * const pstNandCfg)
000128  e92d4010          PUSH     {r4,lr}
;;;254    {
00012c  e1a01000          MOV      r1,r0
;;;255       uint32_t u32RegCfg;
;;;256    
;;;257       uint32_t u32DirCmdVal;
;;;258    
;;;259    
;;;260       /* copy cycles/opmode data from the configuration structure to registers */
;;;261       u32RegCfg = 0x00000000U;
000130  e3a00000          MOV      r0,#0
;;;262       u32RegCfg =
000134  e5913024          LDR      r3,[r1,#0x24]
000138  e1800003          ORR      r0,r0,r3
;;;263          u32RegCfg | ((pstNandCfg->u32ReadCycleTime) << (MEMCTRL_SET_T0_SFT));
;;;264       u32RegCfg =
00013c  e5913020          LDR      r3,[r1,#0x20]
000140  e1800203          ORR      r0,r0,r3,LSL #4
;;;265          u32RegCfg | ((pstNandCfg->u32WriteCycleTime) << (MEMCTRL_SET_T1_SFT));
;;;266       u32RegCfg =
000144  e5913030          LDR      r3,[r1,#0x30]
000148  e1800403          ORR      r0,r0,r3,LSL #8
;;;267          u32RegCfg | ((pstNandCfg->u32AssertDelayReN) << (MEMCTRL_SET_T2_SFT));
;;;268       u32RegCfg =
00014c  e591302c          LDR      r3,[r1,#0x2c]
000150  e1800583          ORR      r0,r0,r3,LSL #11
;;;269          u32RegCfg | ((pstNandCfg->u32DeAssertDelayWeN) << (MEMCTRL_SET_T3_SFT));
;;;270       u32RegCfg =
000154  e591301c          LDR      r3,[r1,#0x1c]
000158  e1800703          ORR      r0,r0,r3,LSL #14
;;;271          u32RegCfg | ((pstNandCfg->u32StatusRdTime) << (MEMCTRL_SET_T4_SFT));
;;;272       u32RegCfg = u32RegCfg | ((pstNandCfg->u32IdRdTime) << (MEMCTRL_SET_T5_SFT));
00015c  e1d131b8          LDRH     r3,[r1,#0x18]
000160  e1800883          ORR      r0,r0,r3,LSL #17
;;;273       u32RegCfg =
000164  e1d132b8          LDRH     r3,[r1,#0x28]
000168  e1800a03          ORR      r0,r0,r3,LSL #20
;;;274          u32RegCfg | ((pstNandCfg->u32BusyCycleToReN) << (MEMCTRL_SET_T6_SFT));
;;;275       MEMCTRL_SET_CYCLES = u32RegCfg;
00016c  e59f3e70          LDR      r3,|L1.4068|
000170  e5830014          STR      r0,[r3,#0x14]
;;;276       /* Force to 8-bit interface at the begining */
;;;277       MEMCTRL_SET_OPMODE = MEMCTRL_SET_MW_8_BITS;
000174  e3a03000          MOV      r3,#0
000178  e59f4e64          LDR      r4,|L1.4068|
00017c  e5843018          STR      r3,[r4,#0x18]
;;;278       /*
;;;279          Update cycles and opmode registers for NAND UpdateRegs (see PL353 spec.,
;;;280          page 3-12) */
;;;281       u32DirCmdVal = MEMCTRL_NAND_CHIP_SEL_MSK | MEMCTRL_CMD_TYPE_UPD_REGS_MSK;
000180  e3a02509          MOV      r2,#0x2400000
;;;282       MEMCTRL_DIRECT_CMD = u32DirCmdVal;
000184  e1c43002          BIC      r3,r4,r2
000188  e5832010          STR      r2,[r3,#0x10]
;;;283       /*
;;;284          Load Ecc Memory Config Register. Change the Extra block configuration
;;;285          bits Write it back to the register */
;;;286       u32RegCfg = MEMCTRL_ECC_MEMCFG;
00018c  e59f3e54          LDR      r3,|L1.4072|
000190  e5930000          LDR      r0,[r3,#0]
;;;287       u32RegCfg = u32RegCfg & (~MEMCTRL_ECC_EXTRA_BLOCK_MSK);
000194  e3c00b01          BIC      r0,r0,#0x400
;;;288       u32RegCfg = u32RegCfg & (~MEMCTRL_ECC_EXTRA_BLOCK_SIZE_MSK);
000198  e3c00b06          BIC      r0,r0,#0x1800
;;;289    
;;;290       switch (pstNandCfg->eExtraBlockCfg)
00019c  e5d13006          LDRB     r3,[r1,#6]
0001a0  e3530001          CMP      r3,#1
0001a4  0a000004          BEQ      |L1.444|
0001a8  e3530002          CMP      r3,#2
0001ac  0a000006          BEQ      |L1.460|
0001b0  e3530003          CMP      r3,#3
0001b4  1a00000c          BNE      |L1.492|
0001b8  ea000007          B        |L1.476|
                  |L1.444|
;;;291       {
;;;292          
;;;293          case NANDFLASH_EXTRA_BLOCK_8_BYTES:
0001bc  e320f000          NOP      
;;;294          {
;;;295             u32RegCfg = (u32RegCfg | (MEMCTRL_ECC_EXTRA_BLOCK_MSK));
0001c0  e3800b01          ORR      r0,r0,#0x400
;;;296             u32RegCfg = (u32RegCfg | (MEMCTRL_ECC_EXTRA_BLOCK_SIZE_8B_BITS));
0001c4  e3800b02          ORR      r0,r0,#0x800
;;;297          }
;;;298             break;
0001c8  ea00000a          B        |L1.504|
                  |L1.460|
;;;299          case NANDFLASH_EXTRA_BLOCK_16_BYTES:
0001cc  e320f000          NOP      
;;;300          {
;;;301             u32RegCfg = (u32RegCfg | (MEMCTRL_ECC_EXTRA_BLOCK_MSK));
0001d0  e3800b01          ORR      r0,r0,#0x400
;;;302             u32RegCfg = (u32RegCfg | (MEMCTRL_ECC_EXTRA_BLOCK_SIZE_16B_BITS));
0001d4  e3800a01          ORR      r0,r0,#0x1000
;;;303          }
;;;304             break;
0001d8  ea000006          B        |L1.504|
                  |L1.476|
;;;305          case NANDFLASH_EXTRA_BLOCK_32_BYTES:
0001dc  e320f000          NOP      
;;;306          {
;;;307             u32RegCfg = (u32RegCfg | (MEMCTRL_ECC_EXTRA_BLOCK_MSK));
0001e0  e3800b01          ORR      r0,r0,#0x400
;;;308             u32RegCfg = (u32RegCfg | (MEMCTRL_ECC_EXTRA_BLOCK_SIZE_32B_BITS));
0001e4  e3800b06          ORR      r0,r0,#0x1800
;;;309          }
;;;310             break;
0001e8  ea000002          B        |L1.504|
                  |L1.492|
;;;311          default:
0001ec  e320f000          NOP      
;;;312          {
;;;313             /* DISABLED for NANDFLASH_EXTRA_BLOCK_DISABLED and invalid values */
;;;314             u32RegCfg = (u32RegCfg & (~MEMCTRL_ECC_EXTRA_BLOCK_MSK));
0001f0  e3c00b01          BIC      r0,r0,#0x400
;;;315          }
;;;316             break;
0001f4  e320f000          NOP      
                  |L1.504|
0001f8  e320f000          NOP                            ;298
;;;317       }
;;;318       MEMCTRL_ECC_MEMCFG = u32RegCfg;
0001fc  e59f3de4          LDR      r3,|L1.4072|
000200  e5830000          STR      r0,[r3,#0]
;;;319    }
000204  e8bd8010          POP      {r4,pc}
;;;320    
                          ENDP

                  NF_uSecWait PROC
;;;1627   /*..........................................................................*/
;;;1628   void NF_uSecWait (uint32_t u32usTime)
000208  e320f000          NOP      
                  |L1.524|
;;;1629   {
;;;1630   /***
;;;1631   * MESSAGE: MISRA-C:2004 Rule 13.2 Value of control expression is not derived
;;;1632   *          from an explicit logical operation.
;;;1633   *
;;;1634   * DESC   : The message for below condition is TRUE, however, to keep the
;;;1635   *          execution time unchanged (SW wait-loop) the source code will remain
;;;1636   *          unchanged.
;;;1637   ****/
;;;1638   /***
;;;1639   * MESSAGE: MISRA-C:2004 Rule 21.1 Unsigned arithmetic definitely results in
;;;1640   *          wraparound past zero.
;;;1641   *
;;;1642   * DESC   : The wraparound even, if would happen should not be dangerous, since
;;;1643   *          the value of '0' should end the counting process, and the u32usTime
;;;1644   *          variable is not used later within the function.
;;;1645   ****/
;;;1646   
;;;1647   /***
;;;1648   * MESSAGE: MISRA-C:2004 Rule 12.13 Result of ++ or -- operator used in expression.
;;;1649   *
;;;1650   * DESC   : This very simple count-own loop has been verfied to generate time
;;;1651   *          intervals based on instruction execution. Thus the implementation
;;;1652   *          will remain.
;;;1653   ****/
;;;1654   
;;;1655       while( u32usTime-- )    /* PRQA S 3372 */  /* PRQA S 3344 */
00020c  e1b01000          MOVS     r1,r0
000210  e2400001          SUB      r0,r0,#1
000214  1afffffc          BNE      |L1.524|
;;;1656       {
;;;1657          ;
;;;1658       }
;;;1659   }
000218  e12fff1e          BX       lr
;;;1660   
                          ENDP

                  vNF_CmdPhaseAxi PROC
;;;322    /* TESTED */
;;;323    static void vNF_CmdPhaseAxi (const NandFlashCfg_st * const pstNandCfg,
00021c  e92d41f0          PUSH     {r4-r8,lr}
;;;324                                 uint32_t u32StartCommand)
;;;325    {
000220  e1a04000          MOV      r4,r0
000224  e1a07001          MOV      r7,r1
;;;326       uint32_t u32CmdPh;                       /* Word to be send within a command
;;;327                                                   phase */
;;;328       uint32_t *pu32CmdPhDest;
;;;329    
;;;330    
;;;331       if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
000228  e5d40004          LDRB     r0,[r4,#4]
00022c  e3500000          CMP      r0,#0
000230  1a000002          BNE      |L1.576|
;;;332       {
;;;333          NANDFLASH_CLEAR_READY_IRQ ();
000234  e3a00010          MOV      r0,#0x10
000238  e59f1da4          LDR      r1,|L1.4068|
00023c  e581000c          STR      r0,[r1,#0xc]
                  |L1.576|
;;;334       }
;;;335    
;;;336       /*
;;;337          WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;338          already. */
;;;339       u32CmdPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
000240  e5940000          LDR      r0,[r4,#0]
000244  e20054ff          AND      r5,r0,#0xff000000
;;;340       u32CmdPh = (u32CmdPh | (u32StartCommand << (MEMCTRL_AXI_START_COMMAND_SFT)));
000248  e1855187          ORR      r5,r5,r7,LSL #3
;;;341    /***
;;;342    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;343    *          integral type.
;;;344    *
;;;345    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;346    *          specific pointer/access based on the integer value built upon the
;;;347    *          combination of integer parameters.
;;;348    ****/
;;;349       pu32CmdPhDest = (uint32_t *)u32CmdPh;    /* PRQA S 0306 */
00024c  e1a06005          MOV      r6,r5
;;;350    
;;;351       /*
;;;352          No any address cycles are send (only command). According to SMC spec.
;;;353          When issuing a command phase access with address cycles==0 : at least one
;;;354          byte lane must be enabled. */
;;;355       *pu32CmdPhDest = 0U;                     /* wdata don't care according to
000250  e3a00000          MOV      r0,#0
000254  e5860000          STR      r0,[r6,#0]
;;;356                                                   SMC spec. page 2-23 */
;;;357       __DSB();
000258  ebfffffe          BL       __DSB
;;;358    
;;;359       if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
00025c  e5d40004          LDRB     r0,[r4,#4]
000260  e3500000          CMP      r0,#0
000264  1a000001          BNE      |L1.624|
;;;360       {
;;;361          NF_uSecWait ((3U * NANDFLASH_TIME_1us));
000268  e3a0001e          MOV      r0,#0x1e
00026c  ebfffffe          BL       NF_uSecWait
                  |L1.624|
;;;362       }
;;;363    }
000270  e8bd81f0          POP      {r4-r8,pc}
;;;364    
                          ENDP

                  vNF_CmdPhaseAxiRegAddr PROC
;;;367    /* TESTED */
;;;368    static void vNF_CmdPhaseAxiRegAddr (const NandFlashCfg_st * const pstNandCfg,
000274  e92d41f0          PUSH     {r4-r8,lr}
;;;369                                        uint32_t u32RegAdr,
;;;370                                        uint32_t u32StartCommand)
;;;371    {
000278  e1a05000          MOV      r5,r0
00027c  e1a07001          MOV      r7,r1
000280  e1a08002          MOV      r8,r2
;;;372       uint32_t u32CmdPh;                       /* Word to be send within a command
;;;373                                                   phase */
;;;374       uint32_t *pu32CmdPhDest;
;;;375    
;;;376    
;;;377       if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
000284  e5d50004          LDRB     r0,[r5,#4]
000288  e3500000          CMP      r0,#0
00028c  1a000002          BNE      |L1.668|
;;;378       {
;;;379          NANDFLASH_CLEAR_READY_IRQ ();
000290  e3a00010          MOV      r0,#0x10
000294  e59f1d48          LDR      r1,|L1.4068|
000298  e581000c          STR      r0,[r1,#0xc]
                  |L1.668|
;;;380       }
;;;381       /*
;;;382          WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;383          already... */
;;;384       u32CmdPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
00029c  e5950000          LDR      r0,[r5,#0]
0002a0  e20044ff          AND      r4,r0,#0xff000000
;;;385       u32CmdPh = (u32CmdPh | (0x1U << (MEMCTRL_AXI_ADDRES_CYCLES_SFT)));
0002a4  e3844602          ORR      r4,r4,#0x200000
;;;386       u32CmdPh =
0002a8  e320f000          NOP      
;;;387          (u32CmdPh | (NF_PAR_CMD_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;388       u32CmdPh = (u32CmdPh | (u32StartCommand << (MEMCTRL_AXI_START_COMMAND_SFT)));
0002ac  e1844188          ORR      r4,r4,r8,LSL #3
;;;389    /***
;;;390    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;391    *          integral type.
;;;392    *
;;;393    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;394    *          specific pointer/access based on the integer value built upon the
;;;395    *          combination of integer parameters.
;;;396    ****/
;;;397       pu32CmdPhDest = (uint32_t *)u32CmdPh;    /* PRQA S 0306 */
0002b0  e1a06004          MOV      r6,r4
;;;398       /* Send a command with parameter(address) to the device */
;;;399       *pu32CmdPhDest = u32RegAdr;
0002b4  e5867000          STR      r7,[r6,#0]
;;;400        __DSB();
0002b8  ebfffffe          BL       __DSB
;;;401    
;;;402       if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
0002bc  e5d50004          LDRB     r0,[r5,#4]
0002c0  e3500000          CMP      r0,#0
0002c4  1a000001          BNE      |L1.720|
;;;403       {
;;;404          NF_uSecWait ((3U * NANDFLASH_TIME_1us));
0002c8  e3a0001e          MOV      r0,#0x1e
0002cc  ebfffffe          BL       NF_uSecWait
                  |L1.720|
;;;405       }
;;;406    }
0002d0  e8bd81f0          POP      {r4-r8,pc}
;;;407    
                          ENDP

                  vNF_CmdPhaseAxiCplx PROC
;;;409    /* TESTED */
;;;410    void vNF_CmdPhaseAxiCplx (const NandFlashCfg_st * const pstNandCfg,
0002d4  e92d4ffe          PUSH     {r1-r11,lr}
;;;411                              uint32_t u32ColAdr, uint32_t u32PageNo,
;;;412                              uint32_t u32BlockNo, uint32_t u32StartCommand,
;;;413                              uint32_t u32EndCmdValid, uint32_t u32EndCommand)
;;;414    {
0002d8  e1a05000          MOV      r5,r0
0002dc  e1a08001          MOV      r8,r1
0002e0  e1a09002          MOV      r9,r2
0002e4  e1a06003          MOV      r6,r3
;;;415       uint32_t u32CmdPh;                       /* Word to be send within a command
;;;416                                                   phase */
;;;417       uint32_t u32Data;
;;;418    
;;;419       uint32_t u32_BA7_6;
;;;420    
;;;421       uint32_t u32_BA15_8;
;;;422    
;;;423       uint32_t u32_PA5_0;
;;;424    
;;;425       uint32_t u32DataNext;
;;;426    
;;;427       uint32_t *pu32CmdPhDest;
;;;428    
;;;429    
;;;430       if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
0002e8  e5d50004          LDRB     r0,[r5,#4]
0002ec  e3500000          CMP      r0,#0
0002f0  1a000002          BNE      |L1.768|
;;;431       {
;;;432          NANDFLASH_CLEAR_READY_IRQ ();
0002f4  e3a00010          MOV      r0,#0x10
0002f8  e59f1ce4          LDR      r1,|L1.4068|
0002fc  e581000c          STR      r0,[r1,#0xc]
                  |L1.768|
;;;433       }
;;;434       /* u32NandChipAddress should be stored in cfg structure shifted already */
;;;435       u32CmdPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
000300  e5950000          LDR      r0,[r5,#0]
000304  e20044ff          AND      r4,r0,#0xff000000
;;;436       u32CmdPh =
000308  e1d500b8          LDRH     r0,[r5,#8]
00030c  e1844a80          ORR      r4,r4,r0,LSL #21
;;;437          (u32CmdPh |
;;;438           (pstNandCfg->u32PageAdrCycNo << (MEMCTRL_AXI_ADDRES_CYCLES_SFT)));
;;;439       u32CmdPh = (u32CmdPh | (u32EndCmdValid << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
000310  e59d0034          LDR      r0,[sp,#0x34]
000314  e1844a00          ORR      r4,r4,r0,LSL #20
;;;440       u32CmdPh =
000318  e320f000          NOP      
;;;441          (u32CmdPh | (NF_PAR_CMD_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;442       u32CmdPh = (u32CmdPh | (u32EndCommand << (MEMCTRL_AXI_END_COMMAND_SFT)));
00031c  e59d0038          LDR      r0,[sp,#0x38]
000320  e1844580          ORR      r4,r4,r0,LSL #11
;;;443       u32CmdPh = (u32CmdPh | (u32StartCommand << (MEMCTRL_AXI_START_COMMAND_SFT)));
000324  e59d0030          LDR      r0,[sp,#0x30]
000328  e1844180          ORR      r4,r4,r0,LSL #3
;;;444    
;;;445       /*
;;;446          5 or more (max. upto 7) address cycles require 2 32-bit words to be send,
;;;447          since each word can carry upto 4 bytes (1 cycle == 1 byte). CHECK ORDER:
;;;448          Data1 or Data2 first? Spec. says that we should 1st. send the data
;;;449          containg the most significant part of the address (u32Data1) and after
;;;450          that lower significant part of the address (u32Data2). This MUST be
;;;451          verified!!! */
;;;452       /* Construct Command-Phase Data Re-formatted address: WARNING: This code
;;;453          should be valid for devices with 2kB pages only. consider suppport of
;;;454          4kB or bigger (or smaller than 2kB pages). See page 13 of MICRON
;;;455          MT29FG08xxx For 5 or more address cycles the device expects: 1st.
;;;456          cycle: CA7..CA0 bits 2nd. cycle: CA11..CA0 bits (right aligned) 3rd.
;;;457          cycle: BA7, BA6, PA5..PA0 bits 4th. cycle: BA15..BA8 bits 5th. cycle:
;;;458          BA17..BA6 bits (right aligned) */
;;;459    
;;;460        /* Construct 1st. and 2nd. cycle byte; CA11-0: offset within page */
;;;461        u32Data = u32ColAdr;
00032c  e1a07008          MOV      r7,r8
;;;462        /* Construct 3rd. cycle byte */
;;;463        u32_PA5_0 = (u32PageNo & 0x3FU);
000330  e209003f          AND      r0,r9,#0x3f
000334  e58d0008          STR      r0,[sp,#8]
;;;464        u32_BA7_6 = (((u32BlockNo << 6) & 0xC0U));
000338  e3a000c0          MOV      r0,#0xc0
00033c  e000a306          AND      r10,r0,r6,LSL #6
;;;465        u32Data = (u32Data | ((u32_BA7_6 | u32_PA5_0) << 16));
000340  e59d0008          LDR      r0,[sp,#8]
000344  e180000a          ORR      r0,r0,r10
000348  e1877800          ORR      r7,r7,r0,LSL #16
;;;466        /* Construct 4th. cycle byte */
;;;467        u32_BA15_8 = (((u32BlockNo >> 2) & 0xFFU));
00034c  e7e7b156          UBFX     r11,r6,#2,#8
;;;468        u32Data = (u32Data | (u32_BA15_8 << 24));
000350  e1877c0b          ORR      r7,r7,r11,LSL #24
;;;469    
;;;470       if (pstNandCfg->u32PageAdrCycNo >= 5U)   /* check if command has 5 or more
000354  e5950008          LDR      r0,[r5,#8]
000358  e3500005          CMP      r0,#5
00035c  3a000007          BCC      |L1.896|
;;;471                                                   adress cycles */
;;;472       {
;;;473          /* Construct cycle 5th. byte */
;;;474          u32DataNext = (u32BlockNo >> 10); /* BA ?? ..BA16 bits */
000360  e1a00526          LSR      r0,r6,#10
000364  e58d0004          STR      r0,[sp,#4]
;;;475          /* Send all address bytes/cycles from u32Dat1 using burst of 2 */
;;;476          vNF_AddrBrstWr(u32CmdPh, u32Data, u32DataNext);
000368  e1a01007          MOV      r1,r7
00036c  e1a00004          MOV      r0,r4
000370  e59d2004          LDR      r2,[sp,#4]
000374  ebfffffe          BL       vNF_AddrBrstWr
;;;477          __DSB();
000378  ebfffffe          BL       __DSB
00037c  ea000003          B        |L1.912|
                  |L1.896|
;;;478       }
;;;479       else /* 4 address bytes only */
;;;480       {
;;;481          /* Pointer init */
;;;482    /***
;;;483    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;484    *          integral type.
;;;485    *
;;;486    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;487    *          specific pointer/access based on the integer value built upon the
;;;488    *          combination of integer parameters.
;;;489    ****/
;;;490          pu32CmdPhDest = (uint32_t *)u32CmdPh;    /* PRQA S 0306 */
000380  e58d4000          STR      r4,[sp,#0]
;;;491          /* Send 4 address bytes/cycles from u32Dat1 */
;;;492          *pu32CmdPhDest = u32Data;
000384  e59d4000          LDR      r4,[sp,#0]
000388  e5847000          STR      r7,[r4,#0]
;;;493          __DSB();
00038c  ebfffffe          BL       __DSB
                  |L1.912|
;;;494       }
;;;495       if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
000390  e5d50004          LDRB     r0,[r5,#4]
000394  e3500000          CMP      r0,#0
000398  1a000001          BNE      |L1.932|
;;;496       {
;;;497          NF_uSecWait ((3U * NANDFLASH_TIME_1us));
00039c  e3a0001e          MOV      r0,#0x1e
0003a0  ebfffffe          BL       NF_uSecWait
                  |L1.932|
;;;498       }
;;;499    }
0003a4  e8bd8ffe          POP      {r1-r11,pc}
;;;500    
                          ENDP

                  u32NF_DataPhaseAxiRead PROC
;;;503    /* TESTED */
;;;504    static uint32_t u32NF_DataPhaseAxiRead (const NandFlashCfg_st *
0003a8  e92d4070          PUSH     {r4-r6,lr}
;;;505                                            const pstNandCfg, uint32_t u32ClearCs,
;;;506                                            uint32_t u32EccLast)
;;;507    {
0003ac  e1a03000          MOV      r3,r0
;;;508       uint32_t u32DatPh;                       /* to be send within a data phase */
;;;509    
;;;510       uint32_t *pu32CmdPhDest;
;;;511    
;;;512       uint32_t u32DataRead;
;;;513    
;;;514       /*
;;;515          WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;516          already... No any END Command send! */
;;;517       u32DatPh = (((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK))
0003b0  e5936000          LDR      r6,[r3,#0]
0003b4  e20664ff          AND      r6,r6,#0xff000000
0003b8  e1866a81          ORR      r6,r6,r1,LSL #21
0003bc  e3866702          ORR      r6,r6,#0x80000
0003c0  e1864502          ORR      r4,r6,r2,LSL #10
;;;518                   | (u32ClearCs << (MEMCTRL_AXI_CLEAR_CS_SFT))
;;;519                   | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT))
;;;520                   | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
;;;521    /***
;;;522    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;523    *          integral type.
;;;524    *
;;;525    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;526    *          specific pointer/access based on the integer value built upon the
;;;527    *          combination of integer parameters.
;;;528    ****/
;;;529       pu32CmdPhDest = (uint32_t *)u32DatPh;    /* PRQA S 0306 */
0003c4  e1a05004          MOV      r5,r4
;;;530       /* Construct Command-Phase Data Re-formatted address */
;;;531       u32DataRead = *pu32CmdPhDest;            /* read from device */
0003c8  e5950000          LDR      r0,[r5,#0]
;;;532    
;;;533       return u32DataRead;
;;;534    }
0003cc  e8bd8070          POP      {r4-r6,pc}
;;;535    
                          ENDP

                  vNF_DataPhaseAxiRdMulti PROC
;;;537    /* TESTED */
;;;538    static void vNF_DataPhaseAxiRdMulti (const NandFlashCfg_st * const pstNandCfg,
0003d0  e92d40f0          PUSH     {r4-r7,lr}
;;;539                                         uint32_t u32BufferLen,
;;;540                                         uint32_t pu32DstBuf[], uint32_t u32EccLast,
;;;541                                         uint32_t pu32ExtrBuf[])
;;;542    {
0003d4  e1a04000          MOV      r4,r0
0003d8  e1a07001          MOV      r7,r1
0003dc  e1a05002          MOV      r5,r2
0003e0  e1a0c003          MOV      r12,r3
0003e4  e59d6014          LDR      r6,[sp,#0x14]
;;;543       uint32_t u32DatPh;                       /* Word to be send within a command
;;;544                                                   phase */
;;;545       uint32_t *pu32CmdPhDest;
;;;546    
;;;547       uint32_t u32Idx;
;;;548    
;;;549       uint32_t u32ExtrBufLen;               /* Extra Length in 32-bit Words */
;;;550    
;;;551    
;;;552       /* WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;553          already. */
;;;554       u32DatPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
0003e8  e594e000          LDR      lr,[r4,#0]
0003ec  e20e04ff          AND      r0,lr,#0xff000000
;;;555       u32DatPh = (u32DatPh | (NF_PAR_CS_ACTIV << (MEMCTRL_AXI_CLEAR_CS_SFT)));
0003f0  e320f000          NOP      
;;;556       u32DatPh =
0003f4  e3800702          ORR      r0,r0,#0x80000
;;;557          (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;558       u32DatPh = (u32DatPh | (NF_PAR_ECC_CALC << (MEMCTRL_AXI_ECC_LAST_SFT)));
0003f8  e320f000          NOP      
;;;559    /***
;;;560    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;561    *          integral type.
;;;562    *
;;;563    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;564    *          specific pointer/access based on the integer value built upon the
;;;565    *          combination of integer parameters.
;;;566    ****/
;;;567       pu32CmdPhDest = (uint32_t *)u32DatPh;    /* PRQA S 0306 */
0003fc  e1a02000          MOV      r2,r0
;;;568    
;;;569       /* Read only 2kB page (without extra block), if Disabled or the destination
;;;570          buffer is NULL (when function is called for Spare Area read) */
;;;571       if ((pstNandCfg->eExtraBlockCfg == NANDFLASH_EXTRA_BLOCK_DISABLED) ||
000400  e5d4e006          LDRB     lr,[r4,#6]
000404  e35e0000          CMP      lr,#0
000408  0a000001          BEQ      |L1.1044|
;;;572           (pu32ExtrBuf == (uint32_t *)0x00U))
00040c  e3560000          CMP      r6,#0
000410  1a000010          BNE      |L1.1112|
                  |L1.1044|
;;;573       {
;;;574          for (u32Idx = 0U; u32Idx < (u32BufferLen - 1U); u32Idx++)
000414  e3a01000          MOV      r1,#0
000418  ea000002          B        |L1.1064|
                  |L1.1052|
;;;575          {
;;;576             /* destination is always 32-bit (min. 4 bytes are read from NAND) */
;;;577             pu32DstBuf[u32Idx] = (*pu32CmdPhDest);
00041c  e592e000          LDR      lr,[r2,#0]
000420  e785e101          STR      lr,[r5,r1,LSL #2]
000424  e2811001          ADD      r1,r1,#1              ;574
                  |L1.1064|
000428  e247e001          SUB      lr,r7,#1              ;574
00042c  e15e0001          CMP      lr,r1                 ;574
000430  8afffff9          BHI      |L1.1052|
;;;578          }
;;;579          /*
;;;580             Chip select must be finished in the last transfer. ECC calculation End
;;;581             depends on the u32EccLast parameter value. */
;;;582          u32DatPh =
000434  e594e000          LDR      lr,[r4,#0]
000438  e20e04ff          AND      r0,lr,#0xff000000
;;;583             ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
;;;584          u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
00043c  e3800602          ORR      r0,r0,#0x200000
;;;585          u32DatPh =
000440  e3800702          ORR      r0,r0,#0x80000
;;;586             (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;587          u32DatPh = (u32DatPh | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
000444  e180050c          ORR      r0,r0,r12,LSL #10
;;;588    /***
;;;589    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;590    *          integral type.
;;;591    *
;;;592    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;593    *          specific pointer/access based on the integer value built upon the
;;;594    *          combination of integer parameters.
;;;595    ****/
;;;596          pu32CmdPhDest = (uint32_t *)u32DatPh;    /* PRQA S 0306 */
000448  e1a02000          MOV      r2,r0
;;;597          /* LAST 32-bit word from device */
;;;598          pu32DstBuf[u32Idx] = (*pu32CmdPhDest);
00044c  e592e000          LDR      lr,[r2,#0]
000450  e785e101          STR      lr,[r5,r1,LSL #2]
000454  ea000029          B        |L1.1280|
                  |L1.1112|
;;;599       }
;;;600       else
;;;601       {
;;;602          /* Extra block enabled and read was for Main Page Area */
;;;603          for (u32Idx = 0U; u32Idx < u32BufferLen; u32Idx++)
000458  e3a01000          MOV      r1,#0
00045c  ea000002          B        |L1.1132|
                  |L1.1120|
;;;604          {
;;;605             /* destination is always 32-bit (min. 4 bytes are read from NAND) */
;;;606             pu32DstBuf[u32Idx] = (*pu32CmdPhDest);
000460  e592e000          LDR      lr,[r2,#0]
000464  e785e101          STR      lr,[r5,r1,LSL #2]
000468  e2811001          ADD      r1,r1,#1              ;603
                  |L1.1132|
00046c  e1510007          CMP      r1,r7                 ;603
000470  3afffffa          BCC      |L1.1120|
;;;607          }
;;;608          /* Default Extra Buffer Length: 32 bytes == 8 x 32-bit words */
;;;609          switch (pstNandCfg->eExtraBlockCfg)
000474  e5d4e006          LDRB     lr,[r4,#6]
000478  e35e0001          CMP      lr,#1
00047c  0a000008          BEQ      |L1.1188|
000480  e35e0002          CMP      lr,#2
000484  0a000003          BEQ      |L1.1176|
000488  e35e0003          CMP      lr,#3
00048c  1a000007          BNE      |L1.1200|
;;;610          {
;;;611             case NANDFLASH_EXTRA_BLOCK_32_BYTES:
;;;612             {
;;;613                u32ExtrBufLen = (32U >> 2);
000490  e3a03008          MOV      r3,#8
;;;614             }
;;;615                break;
000494  ea000008          B        |L1.1212|
                  |L1.1176|
;;;616    
;;;617             case NANDFLASH_EXTRA_BLOCK_16_BYTES:
000498  e320f000          NOP      
;;;618             {
;;;619                u32ExtrBufLen = (16U >> 2);
00049c  e3a03004          MOV      r3,#4
;;;620             }
;;;621                break;
0004a0  ea000005          B        |L1.1212|
                  |L1.1188|
;;;622    
;;;623             case NANDFLASH_EXTRA_BLOCK_8_BYTES:
0004a4  e320f000          NOP      
;;;624             {
;;;625                u32ExtrBufLen = (8U >> 2);
0004a8  e3a03002          MOV      r3,#2
;;;626             }
;;;627                break;
0004ac  ea000002          B        |L1.1212|
                  |L1.1200|
;;;628    
;;;629             default:                          /* 4-bytes */
0004b0  e320f000          NOP      
;;;630             {
;;;631                u32ExtrBufLen = (4U >> 2);
0004b4  e3a03001          MOV      r3,#1
0004b8  e320f000          NOP                            ;609
                  |L1.1212|
0004bc  e320f000          NOP                            ;615
;;;632             }
;;;633          }
;;;634    
;;;635          for (u32Idx = 0U; u32Idx < (u32ExtrBufLen - 1); u32Idx++)
0004c0  e3a01000          MOV      r1,#0
0004c4  ea000002          B        |L1.1236|
                  |L1.1224|
;;;636          {
;;;637             /* destination is always 32-bit (min. 4 bytes are read from NAND) */
;;;638             pu32ExtrBuf[u32Idx] = (*pu32CmdPhDest);
0004c8  e592e000          LDR      lr,[r2,#0]
0004cc  e786e101          STR      lr,[r6,r1,LSL #2]
0004d0  e2811001          ADD      r1,r1,#1              ;635
                  |L1.1236|
0004d4  e243e001          SUB      lr,r3,#1              ;635
0004d8  e15e0001          CMP      lr,r1                 ;635
0004dc  8afffff9          BHI      |L1.1224|
;;;639          }
;;;640          /*
;;;641             Chip select must be finished in the last transfer. ECC calculation End
;;;642             depends on the u32EccLast parameter value. */
;;;643          u32DatPh =
0004e0  e594e000          LDR      lr,[r4,#0]
0004e4  e20e04ff          AND      r0,lr,#0xff000000
;;;644             ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
;;;645          u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
0004e8  e3800602          ORR      r0,r0,#0x200000
;;;646          u32DatPh =
0004ec  e3800702          ORR      r0,r0,#0x80000
;;;647             (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;648          u32DatPh = (u32DatPh | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
0004f0  e180050c          ORR      r0,r0,r12,LSL #10
;;;649    /***
;;;650    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;651    *          integral type.
;;;652    *
;;;653    * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;654    *          specific pointer/access based on the integer value built upon the
;;;655    *          combination of integer parameters.
;;;656    ****/
;;;657          pu32CmdPhDest = (uint32_t *)u32DatPh;    /* PRQA S 0306 */
0004f4  e1a02000          MOV      r2,r0
;;;658          /* LAST 32-bit word from device */
;;;659          pu32ExtrBuf[u32Idx] = (*pu32CmdPhDest);
0004f8  e592e000          LDR      lr,[r2,#0]
0004fc  e786e101          STR      lr,[r6,r1,LSL #2]
                  |L1.1280|
;;;660       }
;;;661    }
000500  e8bd80f0          POP      {r4-r7,pc}
;;;662    
                          ENDP

                  eNF_EccReadReady PROC
;;;667    /* TESTED */
;;;668    static NandFlashStatus_e eNF_EccReadReady (const NandFlashCfg_st *
000504  e92d4030          PUSH     {r4,r5,lr}
;;;669                                               const pstNandCfg)
;;;670    {
000508  e1a04000          MOV      r4,r0
;;;671       NandFlashStatus_e eResult;
;;;672    
;;;673       uint32_t u32TimeCycles;
;;;674    
;;;675       uint32_t u32Status;
;;;676    
;;;677       uint32_t u32EccReadMsk;                  /* depending on Extra Block use the
;;;678                                                   mask can varry */
;;;679    
;;;680       /* Check Last ECC Status */
;;;681       u32Status = MEMCTRL_ECC_STATUS;
00050c  e59f5ad8          LDR      r5,|L1.4076|
000510  e5952000          LDR      r2,[r5,#0]
;;;682       u32Status = (u32Status & MEMCTRL_ECC_LAST_STATUS_MSK);
000514  e2022d06          AND      r2,r2,#0x180
;;;683       if (u32Status == MEMCTRL_ECC_LAST_STATUS_SUCCESS_BITS)
000518  e3520000          CMP      r2,#0
00051c  1a000018          BNE      |L1.1412|
;;;684       {
;;;685          if (pstNandCfg->eExtraBlockCfg == NANDFLASH_EXTRA_BLOCK_DISABLED)
000520  e5d45006          LDRB     r5,[r4,#6]
000524  e3550000          CMP      r5,#0
000528  1a000001          BNE      |L1.1332|
;;;686          {
;;;687             /* Extra Block NOT used */
;;;688             u32EccReadMsk = NF_MASK_4X_ECC_BLOCKS;
00052c  e3a0100f          MOV      r1,#0xf
000530  ea000000          B        |L1.1336|
                  |L1.1332|
;;;689          }
;;;690          else
;;;691          {
;;;692             /* Check Extra Block also */
;;;693             u32EccReadMsk = NF_MASK_5X_ECC_BLOCKS;
000534  e3a0101f          MOV      r1,#0x1f
                  |L1.1336|
;;;694          }
;;;695          u32EccReadMsk = (u32EccReadMsk << (MEMCTRL_ECC_READ_SFT));
000538  e1a01c81          LSL      r1,r1,#25
;;;696    
;;;697          /* Wait with timer until the ECC READ is ready. */
;;;698          u32TimeCycles = pstNandCfg->u32EccTimeOut;
00053c  e5943038          LDR      r3,[r4,#0x38]
;;;699          do
000540  e320f000          NOP      
                  |L1.1348|
;;;700          {
;;;701             /* count down loop with device status check... */
;;;702             if (u32TimeCycles > 0x0U)
000544  e3530000          CMP      r3,#0
000548  0a000000          BEQ      |L1.1360|
;;;703             {
;;;704                u32TimeCycles--;
00054c  e2433001          SUB      r3,r3,#1
                  |L1.1360|
;;;705             }
;;;706             u32Status = MEMCTRL_ECC_STATUS;
000550  e59f5a94          LDR      r5,|L1.4076|
000554  e5952000          LDR      r2,[r5,#0]
;;;707             u32Status = (u32Status & u32EccReadMsk);
000558  e0022001          AND      r2,r2,r1
;;;708          }
;;;709          while (!((u32Status == u32EccReadMsk) || (u32TimeCycles == 0U)));
00055c  e1520001          CMP      r2,r1
000560  0a000001          BEQ      |L1.1388|
000564  e3530000          CMP      r3,#0
000568  1afffff5          BNE      |L1.1348|
                  |L1.1388|
;;;710          /*
;;;711             Waiting should be finished, when the ECC read bits are 1 (read
;;;712             complete) or the loop counter reaches 0. */
;;;713          if (u32Status == u32EccReadMsk)
00056c  e1520001          CMP      r2,r1
000570  1a000001          BNE      |L1.1404|
;;;714          {
;;;715             eResult = NANDFLASH_STATUS_OK;
000574  e3a00000          MOV      r0,#0
000578  ea000002          B        |L1.1416|
                  |L1.1404|
;;;716          }
;;;717          else
;;;718          {
;;;719             eResult = NANDFLASH_STATUS_ECC_RD_ERR; /* READ timeout expired */
00057c  e3a0000b          MOV      r0,#0xb
000580  ea000000          B        |L1.1416|
                  |L1.1412|
;;;720          }
;;;721       }
;;;722       else
;;;723       {
;;;724          eResult = NANDFLASH_STATUS_ECC_ERR;   /* LAst Status NOT successful */
000584  e3a0000c          MOV      r0,#0xc
                  |L1.1416|
;;;725       }
;;;726    
;;;727       return eResult;
;;;728    }
000588  e8bd8030          POP      {r4,r5,pc}
;;;729    
                          ENDP

                  eNF_EccWaitIdle PROC
;;;1861   /* TESTED */
;;;1862   NandFlashStatus_e eNF_EccWaitIdle (const NandFlashCfg_st * const pstNandCfg)
00058c  e92d4010          PUSH     {r4,lr}
;;;1863   {
000590  e1a03000          MOV      r3,r0
;;;1864      NandFlashStatus_e eResult;
;;;1865   
;;;1866      uint32_t u32TimeCycles = pstNandCfg->u32EccTimeOut;
000594  e5931038          LDR      r1,[r3,#0x38]
;;;1867   
;;;1868      uint32_t u32EccStatus;
;;;1869   
;;;1870   
;;;1871      /* Wait with timer until the ECC block is IDLE */
;;;1872      do
000598  e320f000          NOP      
                  |L1.1436|
;;;1873      {
;;;1874         /* count down loop with device status check... */
;;;1875         if (u32TimeCycles > 0x0U)
00059c  e3510000          CMP      r1,#0
0005a0  0a000000          BEQ      |L1.1448|
;;;1876         {
;;;1877            u32TimeCycles--;
0005a4  e2411001          SUB      r1,r1,#1
                  |L1.1448|
;;;1878         }
;;;1879         u32EccStatus = (MEMCTRL_ECC_STATUS);
0005a8  e59f4a3c          LDR      r4,|L1.4076|
0005ac  e5942000          LDR      r2,[r4,#0]
;;;1880         u32EccStatus = u32EccStatus & (MEMCTRL_ECC_BUSY_MSK);
0005b0  e2022040          AND      r2,r2,#0x40
;;;1881      }
;;;1882      while (!((u32EccStatus != (MEMCTRL_ECC_BUSY_MSK)) || (u32TimeCycles == 0U)));
0005b4  e3520040          CMP      r2,#0x40
0005b8  1a000001          BNE      |L1.1476|
0005bc  e3510000          CMP      r1,#0
0005c0  1afffff5          BNE      |L1.1436|
                  |L1.1476|
;;;1883      /*
;;;1884         Waiting should be finished, when the ECC status bit is 0 (IDLE) or the
;;;1885         loop counter reaches 0. */
;;;1886      if (u32EccStatus != (MEMCTRL_ECC_BUSY_MSK))
0005c4  e3520040          CMP      r2,#0x40
0005c8  0a000001          BEQ      |L1.1492|
;;;1887      {
;;;1888         eResult = NANDFLASH_STATUS_OK;
0005cc  e3a00000          MOV      r0,#0
0005d0  ea000000          B        |L1.1496|
                  |L1.1492|
;;;1889      }
;;;1890      else
;;;1891      {
;;;1892         eResult = NANDFLASH_STATUS_BUSY_ERR;  /* busy timout expired */
0005d4  e3a00007          MOV      r0,#7
                  |L1.1496|
;;;1893      }
;;;1894      return eResult;
;;;1895   }
0005d8  e8bd8010          POP      {r4,pc}
;;;1896   
                          ENDP

                  eNF_EccConfigure PROC
;;;731    /* TESTED */
;;;732    NandFlashStatus_e eNF_EccConfigure (const NandFlashCfg_st * const pstNandCfg)
0005dc  e92d4070          PUSH     {r4-r6,lr}
;;;733    {
0005e0  e1a06000          MOV      r6,r0
;;;734       NandFlashStatus_e eResult;
;;;735    
;;;736       uint32_t u32MemCfgReg;
;;;737    
;;;738    
;;;739       eResult = eNF_EccWaitIdle (pstNandCfg);
0005e4  e1a00006          MOV      r0,r6
0005e8  ebfffffe          BL       eNF_EccWaitIdle
0005ec  e1a05000          MOV      r5,r0
;;;740    
;;;741       if (eResult == NANDFLASH_STATUS_OK)
0005f0  e3550000          CMP      r5,#0
0005f4  1a00001a          BNE      |L1.1636|
;;;742       {
;;;743          /* clear ALL interrupts flags */
;;;744          MEMCTRL_ECC_STATUS = MEMCTRL_ECC_RAW_ALL_INTS_MSK;
0005f8  e3a0003f          MOV      r0,#0x3f
0005fc  e59f19e8          LDR      r1,|L1.4076|
000600  e5810000          STR      r0,[r1,#0]
;;;745          /* clear ecc_int interrupt flags */
;;;746          MEMCTRL_ECC_VALUE0 = 0x0U;
000604  e3a00000          MOV      r0,#0
000608  e1811da1          ORR      r1,r1,r1,LSR #27
00060c  e5810000          STR      r0,[r1,#0]
;;;747          MEMCTRL_ECC_VALUE1 = 0x0U;
000610  e1811e21          ORR      r1,r1,r1,LSR #28
000614  e5810000          STR      r0,[r1,#0]
;;;748          MEMCTRL_ECC_VALUE2 = 0x0U;
000618  e2811004          ADD      r1,r1,#4
00061c  e5810000          STR      r0,[r1,#0]
;;;749          MEMCTRL_ECC_VALUE3 = 0x0U;
000620  e2811004          ADD      r1,r1,#4
000624  e5810000          STR      r0,[r1,#0]
;;;750          MEMCTRL_ECC_VALUE4 = 0x0U;
000628  e2811004          ADD      r1,r1,#4
00062c  e5810000          STR      r0,[r1,#0]
;;;751          /*
;;;752             Prepare ECC memory config (valid for LARGE PAGE devices only! Select:
;;;753             MEMCTRL_ECC_JUMP_NO_BITS (reads and writes only occur on the end of
;;;754             page). MEMCTRL_ECC_READ_END_MSK: ECC read at the end of the page.
;;;755             MEMCTRL_ECC_MODE_CALC_RD_WR_BITS: ECC calculated and written/read.
;;;756             to/from memory . MEMCTRL_ECC_PAGE_SIZE_4X512_BITS: Page contains 4 x
;;;757             512 bytes (2048). */
;;;758          u32MemCfgReg = MEMCTRL_ECC_MEMCFG;
000630  e2410024          SUB      r0,r1,#0x24
000634  e5904000          LDR      r4,[r0,#0]
;;;759          /* Clear ECC related and keep other settings */
;;;760          u32MemCfgReg = (u32MemCfgReg & (0xFFFFFF00UL));
000638  e3c440ff          BIC      r4,r4,#0xff
;;;761          /* Configure new ECC settings */
;;;762          u32MemCfgReg = u32MemCfgReg | ((MEMCTRL_ECC_A8_OUTPUT_MSK) | (MEMCTRL_ECC_JUMP_NO_BITS)
00063c  e384401b          ORR      r4,r4,#0x1b
;;;763                                         | (MEMCTRL_ECC_READ_END_MSK)
;;;764                                         | (MEMCTRL_ECC_MODE_CALC_RD_WR_BITS) |
;;;765                                         (MEMCTRL_ECC_PAGE_SIZE_4X512_BITS));
;;;766          /* Write back new ECC settings */
;;;767          MEMCTRL_ECC_MEMCFG = u32MemCfgReg;
000640  e5804000          STR      r4,[r0,#0]
;;;768          /*
;;;769             Specify device-specific commands the ECC block uses to DETECT reading:
;;;770             READ START, READ END, if supported (END VALID) and writing (PROGRAM). */
;;;771          MEMCTRL_ECC_MEMCMD1 =
000644  e59f09a4          LDR      r0,|L1.4080|
000648  e1c11140          BIC      r1,r1,r0,ASR #2
00064c  e5810000          STR      r0,[r1,#0]
;;;772             ((MEMCTRL_ECC_RD_CMD_END_VALID_MSK) |
;;;773              ((NANDFLASH_CMD_PAGE_RD_END) << (MEMCTRL_ECC_RD_CMD_END_SFT)) |
;;;774              ((NANDFLASH_CMD_PAGE_RD_START) << (MEMCTRL_ECC_RD_CMD_SFT)) |
;;;775              ((NANDFLASH_CMD_PROGRAM_START) << (MEMCTRL_ECC_WR_CMD_SFT)));
;;;776          /*
;;;777             Specify device-specific commands to be used, while accessing different
;;;778             parts in NAND page. The usage of this configuration is dependent on the
;;;779             ecc_jump bit in the ecc_memcfg register. MEMCTRL_ECC_JUMP_NO_BITS: NO
;;;780             support for jumps-> below config is meaningless
;;;781             MEMCTRL_ECC_JUMP_COL_CHNG_BITS: Jump using random column change
;;;782             commands, see MEMCTRL_ECC_MEMCMD2 MEMCTRL_ECC_JUMP_FUL_CMD_BITS: Jump
;;;783             using Full command, see MEMCTRL_ECC_MEMCMD1 above Consider ONFi random
;;;784             access commands: Change Read Column Command: 0x05 Change Write Column
;;;785             Command: 0x85 Currently configured for "Jump using Full command" since
;;;786             this insures the proper operation for most devices, however this counts
;;;787             against the maximum number of program operations before a NAND page must
;;;788             be erased. */
;;;789          MEMCTRL_ECC_MEMCMD2 =
000650  e59f099c          LDR      r0,|L1.4084|
000654  e1811e21          ORR      r1,r1,r1,LSR #28
000658  e5810000          STR      r0,[r1,#0]
;;;790             (((NANDFLASH_CMD_RD_COL_CH_E_V) << 24) |
;;;791              ((NANDFLASH_CMD_RD_COL_CH_END) << 16) | ((NANDFLASH_CMD_RD_COL_CHNG)
;;;792                                                       << 8) |
;;;793              ((NANDFLASH_CMD_WR_COL_CHNG) << 0));
;;;794          eResult = NANDFLASH_STATUS_OK;
00065c  e3a05000          MOV      r5,#0
000660  ea000000          B        |L1.1640|
                  |L1.1636|
;;;795       }
;;;796       else
;;;797       {
;;;798          /* could be optimized / removed since eResult is updated already */
;;;799          eResult = NANDFLASH_STATUS_BUSY_ERR;  /* busy timout expired */
000664  e3a05007          MOV      r5,#7
                  |L1.1640|
;;;800       }
;;;801       return eResult;
000668  e1a00005          MOV      r0,r5
;;;802    }
00066c  e8bd8070          POP      {r4-r6,pc}
;;;803    
                          ENDP

                  eNF_EccBitFix PROC
;;;805    /* TESTED */
;;;806    static NandFlashStatus_e eNF_EccBitFix (uint32_t u32EccValue, uint8_t pu8Buf[])
000670  e92d4030          PUSH     {r4,r5,lr}
;;;807    {
000674  e1a05000          MOV      r5,r0
000678  e1a02001          MOV      r2,r1
;;;808       uint32_t u32ByteNo;
;;;809    
;;;810       uint32_t u32BitNo;
;;;811    
;;;812       uint8_t u8BitMask;
;;;813    
;;;814    
;;;815       /* Correct the right bit in the right byte: 5 upper bits -> byte number; 3
;;;816          lower bits -> bit number within a byte */
;;;817       u32ByteNo = (u32EccValue & (MEMCTRL_ECC_VAL_VALUE_MSK));
00067c  e3c514ff          BIC      r1,r5,#0xff000000
;;;818       u32BitNo = u32ByteNo;
000680  e1a04001          MOV      r4,r1
;;;819       u32ByteNo = (u32ByteNo >> 3U);           /* get rid of the bit number */
000684  e1a011a1          LSR      r1,r1,#3
;;;820       u32BitNo = (u32BitNo & 0x7U);            /* get rid of the byte number */
000688  e2044007          AND      r4,r4,#7
;;;821       u8BitMask = (uint8_t)(0x1U << u32BitNo);
00068c  e3a00001          MOV      r0,#1
000690  e1a00410          LSL      r0,r0,r4
000694  e20030ff          AND      r3,r0,#0xff
;;;822    
;;;823       if ((pu8Buf[u32ByteNo] & (u8BitMask)) == 0x00U)
000698  e7d20001          LDRB     r0,[r2,r1]
00069c  e0000003          AND      r0,r0,r3
0006a0  e3500000          CMP      r0,#0
0006a4  1a000003          BNE      |L1.1720|
;;;824       {
;;;825          /* defective bit is 0 -> SET this bit */
;;;826          pu8Buf[u32ByteNo] = pu8Buf[u32ByteNo] | u8BitMask;
0006a8  e7d20001          LDRB     r0,[r2,r1]
0006ac  e1800003          ORR      r0,r0,r3
0006b0  e7c20001          STRB     r0,[r2,r1]
0006b4  ea000004          B        |L1.1740|
                  |L1.1720|
;;;827       }
;;;828       else
;;;829       {
;;;830          /* defective bit is 1 -> CLEAR this bit */
;;;831          u8BitMask = (~u8BitMask);
0006b8  e1e00003          MVN      r0,r3
0006bc  e20030ff          AND      r3,r0,#0xff
;;;832          pu8Buf[u32ByteNo] = pu8Buf[u32ByteNo] & u8BitMask;
0006c0  e7d20001          LDRB     r0,[r2,r1]
0006c4  e0000003          AND      r0,r0,r3
0006c8  e7c20001          STRB     r0,[r2,r1]
                  |L1.1740|
;;;833       }
;;;834       return NANDFLASH_STATUS_OK;
0006cc  e3a00000          MOV      r0,#0
;;;835    }
0006d0  e8bd8030          POP      {r4,r5,pc}
;;;836    
                          ENDP

                  eNF_EccCorrectLarge PROC
;;;846    ****/
;;;847    static NandFlashStatus_e eNF_EccCorrectLarge (const NandFlashCfg_st * const pstNandCfg,
0006d4  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;848                                                  uint8_t pu8DstBuf[],     /* PRQA S 3673 */
;;;849                                                  uint8_t pu8ExtrBuf[])    /* PRQA S 3673 */
;;;850    {
0006d8  e24dd008          SUB      sp,sp,#8
0006dc  e1a09000          MOV      r9,r0
;;;851       NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;    /* PRQA S 3197 */
0006e0  e3a06001          MOV      r6,#1
;;;852    
;;;853       uint32_t u32EccStatus;
;;;854    
;;;855       uint32_t u32EccValue;
;;;856    
;;;857       uint32_t u32EccMsk;
;;;858    
;;;859       uint32_t u32BlockNo;
;;;860    
;;;861       uint32_t u32ValRegAdr;
;;;862    
;;;863       volatile uint32_t *pu32ValueRegister;
;;;864    
;;;865       uint32_t u32BufAddr;   /* track SW buffer address */
;;;866    
;;;867       uint32_t u32MaxBlockNo = 3U; /* by default Extra B. disabled */
0006e4  e3a00003          MOV      r0,#3
0006e8  e58d0000          STR      r0,[sp,#0]
;;;868    
;;;869    
;;;870       /* Wait until ECC module is ready */
;;;871       eResult = eNF_EccWaitIdle (pstNandCfg);
0006ec  e1a00009          MOV      r0,r9
0006f0  ebfffffe          BL       eNF_EccWaitIdle
0006f4  e1a06000          MOV      r6,r0
;;;872    
;;;873       if (eResult == NANDFLASH_STATUS_OK)
0006f8  e3560000          CMP      r6,#0
0006fc  1a00004a          BNE      |L1.2092|
;;;874       {
;;;875          u32EccStatus = MEMCTRL_ECC_STATUS;
000700  e59f08e4          LDR      r0,|L1.4076|
000704  e5907000          LDR      r7,[r0,#0]
;;;876          /*
;;;877             Other bits are meaningful only, if ecc_last_status == b00: Completed
;;;878             successfully. */
;;;879          if ((u32EccStatus & (MEMCTRL_ECC_LAST_STATUS_MSK)) ==
000708  e2070d06          AND      r0,r7,#0x180
00070c  e3500000          CMP      r0,#0
000710  1a000043          BNE      |L1.2084|
;;;880              (MEMCTRL_ECC_LAST_STATUS_SUCCESS_BITS))
;;;881          {
;;;882             /* if Extra Block used - take a different bit mask */
;;;883             if (pstNandCfg->eExtraBlockCfg == NANDFLASH_EXTRA_BLOCK_DISABLED)
000714  e5d90006          LDRB     r0,[r9,#6]
000718  e3500000          CMP      r0,#0
00071c  1a000001          BNE      |L1.1832|
;;;884             {
;;;885                u32EccMsk = 0x0FU;              /* Extra Block NOT used */
000720  e3a0500f          MOV      r5,#0xf
000724  ea000000          B        |L1.1836|
                  |L1.1832|
;;;886             }
;;;887             else
;;;888             {
;;;889                u32EccMsk = 0x1FU;              /* Check also Extra Block */
000728  e3a0501f          MOV      r5,#0x1f
                  |L1.1836|
;;;890             }
;;;891             /* Check if ALL ECC VALID (if ALL block of data read correctly?) */
;;;892             if ((u32EccStatus & (u32EccMsk << (MEMCTRL_ECC_VALUE_VALID_SFT))) ==
00072c  e0070505          AND      r0,r7,r5,LSL #10
000730  e1500505          CMP      r0,r5,LSL #10
000734  1a000038          BNE      |L1.2076|
;;;893                 (u32EccMsk << (MEMCTRL_ECC_VALUE_VALID_SFT)))
;;;894             {
;;;895                /*
;;;896                   Check with TIMEOUT, if the ECC codes for ALL blocks of data have
;;;897                   been read correctly. VERIFY, if wait with TIMEOUT is really
;;;898                   needed... */
;;;899                eResult = eNF_EccReadReady (pstNandCfg);
000738  e1a00009          MOV      r0,r9
00073c  ebfffffe          BL       eNF_EccReadReady
000740  e1a06000          MOV      r6,r0
;;;900                if (eResult == NANDFLASH_STATUS_OK)
000744  e3560000          CMP      r6,#0
000748  1a000031          BNE      |L1.2068|
;;;901                {
;;;902                   /* Check if ALL ECC PASSED (if all ecc_fail flags are zero?) */
;;;903                   u32EccStatus = MEMCTRL_ECC_STATUS;
00074c  e59f0898          LDR      r0,|L1.4076|
000750  e5907000          LDR      r7,[r0,#0]
;;;904    /***
;;;905    * MESSAGE: Msg(3:3371) Unsigned left shift operation << definitely truncates
;;;906    *          bits from result.
;;;907    *
;;;908    * DESC   : This message is TRUE, however it was the intension to get rid of
;;;909    *          unused bits.
;;;910    ****/
;;;911                   if ((u32EccStatus & (u32EccMsk << (MEMCTRL_ECC_ECC_FAIL_SFT))) ==
000754  e0070785          AND      r0,r7,r5,LSL #15
000758  e3500000          CMP      r0,#0
00075c  1a000001          BNE      |L1.1896|
;;;912                       0x00U)
;;;913                   {
;;;914                      /*
;;;915                         ALL ecc_fail bits == 0 -> ECC PASS - correction not
;;;916                         needed. ** Here the reading is over with ALL ECC correct
;;;917                         *** */
;;;918                      eResult = NANDFLASH_STATUS_OK;
000760  e3a06000          MOV      r6,#0
000764  ea000031          B        |L1.2096|
                  |L1.1896|
;;;919                   }
;;;920                   else                         /* ecc_fail == 1: FAIL */
;;;921                   {
;;;922                      /*
;;;923                         With extra block: 0 to 4 registers need to be analyzed and
;;;924                         without extra block: 0 to 3 registers need to be analyzed */
;;;925                      if (pstNandCfg->eExtraBlockCfg !=
000768  e5d90006          LDRB     r0,[r9,#6]
00076c  e3500000          CMP      r0,#0
000770  0a000001          BEQ      |L1.1916|
;;;926                          NANDFLASH_EXTRA_BLOCK_DISABLED)
;;;927                      {
;;;928                         u32MaxBlockNo = 4U;
000774  e3a00004          MOV      r0,#4
000778  e58d0000          STR      r0,[sp,#0]
                  |L1.1916|
;;;929                      }
;;;930                      u32BlockNo = 0U;          /* start at MEMCTRL_ECC_VALUE0 */
00077c  e3a04000          MOV      r4,#0
;;;931                      do
000780  e320f000          NOP      
                  |L1.1924|
;;;932                      {
;;;933                         /*
;;;934                            Calculate address to be accessed and read from that
;;;935                            address: */
;;;936    /***
;;;937    * MESSAGE: MISRA-C:2004 Rule 10.1 Integral expression implicitly converted to
;;;938    *          wider type.
;;;939    *
;;;940    * DESC   : This message is TRUE, however, in that particular casede there is no
;;;941    *          risk for crossing of the 32-bit type range.
;;;942    ****/
;;;943                         u32ValRegAdr = (uint32_t)(MEMCTRL_ECC_VALUE_ADR (u32BlockNo));     /* PRQA S 3212 */
000784  e59f086c          LDR      r0,|L1.4088|
000788  e3a01004          MOV      r1,#4
00078c  e02a0491          MLA      r10,r1,r4,r0
;;;944                         pu32ValueRegister = (volatile uint32_t *)u32ValRegAdr;
000790  e1a0b00a          MOV      r11,r10
;;;945                         u32EccValue = (uint32_t)(*pu32ValueRegister);    /* PRQA S 3212 */
000794  e59b8000          LDR      r8,[r11,#0]
;;;946    
;;;947                         /* check ecc_fail flags, if set to 1: try to correct */
;;;948                         if ((u32EccValue & (MEMCTRL_ECC_VAL_FAIL_MSK)) != 0x0U)
000798  e2080201          AND      r0,r8,#0x10000000
00079c  e3500000          CMP      r0,#0
0007a0  0a000014          BEQ      |L1.2040|
;;;949                         {
;;;950    /***
;;;951    * MESSAGE: MISRA-C:2004 Rule 1.1 [L] Nesting of control structures (statements)
;;;952    *          exceeds 15 - program is non-conforming.
;;;953    *          MISRA-C:2004 Rule 1.1; REFERENCE - ISO-5.2.4.1 Translation Limits
;;;954    *
;;;955    * DESC   : This message is TRUE, however, to keep the code readable the source
;;;956    *          code is preserved in its orginal form.
;;;957    ****/
;;;958                            /* check ecc_correct flag, if set: Correct bad-bit */
;;;959                            if ((u32EccValue & (MEMCTRL_ECC_VAL_CORRECT_MSK)) !=
0007a4  e2080302          AND      r0,r8,#0x8000000
0007a8  e3500000          CMP      r0,#0
0007ac  0a000010          BEQ      |L1.2036|
;;;960                                0x0U)
;;;961                            {    /* PRQA S 0715 */
;;;962                               /* Calculate offest within the SW buffer depending
;;;963                                  on the ECC block number. Block size is by default
;;;964                                  512 bytes for a 2kB Page NAND device. */
;;;965                               if (u32BlockNo < u32MaxBlockNo)
0007b0  e59d0000          LDR      r0,[sp,#0]
0007b4  e1540000          CMP      r4,r0
0007b8  2a000006          BCS      |L1.2008|
;;;966                               {
;;;967                                  /* for 4x 512 Blocks from 2kB Page */
;;;968                                  u32BufAddr = (u32BlockNo * 512U);
0007bc  e1a00484          LSL      r0,r4,#9
0007c0  e58d0004          STR      r0,[sp,#4]
;;;969    /***
;;;970    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;971    *          integral type.
;;;972    *          MISRA-C:2004 Rule 1.2; [U] Integral type is not large enough to hold a pointer value.
;;;973    *
;;;974    * DESC   : These messages are undestood, but is is required to manipulate pointers
;;;975    *          using integer calculations. Since within thise system only 32-bit
;;;976    *          pointers are used - there should be no danger to cast as below.
;;;977    ****/
;;;978                                  u32BufAddr = (u32BufAddr + (uint32_t)pu8DstBuf);    /* PRQA S 0306 */
0007c4  e59d0004          LDR      r0,[sp,#4]
0007c8  e59d100c          LDR      r1,[sp,#0xc]
0007cc  e0800001          ADD      r0,r0,r1
0007d0  e58d0004          STR      r0,[sp,#4]
0007d4  ea000001          B        |L1.2016|
                  |L1.2008|
;;;979                               }
;;;980                               else
;;;981                               {
;;;982                                  /* Extra Block: bit fix in Extra buffer */
;;;983    /***
;;;984    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;985    *          integral type.
;;;986    *          MISRA-C:2004 Rule 1.2; [U] Integral type is not large enough to hold a pointer value.
;;;987    *
;;;988    * DESC   : These messages are undestood, but is is required to manipulate pointers
;;;989    *          using integer calculations. Since within thise system only 32-bit
;;;990    *          pointers are used - there should be no danger to cast as below.
;;;991    ****/
;;;992                                  u32BufAddr = (uint32_t)pu8ExtrBuf;    /* PRQA S 0306 */
0007d8  e59d0010          LDR      r0,[sp,#0x10]
0007dc  e58d0004          STR      r0,[sp,#4]
                  |L1.2016|
;;;993                               }
;;;994    /***
;;;995    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;996    *          integral type.
;;;997    *
;;;998    * DESC   : This message is undestood, but is was required to manipulate (see
;;;999    *          earlier description) pointers using integer calculations.
;;;1000   ****/
;;;1001                              eResult =
0007e0  e1a00008          MOV      r0,r8
0007e4  e59d1004          LDR      r1,[sp,#4]
0007e8  ebfffffe          BL       eNF_EccBitFix
0007ec  e1a06000          MOV      r6,r0
0007f0  ea000000          B        |L1.2040|
                  |L1.2036|
;;;1002                                 eNF_EccBitFix (u32EccValue,
;;;1003                                                (uint8_t *)u32BufAddr);    /* PRQA S 0306 */
;;;1004                           }
;;;1005                           else
;;;1006                           {    /* PRQA S 0715 */
;;;1007                              /* Correction NOT possible */
;;;1008   /***
;;;1009   * MESSAGE: MISRA-C:2004 Rule 1.1 [L] Nesting of control structures (statements)
;;;1010   *          exceeds 15 - program is non-conforming.
;;;1011   *          MISRA-C:2004 Rule 1.1; REFERENCE - ISO-5.2.4.1 Translation Limits
;;;1012   *
;;;1013   * DESC   : This message is TRUE, however, to keep the code readable the source
;;;1014   *          code is preserved in its orginal form.
;;;1015   ****/
;;;1016                              eResult = NANDFLASH_STATUS_ECC_ERR;
0007f4  e3a0600c          MOV      r6,#0xc
                  |L1.2040|
;;;1017                           }
;;;1018                        }
;;;1019                        /* dO it for next ECC block / Value register */
;;;1020                        u32BlockNo++;
0007f8  e2844001          ADD      r4,r4,#1
;;;1021                        /* Run this loop only, if both below conditions are TRUE */
;;;1022                     }
;;;1023                     while (((u32BlockNo <= u32MaxBlockNo) &&
0007fc  e59d0000          LDR      r0,[sp,#0]
000800  e1540000          CMP      r4,r0
000804  8a000009          BHI      |L1.2096|
;;;1024                             (eResult == NANDFLASH_STATUS_OK)));
000808  e3560000          CMP      r6,#0
00080c  0affffdc          BEQ      |L1.1924|
000810  ea000006          B        |L1.2096|
                  |L1.2068|
;;;1025   
;;;1026                     /* *** FINAL eResult available *** */
;;;1027                  }
;;;1028               }
;;;1029               else
;;;1030               {
;;;1031                  /* could be optimized / removed since eResult is updated already
;;;1032                   */
;;;1033                  eResult = NANDFLASH_STATUS_BUSY_ERR; /* busy timout expired */
000814  e3a06007          MOV      r6,#7
000818  ea000004          B        |L1.2096|
                  |L1.2076|
;;;1034               }
;;;1035            }
;;;1036            else
;;;1037            {
;;;1038               eResult = NANDFLASH_STATUS_ECC_RD_ERR; /* SW debugging needed */
00081c  e3a0600b          MOV      r6,#0xb
000820  ea000002          B        |L1.2096|
                  |L1.2084|
;;;1039            }
;;;1040         }
;;;1041         else
;;;1042         {
;;;1043            /* Last Status PROBLEM: Error reason should be analyzed */
;;;1044            eResult = NANDFLASH_STATUS_ECC_ERR;
000824  e3a0600c          MOV      r6,#0xc
000828  ea000000          B        |L1.2096|
                  |L1.2092|
;;;1045         }
;;;1046      }
;;;1047      else
;;;1048      {
;;;1049         /* could be optimized / removed since eResult is updated already */
;;;1050         eResult = NANDFLASH_STATUS_BUSY_ERR;  /* busy timout expired */
00082c  e3a06007          MOV      r6,#7
                  |L1.2096|
;;;1051      }
;;;1052      return eResult;
000830  e1a00006          MOV      r0,r6
000834  e28dd014          ADD      sp,sp,#0x14
;;;1053   }
000838  e8bd8ff0          POP      {r4-r11,pc}
;;;1054   
                          ENDP

                  eNandFlash_WaitDeviceReady PROC
;;;1758   /* TESTED */
;;;1759   NandFlashStatus_e eNandFlash_WaitDeviceReady (const NandFlashCfg_st *
00083c  e92d41f0          PUSH     {r4-r8,lr}
;;;1760                                                 const pstNandCfg)
;;;1761   {
000840  e1a07000          MOV      r7,r0
;;;1762      NandFlashStatus_e eResult;
;;;1763   
;;;1764   
;;;1765      if (pstNandCfg == TYPES_NULL_PTR)
000844  e3570000          CMP      r7,#0
000848  1a000001          BNE      |L1.2132|
;;;1766      {
;;;1767         eResult = NANDFLASH_STATUS_PTR_ERR;
00084c  e3a05004          MOV      r5,#4
000850  ea00003a          B        |L1.2368|
                  |L1.2132|
;;;1768      }
;;;1769      else
;;;1770      {
;;;1771         uint32_t u32BusyReady;
;;;1772   
;;;1773         uint32_t u32TimeCycles = pstNandCfg->u32BusyTimeOut;
000854  e5976034          LDR      r6,[r7,#0x34]
;;;1774   
;;;1775        /* Devices with HOST ECC will be handled with BUSY signal
;;;1776        Edge-sensitive interrupts, while devices with Internal ECC
;;;1777        will be handled with Status Register Busy check */
;;;1778        if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
000858  e5d70004          LDRB     r0,[r7,#4]
00085c  e3500000          CMP      r0,#0
000860  1a000017          BNE      |L1.2244|
;;;1779        {
;;;1780           /* 100ns wait for settling of the BUSY line state... */
;;;1781           NF_uSecWait (NANDFLASH_TIME_1us);
000864  e3a0000a          MOV      r0,#0xa
000868  ebfffffe          BL       NF_uSecWait
;;;1782   
;;;1783           /* Single Loop below executes 12 instructions - each dealy could be 12x
;;;1784            shorter (set to 10x to be ion the safe side) than initially assumed
;;;1785            the required values are set directly within the defines in NandFlash.h */
;;;1786           do
00086c  e320f000          NOP      
                  |L1.2160|
;;;1787           {
;;;1788            u32BusyReady = (MEMCTRL_MEMC_STATUS);
000870  e59f076c          LDR      r0,|L1.4068|
000874  e5904000          LDR      r4,[r0,#0]
;;;1789            u32BusyReady = u32BusyReady & (MEMCTRL_RAW_INT_STATUS1_BIT);
000878  e2044040          AND      r4,r4,#0x40
;;;1790            if (u32BusyReady == 0)
00087c  e3540000          CMP      r4,#0
000880  1a000002          BNE      |L1.2192|
;;;1791            {
;;;1792               /* count down loop with device status check... */
;;;1793               if (u32TimeCycles > 0x0U)
000884  e3560000          CMP      r6,#0
000888  0a000000          BEQ      |L1.2192|
;;;1794               {
;;;1795                  u32TimeCycles--;
00088c  e2466001          SUB      r6,r6,#1
                  |L1.2192|
;;;1796               }
;;;1797            }
;;;1798           }
;;;1799           while (!((u32BusyReady == (MEMCTRL_RAW_INT_STATUS1_BIT)) ||
000890  e3540040          CMP      r4,#0x40
000894  0a000001          BEQ      |L1.2208|
000898  e3560000          CMP      r6,#0
00089c  1afffff3          BNE      |L1.2160|
                  |L1.2208|
;;;1800                   (u32TimeCycles == 0U)));
;;;1801         /*
;;;1802            Waiting should be finished, when the raw_int_status1 bit is HIGH or
;;;1803            the loop counter reaches 0. */
;;;1804         if (u32BusyReady == (MEMCTRL_RAW_INT_STATUS1_BIT))
0008a0  e3540040          CMP      r4,#0x40
0008a4  1a000004          BNE      |L1.2236|
;;;1805         {
;;;1806            /* Clear generated IRQ and return OK */
;;;1807            NANDFLASH_CLEAR_READY_IRQ ();
0008a8  e3a00010          MOV      r0,#0x10
0008ac  e59f1730          LDR      r1,|L1.4068|
0008b0  e581000c          STR      r0,[r1,#0xc]
;;;1808            eResult = NANDFLASH_STATUS_OK;
0008b4  e3a05000          MOV      r5,#0
0008b8  ea00001f          B        |L1.2364|
                  |L1.2236|
;;;1809         }
;;;1810         else
;;;1811         {
;;;1812            eResult = NANDFLASH_STATUS_BUSY_ERR; /* busy timout expired */
0008bc  e3a05007          MOV      r5,#7
0008c0  ea00001d          B        |L1.2364|
                  |L1.2244|
;;;1813         }
;;;1814        }
;;;1815        else
;;;1816        {
;;;1817         /* Single Loop below executes 12 instructions So each delay could be 12x
;;;1818            shorter (set to 10x to be ion the safe side) than initially assumed
;;;1819            the required values are set directly within the defines in NandFlash.h
;;;1820         */
;;;1821         vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_STATUS);
0008c4  e3a01070          MOV      r1,#0x70
0008c8  e1a00007          MOV      r0,r7
0008cc  ebfffffe          BL       vNF_CmdPhaseAxi
;;;1822         do
0008d0  e320f000          NOP      
                  |L1.2260|
;;;1823         {
;;;1824            u32BusyReady = u32NF_DataPhaseAxiRead (pstNandCfg, NF_PAR_CS_ACTIV,
0008d4  e3a02000          MOV      r2,#0
0008d8  e1a01002          MOV      r1,r2
0008dc  e1a00007          MOV      r0,r7
0008e0  ebfffffe          BL       u32NF_DataPhaseAxiRead
0008e4  e1a04000          MOV      r4,r0
;;;1825                                                   NF_PAR_IGNORE);
;;;1826            /* extract #Busy/Ready bit */
;;;1827            u32BusyReady = (u32BusyReady & 0x40U);
0008e8  e2044040          AND      r4,r4,#0x40
;;;1828            if (u32BusyReady == 0x00U)
0008ec  e3540000          CMP      r4,#0
0008f0  1a000002          BNE      |L1.2304|
;;;1829            {
;;;1830               /* NAND device BUSY: count down loop with another status check */
;;;1831               if (u32TimeCycles > 0x0U)
0008f4  e3560000          CMP      r6,#0
0008f8  0a000000          BEQ      |L1.2304|
;;;1832               {
;;;1833                  u32TimeCycles--;
0008fc  e2466001          SUB      r6,r6,#1
                  |L1.2304|
;;;1834               }
;;;1835            }
;;;1836         }
;;;1837         while (!((u32BusyReady == (0x40U)) || (u32TimeCycles == 0U)));
000900  e3540040          CMP      r4,#0x40
000904  0a000001          BEQ      |L1.2320|
000908  e3560000          CMP      r6,#0
00090c  1afffff0          BNE      |L1.2260|
                  |L1.2320|
;;;1838         /* Read it one more time and disable CS */
;;;1839         u32BusyReady = u32NF_DataPhaseAxiRead (pstNandCfg, NF_PAR_CS_CLEAR,
000910  e3a02000          MOV      r2,#0
000914  e3a01001          MOV      r1,#1
000918  e1a00007          MOV      r0,r7
00091c  ebfffffe          BL       u32NF_DataPhaseAxiRead
000920  e1a04000          MOV      r4,r0
;;;1840                                                NF_PAR_IGNORE);
;;;1841         /* extract #Busy/Ready bit */
;;;1842         u32BusyReady = (u32BusyReady & 0x40U);
000924  e2044040          AND      r4,r4,#0x40
;;;1843   
;;;1844         /* Waiting should be finished, when the #Busy/Ready bit is HIGH or
;;;1845            the loop counter reaches 0. */
;;;1846         if (u32BusyReady == 0x40U)
000928  e3540040          CMP      r4,#0x40
00092c  1a000001          BNE      |L1.2360|
;;;1847         {
;;;1848            /* consider return to Read mode... */
;;;1849            eResult = NANDFLASH_STATUS_OK;
000930  e3a05000          MOV      r5,#0
000934  ea000000          B        |L1.2364|
                  |L1.2360|
;;;1850         }
;;;1851         else
;;;1852         {
;;;1853            eResult = NANDFLASH_STATUS_BUSY_ERR; /* busy timout expired */
000938  e3a05007          MOV      r5,#7
                  |L1.2364|
;;;1854         }
;;;1855        }
;;;1856      }
00093c  e320f000          NOP      
                  |L1.2368|
;;;1857      return eResult;
000940  e1a00005          MOV      r0,r5
;;;1858   }
000944  e8bd81f0          POP      {r4-r8,pc}
;;;1859   
                          ENDP

                  eNF_ReadOnfiParamsPage PROC
;;;1055   /*..........................................................................*/
;;;1056   static NandFlashStatus_e eNF_ReadOnfiParamsPage (NandFlashCfg_st * pstNandCfg)
000948  e92d5fff          PUSH     {r0-r12,lr}
;;;1057   {
00094c  e1a04000          MOV      r4,r0
;;;1058   /***
;;;1059   * MESSAGE: Msg(3:3197) The initialiser for 'eResult' is always modified before
;;;1060   *          being used.
;;;1061   *
;;;1062   * DESC   : To detect that eResult is updated every time within this complex
;;;1063   *          function the initial value NANDFLASH_STATUS_UNKNOWN is used.
;;;1064   ****/
;;;1065      NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;    /* PRQA S 3197 */
000950  e3a08001          MOV      r8,#1
;;;1066   
;;;1067      uint32_t u32Idx;
;;;1068   
;;;1069      uint32_t u32ReadNand;
;;;1070   
;;;1071      uint32_t u32tmp;                   /* temporary */
;;;1072   
;;;1073      uint32_t u32DevCrc;                /* CRC read from NAND device */
;;;1074   
;;;1075      uint32_t u32CalCrc;                /* CRC based on read parameters */
;;;1076   
;;;1077      uint32_t u32tmpOffset;
;;;1078   
;;;1079      uint32_t u32Tmp;
;;;1080   
;;;1081      uint8_t u8RowCyc;
;;;1082   
;;;1083      uint8_t u8ColCyc;
;;;1084   
;;;1085      uint32_t u32ParOffset = 0x00U;                /* Parameter Page offset */
000954  e3a0a000          MOV      r10,#0
;;;1086   
;;;1087   
;;;1088         do
000958  e320f000          NOP      
                  |L1.2396|
;;;1089         {
;;;1090            /* Read ONFI Parameter Page */
;;;1091            vNF_CmdPhaseAxiRegAddr (pstNandCfg, u32ParOffset,
00095c  e3a020ec          MOV      r2,#0xec
000960  e1a0100a          MOV      r1,r10
000964  e1a00004          MOV      r0,r4
000968  ebfffffe          BL       vNF_CmdPhaseAxiRegAddr
;;;1092                                    NANDFLASH_CMD_ONFI_READ_PARAM);
;;;1093            /* check with timeout for NAND readyness */
;;;1094            eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
00096c  e1a00004          MOV      r0,r4
000970  ebfffffe          BL       eNandFlash_WaitDeviceReady
000974  e1a08000          MOV      r8,r0
;;;1095            if(eResult == NANDFLASH_STATUS_OK)
000978  e3580000          CMP      r8,#0
00097c  1a000048          BNE      |L1.2724|
;;;1096            {
;;;1097             /* Return to Read Mode after the Status check (Internal ECC only) */
;;;1098             if(pstNandCfg->eDeviceType != NANDFLASH_DEVICE_ONFI_HOST_ECC)
000980  e5d40004          LDRB     r0,[r4,#4]
000984  e3500000          CMP      r0,#0
000988  0a000002          BEQ      |L1.2456|
;;;1099             {
;;;1100               vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_MODE);
00098c  e3a01000          MOV      r1,#0
000990  e1a00004          MOV      r0,r4
000994  ebfffffe          BL       vNF_CmdPhaseAxi
                  |L1.2456|
;;;1101             }
;;;1102            /*
;;;1103               Read 0-253 parameters with integrity check */
;;;1104            for (u32Idx = 0U; u32Idx < (NANDFLASH_ONFI_MAX_PARAM - 4U);
000998  e3a05000          MOV      r5,#0
00099c  ea000013          B        |L1.2544|
                  |L1.2464|
;;;1105                 u32Idx = u32Idx + 4)
;;;1106            {
;;;1107   
;;;1108               u32ReadNand =
0009a0  e3a02000          MOV      r2,#0
0009a4  e1a01002          MOV      r1,r2
0009a8  e1a00004          MOV      r0,r4
0009ac  ebfffffe          BL       u32NF_DataPhaseAxiRead
0009b0  e1a06000          MOV      r6,r0
;;;1109                  u32NF_DataPhaseAxiRead (pstNandCfg, NF_PAR_CS_ACTIV,
;;;1110                                          NF_PAR_IGNORE);
;;;1111               pstNandCfg->pu8Param[u32Idx] = (uint8_t)(u32ReadNand & 0x000000FFU);
0009b4  e284103f          ADD      r1,r4,#0x3f
0009b8  e7c16005          STRB     r6,[r1,r5]
;;;1112               pstNandCfg->pu8Param[u32Idx + 1] =
0009bc  e7e70456          UBFX     r0,r6,#8,#8
0009c0  e284103f          ADD      r1,r4,#0x3f
0009c4  e2852001          ADD      r2,r5,#1
0009c8  e7c10002          STRB     r0,[r1,r2]
;;;1113                  (uint8_t)((u32ReadNand >> 8) & 0x000000FFU);
;;;1114               pstNandCfg->pu8Param[u32Idx + 2] =
0009cc  e7e70856          UBFX     r0,r6,#16,#8
0009d0  e284103f          ADD      r1,r4,#0x3f
0009d4  e2852002          ADD      r2,r5,#2
0009d8  e7c10002          STRB     r0,[r1,r2]
;;;1115                  (uint8_t)((u32ReadNand >> 16) & 0x000000FFU);
;;;1116               pstNandCfg->pu8Param[u32Idx + 3] =
0009dc  e1a00c26          LSR      r0,r6,#24
0009e0  e284103f          ADD      r1,r4,#0x3f
0009e4  e2852003          ADD      r2,r5,#3
0009e8  e7c10002          STRB     r0,[r1,r2]
0009ec  e2855004          ADD      r5,r5,#4              ;1105
                  |L1.2544|
0009f0  e35500fc          CMP      r5,#0xfc              ;1104
0009f4  3affffe9          BCC      |L1.2464|
;;;1117                  (uint8_t)((u32ReadNand >> 24) & 0x000000FFU);
;;;1118            }
;;;1119            /* Last read with CS to be disabled */
;;;1120   
;;;1121            u32ReadNand =
0009f8  e3a02000          MOV      r2,#0
0009fc  e3a01001          MOV      r1,#1
000a00  e1a00004          MOV      r0,r4
000a04  ebfffffe          BL       u32NF_DataPhaseAxiRead
000a08  e1a06000          MOV      r6,r0
;;;1122               u32NF_DataPhaseAxiRead (pstNandCfg, NF_PAR_CS_CLEAR, NF_PAR_IGNORE);
;;;1123   
;;;1124            pstNandCfg->pu8Param[u32Idx] = (uint8_t)(u32ReadNand & 0x000000FFU);
000a0c  e284103f          ADD      r1,r4,#0x3f
000a10  e7c16005          STRB     r6,[r1,r5]
;;;1125            pstNandCfg->pu8Param[u32Idx + 1] = (uint8_t)((u32ReadNand >> 8) & 0x000000FFU);
000a14  e7e70456          UBFX     r0,r6,#8,#8
000a18  e284103f          ADD      r1,r4,#0x3f
000a1c  e2852001          ADD      r2,r5,#1
000a20  e7c10002          STRB     r0,[r1,r2]
;;;1126            pstNandCfg->pu8Param[u32Idx + 2] = (uint8_t)((u32ReadNand >> 16) & 0x000000FFU);
000a24  e7e70856          UBFX     r0,r6,#16,#8
000a28  e284103f          ADD      r1,r4,#0x3f
000a2c  e2852002          ADD      r2,r5,#2
000a30  e7c10002          STRB     r0,[r1,r2]
;;;1127            pstNandCfg->pu8Param[u32Idx + 3] = (uint8_t)((u32ReadNand >> 24) & 0x000000FFU);
000a34  e1a00c26          LSR      r0,r6,#24
000a38  e284103f          ADD      r1,r4,#0x3f
000a3c  e2852003          ADD      r2,r5,#3
000a40  e7c10002          STRB     r0,[r1,r2]
;;;1128   
;;;1129            /* Build CRC-16 word from last 2 bytes */
;;;1130            u32tmp = pstNandCfg->pu8Param[(NANDFLASH_ONFI_MAX_PARAM - 1U)];
000a44  e5d4b13e          LDRB     r11,[r4,#0x13e]
;;;1131            u32DevCrc = (u32tmp << 8);         /* upper CRC-16 byte */
000a48  e1a0040b          LSL      r0,r11,#8
000a4c  e58d000c          STR      r0,[sp,#0xc]
;;;1132            u32tmp = pstNandCfg->pu8Param[(NANDFLASH_ONFI_MAX_PARAM - 2U)];
000a50  e5d4b13d          LDRB     r11,[r4,#0x13d]
;;;1133            u32DevCrc = u32DevCrc | u32tmp;    /* lower CRC-16 byte */
000a54  e59d000c          LDR      r0,[sp,#0xc]
000a58  e180000b          ORR      r0,r0,r11
000a5c  e58d000c          STR      r0,[sp,#0xc]
;;;1134            /*
;;;1135               CRC-16 calculation for all, but last 2 values */
;;;1136            u32CalCrc =
000a60  e3a010fe          MOV      r1,#0xfe
000a64  e284003f          ADD      r0,r4,#0x3f
000a68  ebfffffe          BL       u16CRCGEN_CalculateCrc16
000a6c  e1a09000          MOV      r9,r0
;;;1137               u16CRCGEN_CalculateCrc16 (&(pstNandCfg->pu8Param[0]),
;;;1138                                         (NANDFLASH_ONFI_MAX_PARAM - 2U));
;;;1139            if (u32CalCrc == u32DevCrc)
000a70  e59d000c          LDR      r0,[sp,#0xc]
000a74  e1590000          CMP      r9,r0
000a78  1a000001          BNE      |L1.2692|
;;;1140            {
;;;1141               eResult = NANDFLASH_STATUS_OK;
000a7c  e3a08000          MOV      r8,#0
000a80  ea000007          B        |L1.2724|
                  |L1.2692|
;;;1142            }
;;;1143            else                               /* CRC-16 error - try 1st/2nd
;;;1144                                                  Redundant Parameter Page */
;;;1145            {
;;;1146               u32tmpOffset = (2 * NANDFLASH_ONFI_MAX_PARAM);
000a84  e3000200          MOVW     r0,#0x200
000a88  e58d0008          STR      r0,[sp,#8]
;;;1147   
;;;1148               if (u32ParOffset < u32tmpOffset)
000a8c  e59d0008          LDR      r0,[sp,#8]
000a90  e15a0000          CMP      r10,r0
000a94  2a000001          BCS      |L1.2720|
;;;1149               {
;;;1150                  u32ParOffset = (u32ParOffset + NANDFLASH_ONFI_MAX_PARAM);
000a98  e28aac01          ADD      r10,r10,#0x100
000a9c  ea000000          B        |L1.2724|
                  |L1.2720|
;;;1151               }
;;;1152               else
;;;1153               {
;;;1154                  eResult = NANDFLASH_STATUS_CRC_ERR; /* Exit loop with error */
000aa0  e3a0800a          MOV      r8,#0xa
                  |L1.2724|
;;;1155               }
;;;1156             }
;;;1157            }
;;;1158         }
;;;1159         while (eResult == NANDFLASH_STATUS_UNKNOWN);
000aa4  e3580001          CMP      r8,#1
000aa8  0affffab          BEQ      |L1.2396|
;;;1160   
;;;1161         if (eResult == NANDFLASH_STATUS_OK)   /* CRC was OK */
000aac  e3580000          CMP      r8,#0
000ab0  1a000047          BNE      |L1.3028|
;;;1162         {
;;;1163   
;;;1164            /* Compare readout to ONFI signature: ASCI codes */
;;;1165            if ((pstNandCfg->pu8Param[0] == 0x4FU) &&
000ab4  e5d4003f          LDRB     r0,[r4,#0x3f]
000ab8  e350004f          CMP      r0,#0x4f
000abc  1a000043          BNE      |L1.3024|
;;;1166                (pstNandCfg->pu8Param[1] == 0x4EU) &&
000ac0  e5d40040          LDRB     r0,[r4,#0x40]
000ac4  e350004e          CMP      r0,#0x4e
000ac8  1a000040          BNE      |L1.3024|
;;;1167                (pstNandCfg->pu8Param[2] == 0x46U) &&
000acc  e5d40041          LDRB     r0,[r4,#0x41]
000ad0  e3500046          CMP      r0,#0x46
000ad4  1a00003d          BNE      |L1.3024|
;;;1168                (pstNandCfg->pu8Param[3] == 0x49U))
000ad8  e5d40042          LDRB     r0,[r4,#0x42]
000adc  e3500049          CMP      r0,#0x49
000ae0  1a00003a          BNE      |L1.3024|
;;;1169            {
;;;1170               /* Extract Bus Width */
;;;1171               if ((pstNandCfg->pu8Param[6] & 0x01U) == 0x01U)
000ae4  e5d40045          LDRB     r0,[r4,#0x45]
000ae8  e2000001          AND      r0,r0,#1
000aec  e3500000          CMP      r0,#0
000af0  0a000002          BEQ      |L1.2816|
;;;1172               {
;;;1173                  pstNandCfg->eBusWidth = NANDFLASH_BUS_WIDTH_16;
000af4  e3a00001          MOV      r0,#1
000af8  e5c40005          STRB     r0,[r4,#5]
000afc  ea000001          B        |L1.2824|
                  |L1.2816|
;;;1174               }
;;;1175               else
;;;1176               {
;;;1177                  pstNandCfg->eBusWidth = NANDFLASH_BUS_WIDTH_8;
000b00  e3a00000          MOV      r0,#0
000b04  e5c40005          STRB     r0,[r4,#5]
                  |L1.2824|
;;;1178               }
;;;1179               /* Extract Page Size */
;;;1180               pstNandCfg->u32PageSize = pstNandCfg->pu8Param[80];
000b08  e5d4008f          LDRB     r0,[r4,#0x8f]
000b0c  e5840010          STR      r0,[r4,#0x10]
;;;1181               u32Tmp = pstNandCfg->pu8Param[81];
000b10  e5d47090          LDRB     r7,[r4,#0x90]
;;;1182               pstNandCfg->u32PageSize = pstNandCfg->u32PageSize | (u32Tmp << 8);
000b14  e5940010          LDR      r0,[r4,#0x10]
000b18  e1800407          ORR      r0,r0,r7,LSL #8
000b1c  e5840010          STR      r0,[r4,#0x10]
;;;1183               u32Tmp = pstNandCfg->pu8Param[82];
000b20  e5d47091          LDRB     r7,[r4,#0x91]
;;;1184               pstNandCfg->u32PageSize = pstNandCfg->u32PageSize | (u32Tmp << 16);
000b24  e5940010          LDR      r0,[r4,#0x10]
000b28  e1800807          ORR      r0,r0,r7,LSL #16
000b2c  e5840010          STR      r0,[r4,#0x10]
;;;1185               u32Tmp = pstNandCfg->pu8Param[83];
000b30  e5d47092          LDRB     r7,[r4,#0x92]
;;;1186               pstNandCfg->u32PageSize = pstNandCfg->u32PageSize | (u32Tmp << 24);
000b34  e5940010          LDR      r0,[r4,#0x10]
000b38  e1800c07          ORR      r0,r0,r7,LSL #24
000b3c  e5840010          STR      r0,[r4,#0x10]
;;;1187               /*
;;;1188                  Extract Spare Area Size */
;;;1189               pstNandCfg->u16SpareSize = pstNandCfg->pu8Param[84];
000b40  e5d40093          LDRB     r0,[r4,#0x93]
000b44  e1c401b4          STRH     r0,[r4,#0x14]
;;;1190               u32Tmp = pstNandCfg->pu8Param[85];
000b48  e5d47094          LDRB     r7,[r4,#0x94]
;;;1191               pstNandCfg->u16SpareSize =
000b4c  e1d401b4          LDRH     r0,[r4,#0x14]
000b50  e30f1fff          MOV      r1,#0xffff
000b54  e0011407          AND      r1,r1,r7,LSL #8
000b58  e1800001          ORR      r0,r0,r1
000b5c  e1c401b4          STRH     r0,[r4,#0x14]
;;;1192                  pstNandCfg->u16SpareSize | (uint16_t)(u32Tmp << 8);
;;;1193               /*
;;;1194                  Extract Block Size (number of Pages) */
;;;1195               pstNandCfg->u32BlkSize = pstNandCfg->pu8Param[92];
000b60  e5d4009b          LDRB     r0,[r4,#0x9b]
000b64  e584000c          STR      r0,[r4,#0xc]
;;;1196               u32Tmp = pstNandCfg->pu8Param[93];
000b68  e5d4709c          LDRB     r7,[r4,#0x9c]
;;;1197               pstNandCfg->u32BlkSize = pstNandCfg->u32BlkSize | (u32Tmp << 8);
000b6c  e594000c          LDR      r0,[r4,#0xc]
000b70  e1800407          ORR      r0,r0,r7,LSL #8
000b74  e584000c          STR      r0,[r4,#0xc]
;;;1198               u32Tmp = pstNandCfg->pu8Param[94];
000b78  e5d4709d          LDRB     r7,[r4,#0x9d]
;;;1199               pstNandCfg->u32BlkSize = pstNandCfg->u32BlkSize | (u32Tmp << 16);
000b7c  e594000c          LDR      r0,[r4,#0xc]
000b80  e1800807          ORR      r0,r0,r7,LSL #16
000b84  e584000c          STR      r0,[r4,#0xc]
;;;1200               u32Tmp = pstNandCfg->pu8Param[95];
000b88  e5d4709e          LDRB     r7,[r4,#0x9e]
;;;1201               pstNandCfg->u32BlkSize = pstNandCfg->u32BlkSize | (u32Tmp << 24);
000b8c  e594000c          LDR      r0,[r4,#0xc]
000b90  e1800c07          ORR      r0,r0,r7,LSL #24
000b94  e584000c          STR      r0,[r4,#0xc]
;;;1202               /*
;;;1203                  Page access Address Cycles number */
;;;1204               u8RowCyc = (pstNandCfg->pu8Param[101] & 0x0FU);
000b98  e5d400a4          LDRB     r0,[r4,#0xa4]
000b9c  e200000f          AND      r0,r0,#0xf
000ba0  e58d0004          STR      r0,[sp,#4]
;;;1205               u8ColCyc = ((pstNandCfg->pu8Param[101] & 0xF0U) >> 4);
000ba4  e5d400a4          LDRB     r0,[r4,#0xa4]
000ba8  e1a01220          LSR      r1,r0,#4
000bac  e58d1000          STR      r1,[sp,#0]
;;;1206               pstNandCfg->u32PageAdrCycNo =
000bb0  e59d0004          LDR      r0,[sp,#4]
000bb4  e59d1000          LDR      r1,[sp,#0]
000bb8  e0800001          ADD      r0,r0,r1
000bbc  e2800001          ADD      r0,r0,#1
000bc0  e5840008          STR      r0,[r4,#8]
;;;1207                  ((uint32_t)u8RowCyc + (uint32_t)u8ColCyc)+1;
;;;1208               /*
;;;1209                  Bits of ECC correctability */
;;;1210               pstNandCfg->u8EccBitsCorr = pstNandCfg->pu8Param[112];
000bc4  e5d400af          LDRB     r0,[r4,#0xaf]
000bc8  e5c4003c          STRB     r0,[r4,#0x3c]
000bcc  ea000000          B        |L1.3028|
                  |L1.3024|
;;;1211            }
;;;1212            else
;;;1213            {
;;;1214               /* device is not compliant with ONFI standard */
;;;1215               eResult = NANDFLASH_STATUS_NO_COMPLY_ERR;
000bd0  e3a08002          MOV      r8,#2
                  |L1.3028|
;;;1216            }
;;;1217         }
;;;1218         else
;;;1219         {
;;;1220            /* CRC ERROR: Error code updated already: can be optimized */
;;;1221         }
;;;1222      return eResult;
000bd4  e1a00008          MOV      r0,r8
000bd8  e28dd010          ADD      sp,sp,#0x10
;;;1223   }
000bdc  e8bd9ff0          POP      {r4-r12,pc}
;;;1224   
                          ENDP

                  eNF_SetFeature PROC
;;;1226   /* TESTED */
;;;1227   static NandFlashStatus_e eNF_SetFeature (const NandFlashCfg_st * const pstNandCfg,
000be0  e92d5ff0          PUSH     {r4-r12,lr}
;;;1228                                            uint32_t u32SubAddress,
;;;1229                                            uint8_t const pu8SubParBuf[])
;;;1230   {
000be4  e1a08000          MOV      r8,r0
000be8  e1a09001          MOV      r9,r1
000bec  e1a05002          MOV      r5,r2
;;;1231      NandFlashStatus_e eResult;
;;;1232   
;;;1233      uint32_t u32DatPh;                       /* Word to be send within a command
;;;1234                                                  phase */
;;;1235      uint32_t *pu32CmdPhDest;
;;;1236   
;;;1237      uint32_t u32WrData;
;;;1238   
;;;1239      uint32_t u32Tmp;
;;;1240   
;;;1241   
;;;1242      /* ONFI SET FEATURE command with address == 0x90 == ECC ctrl */
;;;1243      vNF_CmdPhaseAxiRegAddr (pstNandCfg, u32SubAddress,
000bf0  e3a020ef          MOV      r2,#0xef
000bf4  e1a01009          MOV      r1,r9
000bf8  e1a00008          MOV      r0,r8
000bfc  ebfffffe          BL       vNF_CmdPhaseAxiRegAddr
;;;1244                              NANDFLASH_CMD_ONFI_SET_FEATURE);
;;;1245      /*
;;;1246         WAIT ALE to data start tADL == 70ns Timing for tADL begins in the address
;;;1247         cycle, on the final rising edge of WE#, and ends with the first rising
;;;1248         edge of WE# for data input. On FPGA target it takes ~2u to send 8-bytes
;;;1249         using 4 x !WE cycles - so total min. time is: 2.1 [us] + 70 [ns] */
;;;1250      /*
;;;1251         4 bytes are written per single access, so create a word to be written */
;;;1252      u32WrData = pu8SubParBuf[0];
000c00  e5d56000          LDRB     r6,[r5,#0]
;;;1253      u32Tmp = pu8SubParBuf[1];
000c04  e5d57001          LDRB     r7,[r5,#1]
;;;1254      u32WrData = u32WrData | (u32Tmp << 8);
000c08  e1866407          ORR      r6,r6,r7,LSL #8
;;;1255      u32Tmp = pu8SubParBuf[2];
000c0c  e5d57002          LDRB     r7,[r5,#2]
;;;1256      u32WrData = u32WrData | (u32Tmp << 16);
000c10  e1866807          ORR      r6,r6,r7,LSL #16
;;;1257      u32Tmp = pu8SubParBuf[3];
000c14  e5d57003          LDRB     r7,[r5,#3]
;;;1258      u32WrData = u32WrData | (u32Tmp << 24);
000c18  e1866c07          ORR      r6,r6,r7,LSL #24
;;;1259      /*
;;;1260         Chip select must be finished in the last transfer. ECC calculation End
;;;1261         depends on the u32EccLast parameter value. */
;;;1262      u32DatPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
000c1c  e5980000          LDR      r0,[r8,#0]
000c20  e20044ff          AND      r4,r0,#0xff000000
;;;1263      u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
000c24  e3844602          ORR      r4,r4,#0x200000
;;;1264      u32DatPh = (u32DatPh | (NF_PAR_IGNORE << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
000c28  e320f000          NOP      
;;;1265      u32DatPh =
000c2c  e3844702          ORR      r4,r4,#0x80000
;;;1266         (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;1267      u32DatPh =
000c30  e3844902          ORR      r4,r4,#0x8000
;;;1268         (u32DatPh | (NANDFLASH_CMD_PROGRAM_END << (MEMCTRL_AXI_END_COMMAND_SFT)));
;;;1269      u32DatPh = (u32DatPh | (NF_PAR_IGNORE << (MEMCTRL_AXI_ECC_LAST_SFT)));
000c34  e320f000          NOP      
;;;1270   /***
;;;1271   * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;1272   *          integral type.
;;;1273   *
;;;1274   * DESC   : This warning cannot be avoided, since the PL353 MemCtrl requires a
;;;1275   *          specific pointer/access based on the integer value built upon the
;;;1276   *          combination of integer parameters.
;;;1277   ****/
;;;1278      pu32CmdPhDest = (uint32_t *)u32DatPh;    /* PRQA S 0306 */
000c38  e1a0b004          MOV      r11,r4
;;;1279      *pu32CmdPhDest = u32WrData;              /* 4 x 8-bit Write to device */
000c3c  e58b6000          STR      r6,[r11,#0]
;;;1280   
;;;1281      __DSB();
000c40  ebfffffe          BL       __DSB
;;;1282   
;;;1283      /* Wait until the ECC Feature is really setup */
;;;1284      eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
000c44  e1a00008          MOV      r0,r8
000c48  ebfffffe          BL       eNandFlash_WaitDeviceReady
000c4c  e1a0a000          MOV      r10,r0
;;;1285   
;;;1286      return eResult;
000c50  e1a0000a          MOV      r0,r10
;;;1287   }
000c54  e8bd9ff0          POP      {r4-r12,pc}
;;;1288   
                          ENDP

                  eNF_GetDeviceStatus PROC
;;;1290   /* NOT_TESTED */
;;;1291   NandFlashStatus_e eNF_GetDeviceStatus (const NandFlashCfg_st * const pstNandCfg)
000c58  e92d4070          PUSH     {r4-r6,lr}
;;;1292   {
000c5c  e1a05000          MOV      r5,r0
;;;1293      NandFlashStatus_e eResult;
;;;1294   
;;;1295      uint8_t u8DevStat;
;;;1296   
;;;1297   /*
;;;1298    ONFI:
;;;1299    In the case of non-interleaved operations, the Read Status function retrieves
;;;1300    a status value for the last operation issued. If multiple interleaved operations
;;;1301    are in progress on a single LUN, then Read Status returns the composite status
;;;1302    value for status register bits that are independent per interleaved address.
;;;1303    Specifically, Read Status shall return the combined status value of the
;;;1304    independent status register bits according to Table 18. See section 5.10 for
;;;1305    status register bit definitions. */
;;;1306      if (pstNandCfg == TYPES_NULL_PTR)
000c60  e3550000          CMP      r5,#0
000c64  1a000001          BNE      |L1.3184|
;;;1307      {
;;;1308         eResult = NANDFLASH_STATUS_PTR_ERR;
000c68  e3a04004          MOV      r4,#4
000c6c  ea00000d          B        |L1.3240|
                  |L1.3184|
;;;1309      }
;;;1310      else
;;;1311      {
;;;1312         vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_STATUS);
000c70  e3a01070          MOV      r1,#0x70
000c74  e1a00005          MOV      r0,r5
000c78  ebfffffe          BL       vNF_CmdPhaseAxi
;;;1313         /* read ... */
;;;1314         u8DevStat =
000c7c  e3a02000          MOV      r2,#0
000c80  e3a01001          MOV      r1,#1
000c84  e1a00005          MOV      r0,r5
000c88  ebfffffe          BL       u32NF_DataPhaseAxiRead
000c8c  e20060ff          AND      r6,r0,#0xff
;;;1315            (uint8_t)u32NF_DataPhaseAxiRead (pstNandCfg, NF_PAR_CS_CLEAR,
;;;1316                                             NF_PAR_IGNORE);
;;;1317         /* check only bit0: for non-interleaved operations */
;;;1318         if ((u8DevStat & NF_INTERN_ECC_FAILED) == NF_INTERN_ECC_FAILED)
000c90  e2060001          AND      r0,r6,#1
000c94  e3500000          CMP      r0,#0
000c98  0a000001          BEQ      |L1.3236|
;;;1319         {
;;;1320            eResult = NANDFLASH_STATUS_OPERATION_ERR;
000c9c  e3a04003          MOV      r4,#3
000ca0  ea000000          B        |L1.3240|
                  |L1.3236|
;;;1321         }
;;;1322         else
;;;1323         {
;;;1324            eResult = NANDFLASH_STATUS_OK;
000ca4  e3a04000          MOV      r4,#0
                  |L1.3240|
;;;1325         }
;;;1326      }
;;;1327      return eResult;
000ca8  e1a00004          MOV      r0,r4
;;;1328   }
000cac  e8bd8070          POP      {r4-r6,pc}
;;;1329   
                          ENDP

                  eNF_ReadDeviceStatus PROC
;;;1330   /*..........................................................................*/
;;;1331   NandFlashStatus_e eNF_ReadDeviceStatus (const NandFlashCfg_st * const pstNandCfg,
000cb0  e92d4070          PUSH     {r4-r6,lr}
;;;1332                                           uint32_t* pu32NandStatus )
;;;1333   {
000cb4  e1a04000          MOV      r4,r0
000cb8  e1a05001          MOV      r5,r1
;;;1334      NandFlashStatus_e eResult;
;;;1335      eResult = NANDFLASH_STATUS_OK;
000cbc  e3a06000          MOV      r6,#0
;;;1336   
;;;1337      if (pstNandCfg == TYPES_NULL_PTR)
000cc0  e3540000          CMP      r4,#0
000cc4  1a000001          BNE      |L1.3280|
;;;1338      {
;;;1339         eResult = NANDFLASH_STATUS_PTR_ERR;
000cc8  e3a06004          MOV      r6,#4
000ccc  ea000008          B        |L1.3316|
                  |L1.3280|
;;;1340      }
;;;1341      else
;;;1342      {
;;;1343         vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_STATUS);
000cd0  e3a01070          MOV      r1,#0x70
000cd4  e1a00004          MOV      r0,r4
000cd8  ebfffffe          BL       vNF_CmdPhaseAxi
;;;1344         /* read ... */
;;;1345         *pu32NandStatus =
000cdc  e3a02000          MOV      r2,#0
000ce0  e3a01001          MOV      r1,#1
000ce4  e1a00004          MOV      r0,r4
000ce8  ebfffffe          BL       u32NF_DataPhaseAxiRead
000cec  e20000ff          AND      r0,r0,#0xff
000cf0  e5850000          STR      r0,[r5,#0]
                  |L1.3316|
;;;1346            (uint8_t)u32NF_DataPhaseAxiRead (pstNandCfg, NF_PAR_CS_CLEAR,
;;;1347                                             NF_PAR_IGNORE);
;;;1348      }
;;;1349      return eResult;
000cf4  e1a00006          MOV      r0,r6
;;;1350   }
000cf8  e8bd8070          POP      {r4-r6,pc}
;;;1351   
                          ENDP

                  eNandFlash_GetHwConfig PROC
;;;1357   /* TESTED */
;;;1358   NandFlashStatus_e eNandFlash_GetHwConfig (NandFlashCfg_st * pstNandCfg)
000cfc  e92d41f0          PUSH     {r4-r8,lr}
;;;1359   {
000d00  e1a04000          MOV      r4,r0
;;;1360      NandFlashStatus_e eResult;
;;;1361   
;;;1362      uint32_t u32RdCfg;
;;;1363   
;;;1364      uint32_t u32Tmp;
;;;1365   
;;;1366   
;;;1367      if (pstNandCfg == TYPES_NULL_PTR)
000d04  e3540000          CMP      r4,#0
000d08  1a000001          BNE      |L1.3348|
;;;1368      {
;;;1369         eResult = NANDFLASH_STATUS_PTR_ERR;
000d0c  e3a07004          MOV      r7,#4
000d10  ea000034          B        |L1.3560|
                  |L1.3348|
;;;1370      }
;;;1371      else
;;;1372      {
;;;1373         /* copy cycles data from register to the configuration structure */
;;;1374         u32RdCfg = MEMCTRL_NAND_CYCLES;
000d14  e59f02c8          LDR      r0,|L1.4068|
000d18  e5905180          LDR      r5,[r0,#0x180]
;;;1375   
;;;1376         pstNandCfg->u32ReadCycleTime =
000d1c  e205000f          AND      r0,r5,#0xf
000d20  e5840024          STR      r0,[r4,#0x24]
;;;1377            ((u32RdCfg & (MEMCTRL_SET_T0_MSK)) >> (MEMCTRL_SET_T0_SFT));
;;;1378         pstNandCfg->u32WriteCycleTime =
000d24  e7e30255          UBFX     r0,r5,#4,#4
000d28  e5840020          STR      r0,[r4,#0x20]
;;;1379            ((u32RdCfg & (MEMCTRL_SET_T1_MSK)) >> (MEMCTRL_SET_T1_SFT));
;;;1380         pstNandCfg->u32AssertDelayReN =
000d2c  e7e20455          UBFX     r0,r5,#8,#3
000d30  e5840030          STR      r0,[r4,#0x30]
;;;1381            ((u32RdCfg & (MEMCTRL_SET_T2_MSK)) >> (MEMCTRL_SET_T2_SFT));
;;;1382         pstNandCfg->u32DeAssertDelayWeN =
000d34  e7e205d5          UBFX     r0,r5,#11,#3
000d38  e584002c          STR      r0,[r4,#0x2c]
;;;1383            ((u32RdCfg & (MEMCTRL_SET_T3_MSK)) >> (MEMCTRL_SET_T3_SFT));
;;;1384         pstNandCfg->u32StatusRdTime =
000d3c  e7e20755          UBFX     r0,r5,#14,#3
000d40  e584001c          STR      r0,[r4,#0x1c]
;;;1385            ((u32RdCfg & (MEMCTRL_SET_T4_MSK)) >> (MEMCTRL_SET_T4_SFT));
;;;1386         pstNandCfg->u32IdRdTime =
000d44  e7e208d5          UBFX     r0,r5,#17,#3
000d48  e5840018          STR      r0,[r4,#0x18]
;;;1387            ((u32RdCfg & (MEMCTRL_SET_T5_MSK)) >> (MEMCTRL_SET_T5_SFT));
;;;1388         pstNandCfg->u32BusyCycleToReN =
000d4c  e7e30a55          UBFX     r0,r5,#20,#4
000d50  e5840028          STR      r0,[r4,#0x28]
;;;1389            ((u32RdCfg & (MEMCTRL_SET_NAND_T6_MSK)) >> (MEMCTRL_SET_T6_SFT));
;;;1390         /* copy operation mode data from register to the configuration structure */
;;;1391         u32RdCfg = MEMCTRL_NAND_OPMODE;
000d54  e59f0288          LDR      r0,|L1.4068|
000d58  e5905184          LDR      r5,[r0,#0x184]
;;;1392         /*
;;;1393            Load u32BusWidth */
;;;1394         u32Tmp = ((u32RdCfg & (MEMCTRL_SET_MW_MSK)));
000d5c  e2056003          AND      r6,r5,#3
;;;1395         if (u32Tmp == (MEMCTRL_SET_MW_16_BITS))
000d60  e3560001          CMP      r6,#1
000d64  1a000002          BNE      |L1.3444|
;;;1396         {
;;;1397            pstNandCfg->eBusWidth = NANDFLASH_BUS_WIDTH_16;
000d68  e3a00001          MOV      r0,#1
000d6c  e5c40005          STRB     r0,[r4,#5]
000d70  ea000001          B        |L1.3452|
                  |L1.3444|
;;;1398         }
;;;1399         else
;;;1400         {
;;;1401            /* 0x00 and all other values should result as 8-bit mode */
;;;1402            pstNandCfg->eBusWidth = NANDFLASH_BUS_WIDTH_8;
000d74  e3a00000          MOV      r0,#0
000d78  e5c40005          STRB     r0,[r4,#5]
                  |L1.3452|
;;;1403         }
;;;1404         u32RdCfg = MEMCTRL_ECC_MEMCFG;
000d7c  e59f0264          LDR      r0,|L1.4072|
000d80  e5905000          LDR      r5,[r0,#0]
;;;1405         u32Tmp = ((u32RdCfg & (MEMCTRL_ECC_EXTRA_BLOCK_MSK)));
000d84  e2056b01          AND      r6,r5,#0x400
;;;1406         if (u32Tmp == (MEMCTRL_ECC_EXTRA_BLOCK_MSK))
000d88  e3560b01          CMP      r6,#0x400
000d8c  1a000010          BNE      |L1.3540|
;;;1407         {
;;;1408            u32Tmp = ((u32RdCfg & (MEMCTRL_ECC_EXTRA_BLOCK_SIZE_MSK)));
000d90  e2056b06          AND      r6,r5,#0x1800
;;;1409            switch (u32Tmp)
000d94  e3560a01          CMP      r6,#0x1000
000d98  0a000004          BEQ      |L1.3504|
000d9c  e3560b06          CMP      r6,#0x1800
000da0  1a000006          BNE      |L1.3520|
;;;1410            {
;;;1411               case MEMCTRL_ECC_EXTRA_BLOCK_SIZE_32B_BITS:
;;;1412               {
;;;1413                  pstNandCfg->eExtraBlockCfg = NANDFLASH_EXTRA_BLOCK_32_BYTES;
000da4  e3a00003          MOV      r0,#3
000da8  e5c40006          STRB     r0,[r4,#6]
;;;1414               }
;;;1415                  break;
000dac  ea000007          B        |L1.3536|
                  |L1.3504|
;;;1416               case MEMCTRL_ECC_EXTRA_BLOCK_SIZE_16B_BITS:
000db0  e320f000          NOP      
;;;1417               {
;;;1418                  pstNandCfg->eExtraBlockCfg = NANDFLASH_EXTRA_BLOCK_16_BYTES;
000db4  e3a00002          MOV      r0,#2
000db8  e5c40006          STRB     r0,[r4,#6]
;;;1419               }
;;;1420                  break;
000dbc  ea000003          B        |L1.3536|
                  |L1.3520|
;;;1421               default:
000dc0  e320f000          NOP      
;;;1422               {
;;;1423                  pstNandCfg->eExtraBlockCfg = NANDFLASH_EXTRA_BLOCK_8_BYTES;
000dc4  e3a00001          MOV      r0,#1
000dc8  e5c40006          STRB     r0,[r4,#6]
;;;1424               }
;;;1425               break;            
000dcc  e320f000          NOP      
                  |L1.3536|
000dd0  ea000001          B        |L1.3548|
                  |L1.3540|
;;;1426            }
;;;1427         }
;;;1428         else
;;;1429         {
;;;1430            pstNandCfg->eExtraBlockCfg = NANDFLASH_EXTRA_BLOCK_DISABLED;
000dd4  e3a00000          MOV      r0,#0
000dd8  e5c40006          STRB     r0,[r4,#6]
                  |L1.3548|
;;;1431         }
;;;1432   
;;;1433         /* Check all settings */
;;;1434         eResult = eNF_ConfigVerify (pstNandCfg);
000ddc  e1a00004          MOV      r0,r4
000de0  ebfffffe          BL       eNF_ConfigVerify
000de4  e1a07000          MOV      r7,r0
                  |L1.3560|
;;;1435      }
;;;1436      return eResult;
000de8  e1a00007          MOV      r0,r7
;;;1437   }
000dec  e8bd81f0          POP      {r4-r8,pc}
;;;1438   
                          ENDP

                  eNandFlash_ResetDevice PROC
;;;1898   /* TESTED */
;;;1899   NandFlashStatus_e eNandFlash_ResetDevice (const NandFlashCfg_st * const pstNandCfg)
000df0  e92d4070          PUSH     {r4-r6,lr}
;;;1900   {
000df4  e1a05000          MOV      r5,r0
;;;1901      NandFlashStatus_e eResult;
;;;1902   
;;;1903   
;;;1904      if (pstNandCfg == TYPES_NULL_PTR)
000df8  e3550000          CMP      r5,#0
000dfc  1a000001          BNE      |L1.3592|
;;;1905      {
;;;1906         eResult = NANDFLASH_STATUS_PTR_ERR;
000e00  e3a04004          MOV      r4,#4
000e04  ea000005          B        |L1.3616|
                  |L1.3592|
;;;1907      }
;;;1908      else
;;;1909      {
;;;1910         vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_RESET);
000e08  e3a010ff          MOV      r1,#0xff
000e0c  e1a00005          MOV      r0,r5
000e10  ebfffffe          BL       vNF_CmdPhaseAxi
;;;1911         eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
000e14  e1a00005          MOV      r0,r5
000e18  ebfffffe          BL       eNandFlash_WaitDeviceReady
000e1c  e1a04000          MOV      r4,r0
                  |L1.3616|
;;;1912      }
;;;1913      return eResult;
000e20  e1a00004          MOV      r0,r4
;;;1914   }
000e24  e8bd8070          POP      {r4-r6,pc}
;;;1915   
                          ENDP

                  eNandFlash_Initialize PROC
;;;1440   /* TESTED */
;;;1441   NandFlashStatus_e eNandFlash_Initialize (NandFlashCfg_st * pstNandCfg,
000e28  e92d5ffc          PUSH     {r2-r12,lr}
;;;1442                                            NandFlashDeviceType_e eDeviceType)
;;;1443   {
000e2c  e1a04000          MOV      r4,r0
000e30  e1a06001          MOV      r6,r1
;;;1444   /***
;;;1445   * MESSAGE: Msg(3:3197) The initialiser for 'eResult' is always modified before
;;;1446   *          being used.
;;;1447   *
;;;1448   * DESC   : To detect that eResult is updated every time within this complex
;;;1449   *          function the initial value NANDFLASH_STATUS_UNKNOWN is used.
;;;1450   ****/
;;;1451      NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;    /* PRQA S 3197 */
000e34  e3a05001          MOV      r5,#1
;;;1452   
;;;1453      uint32_t u32DirCmdVal;    /* for direct_cmd register value */
;;;1454   
;;;1455      uint32_t u32Opmode;
;;;1456   
;;;1457      uint32_t u32Cycles;
;;;1458   
;;;1459      uint32_t u32Cyc;
;;;1460   
;;;1461      uint32_t u32Mod;
;;;1462   
;;;1463      uint32_t u32TryCnt = 0;   /* Register-update counter */
000e38  e3a00000          MOV      r0,#0
000e3c  e58d0004          STR      r0,[sp,#4]
;;;1464   
;;;1465   
;;;1466      if (pstNandCfg == TYPES_NULL_PTR)
000e40  e3540000          CMP      r4,#0
000e44  1a000001          BNE      |L1.3664|
;;;1467      {
;;;1468         eResult = NANDFLASH_STATUS_PTR_ERR;
000e48  e3a05004          MOV      r5,#4
000e4c  ea000062          B        |L1.4060|
                  |L1.3664|
;;;1469      }
;;;1470      else
;;;1471      {
;;;1472         /* First of all Device Initialization requires Power Supply settling
;;;1473            time, which affects the Ready/#Busy line at Power Up. The NAND device
;;;1474            spec. requires to wait min. 100us from PowerUp (if Busy line is not
;;;1475            monitored). Since in PL353 the Ready state is asserting the
;;;1476            edge-sensitive interrupt - the R/#B line cannot be monitored since the
;;;1477            configuration of the signal requires MEMCTRL_BUSY_CFG_SET macro call
;;;1478            (if configuration is done to late the #Busy/Ready edge IRQ will not be
;;;1479            "latched" be PL353). */
;;;1480         NF_uSecWait (NANDFLASH_INIT_TIME_MAX_us_CFG);
000e50  e30003e8          MOVW     r0,#0x3e8
000e54  ebfffffe          BL       NF_uSecWait
;;;1481   /***
;;;1482   * MESSAGE: MISRA-C:2004 Rule 12.11 Unsigned multiplication in constant
;;;1483   *          expression wraps around past maximum value.
;;;1484   *
;;;1485   * DESC   : Several warnings generated about the risk to cross the boundary of
;;;1486   *          the 32-bit integer type should be taken into account, while changing
;;;1487   *          the values/parameters of: NANDFLASH_BUSY_TIMEOUT_MAX_CFG and
;;;1488   *          NANDFLASH_ECC_TIMEOUT_MAX_CFG. With current selections the result
;;;1489   *          of the macros/calculations is within the range.
;;;1490   ****/
;;;1491         pstNandCfg->u32BusyTimeOut = NANDFLASH_BUSY_TIMEOUT_MAX_CFG;
000e58  e59f019c          LDR      r0,|L1.4092|
000e5c  e5840034          STR      r0,[r4,#0x34]
;;;1492         pstNandCfg->u32EccTimeOut = NANDFLASH_ECC_TIMEOUT_MAX_CFG;
000e60  e59f0198          LDR      r0,|L1.4096|
000e64  e5840038          STR      r0,[r4,#0x38]
;;;1493         /* Enable Interrupts: INT_ENABLE0 and INT_ENABLE1 bits */
;;;1494         /* MEMCTRL_MEM_CFG_SET = 0x00000003U; */
;;;1495   
;;;1496         if(pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_HOST_ECC)
000e68  e5d40004          LDRB     r0,[r4,#4]
000e6c  e3500000          CMP      r0,#0
000e70  1a000004          BNE      |L1.3720|
;;;1497         {
;;;1498            /* ENABLE Busy signal for NAND with HOST ECC */
;;;1499            MEMCTRL_BUSY_CFG_SET = MEMCTRL_BUSY_ENABLE;
000e74  e3a00020          MOV      r0,#0x20
000e78  e59f1164          LDR      r1,|L1.4068|
000e7c  e5810204          STR      r0,[r1,#0x204]
;;;1500            NANDFLASH_CLEAR_READY_IRQ ();         /* Clear after BUSY line cfg */
000e80  e3a00010          MOV      r0,#0x10
000e84  e581000c          STR      r0,[r1,#0xc]
                  |L1.3720|
;;;1501         }
;;;1502   
;;;1503         /* Warning: specify u32NandChipAddress according to LSI/FPGA spec. */
;;;1504         pstNandCfg->u32NandChipAddress = MEMCTRL_NAND_CHIP_ADDRESS;
000e88  e3a00309          MOV      r0,#0x24000000
000e8c  e5840000          STR      r0,[r4,#0]
;;;1505   
;;;1506         eResult = eNF_ConfigVerify (pstNandCfg);
000e90  e1a00004          MOV      r0,r4
000e94  ebfffffe          BL       eNF_ConfigVerify
000e98  e1a05000          MOV      r5,r0
;;;1507   
;;;1508         if (eResult == NANDFLASH_STATUS_OK)
000e9c  e3550000          CMP      r5,#0
000ea0  1a00004d          BNE      |L1.4060|
;;;1509         {
;;;1510            /* Initial copy should be done here to be able to access the device... */
;;;1511            vNF_CopyConfigToRegs (pstNandCfg);
000ea4  e1a00004          MOV      r0,r4
000ea8  ebfffffe          BL       vNF_CopyConfigToRegs
;;;1512   
;;;1513            /* !!! NEW: RESET the NAND device !!! */
;;;1514            eResult = eNandFlash_ResetDevice (pstNandCfg);
000eac  e1a00004          MOV      r0,r4
000eb0  ebfffffe          BL       eNandFlash_ResetDevice
000eb4  e1a05000          MOV      r5,r0
;;;1515            if (eResult == NANDFLASH_STATUS_OK)
000eb8  e3550000          CMP      r5,#0
000ebc  1a000046          BNE      |L1.4060|
;;;1516            {
;;;1517               /*
;;;1518                  This function should configure some parameters according to
;;;1519                  settings taken from the NAND devices configuration registers.
;;;1520                  Those settings are differently stored for ONFI compliant devices
;;;1521                  than for Samsung devices. */
;;;1522               if (eDeviceType == (NANDFLASH_DEVICE_ONFI_HOST_ECC)) /* ONFI device */
000ec0  e3560000          CMP      r6,#0
000ec4  1a000004          BNE      |L1.3804|
;;;1523               {
;;;1524                  pstNandCfg->eDeviceType = eDeviceType;
000ec8  e5c46004          STRB     r6,[r4,#4]
;;;1525                  eResult = eNF_ReadOnfiParamsPage (pstNandCfg);
000ecc  e1a00004          MOV      r0,r4
000ed0  ebfffffe          BL       eNF_ReadOnfiParamsPage
000ed4  e1a05000          MOV      r5,r0
000ed8  ea000011          B        |L1.3876|
                  |L1.3804|
;;;1526               }
;;;1527               else if (eDeviceType == (NANDFLASH_DEVICE_ONFI_VENDOR1_ECC))
000edc  e3560001          CMP      r6,#1
000ee0  1a00000e          BNE      |L1.3872|
;;;1528               {
;;;1529                  pstNandCfg->eDeviceType = eDeviceType;
000ee4  e5c46004          STRB     r6,[r4,#4]
;;;1530                  /* MICRON/ONFI device with internal ECC */
;;;1531                  eResult = eNF_ReadOnfiParamsPage (pstNandCfg);
000ee8  e1a00004          MOV      r0,r4
000eec  ebfffffe          BL       eNF_ReadOnfiParamsPage
000ef0  e1a05000          MOV      r5,r0
;;;1532   
;;;1533                  if (eResult == NANDFLASH_STATUS_OK)
000ef4  e3550000          CMP      r5,#0
000ef8  1a000009          BNE      |L1.3876|
;;;1534                  {
;;;1535                     /* Enable Internal device's ECC sequence */
;;;1536                     uint8_t u8SubParBuf[] = { 0x08U, 0x00U, 0x00U, 0x00U };
000efc  e28f0c01          ADR      r0,|L1.4100|
000f00  e5900000          LDR      r0,[r0,#0]
000f04  e58d0000          STR      r0,[sp,#0]
;;;1537                     /* SET INTERNAL ECC feature */
;;;1538                     eResult = eNF_SetFeature (pstNandCfg, 0x90U, u8SubParBuf);
000f08  e1a0200d          MOV      r2,sp
000f0c  e3a01090          MOV      r1,#0x90
000f10  e1a00004          MOV      r0,r4
000f14  ebfffffe          BL       eNF_SetFeature
000f18  e1a05000          MOV      r5,r0
;;;1539                  }
000f1c  ea000000          B        |L1.3876|
                  |L1.3872|
;;;1540               }
;;;1541               else
;;;1542               {
;;;1543                  eResult = NANDFLASH_STATUS_NO_COMPLY_ERR;
000f20  e3a05002          MOV      r5,#2
                  |L1.3876|
;;;1544               }
;;;1545   
;;;1546               if (eResult == NANDFLASH_STATUS_OK)
000f24  e3550000          CMP      r5,#0
000f28  1a00002b          BNE      |L1.4060|
;;;1547               {
;;;1548                  /*
;;;1549                     Check, if settings are correct */
;;;1550                  eResult = eNF_ConfigVerify (pstNandCfg);
000f2c  e1a00004          MOV      r0,r4
000f30  ebfffffe          BL       eNF_ConfigVerify
000f34  e1a05000          MOV      r5,r0
;;;1551                  if (eResult == NANDFLASH_STATUS_OK)
000f38  e3550000          CMP      r5,#0
000f3c  1a000026          BNE      |L1.4060|
;;;1552                  {
;;;1553                     if (pstNandCfg->eBusWidth == NANDFLASH_BUS_WIDTH_16)
000f40  e5d40005          LDRB     r0,[r4,#5]
000f44  e3500001          CMP      r0,#1
000f48  1a000001          BNE      |L1.3924|
;;;1554                     {
;;;1555                        u32Opmode = MEMCTRL_SET_MW_16_BITS;
000f4c  e3a07001          MOV      r7,#1
000f50  ea000000          B        |L1.3928|
                  |L1.3924|
;;;1556                     }
;;;1557                     else                      /* 8-bit */
;;;1558                     {
;;;1559                        u32Opmode = MEMCTRL_SET_MW_8_BITS;
000f54  e3a07000          MOV      r7,#0
                  |L1.3928|
;;;1560                     }
;;;1561                     /* Update NAND OPMODE Register */
;;;1562                     MEMCTRL_SET_OPMODE = u32Opmode;
000f58  e59f0084          LDR      r0,|L1.4068|
000f5c  e5807018          STR      r7,[r0,#0x18]
;;;1563   
;;;1564                     u32Cycles = MEMCTRL_NAND_CYCLES;
000f60  e5909180          LDR      r9,[r0,#0x180]
;;;1565                     MEMCTRL_SET_CYCLES = u32Cycles;
000f64  e5809014          STR      r9,[r0,#0x14]
;;;1566                     /*
;;;1567                        Configuration is now within set_cycles and set_opmode
;;;1568                        registers. To update the timing within the SMC for a NAND
;;;1569                        device it is required to specify an UpdateRegs cmd_type
;;;1570                        within the direct_cmd register. */
;;;1571                     u32DirCmdVal =
000f68  e3a08509          MOV      r8,#0x2400000
;;;1572                        ((MEMCTRL_NAND_CHIP_SEL_MSK) |
;;;1573                         (MEMCTRL_CMD_TYPE_UPD_REGS_MSK));
;;;1574                     MEMCTRL_DIRECT_CMD = u32DirCmdVal; /* Update registers for
000f6c  e5808010          STR      r8,[r0,#0x10]
;;;1575                                                           NAND */
;;;1576   
;;;1577                     /* reuse eResult for this loop, assume unknown result */
;;;1578                     eResult = NANDFLASH_STATUS_UNKNOWN;
000f70  e3a05001          MOV      r5,#1
;;;1579                     do
000f74  e320f000          NOP      
                  |L1.3960|
;;;1580                     {
;;;1581                        u32Cyc = MEMCTRL_NAND_CYCLES;
000f78  e59f0064          LDR      r0,|L1.4068|
000f7c  e590a180          LDR      r10,[r0,#0x180]
;;;1582   
;;;1583                        u32Mod = (MEMCTRL_NAND_OPMODE & (MEMCTRL_SET_MW_MSK));
000f80  e5900184          LDR      r0,[r0,#0x184]
000f84  e200b003          AND      r11,r0,#3
;;;1584   
;;;1585                        if ((u32Cyc == u32Cycles) && (u32Mod == u32Opmode))
000f88  e15a0009          CMP      r10,r9
000f8c  1a000003          BNE      |L1.4000|
000f90  e15b0007          CMP      r11,r7
000f94  1a000001          BNE      |L1.4000|
;;;1586                        {
;;;1587                           eResult = NANDFLASH_STATUS_OK;
000f98  e3a05000          MOV      r5,#0
000f9c  ea000009          B        |L1.4040|
                  |L1.4000|
;;;1588                        }
;;;1589                        else
;;;1590                        {
;;;1591   /***
;;;1592   * MESSAGE: MISRA-C:2004 Rule 1.1 [L] Nesting of control structures (statements)
;;;1593   *          exceeds 15 - program is non-conforming.
;;;1594   *          MISRA-C:2004 Rule 1.1; REFERENCE - ISO-5.2.4.1 Translation Limits
;;;1595   *
;;;1596   * DESC   : Two messages for below conditions are TRUE, however, to keep the
;;;1597   *          code readable the source code is preserved in its orginal form.
;;;1598   ****/
;;;1599                           if (u32TryCnt < 4U)
000fa0  e59d0004          LDR      r0,[sp,#4]
000fa4  e3500004          CMP      r0,#4
000fa8  2a000005          BCS      |L1.4036|
;;;1600                           {    /* PRQA S 0715 */
;;;1601                              MEMCTRL_DIRECT_CMD = u32DirCmdVal;
000fac  e59f0030          LDR      r0,|L1.4068|
000fb0  e5808010          STR      r8,[r0,#0x10]
;;;1602                              u32TryCnt++;
000fb4  e59d0004          LDR      r0,[sp,#4]
000fb8  e2800001          ADD      r0,r0,#1
000fbc  e58d0004          STR      r0,[sp,#4]
000fc0  ea000000          B        |L1.4040|
                  |L1.4036|
;;;1603                           }
;;;1604                           else
;;;1605                           {    /* PRQA S 0715 */
;;;1606                              eResult = NANDFLASH_STATUS_OPERATION_ERR; /* update
000fc4  e3a05003          MOV      r5,#3
                  |L1.4040|
;;;1607                                                                           failed */
;;;1608                           }
;;;1609                        }
;;;1610                     }
;;;1611                     while (!((eResult == (NANDFLASH_STATUS_OK)) ||
000fc8  e3550000          CMP      r5,#0
000fcc  0a000001          BEQ      |L1.4056|
000fd0  e3550003          CMP      r5,#3
000fd4  1affffe7          BNE      |L1.3960|
                  |L1.4056|
;;;1612                             (eResult == (NANDFLASH_STATUS_OPERATION_ERR))));
;;;1613   
;;;1614                     eResult = NANDFLASH_STATUS_OK;
000fd8  e3a05000          MOV      r5,#0
                  |L1.4060|
;;;1615                  }
;;;1616               }
;;;1617               else
;;;1618               {
;;;1619                  /* eResult updated already - optimize it */
;;;1620               }
;;;1621            }
;;;1622         }
;;;1623      }
;;;1624      return eResult;
000fdc  e1a00005          MOV      r0,r5
;;;1625   }
000fe0  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.4068|
                          DCD      0xc0200000
                  |L1.4072|
                          DCD      0xc0200404
                  |L1.4076|
                          DCD      0xc0200400
                  |L1.4080|
                          DCD      0x01300080
                  |L1.4084|
                          DCD      0x01e00585
                  |L1.4088|
                          DCD      0xc0200418
                  |L1.4092|
                          DCD      0x00065b9a
                  |L1.4096|
                          DCD      0x000f4240
                  |L1.4100|
001004  0800              DCB      "\b",0
001006  00                DCB      0
001007  00                DCB      0
                          ENDP

                  eNandFlash_SetExtraBlock PROC
;;;1662   /* TESTED */
;;;1663   NandFlashStatus_e eNandFlash_SetExtraBlock (NandFlashCfg_st * pstNandCfg,
001008  e1a02000          MOV      r2,r0
;;;1664                                               NandFlashExtraBlock_e eExtraBlkCfg)
;;;1665   {
;;;1666      NandFlashStatus_e eResult;
;;;1667   
;;;1668      if (pstNandCfg == TYPES_NULL_PTR)
00100c  e3520000          CMP      r2,#0
001010  1a000001          BNE      |L1.4124|
;;;1669      {
;;;1670         eResult = NANDFLASH_STATUS_PTR_ERR;
001014  e3a00004          MOV      r0,#4
001018  ea000001          B        |L1.4132|
                  |L1.4124|
;;;1671      }
;;;1672      else
;;;1673      {
;;;1674         pstNandCfg->eExtraBlockCfg = eExtraBlkCfg;
00101c  e5c21006          STRB     r1,[r2,#6]
;;;1675         eResult = NANDFLASH_STATUS_OK;
001020  e3a00000          MOV      r0,#0
                  |L1.4132|
;;;1676      }
;;;1677      return eResult;
;;;1678   }
001024  e12fff1e          BX       lr
;;;1679   
                          ENDP

                  eNandFlash_SetBusTiming PROC
;;;1681   /* TESTED */
;;;1682   NandFlashStatus_e eNandFlash_SetBusTiming (NandFlashCfg_st * pstNandCfg,
001028  e92d4030          PUSH     {r4,r5,lr}
;;;1683                                              uint32_t u32IdRdTime,
;;;1684                                              uint32_t u32StatusRdTime,
;;;1685                                              uint32_t u32WriteCycleTime,
;;;1686                                              uint32_t u32ReadCycleTime)
;;;1687   {
00102c  e1a04000          MOV      r4,r0
001030  e59d500c          LDR      r5,[sp,#0xc]
;;;1688      NandFlashStatus_e eResult;
;;;1689   
;;;1690      if (pstNandCfg == TYPES_NULL_PTR)
001034  e3540000          CMP      r4,#0
001038  1a000001          BNE      |L1.4164|
;;;1691      {
;;;1692         eResult = NANDFLASH_STATUS_PTR_ERR;
00103c  e3a00004          MOV      r0,#4
001040  ea000012          B        |L1.4240|
                  |L1.4164|
;;;1693      }
;;;1694      else
;;;1695      {
;;;1696         if ((u32IdRdTime > (NANDFLASH_ID_RD_MAX)) ||
001044  e3510007          CMP      r1,#7
001048  8a000009          BHI      |L1.4212|
;;;1697             (u32StatusRdTime > (NANDFLASH_STATUS_RD_MAX)) ||
00104c  e3520007          CMP      r2,#7
001050  8a000007          BHI      |L1.4212|
;;;1698             (u32WriteCycleTime < (NANDFLASH_WR_CYCLE_MIN)) ||
001054  e3530002          CMP      r3,#2
001058  3a000005          BCC      |L1.4212|
;;;1699             (u32WriteCycleTime > (NANDFLASH_WR_CYCLE_MAX)) ||
00105c  e353000f          CMP      r3,#0xf
001060  8a000003          BHI      |L1.4212|
;;;1700             (u32ReadCycleTime < (NANDFLASH_RD_CYCLE_MIN)) ||
001064  e3550002          CMP      r5,#2
001068  3a000001          BCC      |L1.4212|
;;;1701             (u32ReadCycleTime > (NANDFLASH_RD_CYCLE_MAX)))
00106c  e355000f          CMP      r5,#0xf
001070  9a000001          BLS      |L1.4220|
                  |L1.4212|
;;;1702         {
;;;1703            eResult = NANDFLASH_STATUS_CFG_ERR;
001074  e3a00005          MOV      r0,#5
001078  ea000004          B        |L1.4240|
                  |L1.4220|
;;;1704         }
;;;1705         else
;;;1706         {
;;;1707            pstNandCfg->u32IdRdTime = u32IdRdTime;
00107c  e5841018          STR      r1,[r4,#0x18]
;;;1708            pstNandCfg->u32StatusRdTime = u32StatusRdTime;
001080  e584201c          STR      r2,[r4,#0x1c]
;;;1709            pstNandCfg->u32WriteCycleTime = u32WriteCycleTime;
001084  e5843020          STR      r3,[r4,#0x20]
;;;1710            pstNandCfg->u32ReadCycleTime = u32ReadCycleTime;
001088  e5845024          STR      r5,[r4,#0x24]
;;;1711            eResult = NANDFLASH_STATUS_OK;
00108c  e3a00000          MOV      r0,#0
                  |L1.4240|
;;;1712         }
;;;1713      }
;;;1714      return eResult;
;;;1715   }
001090  e8bd8030          POP      {r4,r5,pc}
;;;1716   
                          ENDP

                  eNandFlash_SetCycleAssertDelays PROC
;;;1718   /* TESTED */
;;;1719   NandFlashStatus_e eNandFlash_SetCycleAssertDelays (NandFlashCfg_st * pstNandCfg,
001094  e92d4010          PUSH     {r4,lr}
;;;1720                                                      uint32_t u32BusyCycleToReN,
;;;1721                                                      uint32_t u32DeAssertDelayWeN,
;;;1722                                                      uint32_t u32AssertDelayReN)
;;;1723   {
001098  e1a04000          MOV      r4,r0
;;;1724      NandFlashStatus_e eResult;
;;;1725   
;;;1726      if (pstNandCfg == TYPES_NULL_PTR)
00109c  e3540000          CMP      r4,#0
0010a0  1a000001          BNE      |L1.4268|
;;;1727      {
;;;1728         eResult = NANDFLASH_STATUS_PTR_ERR;
0010a4  e3a00004          MOV      r0,#4
0010a8  ea00000f          B        |L1.4332|
                  |L1.4268|
;;;1729      }
;;;1730      else
;;;1731      {
;;;1732         if ((u32AssertDelayReN < (NANDFLASH_ASSERT_REN_MIN)) ||
0010ac  e3530000          CMP      r3,#0
0010b0  0a000007          BEQ      |L1.4308|
;;;1733             (u32AssertDelayReN > (NANDFLASH_ASSERT_REN_MAX)) ||
0010b4  e3530007          CMP      r3,#7
0010b8  8a000005          BHI      |L1.4308|
;;;1734             (u32DeAssertDelayWeN < (NANDFLASH_DEASSERT_WEN_MIN)) ||
0010bc  e3520000          CMP      r2,#0
0010c0  0a000003          BEQ      |L1.4308|
;;;1735             (u32DeAssertDelayWeN > (NANDFLASH_DEASSERT_WEN_MAX)) ||
0010c4  e3520007          CMP      r2,#7
0010c8  8a000001          BHI      |L1.4308|
;;;1736             (u32BusyCycleToReN > (NANDFLASH_BUSY_TO_REN_MAX)))
0010cc  e351000f          CMP      r1,#0xf
0010d0  9a000001          BLS      |L1.4316|
                  |L1.4308|
;;;1737         {
;;;1738            eResult = NANDFLASH_STATUS_CFG_ERR;
0010d4  e3a00005          MOV      r0,#5
0010d8  ea000003          B        |L1.4332|
                  |L1.4316|
;;;1739         }
;;;1740         else
;;;1741         {
;;;1742            pstNandCfg->u32AssertDelayReN = u32AssertDelayReN;
0010dc  e5843030          STR      r3,[r4,#0x30]
;;;1743            pstNandCfg->u32DeAssertDelayWeN = u32DeAssertDelayWeN;
0010e0  e584202c          STR      r2,[r4,#0x2c]
;;;1744            pstNandCfg->u32BusyCycleToReN = u32BusyCycleToReN;
0010e4  e5841028          STR      r1,[r4,#0x28]
;;;1745            eResult = NANDFLASH_STATUS_OK;
0010e8  e3a00000          MOV      r0,#0
                  |L1.4332|
;;;1746         }
;;;1747   
;;;1748      }
;;;1749      return eResult;
;;;1750   }
0010ec  e8bd8010          POP      {r4,pc}
;;;1751   
                          ENDP

                  eNandFlash_ReadSinglePage PROC
;;;1917   /* TESTED */
;;;1918   NandFlashStatus_e eNandFlash_ReadSinglePage (NandFlashCfg_st * pstNandCfg,    /* PRQA S 3673 */
0010f0  e92d4ffe          PUSH     {r1-r11,lr}
;;;1919                                                uint32_t u32BlockNumber,
;;;1920                                                uint32_t u32PageNumber,
;;;1921                                                uint32_t pu32DstBuf[],
;;;1922                                                uint32_t pu32ExtrBuf[])
;;;1923   {
0010f4  e1a04000          MOV      r4,r0
0010f8  e1a08001          MOV      r8,r1
0010fc  e1a09002          MOV      r9,r2
001100  e1a06003          MOV      r6,r3
001104  e59d7030          LDR      r7,[sp,#0x30]
;;;1924   /***
;;;1925   * MESSAGE: Msg(3:3197) The initialiser for 'eResult' is always modified before
;;;1926   *          being used.
;;;1927   *
;;;1928   * DESC   : To detect that eResult is updated every time within this complex
;;;1929   *          function the initial value NANDFLASH_STATUS_UNKNOWN is used.
;;;1930   ****/
;;;1931      NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;    /* PRQA S 3197 */
001108  e3a05001          MOV      r5,#1
;;;1932   
;;;1933   
;;;1934      if ((pstNandCfg == TYPES_NULL_PTR))
00110c  e3540000          CMP      r4,#0
001110  1a000001          BNE      |L1.4380|
;;;1935      {
;;;1936         eResult = NANDFLASH_STATUS_PTR_ERR;
001114  e3a05004          MOV      r5,#4
001118  ea000056          B        |L1.4728|
                  |L1.4380|
;;;1937      }
;;;1938      else
;;;1939      {
;;;1940         if (u32PageNumber < (pstNandCfg->u32BlkSize))
00111c  e594000c          LDR      r0,[r4,#0xc]
001120  e1500009          CMP      r0,r9
001124  9a000052          BLS      |L1.4724|
;;;1941         {
;;;1942            uint32_t u32BufferLen = ((pstNandCfg->u32PageSize) >> 2);
001128  e5940010          LDR      r0,[r4,#0x10]
00112c  e1a0a120          LSR      r10,r0,#2
;;;1943   
;;;1944            /* ECC handled differently for devices with internal ECC */
;;;1945            if (pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_VENDOR1_ECC)
001130  e5d40004          LDRB     r0,[r4,#4]
001134  e3500001          CMP      r0,#1
001138  1a00001f          BNE      |L1.4540|
;;;1946            {
;;;1947               vNF_CmdPhaseAxiCplx (pstNandCfg, 0x0U, u32PageNumber,
00113c  e3a00030          MOV      r0,#0x30
001140  e3a01001          MOV      r1,#1
001144  e3a02000          MOV      r2,#0
001148  e1a03008          MOV      r3,r8
00114c  e58d2000          STR      r2,[sp,#0]
001150  e1a02009          MOV      r2,r9
001154  e58d1004          STR      r1,[sp,#4]
001158  e3a01000          MOV      r1,#0
00115c  e58d0008          STR      r0,[sp,#8]
001160  e1a00004          MOV      r0,r4
001164  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;1948                                    u32BlockNumber, NANDFLASH_CMD_PAGE_RD_START,
;;;1949                                    NF_PAR_END_VALID, NANDFLASH_CMD_PAGE_RD_END);
;;;1950               /* Wait until ready: Take into account: tWB tR tRR tR_ECC */
;;;1951               eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
001168  e1a00004          MOV      r0,r4
00116c  ebfffffe          BL       eNandFlash_WaitDeviceReady
001170  e1a05000          MOV      r5,r0
;;;1952               /* Return to Read Mode after the Status check (Internal ECC only) */
;;;1953               if(pstNandCfg->eDeviceType != NANDFLASH_DEVICE_ONFI_HOST_ECC)
001174  e5d40004          LDRB     r0,[r4,#4]
001178  e3500000          CMP      r0,#0
00117c  0a000002          BEQ      |L1.4492|
;;;1954               {
;;;1955                 vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_MODE);
001180  e3a01000          MOV      r1,#0
001184  e1a00004          MOV      r0,r4
001188  ebfffffe          BL       vNF_CmdPhaseAxi
                  |L1.4492|
;;;1956               }
;;;1957   
;;;1958               if (eResult == NANDFLASH_STATUS_OK)
00118c  e3550000          CMP      r5,#0
001190  1a000036          BNE      |L1.4720|
;;;1959               {
;;;1960                  vNF_DataPhaseAxiRdMulti (pstNandCfg, u32BufferLen, pu32DstBuf,
001194  e3a03000          MOV      r3,#0
001198  e1a02006          MOV      r2,r6
00119c  e1a0100a          MOV      r1,r10
0011a0  e1a00004          MOV      r0,r4
0011a4  e58d7000          STR      r7,[sp,#0]
0011a8  ebfffffe          BL       vNF_DataPhaseAxiRdMulti
;;;1961                                           NF_PAR_IGNORE, pu32ExtrBuf);
;;;1962   
;;;1963                  /* Check devices status: SR bit0 = 0: READ successful SR bit 1 =
;;;1964                     0 READ error */
;;;1965                  eResult = eNF_GetDeviceStatus (pstNandCfg);
0011ac  e1a00004          MOV      r0,r4
0011b0  ebfffffe          BL       eNF_GetDeviceStatus
0011b4  e1a05000          MOV      r5,r0
0011b8  ea00002c          B        |L1.4720|
                  |L1.4540|
;;;1966                  /* ****** FINAL eResult should be available here ****** */
;;;1967               }
;;;1968            }
;;;1969            else                               /* 1-bit ECC: ONFI devices */
;;;1970            {
;;;1971               /* Prepare ECC HW before reading data */
;;;1972               eResult = eNF_EccConfigure (pstNandCfg);
0011bc  e1a00004          MOV      r0,r4
0011c0  ebfffffe          BL       eNF_EccConfigure
0011c4  e1a05000          MOV      r5,r0
;;;1973   
;;;1974               if (eResult == NANDFLASH_STATUS_OK)
0011c8  e3550000          CMP      r5,#0
0011cc  1a000026          BNE      |L1.4716|
;;;1975               {
;;;1976                  vNF_CmdPhaseAxiCplx (pstNandCfg, 0U, u32PageNumber,
0011d0  e3a00030          MOV      r0,#0x30
0011d4  e3a01001          MOV      r1,#1
0011d8  e3a02000          MOV      r2,#0
0011dc  e1a03008          MOV      r3,r8
0011e0  e58d2000          STR      r2,[sp,#0]
0011e4  e1a02009          MOV      r2,r9
0011e8  e58d1004          STR      r1,[sp,#4]
0011ec  e3a01000          MOV      r1,#0
0011f0  e58d0008          STR      r0,[sp,#8]
0011f4  e1a00004          MOV      r0,r4
0011f8  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;1977                                       u32BlockNumber, NANDFLASH_CMD_PAGE_RD_START,
;;;1978                                       NF_PAR_END_VALID,
;;;1979                                       NANDFLASH_CMD_PAGE_RD_END);
;;;1980                  eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
0011fc  e1a00004          MOV      r0,r4
001200  ebfffffe          BL       eNandFlash_WaitDeviceReady
001204  e1a05000          MOV      r5,r0
;;;1981               /* Return to Read Mode after the Status check (Internal ECC only) */
;;;1982                  if(pstNandCfg->eDeviceType != NANDFLASH_DEVICE_ONFI_HOST_ECC)
001208  e5d40004          LDRB     r0,[r4,#4]
00120c  e3500000          CMP      r0,#0
001210  0a000002          BEQ      |L1.4640|
;;;1983                  {
;;;1984                    vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_MODE);
001214  e3a01000          MOV      r1,#0
001218  e1a00004          MOV      r0,r4
00121c  ebfffffe          BL       vNF_CmdPhaseAxi
                  |L1.4640|
;;;1985                  }
;;;1986   
;;;1987                  if (eResult == NANDFLASH_STATUS_OK)
001220  e3550000          CMP      r5,#0
001224  1a000011          BNE      |L1.4720|
;;;1988                  {
;;;1989                     vNF_DataPhaseAxiRdMulti (pstNandCfg, u32BufferLen, pu32DstBuf,
001228  e3a03001          MOV      r3,#1
00122c  e1a02006          MOV      r2,r6
001230  e1a0100a          MOV      r1,r10
001234  e1a00004          MOV      r0,r4
001238  e58d7000          STR      r7,[sp,#0]
00123c  ebfffffe          BL       vNF_DataPhaseAxiRdMulti
;;;1990                                              NF_PAR_ECC_LAST, pu32ExtrBuf);
;;;1991                     /* Wait until ECC is IDLE */
;;;1992                     eResult = eNF_EccWaitIdle (pstNandCfg);
001240  e1a00004          MOV      r0,r4
001244  ebfffffe          BL       eNF_EccWaitIdle
001248  e1a05000          MOV      r5,r0
;;;1993                     if (eResult == NANDFLASH_STATUS_OK)
00124c  e3550000          CMP      r5,#0
001250  1a000006          BNE      |L1.4720|
;;;1994                     {
;;;1995                        /*
;;;1996                         *** Now apply ECC Correction, based on ECC values ***
;;;1997                         */
;;;1998   /***
;;;1999   * MESSAGE: MISRA-C:2004 Rule 11.4; Casting to different object pointer type.
;;;2000   *
;;;2001   * DESC   : Due to a different nature of the reading (32-bit accesses) and error
;;;2002   *          correction (based on byte-addressing) it is required to cast
;;;2003   *          pointers. It should be safe since 32-bit buffer is used as being an
;;;2004   *          8-bit buffer.
;;;2005   *
;;;2006   ****/
;;;2007                        eResult =
001254  e1a02007          MOV      r2,r7
001258  e1a01006          MOV      r1,r6
00125c  e1a00004          MOV      r0,r4
001260  ebfffffe          BL       eNF_EccCorrectLarge
001264  e1a05000          MOV      r5,r0
001268  ea000000          B        |L1.4720|
                  |L1.4716|
;;;2008                           eNF_EccCorrectLarge (pstNandCfg, (uint8_t *)pu32DstBuf,     /* PRQA S 0310 */
;;;2009                                                (uint8_t *)pu32ExtrBuf);               /* PRQA S 0310 */
;;;2010                     }
;;;2011                  }
;;;2012                  /* ****** FINAL eResult should be available here ****** */
;;;2013               }
;;;2014               else
;;;2015               {
;;;2016                  eResult = eResult;           /* to be optimized / removed ... */
00126c  e320f000          NOP      
                  |L1.4720|
;;;2017               }
;;;2018            }
;;;2019         }
001270  ea000000          B        |L1.4728|
                  |L1.4724|
;;;2020         else
;;;2021         {
;;;2022            eResult = NANDFLASH_STATUS_USAGE_ERR;
001274  e3a05008          MOV      r5,#8
                  |L1.4728|
;;;2023         }
;;;2024      }
;;;2025      return eResult;
001278  e1a00005          MOV      r0,r5
;;;2026   }
00127c  e8bd8ffe          POP      {r1-r11,pc}
;;;2027   
                          ENDP

                  eNandFlash_ReadSpareArea PROC
;;;2030    u32SpareOffset: offset within spare Area is always counted in 32-bit words */
;;;2031   NandFlashStatus_e eNandFlash_ReadSpareArea (NandFlashCfg_st * pstNandCfg,    /* PRQA S 3673 */
001280  e92d4ffe          PUSH     {r1-r11,lr}
;;;2032                                               uint32_t u32BlockNumber,
;;;2033                                               uint32_t u32PageNumber,
;;;2034                                               uint32_t u32SpareOffset,
;;;2035                                               uint32_t u32BufferLen,
;;;2036                                               uint32_t pu32DstBuf[])
;;;2037   {
001284  e1a04000          MOV      r4,r0
001288  e1a09001          MOV      r9,r1
00128c  e1a0a002          MOV      r10,r2
001290  e1a05003          MOV      r5,r3
;;;2038   /***
;;;2039   * MESSAGE: Msg(3:3197) The initialiser for 'eResult' is always modified before
;;;2040   *          being used.
;;;2041   *
;;;2042   * DESC   : To detect that eResult is updated every time within this complex
;;;2043   *          function the initial value NANDFLASH_STATUS_UNKNOWN is used.
;;;2044   ****/
;;;2045      NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;    /* PRQA S 3197 */
001294  e3a06001          MOV      r6,#1
;;;2046   
;;;2047      uint32_t u32EccSetOld;
;;;2048   
;;;2049      uint32_t u32EccSetNew;
;;;2050   
;;;2051      uint32_t u32SpareAdr;
;;;2052   
;;;2053   
;;;2054      if ((pstNandCfg == TYPES_NULL_PTR))
001298  e3540000          CMP      r4,#0
00129c  1a000001          BNE      |L1.4776|
;;;2055      {
;;;2056         eResult = NANDFLASH_STATUS_PTR_ERR;
0012a0  e3a06004          MOV      r6,#4
0012a4  ea00003a          B        |L1.5012|
                  |L1.4776|
;;;2057      }
;;;2058      else
;;;2059      {
;;;2060         /*
;;;2061            Spare area read requires to temporary disable Host's ECC engine. */
;;;2062         u32EccSetOld = MEMCTRL_ECC_MEMCFG;    /* remember orig. settings */
0012a8  e51f02c8          LDR      r0,|L1.4072|
0012ac  e5907000          LDR      r7,[r0,#0]
;;;2063         u32EccSetNew = u32EccSetOld & ~(MEMCTRL_ECC_MODE_MSK); /* Disable ECC */
0012b0  e3c7b00c          BIC      r11,r7,#0xc
;;;2064         MEMCTRL_ECC_MEMCFG = u32EccSetNew;    /* Write it back to MemCtrl */
0012b4  e580b000          STR      r11,[r0,#0]
;;;2065   
;;;2066         if ((u32SpareOffset + u32BufferLen) <= ((pstNandCfg->u16SpareSize) >> 2))
0012b8  e59d0030          LDR      r0,[sp,#0x30]
0012bc  e0800005          ADD      r0,r0,r5
0012c0  e1d411b4          LDRH     r1,[r4,#0x14]
0012c4  e1500141          CMP      r0,r1,ASR #2
0012c8  8a00002e          BHI      |L1.5000|
;;;2067         {
;;;2068            if (u32PageNumber < (pstNandCfg->u32BlkSize))
0012cc  e594000c          LDR      r0,[r4,#0xc]
0012d0  e150000a          CMP      r0,r10
0012d4  9a000029          BLS      |L1.4992|
;;;2069            {
;;;2070               /*
;;;2071                  Spare Area: address just after the Page. The address differs for
;;;2072                  8-bit and 16-bit devices. */
;;;2073               if (pstNandCfg->eBusWidth == NANDFLASH_BUS_WIDTH_8)
0012d8  e5d40005          LDRB     r0,[r4,#5]
0012dc  e3500000          CMP      r0,#0
0012e0  1a000002          BNE      |L1.4848|
;;;2074               {
;;;2075                  /* 2kB Page + 64 bytes Spare */
;;;2076                  u32SpareAdr = (pstNandCfg->u32PageSize + u32SpareOffset);
0012e4  e5940010          LDR      r0,[r4,#0x10]
0012e8  e0808005          ADD      r8,r0,r5
0012ec  ea000001          B        |L1.4856|
                  |L1.4848|
;;;2077               }
;;;2078               else
;;;2079               {
;;;2080                  /* 1k 16-bit Words Page + 32x 16-bit Words Spare */
;;;2081                  u32SpareAdr =
0012f0  e5940010          LDR      r0,[r4,#0x10]
0012f4  e08580a0          ADD      r8,r5,r0,LSR #1
                  |L1.4856|
;;;2082                     (((pstNandCfg->u32PageSize) >> 1) + u32SpareOffset);
;;;2083               }
;;;2084   
;;;2085               vNF_CmdPhaseAxiCplx (pstNandCfg, u32SpareAdr, u32PageNumber,
0012f8  e3a00030          MOV      r0,#0x30
0012fc  e3a01001          MOV      r1,#1
001300  e3a02000          MOV      r2,#0
001304  e1a03009          MOV      r3,r9
001308  e58d2000          STR      r2,[sp,#0]
00130c  e1a0200a          MOV      r2,r10
001310  e58d1004          STR      r1,[sp,#4]
001314  e1a01008          MOV      r1,r8
001318  e58d0008          STR      r0,[sp,#8]
00131c  e1a00004          MOV      r0,r4
001320  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;2086                                    u32BlockNumber, NANDFLASH_CMD_PAGE_RD_START,
;;;2087                                    NF_PAR_END_VALID, NANDFLASH_CMD_PAGE_RD_END);
;;;2088   
;;;2089               eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
001324  e1a00004          MOV      r0,r4
001328  ebfffffe          BL       eNandFlash_WaitDeviceReady
00132c  e1a06000          MOV      r6,r0
;;;2090               /* Return to Read Mode after the Status check (Internal ECC only) */
;;;2091               if(pstNandCfg->eDeviceType != NANDFLASH_DEVICE_ONFI_HOST_ECC)
001330  e5d40004          LDRB     r0,[r4,#4]
001334  e3500000          CMP      r0,#0
001338  0a000002          BEQ      |L1.4936|
;;;2092               {
;;;2093                 vNF_CmdPhaseAxi (pstNandCfg, NANDFLASH_CMD_READ_MODE);
00133c  e3a01000          MOV      r1,#0
001340  e1a00004          MOV      r0,r4
001344  ebfffffe          BL       vNF_CmdPhaseAxi
                  |L1.4936|
;;;2094               }
;;;2095   
;;;2096               if (eResult == NANDFLASH_STATUS_OK)
001348  e3560000          CMP      r6,#0
00134c  1a00000a          BNE      |L1.4988|
;;;2097               {
;;;2098                  /*
;;;2099                     Read of the spare area (typically ECC related) does not
;;;2100                     invlove the ECC calculation itself - that's why use:
;;;2101                     NF_PAR_IGNORE. */
;;;2102                  vNF_DataPhaseAxiRdMulti (pstNandCfg, u32BufferLen, pu32DstBuf,
001350  e3a00000          MOV      r0,#0
001354  e58d0000          STR      r0,[sp,#0]
001358  e1a03000          MOV      r3,r0
00135c  e1a00004          MOV      r0,r4
001360  e59d1030          LDR      r1,[sp,#0x30]
001364  e59d2034          LDR      r2,[sp,#0x34]
001368  ebfffffe          BL       vNF_DataPhaseAxiRdMulti
;;;2103                                           NF_PAR_IGNORE, (uint32_t *)0x00U);
;;;2104                  eResult = eNF_GetDeviceStatus (pstNandCfg);
00136c  e1a00004          MOV      r0,r4
001370  ebfffffe          BL       eNF_GetDeviceStatus
001374  e1a06000          MOV      r6,r0
001378  ea000003          B        |L1.5004|
                  |L1.4988|
;;;2105                  /* ****** FINAL eResult should be available here ****** */
;;;2106               }
;;;2107               else
;;;2108               {
;;;2109                  eResult = eResult;           /* to be optimized / removed ... */
00137c  ea000002          B        |L1.5004|
                  |L1.4992|
;;;2110               }
;;;2111            }
;;;2112            else
;;;2113            {
;;;2114               eResult = NANDFLASH_STATUS_USAGE_ERR;
001380  e3a06008          MOV      r6,#8
001384  ea000000          B        |L1.5004|
                  |L1.5000|
;;;2115            }
;;;2116         }
;;;2117         else
;;;2118         {
;;;2119            eResult = NANDFLASH_STATUS_SIZE_ERR; /* too many data to be read! */
001388  e3a06006          MOV      r6,#6
                  |L1.5004|
;;;2120         }
;;;2121         MEMCTRL_ECC_MEMCFG = u32EccSetOld;    /* Write old settings to MemCtrl */
00138c  e51f03ac          LDR      r0,|L1.4072|
001390  e5807000          STR      r7,[r0,#0]
                  |L1.5012|
;;;2122      }
;;;2123      return eResult;
001394  e1a00006          MOV      r0,r6
;;;2124   }
001398  e8bd8ffe          POP      {r1-r11,pc}
;;;2125   
                          ENDP

                  eNandFlash_ReadPages PROC
;;;2136   ****/
;;;2137   NandFlashStatus_e eNandFlash_ReadPages (NandFlashCfg_st * pstNandCfg,
00139c  e92d4ff8          PUSH     {r3-r11,lr}
;;;2138                                           uint32_t u32BlockNumber,
;;;2139                                           uint32_t u32StartPage,
;;;2140                                           uint32_t u32NoOfPages,
;;;2141                                           uint32_t pu32DstBuf[],    /* PRQA S 3673 */
;;;2142                                           uint32_t pu32ExtrBuf[])
;;;2143   {
0013a0  e1a05000          MOV      r5,r0
0013a4  e1a09001          MOV      r9,r1
0013a8  e1a06002          MOV      r6,r2
0013ac  e1a07003          MOV      r7,r3
0013b0  e59db028          LDR      r11,[sp,#0x28]
;;;2144   /***
;;;2145   * MESSAGE: Msg(3:3197) The initialiser for 'eResult' is always modified before
;;;2146   *          being used.
;;;2147   *
;;;2148   * DESC   : To detect that eResult is updated every time within this complex
;;;2149   *          function the initial value NANDFLASH_STATUS_UNKNOWN is used.
;;;2150   ****/
;;;2151      NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;     /* PRQA S 3197 */
0013b4  e3a0a001          MOV      r10,#1
;;;2152   
;;;2153      uint32_t u32Idx;
;;;2154   
;;;2155      uint32_t u32DstAddr ;
;;;2156   
;;;2157   
;;;2158      if ((pstNandCfg == TYPES_NULL_PTR))
0013b8  e3550000          CMP      r5,#0
0013bc  1a000001          BNE      |L1.5064|
;;;2159      {
;;;2160         eResult = NANDFLASH_STATUS_PTR_ERR;
0013c0  e3a0a004          MOV      r10,#4
0013c4  ea00001e          B        |L1.5188|
                  |L1.5064|
;;;2161      }
;;;2162      else
;;;2163      {
;;;2164         /*
;;;2165            Check, if all Pages belong to the current block. */
;;;2166         if (u32NoOfPages > 0U)                /* is anything to read */
0013c8  e3570000          CMP      r7,#0
0013cc  0a00001b          BEQ      |L1.5184|
;;;2167         {
;;;2168            u32Idx = u32StartPage;
0013d0  e1a04006          MOV      r4,r6
;;;2169   /***
;;;2170   * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;2171   *          integral type.
;;;2172   *
;;;2173   *          MISRA-C:2004 Rule 1.2; [U] Integral type is not large enough to hold
;;;2174   *          a pointer value.
;;;2175   *
;;;2176   * DESC   : These messages are undestood, but the pointer manipulation was
;;;2177   *          required to maintian the position within the buffer. As unsigned int
;;;2178   *          type is 32-bit on ARM, which is same as pointer - there should be no
;;;2179   *          danger with such cast.
;;;2180   ****/
;;;2181            /* Source location to read from */
;;;2182            u32DstAddr = (uint32_t)pu32DstBuf;     /* PRQA S 0306 */
0013d4  e1a0800b          MOV      r8,r11
;;;2183            do
0013d8  e320f000          NOP      
                  |L1.5084|
;;;2184            {
;;;2185               if (u32Idx >= pstNandCfg->u32BlkSize) /* check range/condition! */
0013dc  e595000c          LDR      r0,[r5,#0xc]
0013e0  e1500004          CMP      r0,r4
0013e4  8a000004          BHI      |L1.5116|
;;;2186               {
;;;2187                  /* This function might cross the total size / number of blocks
;;;2188                     of the NAND device. DO NOT reset StartPage since it is used
;;;2189                     in the loop exit condition. */
;;;2190                  u32BlockNumber++;
0013e8  e2899001          ADD      r9,r9,#1
;;;2191                  u32NoOfPages = (u32NoOfPages - (u32Idx - u32StartPage));
0013ec  e0440006          SUB      r0,r4,r6
0013f0  e0477000          SUB      r7,r7,r0
;;;2192                  /* Read should continue at the beginning of the next block */
;;;2193                  u32Idx = 0U;
0013f4  e3a04000          MOV      r4,#0
;;;2194                  u32StartPage = 0U;
0013f8  e3a06000          MOV      r6,#0
                  |L1.5116|
;;;2195               }
;;;2196   /***
;;;2197   * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;2198   *          integral type.
;;;2199   *
;;;2200   * DESC   : These message is undestood, but the pointer manipulation was
;;;2201   *          required to maintian the position within the buffer. Here the reverse
;;;2202   *          cast is required (see upper listed MISRA warnings).
;;;2203   ****/
;;;2204               eResult =
0013fc  e59d002c          LDR      r0,[sp,#0x2c]
001400  e1a03008          MOV      r3,r8
001404  e1a02004          MOV      r2,r4
001408  e1a01009          MOV      r1,r9
00140c  e58d0000          STR      r0,[sp,#0]
001410  e1a00005          MOV      r0,r5
001414  ebfffffe          BL       eNandFlash_ReadSinglePage
001418  e1a0a000          MOV      r10,r0
;;;2205                  eNandFlash_ReadSinglePage (pstNandCfg, u32BlockNumber, u32Idx,      /* PRQA S 0306 */
;;;2206                                             (uint32_t *)u32DstAddr, pu32ExtrBuf);    /* PRQA S 0306 */
;;;2207               u32Idx++;
00141c  e2844001          ADD      r4,r4,#1
;;;2208               u32DstAddr = (u32DstAddr + pstNandCfg->u32PageSize);
001420  e5950010          LDR      r0,[r5,#0x10]
001424  e0888000          ADD      r8,r8,r0
;;;2209            }
;;;2210            while (((u32Idx < (u32NoOfPages + u32StartPage)) &&
001428  e0870006          ADD      r0,r7,r6
00142c  e1500004          CMP      r0,r4
001430  9a000003          BLS      |L1.5188|
;;;2211                    (eResult == NANDFLASH_STATUS_OK)));
001434  e35a0000          CMP      r10,#0
001438  0affffe7          BEQ      |L1.5084|
00143c  ea000000          B        |L1.5188|
                  |L1.5184|
;;;2212   
;;;2213            /* ****** FINAL eResult should be available here ****** */
;;;2214         }
;;;2215         else
;;;2216         {
;;;2217            eResult = NANDFLASH_STATUS_PARAM_ERR; /* */
001440  e3a0a009          MOV      r10,#9
                  |L1.5188|
;;;2218         }
;;;2219      }
;;;2220      return eResult;
001444  e1a0000a          MOV      r0,r10
;;;2221   }
001448  e8bd8ff8          POP      {r3-r11,pc}
;;;2222   
                          ENDP

                  eNandFlash_ReadNand PROC
;;;2224   /* TESTED: */
;;;2225   NandFlashStatus_e eNandFlash_ReadNand (NandFlashCfg_st * pstNandCfg,
00144c  e92d5fff          PUSH     {r0-r12,lr}
;;;2226                                          uint32_t u32StartAddr,
;;;2227                                          uint32_t pu32Data[],
;;;2228                                          uint32_t u32BufferLen)
;;;2229   {
001450  e1a04000          MOV      r4,r0
001454  e1a06001          MOV      r6,r1
001458  e1a07002          MOV      r7,r2
00145c  e1a05003          MOV      r5,r3
;;;2230      NandFlashStatus_e eNandStatus;
;;;2231   
;;;2232      uint32_t u32BlockBytes;
;;;2233   
;;;2234      uint32_t u32BlockNumber;
;;;2235   
;;;2236      uint32_t u32ByteBlkOffset;
;;;2237   
;;;2238      uint32_t u32StartPage;
;;;2239   
;;;2240      uint32_t u32NoOfPages;
;;;2241   
;;;2242   
;;;2243      /* Calculate Block and Page number */
;;;2244      u32BlockBytes = (pstNandCfg->u32BlkSize) * (pstNandCfg->u32PageSize);
001460  e1c400dc          LDRD     r0,r1,[r4,#0xc]
001464  e00a0190          MUL      r10,r0,r1
;;;2245      /* Block number where the addr is pointing to */
;;;2246      u32BlockNumber = (u32StartAddr / u32BlockBytes);
001468  e1a0100a          MOV      r1,r10
00146c  e1a00006          MOV      r0,r6
001470  ebfffffe          BL       __aeabi_uidiv
001474  e1a0b000          MOV      r11,r0
;;;2247      /* Address offset from the beginning of the block */
;;;2248      u32ByteBlkOffset = (u32StartAddr % u32BlockBytes);
001478  e1a0100a          MOV      r1,r10
00147c  e1a00006          MOV      r0,r6
001480  ebfffffe          BL       __aeabi_uidivmod
001484  e58d100c          STR      r1,[sp,#0xc]
;;;2249      /* Page number, in which the addr is pointing to */
;;;2250      u32StartPage = (u32ByteBlkOffset / (pstNandCfg->u32PageSize));
001488  e5941010          LDR      r1,[r4,#0x10]
00148c  e59d000c          LDR      r0,[sp,#0xc]
001490  ebfffffe          BL       __aeabi_uidiv
001494  e58d0008          STR      r0,[sp,#8]
;;;2251      /* Convert no of 32-bit Words to no of Bytes */
;;;2252      u32BufferLen = (u32BufferLen << 2);
001498  e1a05105          LSL      r5,r5,#2
;;;2253   
;;;2254      /* Calculate how many pages should be read */
;;;2255      u32NoOfPages = ((u32BufferLen) / pstNandCfg->u32PageSize);
00149c  e1a00005          MOV      r0,r5
0014a0  e5941010          LDR      r1,[r4,#0x10]
0014a4  ebfffffe          BL       __aeabi_uidiv
0014a8  e1a09000          MOV      r9,r0
;;;2256      /*
;;;2257         Check, if one additional page needs to be read */
;;;2258      if (((u32BufferLen) % (pstNandCfg->u32PageSize)) != 0)
0014ac  e1a00005          MOV      r0,r5
0014b0  e5941010          LDR      r1,[r4,#0x10]
0014b4  ebfffffe          BL       __aeabi_uidivmod
0014b8  e3510000          CMP      r1,#0
0014bc  0a000000          BEQ      |L1.5316|
;;;2259      {
;;;2260         u32NoOfPages++;                       /* Another page must be read */
0014c0  e2899001          ADD      r9,r9,#1
                  |L1.5316|
;;;2261      }
;;;2262      /* Perform NAND data-read */
;;;2263      eNandStatus =
0014c4  e59f0028          LDR      r0,|L1.5364|
0014c8  e1a03009          MOV      r3,r9
0014cc  e58d0004          STR      r0,[sp,#4]
0014d0  e58d7000          STR      r7,[sp,#0]
0014d4  e1a0100b          MOV      r1,r11
0014d8  e1a00004          MOV      r0,r4
0014dc  e59d2008          LDR      r2,[sp,#8]
0014e0  ebfffffe          BL       eNandFlash_ReadPages
0014e4  e1a08000          MOV      r8,r0
;;;2264         eNandFlash_ReadPages (pstNandCfg, u32BlockNumber, u32StartPage,
;;;2265                               u32NoOfPages, pu32Data, pu32GlExtraBlockBuf);
;;;2266      return eNandStatus;
0014e8  e1a00008          MOV      r0,r8
0014ec  e28dd010          ADD      sp,sp,#0x10
;;;2267   }
0014f0  e8bd9ff0          POP      {r4-r12,pc}
;;;2268   
                          ENDP

                  |L1.5364|
                          DCD      pu32GlExtraBlockBuf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pu32GlExtraBlockBuf
                          %        32
