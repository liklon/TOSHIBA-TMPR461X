; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\qspic.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\qspic.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\qspic.crf ..\..\..\..\lldd\src\qspic.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vQSPIC_GetVersion PROC
;;;90     
;;;91     void vQSPIC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
000000  e92d4070          PUSH     {r4-r6,lr}
;;;92                            uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
;;;93                            uint8_t** pau8IORevision, uint8_t** pau8IOTag)
;;;94     {
000004  e1cd41d0          LDRD     r4,r5,[sp,#0x10]
;;;95        *pau8ModuleRevision = &au8LLDD_QSPIC_C_REVISION[0];
000008  e59f6ddc          LDR      r6,|L1.3564|
00000c  e5806000          STR      r6,[r0,#0]
;;;96        *pau8ModuleTag      = &au8LLDD_QSPIC_C_TAG[0];
000010  e59f6dd8          LDR      r6,|L1.3568|
000014  e5816000          STR      r6,[r1,#0]
;;;97        *pau8HeaderRevision = &au8LLDD_QSPIC_H_REVISION[0];
000018  e59f6dd4          LDR      r6,|L1.3572|
00001c  e5826000          STR      r6,[r2,#0]
;;;98        *pau8HeaderTag      = &au8LLDD_QSPIC_H_TAG[0];
000020  e59f6dd0          LDR      r6,|L1.3576|
000024  e5836000          STR      r6,[r3,#0]
;;;99        *pau8IORevision     = &au8LLDD_QSPIC_IO_H_REVISION[0];
000028  e59f6dcc          LDR      r6,|L1.3580|
00002c  e5846000          STR      r6,[r4,#0]
;;;100       *pau8IOTag          = &au8LLDD_QSPIC_IO_H_TAG[0];
000030  e59f6dc8          LDR      r6,|L1.3584|
000034  e5856000          STR      r6,[r5,#0]
;;;101    }
000038  e8bd8070          POP      {r4-r6,pc}
;;;102    
                          ENDP

                  i32QSPIC_ConfigureDirectControl PROC
;;;105    
;;;106    int32_t i32QSPIC_ConfigureDirectControl(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_directconfig_st *pstDirConf)
00003c  e92d4030          PUSH     {r4,r5,lr}
;;;107    {
000040  e1a03000          MOV      r3,r0
;;;108        int32_t i32Res = C_SUCCESS;
000044  e3a00000          MOV      r0,#0
;;;109    
;;;110        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000048  e3530000          CMP      r3,#0
00004c  0a000004          BEQ      |L1.100|
000050  e59f4dac          LDR      r4,|L1.3588|
000054  e1530004          CMP      r3,r4
000058  0a000001          BEQ      |L1.100|
00005c  e3530a01          CMP      r3,#0x1000
000060  1a0000c6          BNE      |L1.896|
                  |L1.100|
;;;111        {
;;;112            switch (eDevice)
000064  e3510000          CMP      r1,#0
000068  0a000002          BEQ      |L1.120|
00006c  e3510001          CMP      r1,#1
000070  1a0000be          BNE      |L1.880|
000074  ea00005b          B        |L1.488|
                  |L1.120|
;;;113            {
;;;114                case QSPIC_DEV_0:
000078  e320f000          NOP      
;;;115                    {
;;;116                        vSetQSPIC_FlshMemMap0_FBA(eController,     pstDirConf->u16FlashBaseAddress);
00007c  e1d250b0          LDRH     r5,[r2,#0]
000080  e59f4d80          LDR      r4,|L1.3592|
000084  e7934004          LDR      r4,[r3,r4]
000088  e7df4815          BFI      r4,r5,#16,#16
00008c  e59f5d74          LDR      r5,|L1.3592|
000090  e7834005          STR      r4,[r3,r5]
;;;117                        vSetQSPIC_FlshMemMap0_FDEN(eController,    pstDirConf->eFlashDensity);
000094  e5d25002          LDRB     r5,[r2,#2]
000098  e59f4d68          LDR      r4,|L1.3592|
00009c  e7934004          LDR      r4,[r3,r4]
0000a0  e7c54115          BFI      r4,r5,#2,#4
0000a4  e59f5d5c          LDR      r5,|L1.3592|
0000a8  e7834005          STR      r4,[r3,r5]
;;;118                        vSetQSPIC_FlshMemMap0_RE(eController,      pstDirConf->eEnableMemMapRd);
0000ac  e5d25003          LDRB     r5,[r2,#3]
0000b0  e59f4d50          LDR      r4,|L1.3592|
0000b4  e7934004          LDR      r4,[r3,r4]
0000b8  e7c04015          BFI      r4,r5,#0,#1
0000bc  e59f5d44          LDR      r5,|L1.3592|
0000c0  e7834005          STR      r4,[r3,r5]
;;;119                        vSetQSPIC_DirAccCtrl0_PollWIP(eController, pstDirConf->eWIPEnable);
0000c4  e5d25010          LDRB     r5,[r2,#0x10]
0000c8  e59f4d38          LDR      r4,|L1.3592|
0000cc  e0844003          ADD      r4,r4,r3
0000d0  e5944008          LDR      r4,[r4,#8]
0000d4  e7c64315          BFI      r4,r5,#6,#1
0000d8  e59f5d28          LDR      r5,|L1.3592|
0000dc  e0855003          ADD      r5,r5,r3
0000e0  e5854008          STR      r4,[r5,#8]
;;;120                        vSetQSPIC_DirAccCtrl0_SCSD(eController,    pstDirConf->u8CSTime);
0000e4  e5d25011          LDRB     r5,[r2,#0x11]
0000e8  e59f4d18          LDR      r4,|L1.3592|
0000ec  e0844003          ADD      r4,r4,r3
0000f0  e5944008          LDR      r4,[r4,#8]
0000f4  e7cf4415          BFI      r4,r5,#8,#8
0000f8  e59f5d08          LDR      r5,|L1.3592|
0000fc  e0855003          ADD      r5,r5,r3
000100  e5854008          STR      r4,[r5,#8]
;;;121                        vSetQSPIC_DirAccCtrl0_SDCE(eController,    pstDirConf->eEdge);
000104  e5d25012          LDRB     r5,[r2,#0x12]
000108  e59f4cf8          LDR      r4,|L1.3592|
00010c  e0844003          ADD      r4,r4,r3
000110  e5944008          LDR      r4,[r4,#8]
000114  e7c54215          BFI      r4,r5,#4,#2
000118  e59f5ce8          LDR      r5,|L1.3592|
00011c  e0855003          ADD      r5,r5,r3
000120  e5854008          STR      r4,[r5,#8]
;;;122    
;;;123                        /* Direct read Control Register */
;;;124                        vSetQSPIC_DirRdCtrl0_SpiRdCmdOp    (eController, pstDirConf->stRdCtrl.eCmd);
000124  e5d25004          LDRB     r5,[r2,#4]
000128  e59f4cd8          LDR      r4,|L1.3592|
00012c  e0844003          ADD      r4,r4,r3
000130  e5944010          LDR      r4,[r4,#0x10]
000134  e7df4c15          BFI      r4,r5,#24,#8
000138  e59f5cc8          LDR      r5,|L1.3592|
00013c  e0855003          ADD      r5,r5,r3
000140  e5854010          STR      r4,[r5,#0x10]
;;;125                        vSetQSPIC_DirRdCtrl0_SpiDmyByteCnt (eController, pstDirConf->stRdCtrl.u32DummyByteCnt);
000144  e5d25008          LDRB     r5,[r2,#8]
000148  e59f4cb8          LDR      r4,|L1.3592|
00014c  e0844003          ADD      r4,r4,r3
000150  e5944010          LDR      r4,[r4,#0x10]
000154  e7cf4615          BFI      r4,r5,#12,#4
000158  e59f5ca8          LDR      r5,|L1.3592|
00015c  e0855003          ADD      r5,r5,r3
000160  e5854010          STR      r4,[r5,#0x10]
;;;126                        vSetQSPIC_DirRdCtrl0_SpiAddrByteCnt(eController, pstDirConf->stRdCtrl.eAddrByteCnt);
000164  e5d2500c          LDRB     r5,[r2,#0xc]
000168  e59f4c98          LDR      r4,|L1.3592|
00016c  e0844003          ADD      r4,r4,r3
000170  e5944010          LDR      r4,[r4,#0x10]
000174  e7cb4595          BFI      r4,r5,#11,#1
000178  e59f5c88          LDR      r5,|L1.3592|
00017c  e0855003          ADD      r5,r5,r3
000180  e5854010          STR      r4,[r5,#0x10]
;;;127                        vSetQSPIC_DirRdCtrl0_SpiDatIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDatIOCtrl);
000184  e5d2500d          LDRB     r5,[r2,#0xd]
000188  e59f4c78          LDR      r4,|L1.3592|
00018c  e0844003          ADD      r4,r4,r3
000190  e5944010          LDR      r4,[r4,#0x10]
000194  e7c74315          BFI      r4,r5,#6,#2
000198  e59f5c68          LDR      r5,|L1.3592|
00019c  e0855003          ADD      r5,r5,r3
0001a0  e5854010          STR      r4,[r5,#0x10]
;;;128                        vSetQSPIC_DirRdCtrl0_SpiDmyIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDmyIOCtrl);
0001a4  e5d2500e          LDRB     r5,[r2,#0xe]
0001a8  e59f4c58          LDR      r4,|L1.3592|
0001ac  e0844003          ADD      r4,r4,r3
0001b0  e5944010          LDR      r4,[r4,#0x10]
0001b4  e7c54215          BFI      r4,r5,#4,#2
0001b8  e59f5c48          LDR      r5,|L1.3592|
0001bc  e0855003          ADD      r5,r5,r3
0001c0  e5854010          STR      r4,[r5,#0x10]
;;;129                        vSetQSPIC_DirRdCtrl0_SpiAdrIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiAdrIOCtrl);
0001c4  e5d2500f          LDRB     r5,[r2,#0xf]
0001c8  e59f4c38          LDR      r4,|L1.3592|
0001cc  e0844003          ADD      r4,r4,r3
0001d0  e5944010          LDR      r4,[r4,#0x10]
0001d4  e7c34115          BFI      r4,r5,#2,#2
0001d8  e59f5c28          LDR      r5,|L1.3592|
0001dc  e0855003          ADD      r5,r5,r3
0001e0  e5854010          STR      r4,[r5,#0x10]
;;;130                    }
;;;131                    break;
0001e4  ea000064          B        |L1.892|
                  |L1.488|
;;;132                case QSPIC_DEV_1:
0001e8  e320f000          NOP      
;;;133                    {
;;;134                        vSetQSPIC_FlshMemMap1_FBA(eController,     pstDirConf->u16FlashBaseAddress);
0001ec  e1d250b0          LDRH     r5,[r2,#0]
0001f0  e59f4c10          LDR      r4,|L1.3592|
0001f4  e0844003          ADD      r4,r4,r3
0001f8  e5944004          LDR      r4,[r4,#4]
0001fc  e7df4815          BFI      r4,r5,#16,#16
000200  e59f5c00          LDR      r5,|L1.3592|
000204  e0855003          ADD      r5,r5,r3
000208  e5854004          STR      r4,[r5,#4]
;;;135                        vSetQSPIC_FlshMemMap1_FDEN(eController,    pstDirConf->eFlashDensity);
00020c  e5d25002          LDRB     r5,[r2,#2]
000210  e59f4bf0          LDR      r4,|L1.3592|
000214  e0844003          ADD      r4,r4,r3
000218  e5944004          LDR      r4,[r4,#4]
00021c  e7c54115          BFI      r4,r5,#2,#4
000220  e59f5be0          LDR      r5,|L1.3592|
000224  e0855003          ADD      r5,r5,r3
000228  e5854004          STR      r4,[r5,#4]
;;;136                        vSetQSPIC_FlshMemMap1_RE(eController,      pstDirConf->eEnableMemMapRd);
00022c  e5d25003          LDRB     r5,[r2,#3]
000230  e59f4bd0          LDR      r4,|L1.3592|
000234  e0844003          ADD      r4,r4,r3
000238  e5944004          LDR      r4,[r4,#4]
00023c  e7c04015          BFI      r4,r5,#0,#1
000240  e59f5bc0          LDR      r5,|L1.3592|
000244  e0855003          ADD      r5,r5,r3
000248  e5854004          STR      r4,[r5,#4]
;;;137                        vSetQSPIC_DirAccCtrl1_PollWIP(eController, pstDirConf->eWIPEnable);
00024c  e5d25010          LDRB     r5,[r2,#0x10]
000250  e59f4bb0          LDR      r4,|L1.3592|
000254  e0844003          ADD      r4,r4,r3
000258  e594400c          LDR      r4,[r4,#0xc]
00025c  e7c64315          BFI      r4,r5,#6,#1
000260  e59f5ba0          LDR      r5,|L1.3592|
000264  e0855003          ADD      r5,r5,r3
000268  e585400c          STR      r4,[r5,#0xc]
;;;138                        vSetQSPIC_DirAccCtrl1_SCSD(eController,    pstDirConf->u8CSTime);
00026c  e5d25011          LDRB     r5,[r2,#0x11]
000270  e59f4b90          LDR      r4,|L1.3592|
000274  e0844003          ADD      r4,r4,r3
000278  e594400c          LDR      r4,[r4,#0xc]
00027c  e7cf4415          BFI      r4,r5,#8,#8
000280  e59f5b80          LDR      r5,|L1.3592|
000284  e0855003          ADD      r5,r5,r3
000288  e585400c          STR      r4,[r5,#0xc]
;;;139                        vSetQSPIC_DirAccCtrl1_SDCE(eController,    pstDirConf->eEdge);
00028c  e5d25012          LDRB     r5,[r2,#0x12]
000290  e59f4b70          LDR      r4,|L1.3592|
000294  e0844003          ADD      r4,r4,r3
000298  e594400c          LDR      r4,[r4,#0xc]
00029c  e7c54215          BFI      r4,r5,#4,#2
0002a0  e59f5b60          LDR      r5,|L1.3592|
0002a4  e0855003          ADD      r5,r5,r3
0002a8  e585400c          STR      r4,[r5,#0xc]
;;;140    
;;;141                        /* Direct read Control Register */
;;;142                        vSetQSPIC_DirRdCtrl1_SpiRdCmdOp    (eController, pstDirConf->stRdCtrl.eCmd);
0002ac  e5d25004          LDRB     r5,[r2,#4]
0002b0  e59f4b50          LDR      r4,|L1.3592|
0002b4  e0844003          ADD      r4,r4,r3
0002b8  e5944014          LDR      r4,[r4,#0x14]
0002bc  e7df4c15          BFI      r4,r5,#24,#8
0002c0  e59f5b40          LDR      r5,|L1.3592|
0002c4  e0855003          ADD      r5,r5,r3
0002c8  e5854014          STR      r4,[r5,#0x14]
;;;143                        vSetQSPIC_DirRdCtrl1_SpiDmyByteCnt (eController, pstDirConf->stRdCtrl.u32DummyByteCnt);
0002cc  e5d25008          LDRB     r5,[r2,#8]
0002d0  e59f4b30          LDR      r4,|L1.3592|
0002d4  e0844003          ADD      r4,r4,r3
0002d8  e5944014          LDR      r4,[r4,#0x14]
0002dc  e7cf4615          BFI      r4,r5,#12,#4
0002e0  e59f5b20          LDR      r5,|L1.3592|
0002e4  e0855003          ADD      r5,r5,r3
0002e8  e5854014          STR      r4,[r5,#0x14]
;;;144                        vSetQSPIC_DirRdCtrl1_SpiAddrByteCnt(eController, pstDirConf->stRdCtrl.eAddrByteCnt);
0002ec  e5d2500c          LDRB     r5,[r2,#0xc]
0002f0  e59f4b10          LDR      r4,|L1.3592|
0002f4  e0844003          ADD      r4,r4,r3
0002f8  e5944014          LDR      r4,[r4,#0x14]
0002fc  e7cb4595          BFI      r4,r5,#11,#1
000300  e59f5b00          LDR      r5,|L1.3592|
000304  e0855003          ADD      r5,r5,r3
000308  e5854014          STR      r4,[r5,#0x14]
;;;145                        vSetQSPIC_DirRdCtrl1_SpiDatIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDatIOCtrl);
00030c  e5d2500d          LDRB     r5,[r2,#0xd]
000310  e59f4af0          LDR      r4,|L1.3592|
000314  e0844003          ADD      r4,r4,r3
000318  e5944014          LDR      r4,[r4,#0x14]
00031c  e7c74315          BFI      r4,r5,#6,#2
000320  e59f5ae0          LDR      r5,|L1.3592|
000324  e0855003          ADD      r5,r5,r3
000328  e5854014          STR      r4,[r5,#0x14]
;;;146                        vSetQSPIC_DirRdCtrl1_SpiDmyIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiDmyIOCtrl);
00032c  e5d2500e          LDRB     r5,[r2,#0xe]
000330  e59f4ad0          LDR      r4,|L1.3592|
000334  e0844003          ADD      r4,r4,r3
000338  e5944014          LDR      r4,[r4,#0x14]
00033c  e7c54215          BFI      r4,r5,#4,#2
000340  e59f5ac0          LDR      r5,|L1.3592|
000344  e0855003          ADD      r5,r5,r3
000348  e5854014          STR      r4,[r5,#0x14]
;;;147                        vSetQSPIC_DirRdCtrl1_SpiAdrIOCtrl  (eController, pstDirConf->stRdCtrl.eSpiAdrIOCtrl);
00034c  e5d2500f          LDRB     r5,[r2,#0xf]
000350  e59f4ab0          LDR      r4,|L1.3592|
000354  e0844003          ADD      r4,r4,r3
000358  e5944014          LDR      r4,[r4,#0x14]
00035c  e7c34115          BFI      r4,r5,#2,#2
000360  e59f5aa0          LDR      r5,|L1.3592|
000364  e0855003          ADD      r5,r5,r3
000368  e5854014          STR      r4,[r5,#0x14]
;;;148                    }
;;;149                    break;
00036c  ea000002          B        |L1.892|
                  |L1.880|
;;;150                default:
000370  e320f000          NOP      
;;;151                    {
;;;152                        i32Res = C_FAILED;
000374  e3e00000          MVN      r0,#0
;;;153                    }
;;;154                    break;
000378  e320f000          NOP      
                  |L1.892|
00037c  ea000000          B        |L1.900|
                  |L1.896|
;;;155            }
;;;156        }
;;;157        else
;;;158        {
;;;159            i32Res = C_FAILED;
000380  e3e00000          MVN      r0,#0
                  |L1.900|
;;;160        }
;;;161    
;;;162        return i32Res;
;;;163    }
000384  e8bd8030          POP      {r4,r5,pc}
;;;164    
                          ENDP

                  i32QSPIC_ConfigurePrgControl PROC
;;;167    
;;;168    int32_t i32QSPIC_ConfigurePrgControl(qspic_cntrl_e eController, qspic_prgconfig_st *pstPrgConf)
000388  e92d4010          PUSH     {r4,lr}
;;;169    {
00038c  e1a02000          MOV      r2,r0
;;;170        int32_t i32Res = C_SUCCESS;
000390  e3a00000          MOV      r0,#0
;;;171    
;;;172        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000394  e3520000          CMP      r2,#0
000398  0a000004          BEQ      |L1.944|
00039c  e59f3a60          LDR      r3,|L1.3588|
0003a0  e1520003          CMP      r2,r3
0003a4  0a000001          BEQ      |L1.944|
0003a8  e3520a01          CMP      r2,#0x1000
0003ac  1a000013          BNE      |L1.1024|
                  |L1.944|
;;;173        {
;;;174            vSetQSPIC_PrgAccCtrl0_SCSD(eController, pstPrgConf->u8CSTime);
0003b0  e5d14000          LDRB     r4,[r1,#0]
0003b4  e59f3a4c          LDR      r3,|L1.3592|
0003b8  e0833002          ADD      r3,r3,r2
0003bc  e5933400          LDR      r3,[r3,#0x400]
0003c0  e7cf3414          BFI      r3,r4,#8,#8
0003c4  e59f4a3c          LDR      r4,|L1.3592|
0003c8  e0844002          ADD      r4,r4,r2
0003cc  e5843400          STR      r3,[r4,#0x400]
;;;175            vSetQSPIC_PrgAccCtrl0_SDCE(eController, pstPrgConf->eEdge);
0003d0  e5d14001          LDRB     r4,[r1,#1]
0003d4  e59f3a2c          LDR      r3,|L1.3592|
0003d8  e0833002          ADD      r3,r3,r2
0003dc  e5933400          LDR      r3,[r3,#0x400]
0003e0  e7c53214          BFI      r3,r4,#4,#2
0003e4  e59f4a1c          LDR      r4,|L1.3592|
0003e8  e0844002          ADD      r4,r4,r2
0003ec  e5843400          STR      r3,[r4,#0x400]
;;;176    
;;;177            ePrgAddressByteCnt = pstPrgConf->eAddrByteCnt;
0003f0  e5d13002          LDRB     r3,[r1,#2]
0003f4  e59f4a10          LDR      r4,|L1.3596|
0003f8  e5c43000          STRB     r3,[r4,#0]  ; ePrgAddressByteCnt
0003fc  ea000000          B        |L1.1028|
                  |L1.1024|
;;;178        }
;;;179        else
;;;180        {
;;;181            i32Res = C_FAILED;
000400  e3e00000          MVN      r0,#0
                  |L1.1028|
;;;182        }
;;;183    
;;;184        return i32Res;
;;;185    }
000404  e8bd8010          POP      {r4,pc}
;;;186    
                          ENDP

                  i32QSPIC_SetDirectFlashBaseAddress PROC
;;;189    
;;;190    int32_t i32QSPIC_SetDirectFlashBaseAddress(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t u16FlashBaseAddress)
000408  e92d4030          PUSH     {r4,r5,lr}
;;;191    {
00040c  e1a03000          MOV      r3,r0
;;;192        int32_t i32Res = C_SUCCESS;
000410  e3a00000          MOV      r0,#0
;;;193    
;;;194        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000414  e3530000          CMP      r3,#0
000418  0a000004          BEQ      |L1.1072|
00041c  e59f49e0          LDR      r4,|L1.3588|
000420  e1530004          CMP      r3,r4
000424  0a000001          BEQ      |L1.1072|
000428  e3530a01          CMP      r3,#0x1000
00042c  1a000018          BNE      |L1.1172|
                  |L1.1072|
;;;195        {
;;;196            switch (eDevice)
000430  e3510000          CMP      r1,#0
000434  0a000002          BEQ      |L1.1092|
000438  e3510001          CMP      r1,#1
00043c  1a000010          BNE      |L1.1156|
000440  ea000006          B        |L1.1120|
                  |L1.1092|
;;;197            {
;;;198                case QSPIC_DEV_0:
000444  e320f000          NOP      
;;;199                    {
;;;200                        vSetQSPIC_FlshMemMap0_FBA(eController, u16FlashBaseAddress);
000448  e59f49b8          LDR      r4,|L1.3592|
00044c  e7934004          LDR      r4,[r3,r4]
000450  e7df4812          BFI      r4,r2,#16,#16
000454  e59f59ac          LDR      r5,|L1.3592|
000458  e7834005          STR      r4,[r3,r5]
;;;201                    }
;;;202                    break;
00045c  ea00000b          B        |L1.1168|
                  |L1.1120|
;;;203                case QSPIC_DEV_1:
000460  e320f000          NOP      
;;;204                    {
;;;205                        vSetQSPIC_FlshMemMap1_FBA(eController, u16FlashBaseAddress);
000464  e59f499c          LDR      r4,|L1.3592|
000468  e0844003          ADD      r4,r4,r3
00046c  e5944004          LDR      r4,[r4,#4]
000470  e7df4812          BFI      r4,r2,#16,#16
000474  e59f598c          LDR      r5,|L1.3592|
000478  e0855003          ADD      r5,r5,r3
00047c  e5854004          STR      r4,[r5,#4]
;;;206                    }
;;;207                    break;
000480  ea000002          B        |L1.1168|
                  |L1.1156|
;;;208                default:
000484  e320f000          NOP      
;;;209                    {
;;;210                        i32Res = C_FAILED;
000488  e3e00000          MVN      r0,#0
;;;211                    }
;;;212                    break;
00048c  e320f000          NOP      
                  |L1.1168|
000490  ea000000          B        |L1.1176|
                  |L1.1172|
;;;213            }
;;;214        }
;;;215        else
;;;216        {
;;;217            i32Res = C_FAILED;
000494  e3e00000          MVN      r0,#0
                  |L1.1176|
;;;218        }
;;;219    
;;;220        return i32Res;
;;;221    }
000498  e8bd8030          POP      {r4,r5,pc}
;;;222    
                          ENDP

                  i32QSPIC_GetDirectFlashBaseAddress PROC
;;;225    
;;;226    int32_t i32QSPIC_GetDirectFlashBaseAddress(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t * u16FlashBaseAddress)
00049c  e92d4010          PUSH     {r4,lr}
;;;227    {
0004a0  e1a03000          MOV      r3,r0
;;;228        int32_t i32Res = C_SUCCESS;
0004a4  e3a00000          MOV      r0,#0
;;;229    
;;;230        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
0004a8  e3530000          CMP      r3,#0
0004ac  0a000004          BEQ      |L1.1220|
0004b0  e59f494c          LDR      r4,|L1.3588|
0004b4  e1530004          CMP      r3,r4
0004b8  0a000001          BEQ      |L1.1220|
0004bc  e3530a01          CMP      r3,#0x1000
0004c0  1a000015          BNE      |L1.1308|
                  |L1.1220|
;;;231        {
;;;232            switch (eDevice)
0004c4  e3510000          CMP      r1,#0
0004c8  0a000002          BEQ      |L1.1240|
0004cc  e3510001          CMP      r1,#1
0004d0  1a00000d          BNE      |L1.1292|
0004d4  ea000005          B        |L1.1264|
                  |L1.1240|
;;;233            {
;;;234                case QSPIC_DEV_0:
0004d8  e320f000          NOP      
;;;235                    {
;;;236                        *u16FlashBaseAddress = biGetQSPIC_FlshMemMap0_FBA(eController);
0004dc  e59f4924          LDR      r4,|L1.3592|
0004e0  e7934004          LDR      r4,[r3,r4]
0004e4  e1a04824          LSR      r4,r4,#16
0004e8  e1c240b0          STRH     r4,[r2,#0]
;;;237                    }
;;;238                    break;
0004ec  ea000009          B        |L1.1304|
                  |L1.1264|
;;;239                case QSPIC_DEV_1:
0004f0  e320f000          NOP      
;;;240                    {
;;;241                        *u16FlashBaseAddress = biGetQSPIC_FlshMemMap1_FBA(eController);
0004f4  e59f490c          LDR      r4,|L1.3592|
0004f8  e0844003          ADD      r4,r4,r3
0004fc  e5944004          LDR      r4,[r4,#4]
000500  e1a04824          LSR      r4,r4,#16
000504  e1c240b0          STRH     r4,[r2,#0]
;;;242                    }
;;;243                    break;
000508  ea000002          B        |L1.1304|
                  |L1.1292|
;;;244                default:
00050c  e320f000          NOP      
;;;245                    {
;;;246                        i32Res = C_FAILED;
000510  e3e00000          MVN      r0,#0
;;;247                    }
;;;248                    break;
000514  e320f000          NOP      
                  |L1.1304|
000518  ea000000          B        |L1.1312|
                  |L1.1308|
;;;249            }
;;;250        }
;;;251        else
;;;252        {
;;;253            i32Res = C_FAILED;
00051c  e3e00000          MVN      r0,#0
                  |L1.1312|
;;;254        }
;;;255    
;;;256        return i32Res;
;;;257    }
000520  e8bd8010          POP      {r4,pc}
;;;258    
                          ENDP

                  i32QSPIC_SetDirectFlashDensity PROC
;;;261    
;;;262    int32_t i32QSPIC_SetDirectFlashDensity(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_density_e eFlashDensity)
000524  e92d4030          PUSH     {r4,r5,lr}
;;;263    {
000528  e1a03000          MOV      r3,r0
;;;264        int32_t i32Res = C_SUCCESS;
00052c  e3a00000          MOV      r0,#0
;;;265    
;;;266        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000530  e3530000          CMP      r3,#0
000534  0a000004          BEQ      |L1.1356|
000538  e59f48c4          LDR      r4,|L1.3588|
00053c  e1530004          CMP      r3,r4
000540  0a000001          BEQ      |L1.1356|
000544  e3530a01          CMP      r3,#0x1000
000548  1a000018          BNE      |L1.1456|
                  |L1.1356|
;;;267        {
;;;268            switch (eDevice)
00054c  e3510000          CMP      r1,#0
000550  0a000002          BEQ      |L1.1376|
000554  e3510001          CMP      r1,#1
000558  1a000010          BNE      |L1.1440|
00055c  ea000006          B        |L1.1404|
                  |L1.1376|
;;;269            {
;;;270                case QSPIC_DEV_0:
000560  e320f000          NOP      
;;;271                    {
;;;272                        vSetQSPIC_FlshMemMap0_FDEN(eController, eFlashDensity);
000564  e59f489c          LDR      r4,|L1.3592|
000568  e7934004          LDR      r4,[r3,r4]
00056c  e7c54112          BFI      r4,r2,#2,#4
000570  e59f5890          LDR      r5,|L1.3592|
000574  e7834005          STR      r4,[r3,r5]
;;;273                    }
;;;274                    break;
000578  ea00000b          B        |L1.1452|
                  |L1.1404|
;;;275                case QSPIC_DEV_1:
00057c  e320f000          NOP      
;;;276                    {
;;;277                        vSetQSPIC_FlshMemMap1_FDEN(eController, eFlashDensity);
000580  e59f4880          LDR      r4,|L1.3592|
000584  e0844003          ADD      r4,r4,r3
000588  e5944004          LDR      r4,[r4,#4]
00058c  e7c54112          BFI      r4,r2,#2,#4
000590  e59f5870          LDR      r5,|L1.3592|
000594  e0855003          ADD      r5,r5,r3
000598  e5854004          STR      r4,[r5,#4]
;;;278                    }
;;;279                    break;
00059c  ea000002          B        |L1.1452|
                  |L1.1440|
;;;280                default:
0005a0  e320f000          NOP      
;;;281                    {
;;;282                        i32Res = C_FAILED;
0005a4  e3e00000          MVN      r0,#0
;;;283                    }
;;;284                    break;
0005a8  e320f000          NOP      
                  |L1.1452|
0005ac  ea000000          B        |L1.1460|
                  |L1.1456|
;;;285            }
;;;286        }
;;;287        else
;;;288        {
;;;289            i32Res = C_FAILED;
0005b0  e3e00000          MVN      r0,#0
                  |L1.1460|
;;;290        }
;;;291    
;;;292        return i32Res;
;;;293    }
0005b4  e8bd8030          POP      {r4,r5,pc}
;;;294    
                          ENDP

                  i32QSPIC_GetDirectFlashDensity PROC
;;;297    
;;;298    int32_t i32QSPIC_GetDirectFlashDensity(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_density_e * eFlashDensity)
0005b8  e92d4010          PUSH     {r4,lr}
;;;299    {
0005bc  e1a03000          MOV      r3,r0
;;;300        int32_t i32Res = C_SUCCESS;
0005c0  e3a00000          MOV      r0,#0
;;;301    
;;;302        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
0005c4  e3530000          CMP      r3,#0
0005c8  0a000004          BEQ      |L1.1504|
0005cc  e59f4830          LDR      r4,|L1.3588|
0005d0  e1530004          CMP      r3,r4
0005d4  0a000001          BEQ      |L1.1504|
0005d8  e3530a01          CMP      r3,#0x1000
0005dc  1a000015          BNE      |L1.1592|
                  |L1.1504|
;;;303        {
;;;304            switch (eDevice)
0005e0  e3510000          CMP      r1,#0
0005e4  0a000002          BEQ      |L1.1524|
0005e8  e3510001          CMP      r1,#1
0005ec  1a00000d          BNE      |L1.1576|
0005f0  ea000005          B        |L1.1548|
                  |L1.1524|
;;;305            {
;;;306                case QSPIC_DEV_0:
0005f4  e320f000          NOP      
;;;307                    {
;;;308                        *eFlashDensity = (qspic_density_e) biGetQSPIC_FlshMemMap0_FDEN(eController);
0005f8  e59f4808          LDR      r4,|L1.3592|
0005fc  e7934004          LDR      r4,[r3,r4]
000600  e7e34154          UBFX     r4,r4,#2,#4
000604  e5c24000          STRB     r4,[r2,#0]
;;;309                    }
;;;310                    break;
000608  ea000009          B        |L1.1588|
                  |L1.1548|
;;;311                case QSPIC_DEV_1:
00060c  e320f000          NOP      
;;;312                    {
;;;313                        *eFlashDensity = (qspic_density_e) biGetQSPIC_FlshMemMap1_FDEN(eController);
000610  e59f47f0          LDR      r4,|L1.3592|
000614  e0844003          ADD      r4,r4,r3
000618  e5944004          LDR      r4,[r4,#4]
00061c  e7e34154          UBFX     r4,r4,#2,#4
000620  e5c24000          STRB     r4,[r2,#0]
;;;314                    }
;;;315                    break;
000624  ea000002          B        |L1.1588|
                  |L1.1576|
;;;316                default:
000628  e320f000          NOP      
;;;317                    {
;;;318                        i32Res = C_FAILED;
00062c  e3e00000          MVN      r0,#0
;;;319                    }
;;;320                    break;
000630  e320f000          NOP      
                  |L1.1588|
000634  ea000000          B        |L1.1596|
                  |L1.1592|
;;;321            }
;;;322        }
;;;323        else
;;;324        {
;;;325            i32Res = C_FAILED;
000638  e3e00000          MVN      r0,#0
                  |L1.1596|
;;;326        }
;;;327    
;;;328        return i32Res;
;;;329    }
00063c  e8bd8010          POP      {r4,pc}
;;;330    
                          ENDP

                  i32QSPIC_EnableDirectMemMapRd PROC
;;;333    
;;;334    int32_t i32QSPIC_EnableDirectMemMapRd(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e eEnableMemMap)
000640  e92d4030          PUSH     {r4,r5,lr}
;;;335    {
000644  e1a03000          MOV      r3,r0
;;;336        int32_t i32Res = C_SUCCESS;
000648  e3a00000          MOV      r0,#0
;;;337    
;;;338        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
00064c  e3530000          CMP      r3,#0
000650  0a000004          BEQ      |L1.1640|
000654  e59f47a8          LDR      r4,|L1.3588|
000658  e1530004          CMP      r3,r4
00065c  0a000001          BEQ      |L1.1640|
000660  e3530a01          CMP      r3,#0x1000
000664  1a000018          BNE      |L1.1740|
                  |L1.1640|
;;;339        {
;;;340            switch (eDevice)
000668  e3510000          CMP      r1,#0
00066c  0a000002          BEQ      |L1.1660|
000670  e3510001          CMP      r1,#1
000674  1a000010          BNE      |L1.1724|
000678  ea000006          B        |L1.1688|
                  |L1.1660|
;;;341            {
;;;342                case QSPIC_DEV_0:
00067c  e320f000          NOP      
;;;343                    {
;;;344                        vSetQSPIC_FlshMemMap0_RE(eController, eEnableMemMap);
000680  e59f4780          LDR      r4,|L1.3592|
000684  e7934004          LDR      r4,[r3,r4]
000688  e7c04012          BFI      r4,r2,#0,#1
00068c  e59f5774          LDR      r5,|L1.3592|
000690  e7834005          STR      r4,[r3,r5]
;;;345                    }
;;;346                    break;
000694  ea00000b          B        |L1.1736|
                  |L1.1688|
;;;347                case QSPIC_DEV_1:
000698  e320f000          NOP      
;;;348                    {
;;;349                        vSetQSPIC_FlshMemMap1_RE(eController, eEnableMemMap);
00069c  e59f4764          LDR      r4,|L1.3592|
0006a0  e0844003          ADD      r4,r4,r3
0006a4  e5944004          LDR      r4,[r4,#4]
0006a8  e7c04012          BFI      r4,r2,#0,#1
0006ac  e59f5754          LDR      r5,|L1.3592|
0006b0  e0855003          ADD      r5,r5,r3
0006b4  e5854004          STR      r4,[r5,#4]
;;;350                    }
;;;351                    break;
0006b8  ea000002          B        |L1.1736|
                  |L1.1724|
;;;352                default:
0006bc  e320f000          NOP      
;;;353                    {
;;;354                        i32Res = C_FAILED;
0006c0  e3e00000          MVN      r0,#0
;;;355                    }
;;;356                    break;
0006c4  e320f000          NOP      
                  |L1.1736|
0006c8  ea000000          B        |L1.1744|
                  |L1.1740|
;;;357            }
;;;358        }
;;;359        else
;;;360        {
;;;361            i32Res = C_FAILED;
0006cc  e3e00000          MVN      r0,#0
                  |L1.1744|
;;;362        }
;;;363    
;;;364        return i32Res;
;;;365    }
0006d0  e8bd8030          POP      {r4,r5,pc}
;;;366    
                          ENDP

                  i32QSPIC_GetDirectMemMapStatusRd PROC
;;;369    
;;;370    int32_t i32QSPIC_GetDirectMemMapStatusRd(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e * eEnableMemMap)
0006d4  e92d4010          PUSH     {r4,lr}
;;;371    {
0006d8  e1a03000          MOV      r3,r0
;;;372        int32_t i32Res = C_SUCCESS;
0006dc  e3a00000          MOV      r0,#0
;;;373    
;;;374        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
0006e0  e3530000          CMP      r3,#0
0006e4  0a000004          BEQ      |L1.1788|
0006e8  e59f4714          LDR      r4,|L1.3588|
0006ec  e1530004          CMP      r3,r4
0006f0  0a000001          BEQ      |L1.1788|
0006f4  e3530a01          CMP      r3,#0x1000
0006f8  1a000015          BNE      |L1.1876|
                  |L1.1788|
;;;375        {
;;;376            switch (eDevice)
0006fc  e3510000          CMP      r1,#0
000700  0a000002          BEQ      |L1.1808|
000704  e3510001          CMP      r1,#1
000708  1a00000d          BNE      |L1.1860|
00070c  ea000005          B        |L1.1832|
                  |L1.1808|
;;;377            {
;;;378                case QSPIC_DEV_0:
000710  e320f000          NOP      
;;;379                    {
;;;380                        *eEnableMemMap = (qspic_en_e) biGetQSPIC_FlshMemMap0_RE(eController);
000714  e59f46ec          LDR      r4,|L1.3592|
000718  e7934004          LDR      r4,[r3,r4]
00071c  e2044001          AND      r4,r4,#1
000720  e5c24000          STRB     r4,[r2,#0]
;;;381                    }
;;;382                    break;
000724  ea000009          B        |L1.1872|
                  |L1.1832|
;;;383                case QSPIC_DEV_1:
000728  e320f000          NOP      
;;;384                    {
;;;385                        *eEnableMemMap = (qspic_en_e) biGetQSPIC_FlshMemMap1_RE(eController);
00072c  e59f46d4          LDR      r4,|L1.3592|
000730  e0844003          ADD      r4,r4,r3
000734  e5944004          LDR      r4,[r4,#4]
000738  e2044001          AND      r4,r4,#1
00073c  e5c24000          STRB     r4,[r2,#0]
;;;386                    }
;;;387                    break;
000740  ea000002          B        |L1.1872|
                  |L1.1860|
;;;388                default:
000744  e320f000          NOP      
;;;389                    {
;;;390                        i32Res = C_FAILED;
000748  e3e00000          MVN      r0,#0
;;;391                    }
;;;392                    break;
00074c  e320f000          NOP      
                  |L1.1872|
000750  ea000000          B        |L1.1880|
                  |L1.1876|
;;;393            }
;;;394        }
;;;395        else
;;;396        {
;;;397            i32Res = C_FAILED;
000754  e3e00000          MVN      r0,#0
                  |L1.1880|
;;;398        }
;;;399    
;;;400        return i32Res;
;;;401    }
000758  e8bd8010          POP      {r4,pc}
;;;402    
                          ENDP

                  i32QSPIC_SetDirectFlashMemMap PROC
;;;405    
;;;406    int32_t i32QSPIC_SetDirectFlashMemMap(qspic_cntrl_e eController, qspic_dev_e eDevice, uint16_t u16FlashBaseAddress,
00075c  e92d40f0          PUSH     {r4-r7,lr}
;;;407                                          qspic_density_e eFlashDensity, qspic_en_e eEnableMemMapRd)
;;;408    {
000760  e1a04000          MOV      r4,r0
000764  e59d5014          LDR      r5,[sp,#0x14]
;;;409        int32_t i32Res = C_SUCCESS;
000768  e3a00000          MOV      r0,#0
;;;410    
;;;411        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
00076c  e3540000          CMP      r4,#0
000770  0a000004          BEQ      |L1.1928|
000774  e59f6688          LDR      r6,|L1.3588|
000778  e1540006          CMP      r4,r6
00077c  0a000001          BEQ      |L1.1928|
000780  e3540a01          CMP      r4,#0x1000
000784  1a00002e          BNE      |L1.2116|
                  |L1.1928|
;;;412        {
;;;413            switch (eDevice)
000788  e3510000          CMP      r1,#0
00078c  0a000002          BEQ      |L1.1948|
000790  e3510001          CMP      r1,#1
000794  1a000026          BNE      |L1.2100|
000798  ea00000e          B        |L1.2008|
                  |L1.1948|
;;;414            {
;;;415                case QSPIC_DEV_0:
00079c  e320f000          NOP      
;;;416                    {
;;;417                        vSetQSPIC_FlshMemMap0_FBA(eController, u16FlashBaseAddress);
0007a0  e59f6660          LDR      r6,|L1.3592|
0007a4  e7946006          LDR      r6,[r4,r6]
0007a8  e7df6812          BFI      r6,r2,#16,#16
0007ac  e59f7654          LDR      r7,|L1.3592|
0007b0  e7846007          STR      r6,[r4,r7]
;;;418                        vSetQSPIC_FlshMemMap0_FDEN(eController, eFlashDensity);
0007b4  e1a06007          MOV      r6,r7
0007b8  e7946006          LDR      r6,[r4,r6]
0007bc  e7c56113          BFI      r6,r3,#2,#4
0007c0  e7846007          STR      r6,[r4,r7]
;;;419                        vSetQSPIC_FlshMemMap0_RE(eController, eEnableMemMapRd);
0007c4  e1a06007          MOV      r6,r7
0007c8  e7946006          LDR      r6,[r4,r6]
0007cc  e7c06015          BFI      r6,r5,#0,#1
0007d0  e7846007          STR      r6,[r4,r7]
;;;420                    }
;;;421                    break;
0007d4  ea000019          B        |L1.2112|
                  |L1.2008|
;;;422                case QSPIC_DEV_1:
0007d8  e320f000          NOP      
;;;423                    {
;;;424                        vSetQSPIC_FlshMemMap1_FBA(eController, u16FlashBaseAddress);
0007dc  e59f6624          LDR      r6,|L1.3592|
0007e0  e0866004          ADD      r6,r6,r4
0007e4  e5966004          LDR      r6,[r6,#4]
0007e8  e7df6812          BFI      r6,r2,#16,#16
0007ec  e59f7614          LDR      r7,|L1.3592|
0007f0  e0877004          ADD      r7,r7,r4
0007f4  e5876004          STR      r6,[r7,#4]
;;;425                        vSetQSPIC_FlshMemMap1_FDEN(eController, eFlashDensity);
0007f8  e59f6608          LDR      r6,|L1.3592|
0007fc  e0866004          ADD      r6,r6,r4
000800  e5966004          LDR      r6,[r6,#4]
000804  e7c56113          BFI      r6,r3,#2,#4
000808  e59f75f8          LDR      r7,|L1.3592|
00080c  e0877004          ADD      r7,r7,r4
000810  e5876004          STR      r6,[r7,#4]
;;;426                        vSetQSPIC_FlshMemMap1_RE(eController, eEnableMemMapRd);
000814  e59f65ec          LDR      r6,|L1.3592|
000818  e0866004          ADD      r6,r6,r4
00081c  e5966004          LDR      r6,[r6,#4]
000820  e7c06015          BFI      r6,r5,#0,#1
000824  e59f75dc          LDR      r7,|L1.3592|
000828  e0877004          ADD      r7,r7,r4
00082c  e5876004          STR      r6,[r7,#4]
;;;427                    }
;;;428                    break;
000830  ea000002          B        |L1.2112|
                  |L1.2100|
;;;429                default:
000834  e320f000          NOP      
;;;430                    {
;;;431                        i32Res = C_FAILED;
000838  e3e00000          MVN      r0,#0
;;;432                    }
;;;433                    break;
00083c  e320f000          NOP      
                  |L1.2112|
000840  ea000000          B        |L1.2120|
                  |L1.2116|
;;;434            }
;;;435        }
;;;436        else
;;;437        {
;;;438            i32Res = C_FAILED;
000844  e3e00000          MVN      r0,#0
                  |L1.2120|
;;;439        }
;;;440    
;;;441        return i32Res;
;;;442    }
000848  e8bd80f0          POP      {r4-r7,pc}
;;;443    
                          ENDP

                  i32QSPIC_DirectSetReadCtrl PROC
;;;446    
;;;447    int32_t i32QSPIC_DirectSetReadCtrl(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32Ctrl)
00084c  e92d4010          PUSH     {r4,lr}
;;;448    {
000850  e1a03000          MOV      r3,r0
;;;449        int32_t i32Res = C_SUCCESS;
000854  e3a00000          MOV      r0,#0
;;;450    
;;;451        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000858  e3530000          CMP      r3,#0
00085c  0a000004          BEQ      |L1.2164|
000860  e59f459c          LDR      r4,|L1.3588|
000864  e1530004          CMP      r3,r4
000868  0a000001          BEQ      |L1.2164|
00086c  e3530a01          CMP      r3,#0x1000
000870  1a000012          BNE      |L1.2240|
                  |L1.2164|
;;;452        {
;;;453            switch (eDevice)
000874  e3510000          CMP      r1,#0
000878  0a000002          BEQ      |L1.2184|
00087c  e3510001          CMP      r1,#1
000880  1a00000a          BNE      |L1.2224|
000884  ea000004          B        |L1.2204|
                  |L1.2184|
;;;454            {
;;;455                case QSPIC_DEV_0:
000888  e320f000          NOP      
;;;456                    {
;;;457                        vSetQSPIC_DirRdCtrl0(eController, u32Ctrl);
00088c  e59f4574          LDR      r4,|L1.3592|
000890  e0844003          ADD      r4,r4,r3
000894  e5842010          STR      r2,[r4,#0x10]
;;;458                    }
;;;459                    break;
000898  ea000007          B        |L1.2236|
                  |L1.2204|
;;;460                case QSPIC_DEV_1:
00089c  e320f000          NOP      
;;;461                    {
;;;462                        vSetQSPIC_DirRdCtrl1(eController, u32Ctrl);
0008a0  e59f4560          LDR      r4,|L1.3592|
0008a4  e0844003          ADD      r4,r4,r3
0008a8  e5842014          STR      r2,[r4,#0x14]
;;;463                    }
;;;464                    break;
0008ac  ea000002          B        |L1.2236|
                  |L1.2224|
;;;465                default:
0008b0  e320f000          NOP      
;;;466                    {
;;;467                        i32Res = C_FAILED;
0008b4  e3e00000          MVN      r0,#0
;;;468                    }
;;;469                    break;
0008b8  e320f000          NOP      
                  |L1.2236|
0008bc  ea000000          B        |L1.2244|
                  |L1.2240|
;;;470            }
;;;471        }
;;;472        else
;;;473        {
;;;474            i32Res = C_FAILED;
0008c0  e3e00000          MVN      r0,#0
                  |L1.2244|
;;;475        }
;;;476    
;;;477        return i32Res;
;;;478    }
0008c4  e8bd8010          POP      {r4,pc}
;;;479    
                          ENDP

                  i32QSPIC_DirectGetReadCtrl PROC
;;;482    
;;;483    int32_t i32QSPIC_DirectGetReadCtrl(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t * u32Ctrl)
0008c8  e92d4010          PUSH     {r4,lr}
;;;484    {
0008cc  e1a03000          MOV      r3,r0
;;;485        int32_t i32Res = C_SUCCESS;
0008d0  e3a00000          MOV      r0,#0
;;;486    
;;;487        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
0008d4  e3530000          CMP      r3,#0
0008d8  0a000004          BEQ      |L1.2288|
0008dc  e59f4520          LDR      r4,|L1.3588|
0008e0  e1530004          CMP      r3,r4
0008e4  0a000001          BEQ      |L1.2288|
0008e8  e3530a01          CMP      r3,#0x1000
0008ec  1a000014          BNE      |L1.2372|
                  |L1.2288|
;;;488        {
;;;489            switch (eDevice)
0008f0  e3510000          CMP      r1,#0
0008f4  0a000002          BEQ      |L1.2308|
0008f8  e3510001          CMP      r1,#1
0008fc  1a00000c          BNE      |L1.2356|
000900  ea000005          B        |L1.2332|
                  |L1.2308|
;;;490            {
;;;491                case QSPIC_DEV_0:
000904  e320f000          NOP      
;;;492                    {
;;;493                        *u32Ctrl = u32GetQSPIC_DirRdCtrl0(eController);
000908  e59f44f8          LDR      r4,|L1.3592|
00090c  e0844003          ADD      r4,r4,r3
000910  e5944010          LDR      r4,[r4,#0x10]
000914  e5824000          STR      r4,[r2,#0]
;;;494                    }
;;;495                    break;
000918  ea000008          B        |L1.2368|
                  |L1.2332|
;;;496                case QSPIC_DEV_1:
00091c  e320f000          NOP      
;;;497                    {
;;;498                        *u32Ctrl = u32GetQSPIC_DirRdCtrl1(eController);
000920  e59f44e0          LDR      r4,|L1.3592|
000924  e0844003          ADD      r4,r4,r3
000928  e5944014          LDR      r4,[r4,#0x14]
00092c  e5824000          STR      r4,[r2,#0]
;;;499                    }
;;;500                    break;
000930  ea000002          B        |L1.2368|
                  |L1.2356|
;;;501                default:
000934  e320f000          NOP      
;;;502                    {
;;;503                        i32Res = C_FAILED;
000938  e3e00000          MVN      r0,#0
;;;504                    }
;;;505                    break;
00093c  e320f000          NOP      
                  |L1.2368|
000940  ea000000          B        |L1.2376|
                  |L1.2372|
;;;506            }
;;;507        }
;;;508        else
;;;509        {
;;;510            i32Res = C_FAILED;
000944  e3e00000          MVN      r0,#0
                  |L1.2376|
;;;511        }
;;;512    
;;;513        return i32Res;
;;;514    }
000948  e8bd8010          POP      {r4,pc}
;;;515    
                          ENDP

                  i32QSPIC_DirectEnableWIPPolling PROC
;;;518    
;;;519    int32_t i32QSPIC_DirectEnableWIPPolling(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e eEnable)
00094c  e92d4030          PUSH     {r4,r5,lr}
;;;520    {
000950  e1a03000          MOV      r3,r0
;;;521        int32_t i32Res = C_SUCCESS;
000954  e3a00000          MOV      r0,#0
;;;522    
;;;523        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000958  e3530000          CMP      r3,#0
00095c  0a000004          BEQ      |L1.2420|
000960  e59f449c          LDR      r4,|L1.3588|
000964  e1530004          CMP      r3,r4
000968  0a000001          BEQ      |L1.2420|
00096c  e3530a01          CMP      r3,#0x1000
000970  1a00001a          BNE      |L1.2528|
                  |L1.2420|
;;;524        {
;;;525            switch (eDevice)
000974  e3510000          CMP      r1,#0
000978  0a000002          BEQ      |L1.2440|
00097c  e3510001          CMP      r1,#1
000980  1a000012          BNE      |L1.2512|
000984  ea000008          B        |L1.2476|
                  |L1.2440|
;;;526            {
;;;527                case QSPIC_DEV_0:
000988  e320f000          NOP      
;;;528                    {
;;;529                        vSetQSPIC_DirAccCtrl0_PollWIP(eController, eEnable);
00098c  e59f4474          LDR      r4,|L1.3592|
000990  e0844003          ADD      r4,r4,r3
000994  e5944008          LDR      r4,[r4,#8]
000998  e7c64312          BFI      r4,r2,#6,#1
00099c  e59f5464          LDR      r5,|L1.3592|
0009a0  e0855003          ADD      r5,r5,r3
0009a4  e5854008          STR      r4,[r5,#8]
;;;530                    }
;;;531                    break;
0009a8  ea00000b          B        |L1.2524|
                  |L1.2476|
;;;532                case QSPIC_DEV_1:
0009ac  e320f000          NOP      
;;;533                    {
;;;534                        vSetQSPIC_DirAccCtrl1_PollWIP(eController, eEnable);
0009b0  e59f4450          LDR      r4,|L1.3592|
0009b4  e0844003          ADD      r4,r4,r3
0009b8  e594400c          LDR      r4,[r4,#0xc]
0009bc  e7c64312          BFI      r4,r2,#6,#1
0009c0  e59f5440          LDR      r5,|L1.3592|
0009c4  e0855003          ADD      r5,r5,r3
0009c8  e585400c          STR      r4,[r5,#0xc]
;;;535                    }
;;;536                    break;
0009cc  ea000002          B        |L1.2524|
                  |L1.2512|
;;;537                default:
0009d0  e320f000          NOP      
;;;538                    {
;;;539                        i32Res = C_FAILED;
0009d4  e3e00000          MVN      r0,#0
;;;540                    }
;;;541                    break;
0009d8  e320f000          NOP      
                  |L1.2524|
0009dc  ea000000          B        |L1.2532|
                  |L1.2528|
;;;542            }
;;;543        }
;;;544        else
;;;545        {
;;;546            i32Res = C_FAILED;
0009e0  e3e00000          MVN      r0,#0
                  |L1.2532|
;;;547        }
;;;548    
;;;549        return i32Res;
;;;550    }
0009e4  e8bd8030          POP      {r4,r5,pc}
;;;551    
                          ENDP

                  i32QSPIC_DirectGetStatusWIPPolling PROC
;;;554    
;;;555    int32_t i32QSPIC_DirectGetStatusWIPPolling(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_en_e * eEnable)
0009e8  e92d4010          PUSH     {r4,lr}
;;;556    {
0009ec  e1a03000          MOV      r3,r0
;;;557        int32_t i32Res = C_SUCCESS;
0009f0  e3a00000          MOV      r0,#0
;;;558    
;;;559        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
0009f4  e3530000          CMP      r3,#0
0009f8  0a000004          BEQ      |L1.2576|
0009fc  e59f4400          LDR      r4,|L1.3588|
000a00  e1530004          CMP      r3,r4
000a04  0a000001          BEQ      |L1.2576|
000a08  e3530a01          CMP      r3,#0x1000
000a0c  1a000016          BNE      |L1.2668|
                  |L1.2576|
;;;560        {
;;;561            switch (eDevice)
000a10  e3510000          CMP      r1,#0
000a14  0a000002          BEQ      |L1.2596|
000a18  e3510001          CMP      r1,#1
000a1c  1a00000e          BNE      |L1.2652|
000a20  ea000006          B        |L1.2624|
                  |L1.2596|
;;;562            {
;;;563                case QSPIC_DEV_0:
000a24  e320f000          NOP      
;;;564                    {
;;;565                        *eEnable = (qspic_en_e) biGetQSPIC_DirAccCtrl0_PollWIP(eController);
000a28  e59f43d8          LDR      r4,|L1.3592|
000a2c  e0844003          ADD      r4,r4,r3
000a30  e5944008          LDR      r4,[r4,#8]
000a34  e7e04354          UBFX     r4,r4,#6,#1
000a38  e5c24000          STRB     r4,[r2,#0]
;;;566                    }
;;;567                    break;
000a3c  ea000009          B        |L1.2664|
                  |L1.2624|
;;;568                case QSPIC_DEV_1:
000a40  e320f000          NOP      
;;;569                    {
;;;570                        *eEnable = (qspic_en_e) biGetQSPIC_DirAccCtrl1_PollWIP(eController);
000a44  e59f43bc          LDR      r4,|L1.3592|
000a48  e0844003          ADD      r4,r4,r3
000a4c  e594400c          LDR      r4,[r4,#0xc]
000a50  e7e04354          UBFX     r4,r4,#6,#1
000a54  e5c24000          STRB     r4,[r2,#0]
;;;571                    }
;;;572                    break;
000a58  ea000002          B        |L1.2664|
                  |L1.2652|
;;;573                default:
000a5c  e320f000          NOP      
;;;574                    {
;;;575                        i32Res = C_FAILED;
000a60  e3e00000          MVN      r0,#0
;;;576                    }
;;;577                    break;
000a64  e320f000          NOP      
                  |L1.2664|
000a68  ea000000          B        |L1.2672|
                  |L1.2668|
;;;578            }
;;;579        }
;;;580        else
;;;581        {
;;;582            i32Res = C_FAILED;
000a6c  e3e00000          MVN      r0,#0
                  |L1.2672|
;;;583        }
;;;584    
;;;585        return i32Res;
;;;586    }
000a70  e8bd8010          POP      {r4,pc}
;;;587    
                          ENDP

                  i32QSPIC_DirectSetCSDeassertionTime PROC
;;;590    
;;;591    int32_t i32QSPIC_DirectSetCSDeassertionTime(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8CSTime)
000a74  e92d4030          PUSH     {r4,r5,lr}
;;;592    {
000a78  e1a03000          MOV      r3,r0
;;;593        int32_t i32Res = C_SUCCESS;
000a7c  e3a00000          MOV      r0,#0
;;;594    
;;;595        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000a80  e3530000          CMP      r3,#0
000a84  0a000004          BEQ      |L1.2716|
000a88  e59f4374          LDR      r4,|L1.3588|
000a8c  e1530004          CMP      r3,r4
000a90  0a000001          BEQ      |L1.2716|
000a94  e3530a01          CMP      r3,#0x1000
000a98  1a00001a          BNE      |L1.2824|
                  |L1.2716|
;;;596        {
;;;597            switch (eDevice)
000a9c  e3510000          CMP      r1,#0
000aa0  0a000002          BEQ      |L1.2736|
000aa4  e3510001          CMP      r1,#1
000aa8  1a000012          BNE      |L1.2808|
000aac  ea000008          B        |L1.2772|
                  |L1.2736|
;;;598            {
;;;599                case QSPIC_DEV_0:
000ab0  e320f000          NOP      
;;;600                    {
;;;601                        vSetQSPIC_DirAccCtrl0_SCSD(eController, u8CSTime);
000ab4  e59f434c          LDR      r4,|L1.3592|
000ab8  e0844003          ADD      r4,r4,r3
000abc  e5944008          LDR      r4,[r4,#8]
000ac0  e7cf4412          BFI      r4,r2,#8,#8
000ac4  e59f533c          LDR      r5,|L1.3592|
000ac8  e0855003          ADD      r5,r5,r3
000acc  e5854008          STR      r4,[r5,#8]
;;;602                    }
;;;603                    break;
000ad0  ea00000b          B        |L1.2820|
                  |L1.2772|
;;;604                case QSPIC_DEV_1:
000ad4  e320f000          NOP      
;;;605                    {
;;;606                        vSetQSPIC_DirAccCtrl1_SCSD(eController, u8CSTime);
000ad8  e59f4328          LDR      r4,|L1.3592|
000adc  e0844003          ADD      r4,r4,r3
000ae0  e594400c          LDR      r4,[r4,#0xc]
000ae4  e7cf4412          BFI      r4,r2,#8,#8
000ae8  e59f5318          LDR      r5,|L1.3592|
000aec  e0855003          ADD      r5,r5,r3
000af0  e585400c          STR      r4,[r5,#0xc]
;;;607                    }
;;;608                    break;
000af4  ea000002          B        |L1.2820|
                  |L1.2808|
;;;609                default:
000af8  e320f000          NOP      
;;;610                    {
;;;611                        i32Res = C_FAILED;
000afc  e3e00000          MVN      r0,#0
;;;612                    }
;;;613                    break;
000b00  e320f000          NOP      
                  |L1.2820|
000b04  ea000000          B        |L1.2828|
                  |L1.2824|
;;;614            }
;;;615        }
;;;616        else
;;;617        {
;;;618            i32Res = C_FAILED;
000b08  e3e00000          MVN      r0,#0
                  |L1.2828|
;;;619        }
;;;620    
;;;621        return i32Res;
;;;622    }
000b0c  e8bd8030          POP      {r4,r5,pc}
;;;623    
                          ENDP

                  i32QSPIC_DirectGetCSDeassertionTime PROC
;;;626    
;;;627    int32_t i32QSPIC_DirectGetCSDeassertionTime(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t * u8CSTime)
000b10  e92d4010          PUSH     {r4,lr}
;;;628    {
000b14  e1a03000          MOV      r3,r0
;;;629        int32_t i32Res = C_SUCCESS;
000b18  e3a00000          MOV      r0,#0
;;;630    
;;;631        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000b1c  e3530000          CMP      r3,#0
000b20  0a000004          BEQ      |L1.2872|
000b24  e59f42d8          LDR      r4,|L1.3588|
000b28  e1530004          CMP      r3,r4
000b2c  0a000001          BEQ      |L1.2872|
000b30  e3530a01          CMP      r3,#0x1000
000b34  1a000016          BNE      |L1.2964|
                  |L1.2872|
;;;632        {
;;;633            switch (eDevice)
000b38  e3510000          CMP      r1,#0
000b3c  0a000002          BEQ      |L1.2892|
000b40  e3510001          CMP      r1,#1
000b44  1a00000e          BNE      |L1.2948|
000b48  ea000006          B        |L1.2920|
                  |L1.2892|
;;;634            {
;;;635                case QSPIC_DEV_0:
000b4c  e320f000          NOP      
;;;636                    {
;;;637                        *u8CSTime = biGetQSPIC_DirAccCtrl0_SCSD(eController);
000b50  e59f42b0          LDR      r4,|L1.3592|
000b54  e0844003          ADD      r4,r4,r3
000b58  e5944008          LDR      r4,[r4,#8]
000b5c  e1a04424          LSR      r4,r4,#8
000b60  e5c24000          STRB     r4,[r2,#0]
;;;638                    }
;;;639                    break;
000b64  ea000009          B        |L1.2960|
                  |L1.2920|
;;;640                case QSPIC_DEV_1:
000b68  e320f000          NOP      
;;;641                    {
;;;642                        *u8CSTime = biGetQSPIC_DirAccCtrl1_SCSD(eController);
000b6c  e59f4294          LDR      r4,|L1.3592|
000b70  e0844003          ADD      r4,r4,r3
000b74  e594400c          LDR      r4,[r4,#0xc]
000b78  e1a04424          LSR      r4,r4,#8
000b7c  e5c24000          STRB     r4,[r2,#0]
;;;643                    }
;;;644                    break;
000b80  ea000002          B        |L1.2960|
                  |L1.2948|
;;;645                default:
000b84  e320f000          NOP      
;;;646                    {
;;;647                        i32Res = C_FAILED;
000b88  e3e00000          MVN      r0,#0
;;;648                    }
;;;649                    break;
000b8c  e320f000          NOP      
                  |L1.2960|
000b90  ea000000          B        |L1.2968|
                  |L1.2964|
;;;650            }
;;;651        }
;;;652        else
;;;653        {
;;;654            i32Res = C_FAILED;
000b94  e3e00000          MVN      r0,#0
                  |L1.2968|
;;;655        }
;;;656    
;;;657        return i32Res;
;;;658    }
000b98  e8bd8010          POP      {r4,pc}
;;;659    
                          ENDP

                  i32QSPIC_PgrmSetCSDeassertionTime PROC
;;;662    
;;;663    int32_t i32QSPIC_PgrmSetCSDeassertionTime(qspic_cntrl_e eController, uint8_t u8CSTime)
000b9c  e92d4010          PUSH     {r4,lr}
;;;664    {
000ba0  e1a02000          MOV      r2,r0
;;;665        int32_t i32Res = C_SUCCESS;
000ba4  e3a00000          MOV      r0,#0
;;;666    
;;;667        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000ba8  e3520000          CMP      r2,#0
000bac  0a000004          BEQ      |L1.3012|
000bb0  e59f324c          LDR      r3,|L1.3588|
000bb4  e1520003          CMP      r2,r3
000bb8  0a000001          BEQ      |L1.3012|
000bbc  e3520a01          CMP      r2,#0x1000
000bc0  1a000007          BNE      |L1.3044|
                  |L1.3012|
;;;668        {
;;;669            vSetQSPIC_PrgAccCtrl0_SCSD(eController, u8CSTime);
000bc4  e59f323c          LDR      r3,|L1.3592|
000bc8  e0833002          ADD      r3,r3,r2
000bcc  e5933400          LDR      r3,[r3,#0x400]
000bd0  e7cf3411          BFI      r3,r1,#8,#8
000bd4  e59f422c          LDR      r4,|L1.3592|
000bd8  e0844002          ADD      r4,r4,r2
000bdc  e5843400          STR      r3,[r4,#0x400]
000be0  ea000000          B        |L1.3048|
                  |L1.3044|
;;;670        }
;;;671        else
;;;672        {
;;;673            i32Res = C_FAILED;
000be4  e3e00000          MVN      r0,#0
                  |L1.3048|
;;;674        }
;;;675    
;;;676        return i32Res;
;;;677    }
000be8  e8bd8010          POP      {r4,pc}
;;;678    
                          ENDP

                  i32QSPIC_PgrmGetCSDeassertionTime PROC
;;;681    
;;;682    int32_t i32QSPIC_PgrmGetCSDeassertionTime(qspic_cntrl_e eController, uint8_t * u8CSTime)
000bec  e1a02000          MOV      r2,r0
;;;683    {
;;;684        int32_t i32Res = C_SUCCESS;
000bf0  e3a00000          MOV      r0,#0
;;;685    
;;;686        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000bf4  e3520000          CMP      r2,#0
000bf8  0a000004          BEQ      |L1.3088|
000bfc  e59f3200          LDR      r3,|L1.3588|
000c00  e1520003          CMP      r2,r3
000c04  0a000001          BEQ      |L1.3088|
000c08  e3520a01          CMP      r2,#0x1000
000c0c  1a000005          BNE      |L1.3112|
                  |L1.3088|
;;;687        {
;;;688            *u8CSTime = biGetQSPIC_PrgAccCtrl0_SCSD(eController);
000c10  e59f31f0          LDR      r3,|L1.3592|
000c14  e0833002          ADD      r3,r3,r2
000c18  e5933400          LDR      r3,[r3,#0x400]
000c1c  e1a03423          LSR      r3,r3,#8
000c20  e5c13000          STRB     r3,[r1,#0]
000c24  ea000000          B        |L1.3116|
                  |L1.3112|
;;;689        }
;;;690        else
;;;691        {
;;;692            i32Res = C_FAILED;
000c28  e3e00000          MVN      r0,#0
                  |L1.3116|
;;;693        }
;;;694    
;;;695        return i32Res;
;;;696    }
000c2c  e12fff1e          BX       lr
;;;697    
                          ENDP

                  i32QSPIC_DirectSetDataCaptureEdge PROC
;;;700    
;;;701    int32_t i32QSPIC_DirectSetDataCaptureEdge(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_sdce_e eEdge)
000c30  e92d4030          PUSH     {r4,r5,lr}
;;;702    {
000c34  e1a03000          MOV      r3,r0
;;;703        int32_t i32Res = C_SUCCESS;
000c38  e3a00000          MOV      r0,#0
;;;704    
;;;705        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000c3c  e3530000          CMP      r3,#0
000c40  0a000004          BEQ      |L1.3160|
000c44  e59f41b8          LDR      r4,|L1.3588|
000c48  e1530004          CMP      r3,r4
000c4c  0a000001          BEQ      |L1.3160|
000c50  e3530a01          CMP      r3,#0x1000
000c54  1a00001a          BNE      |L1.3268|
                  |L1.3160|
;;;706        {
;;;707            switch (eDevice)
000c58  e3510000          CMP      r1,#0
000c5c  0a000002          BEQ      |L1.3180|
000c60  e3510001          CMP      r1,#1
000c64  1a000012          BNE      |L1.3252|
000c68  ea000008          B        |L1.3216|
                  |L1.3180|
;;;708            {
;;;709                case QSPIC_DEV_0:
000c6c  e320f000          NOP      
;;;710                    {
;;;711                        vSetQSPIC_DirAccCtrl0_SDCE(eController, eEdge);
000c70  e59f4190          LDR      r4,|L1.3592|
000c74  e0844003          ADD      r4,r4,r3
000c78  e5944008          LDR      r4,[r4,#8]
000c7c  e7c54212          BFI      r4,r2,#4,#2
000c80  e59f5180          LDR      r5,|L1.3592|
000c84  e0855003          ADD      r5,r5,r3
000c88  e5854008          STR      r4,[r5,#8]
;;;712                    }
;;;713                    break;
000c8c  ea00000b          B        |L1.3264|
                  |L1.3216|
;;;714                case QSPIC_DEV_1:
000c90  e320f000          NOP      
;;;715                    {
;;;716                        vSetQSPIC_DirAccCtrl1_SDCE(eController, eEdge);
000c94  e59f416c          LDR      r4,|L1.3592|
000c98  e0844003          ADD      r4,r4,r3
000c9c  e594400c          LDR      r4,[r4,#0xc]
000ca0  e7c54212          BFI      r4,r2,#4,#2
000ca4  e59f515c          LDR      r5,|L1.3592|
000ca8  e0855003          ADD      r5,r5,r3
000cac  e585400c          STR      r4,[r5,#0xc]
;;;717                    }
;;;718                    break;
000cb0  ea000002          B        |L1.3264|
                  |L1.3252|
;;;719                default:
000cb4  e320f000          NOP      
;;;720                    {
;;;721                        i32Res = C_FAILED;
000cb8  e3e00000          MVN      r0,#0
;;;722                    }
;;;723                    break;
000cbc  e320f000          NOP      
                  |L1.3264|
000cc0  ea000000          B        |L1.3272|
                  |L1.3268|
;;;724            }
;;;725        }
;;;726        else
;;;727        {
;;;728            i32Res = C_FAILED;
000cc4  e3e00000          MVN      r0,#0
                  |L1.3272|
;;;729        }
;;;730    
;;;731        return i32Res;
;;;732    }
000cc8  e8bd8030          POP      {r4,r5,pc}
;;;733    
                          ENDP

                  i32QSPIC_DirectGetDataCaptureEdge PROC
;;;736    
;;;737    int32_t i32QSPIC_DirectGetDataCaptureEdge(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_sdce_e * eEdge)
000ccc  e92d4010          PUSH     {r4,lr}
;;;738    {
000cd0  e1a03000          MOV      r3,r0
;;;739        int32_t i32Res = C_SUCCESS;
000cd4  e3a00000          MOV      r0,#0
;;;740    
;;;741        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000cd8  e3530000          CMP      r3,#0
000cdc  0a000004          BEQ      |L1.3316|
000ce0  e59f411c          LDR      r4,|L1.3588|
000ce4  e1530004          CMP      r3,r4
000ce8  0a000001          BEQ      |L1.3316|
000cec  e3530a01          CMP      r3,#0x1000
000cf0  1a000016          BNE      |L1.3408|
                  |L1.3316|
;;;742        {
;;;743            switch (eDevice)
000cf4  e3510000          CMP      r1,#0
000cf8  0a000002          BEQ      |L1.3336|
000cfc  e3510001          CMP      r1,#1
000d00  1a00000e          BNE      |L1.3392|
000d04  ea000006          B        |L1.3364|
                  |L1.3336|
;;;744            {
;;;745                case QSPIC_DEV_0:
000d08  e320f000          NOP      
;;;746                    {
;;;747                        *eEdge = (qspic_sdce_e) biGetQSPIC_DirAccCtrl0_SDCE(eController);
000d0c  e59f40f4          LDR      r4,|L1.3592|
000d10  e0844003          ADD      r4,r4,r3
000d14  e5944008          LDR      r4,[r4,#8]
000d18  e7e14254          UBFX     r4,r4,#4,#2
000d1c  e5c24000          STRB     r4,[r2,#0]
;;;748                    }
;;;749                    break;
000d20  ea000009          B        |L1.3404|
                  |L1.3364|
;;;750                case QSPIC_DEV_1:
000d24  e320f000          NOP      
;;;751                    {
;;;752                        *eEdge = (qspic_sdce_e) biGetQSPIC_DirAccCtrl1_SDCE(eController);
000d28  e59f40d8          LDR      r4,|L1.3592|
000d2c  e0844003          ADD      r4,r4,r3
000d30  e594400c          LDR      r4,[r4,#0xc]
000d34  e7e14254          UBFX     r4,r4,#4,#2
000d38  e5c24000          STRB     r4,[r2,#0]
;;;753                    }
;;;754                    break;
000d3c  ea000002          B        |L1.3404|
                  |L1.3392|
;;;755                default:
000d40  e320f000          NOP      
;;;756                    {
;;;757                        i32Res = C_FAILED;
000d44  e3e00000          MVN      r0,#0
;;;758                    }
;;;759                    break;
000d48  e320f000          NOP      
                  |L1.3404|
000d4c  ea000000          B        |L1.3412|
                  |L1.3408|
;;;760            }
;;;761        }
;;;762        else
;;;763        {
;;;764            i32Res = C_FAILED;
000d50  e3e00000          MVN      r0,#0
                  |L1.3412|
;;;765        }
;;;766    
;;;767        return i32Res;
;;;768    }
000d54  e8bd8010          POP      {r4,pc}
;;;769    
                          ENDP

                  i32QSPIC_PgrmSetDataCaptureEdge PROC
;;;772    
;;;773    int32_t i32QSPIC_PgrmSetDataCaptureEdge(qspic_cntrl_e eController, qspic_sdce_e eEdge)
000d58  e92d4010          PUSH     {r4,lr}
;;;774    {
000d5c  e1a02000          MOV      r2,r0
;;;775        int32_t i32Res = C_SUCCESS;
000d60  e3a00000          MOV      r0,#0
;;;776    
;;;777        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000d64  e3520000          CMP      r2,#0
000d68  0a000004          BEQ      |L1.3456|
000d6c  e59f3090          LDR      r3,|L1.3588|
000d70  e1520003          CMP      r2,r3
000d74  0a000001          BEQ      |L1.3456|
000d78  e3520a01          CMP      r2,#0x1000
000d7c  1a000007          BNE      |L1.3488|
                  |L1.3456|
;;;778        {
;;;779            vSetQSPIC_PrgAccCtrl0_SDCE(eController, eEdge);
000d80  e59f3080          LDR      r3,|L1.3592|
000d84  e0833002          ADD      r3,r3,r2
000d88  e5933400          LDR      r3,[r3,#0x400]
000d8c  e7c53211          BFI      r3,r1,#4,#2
000d90  e59f4070          LDR      r4,|L1.3592|
000d94  e0844002          ADD      r4,r4,r2
000d98  e5843400          STR      r3,[r4,#0x400]
000d9c  ea000000          B        |L1.3492|
                  |L1.3488|
;;;780        }
;;;781        else
;;;782        {
;;;783            i32Res = C_FAILED;
000da0  e3e00000          MVN      r0,#0
                  |L1.3492|
;;;784        }
;;;785    
;;;786        return i32Res;
;;;787    }
000da4  e8bd8010          POP      {r4,pc}
;;;788    
                          ENDP

                  i32QSPIC_PgrmGetDataCaptureEdge PROC
;;;791    
;;;792    int32_t i32QSPIC_PgrmGetDataCaptureEdge(qspic_cntrl_e eController, qspic_sdce_e * eEdge)
000da8  e1a02000          MOV      r2,r0
;;;793    {
;;;794        int32_t i32Res = C_SUCCESS;
000dac  e3a00000          MOV      r0,#0
;;;795    
;;;796        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000db0  e3520000          CMP      r2,#0
000db4  0a000004          BEQ      |L1.3532|
000db8  e59f3044          LDR      r3,|L1.3588|
000dbc  e1520003          CMP      r2,r3
000dc0  0a000001          BEQ      |L1.3532|
000dc4  e3520a01          CMP      r2,#0x1000
000dc8  1a000005          BNE      |L1.3556|
                  |L1.3532|
;;;797        {
;;;798            *eEdge = (qspic_sdce_e) biGetQSPIC_PrgAccCtrl0_SDCE(eController);
000dcc  e59f3034          LDR      r3,|L1.3592|
000dd0  e0833002          ADD      r3,r3,r2
000dd4  e5933400          LDR      r3,[r3,#0x400]
000dd8  e7e13253          UBFX     r3,r3,#4,#2
000ddc  e5c13000          STRB     r3,[r1,#0]
000de0  ea000000          B        |L1.3560|
                  |L1.3556|
;;;799        }
;;;800        else
;;;801        {
;;;802            i32Res = C_FAILED;
000de4  e3e00000          MVN      r0,#0
                  |L1.3560|
;;;803        }
;;;804    
;;;805        return i32Res;
;;;806    }
000de8  e12fff1e          BX       lr
                  |L1.3564|
                          DCD      au8LLDD_QSPIC_C_REVISION
                  |L1.3568|
                          DCD      au8LLDD_QSPIC_C_TAG
                  |L1.3572|
                          DCD      au8LLDD_QSPIC_H_REVISION
                  |L1.3576|
                          DCD      au8LLDD_QSPIC_H_TAG
                  |L1.3580|
                          DCD      au8LLDD_QSPIC_IO_H_REVISION
                  |L1.3584|
                          DCD      au8LLDD_QSPIC_IO_H_TAG
                  |L1.3588|
                          DCD      0x00af8000
                  |L1.3592|
                          DCD      0xc0109000
                  |L1.3596|
                          DCD      ePrgAddressByteCnt
                          ENDP

                  i32QSPIC_EnableInterrupt PROC
;;;810    
;;;811    int32_t i32QSPIC_EnableInterrupt(qspic_cntrl_e eController, qspic_en_e eEnable)
000e10  e92d4010          PUSH     {r4,lr}
;;;812    {
000e14  e1a02000          MOV      r2,r0
;;;813        int32_t i32Res = C_SUCCESS;
000e18  e3a00000          MOV      r0,#0
;;;814    
;;;815        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000e1c  e3520000          CMP      r2,#0
000e20  0a000004          BEQ      |L1.3640|
000e24  e51f3028          LDR      r3,|L1.3588|
000e28  e1520003          CMP      r2,r3
000e2c  0a000001          BEQ      |L1.3640|
000e30  e3520a01          CMP      r2,#0x1000
000e34  1a000007          BNE      |L1.3672|
                  |L1.3640|
;;;816        {
;;;817            vSetQSPIC_PrgAccIntEn_SpiIntEn(eController, eEnable);
000e38  e51f3038          LDR      r3,|L1.3592|
000e3c  e0833002          ADD      r3,r3,r2
000e40  e5933408          LDR      r3,[r3,#0x408]
000e44  e7c03011          BFI      r3,r1,#0,#1
000e48  e51f4048          LDR      r4,|L1.3592|
000e4c  e0844002          ADD      r4,r4,r2
000e50  e5843408          STR      r3,[r4,#0x408]
000e54  ea000000          B        |L1.3676|
                  |L1.3672|
;;;818        }
;;;819        else
;;;820        {
;;;821            i32Res = C_FAILED;
000e58  e3e00000          MVN      r0,#0
                  |L1.3676|
;;;822        }
;;;823    
;;;824        return i32Res;
;;;825    }
000e5c  e8bd8010          POP      {r4,pc}
;;;826    
                          ENDP

                  i32QSPIC_GetInterruptStatus PROC
;;;829    
;;;830    int32_t i32QSPIC_GetInterruptStatus(qspic_cntrl_e eController, qspic_en_e * eEnable)
000e60  e1a02000          MOV      r2,r0
;;;831    {
;;;832        int32_t i32Res = C_SUCCESS;
000e64  e3a00000          MOV      r0,#0
;;;833    
;;;834        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000e68  e3520000          CMP      r2,#0
000e6c  0a000004          BEQ      |L1.3716|
000e70  e51f3074          LDR      r3,|L1.3588|
000e74  e1520003          CMP      r2,r3
000e78  0a000001          BEQ      |L1.3716|
000e7c  e3520a01          CMP      r2,#0x1000
000e80  1a000005          BNE      |L1.3740|
                  |L1.3716|
;;;835        {
;;;836            *eEnable = (qspic_en_e) biGetQSPIC_PrgAccIntEn_SpiIntEn(eController);
000e84  e51f3084          LDR      r3,|L1.3592|
000e88  e0833002          ADD      r3,r3,r2
000e8c  e5933408          LDR      r3,[r3,#0x408]
000e90  e2033001          AND      r3,r3,#1
000e94  e5c13000          STRB     r3,[r1,#0]
000e98  ea000000          B        |L1.3744|
                  |L1.3740|
;;;837        }
;;;838        else
;;;839        {
;;;840            i32Res = C_FAILED;
000e9c  e3e00000          MVN      r0,#0
                  |L1.3744|
;;;841        }
;;;842    
;;;843        return i32Res;
;;;844    }
000ea0  e12fff1e          BX       lr
;;;845    
                          ENDP

                  i32QSPIC_IsSpiCycleDone PROC
;;;849    
;;;850    int32_t i32QSPIC_IsSpiCycleDone(qspic_cntrl_e eController, bool_t * bResult)
000ea4  e92d4010          PUSH     {r4,lr}
;;;851    {
000ea8  e1a02000          MOV      r2,r0
;;;852        int32_t i32Res = C_SUCCESS;
000eac  e3a00000          MOV      r0,#0
;;;853    
;;;854        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000eb0  e3520000          CMP      r2,#0
000eb4  0a000004          BEQ      |L1.3788|
000eb8  e51f30bc          LDR      r3,|L1.3588|
000ebc  e1520003          CMP      r2,r3
000ec0  0a000001          BEQ      |L1.3788|
000ec4  e3520a01          CMP      r2,#0x1000
000ec8  1a000012          BNE      |L1.3864|
                  |L1.3788|
;;;855        {
;;;856            if ( 1==biGetQSPIC_PrgAccStat_SpiCycDone(eController) )
000ecc  e51f30cc          LDR      r3,|L1.3592|
000ed0  e0833002          ADD      r3,r3,r2
000ed4  e593340c          LDR      r3,[r3,#0x40c]
000ed8  e2033001          AND      r3,r3,#1
000edc  e3530000          CMP      r3,#0
000ee0  0a000009          BEQ      |L1.3852|
;;;857            {
;;;858                /* reset the cycle done flag */
;;;859                vSetQSPIC_PrgAccStat_SpiCycDone(eController, 0);
000ee4  e51f30e4          LDR      r3,|L1.3592|
000ee8  e0833002          ADD      r3,r3,r2
000eec  e593340c          LDR      r3,[r3,#0x40c]
000ef0  e3c33001          BIC      r3,r3,#1
000ef4  e51f40f4          LDR      r4,|L1.3592|
000ef8  e0844002          ADD      r4,r4,r2
000efc  e584340c          STR      r3,[r4,#0x40c]
;;;860                *bResult = C_TRUE;
000f00  e3a03001          MOV      r3,#1
000f04  e5813000          STR      r3,[r1,#0]
000f08  ea000003          B        |L1.3868|
                  |L1.3852|
;;;861            }
;;;862            else
;;;863            {
;;;864                *bResult = C_FALSE;
000f0c  e3a03000          MOV      r3,#0
000f10  e5813000          STR      r3,[r1,#0]
000f14  ea000000          B        |L1.3868|
                  |L1.3864|
;;;865            }
;;;866        }
;;;867        else
;;;868        {
;;;869            i32Res = C_FAILED;
000f18  e3e00000          MVN      r0,#0
                  |L1.3868|
;;;870        }
;;;871    
;;;872        return i32Res;
;;;873    }
000f1c  e8bd8010          POP      {r4,pc}
;;;874    
                          ENDP

                  boQSPIC_IsSpiCycleInPgrs PROC
;;;877    
;;;878    bool_t boQSPIC_IsSpiCycleInPgrs(qspic_cntrl_e eController)
000f20  e1a01000          MOV      r1,r0
;;;879    {
;;;880        bool_t bResult = C_FALSE;
000f24  e3a00000          MOV      r0,#0
;;;881    
;;;882        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000f28  e3510000          CMP      r1,#0
000f2c  0a000004          BEQ      |L1.3908|
000f30  e51f2134          LDR      r2,|L1.3588|
000f34  e1510002          CMP      r1,r2
000f38  0a000001          BEQ      |L1.3908|
000f3c  e3510a01          CMP      r1,#0x1000
000f40  1a000006          BNE      |L1.3936|
                  |L1.3908|
;;;883        {
;;;884            if ( 1==biGetQSPIC_PrgAccStat_SpiCycInPrgrs(eController) )
000f44  e51f2144          LDR      r2,|L1.3592|
000f48  e0822001          ADD      r2,r2,r1
000f4c  e592240c          LDR      r2,[r2,#0x40c]
000f50  e7e020d2          UBFX     r2,r2,#1,#1
000f54  e3520000          CMP      r2,#0
000f58  0a000000          BEQ      |L1.3936|
;;;885            {
;;;886                bResult = C_TRUE;
000f5c  e3a00001          MOV      r0,#1
                  |L1.3936|
;;;887            }
;;;888        }
;;;889        return bResult;
;;;890    }
000f60  e12fff1e          BX       lr
;;;891    
                          ENDP

                  boQSPIC_IsSpiCycleDone PROC
;;;894    
;;;895    bool_t boQSPIC_IsSpiCycleDone(qspic_cntrl_e eController)
000f64  e1a01000          MOV      r1,r0
;;;896    {
;;;897        bool_t bResult = C_FALSE;
000f68  e3a00000          MOV      r0,#0
;;;898    
;;;899        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000f6c  e3510000          CMP      r1,#0
000f70  0a000004          BEQ      |L1.3976|
000f74  e51f2178          LDR      r2,|L1.3588|
000f78  e1510002          CMP      r1,r2
000f7c  0a000001          BEQ      |L1.3976|
000f80  e3510a01          CMP      r1,#0x1000
000f84  1a00000d          BNE      |L1.4032|
                  |L1.3976|
;;;900        {
;;;901            if ( 1==biGetQSPIC_PrgAccStat_SpiCycDone(eController) )
000f88  e51f2188          LDR      r2,|L1.3592|
000f8c  e0822001          ADD      r2,r2,r1
000f90  e592240c          LDR      r2,[r2,#0x40c]
000f94  e2022001          AND      r2,r2,#1
000f98  e3520000          CMP      r2,#0
000f9c  0a000007          BEQ      |L1.4032|
;;;902            {
;;;903                /* reset the cycle done flag */
;;;904                vSetQSPIC_PrgAccStat_SpiCycDone(eController, 0);
000fa0  e51f21a0          LDR      r2,|L1.3592|
000fa4  e0822001          ADD      r2,r2,r1
000fa8  e592240c          LDR      r2,[r2,#0x40c]
000fac  e3c22001          BIC      r2,r2,#1
000fb0  e51f31b0          LDR      r3,|L1.3592|
000fb4  e0833001          ADD      r3,r3,r1
000fb8  e583240c          STR      r2,[r3,#0x40c]
;;;905                bResult = C_TRUE;
000fbc  e3a00001          MOV      r0,#1
                  |L1.4032|
;;;906            }
;;;907        }
;;;908    
;;;909        return bResult;
;;;910    }
000fc0  e12fff1e          BX       lr
;;;911    
                          ENDP

                  i32QSPIC_WaitForCompletion PROC
;;;914    
;;;915    int32_t i32QSPIC_WaitForCompletion(qspic_cntrl_e eController)
000fc4  e92d4010          PUSH     {r4,lr}
;;;916    {
000fc8  e1a03000          MOV      r3,r0
;;;917        int32_t i32Res = C_SUCCESS;
000fcc  e3a04000          MOV      r4,#0
;;;918    
;;;919        if ( (QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController) || (QSPIC_CNTRL_2 == eController) )
000fd0  e3530000          CMP      r3,#0
000fd4  0a000004          BEQ      |L1.4076|
000fd8  e51f01dc          LDR      r0,|L1.3588|
000fdc  e1530000          CMP      r3,r0
000fe0  0a000001          BEQ      |L1.4076|
000fe4  e3530a01          CMP      r3,#0x1000
000fe8  1a000005          BNE      |L1.4100|
                  |L1.4076|
;;;920        {
;;;921            while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) )
000fec  e320f000          NOP      
                  |L1.4080|
000ff0  e1a00003          MOV      r0,r3
000ff4  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
000ff8  e3500001          CMP      r0,#1
000ffc  0afffffb          BEQ      |L1.4080|
001000  ea000000          B        |L1.4104|
                  |L1.4100|
;;;922            {
;;;923                ;
;;;924            }
;;;925        }
;;;926        else
;;;927        {
;;;928            i32Res = C_FAILED;
001004  e3e04000          MVN      r4,#0
                  |L1.4104|
;;;929        }
;;;930    
;;;931        return i32Res;
001008  e1a00004          MOV      r0,r4
;;;932    }
00100c  e8bd8010          POP      {r4,pc}
;;;933    
                          ENDP

                  i32QSPIC_PgrmStatusRead PROC
;;;936    
;;;937    int32_t i32QSPIC_PgrmStatusRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Status)
001010  e92d41f0          PUSH     {r4-r8,lr}
;;;938    {
001014  e1a04000          MOV      r4,r0
001018  e1a05001          MOV      r5,r1
00101c  e1a07002          MOV      r7,r2
;;;939        int32_t i32Res = C_SUCCESS;
001020  e3a08000          MOV      r8,#0
;;;940    
;;;941        /* default values for Prg Access Ctrl value is as follows:
;;;942         * Primary and secondary buffer size = 0, both buffers are disabled
;;;943         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;944         * SpiCycGo = Program Register Access is initiated.
;;;945         */
;;;946        uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001024  e3a06001          MOV      r6,#1
;;;947    
;;;948        if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001028  e3540000          CMP      r4,#0
00102c  0a000002          BEQ      |L1.4156|
001030  e51f0234          LDR      r0,|L1.3588|
001034  e1540000          CMP      r4,r0
001038  1a000003          BNE      |L1.4172|
                  |L1.4156|
;;;949                        (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
00103c  e3550000          CMP      r5,#0
001040  0a000005          BEQ      |L1.4188|
001044  e3550001          CMP      r5,#1
001048  0a000003          BEQ      |L1.4188|
                  |L1.4172|
;;;950            || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
00104c  e3540a01          CMP      r4,#0x1000
001050  1a00002a          BNE      |L1.4352|
001054  e3550000          CMP      r5,#0
001058  1a000028          BNE      |L1.4352|
                  |L1.4188|
;;;951        {
;;;952            /* check for valid status pointer */
;;;953            if (C_NULL == pu8Status)
00105c  e3570000          CMP      r7,#0
001060  1a000001          BNE      |L1.4204|
;;;954            {
;;;955                i32Res = C_FAILED;
001064  e3e08000          MVN      r8,#0
001068  ea000025          B        |L1.4356|
                  |L1.4204|
;;;956            }
;;;957            else
;;;958            {
;;;959                /* wait for cycle completion of previous program access */
;;;960                while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
00106c  e320f000          NOP      
                  |L1.4208|
001070  e1a00004          MOV      r0,r4
001074  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001078  e3500001          CMP      r0,#1
00107c  0afffffb          BEQ      |L1.4208|
;;;961    
;;;962                /* set up STATUS READ opcode */
;;;963                vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_STS_READ);
001080  e3a00005          MOV      r0,#5
001084  e59f1e40          LDR      r1,|L1.7884|
001088  e7c40001          STRB     r0,[r4,r1]
;;;964    
;;;965                if (QSPIC_DEV_1 == eDevice )
00108c  e3550001          CMP      r5,#1
001090  1a000000          BNE      |L1.4248|
;;;966                {
;;;967                    /* set SPI_CS1_N accordingly */
;;;968                    u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001094  e3866002          ORR      r6,r6,#2
                  |L1.4248|
;;;969                }
;;;970    
;;;971                if ( QSPIC_CNTRL_2 == eController )
001098  e3540a01          CMP      r4,#0x1000
00109c  1a000001          BNE      |L1.4264|
;;;972                {
;;;973                    /* for QSPIC_CNTRL_2 the data is always transmitted in secondary buffer */
;;;974                    u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
0010a0  e3866020          ORR      r6,r6,#0x20
0010a4  ea000000          B        |L1.4268|
                  |L1.4264|
;;;975                }
;;;976                else
;;;977                {
;;;978                    /* for other controllers the data is transmitted in primary buffer */
;;;979                    /* set primary buffer byte counter 1 */
;;;980                    u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
0010a8  e3866801          ORR      r6,r6,#0x10000
                  |L1.4268|
;;;981                }
;;;982                /* enable primary buffer */
;;;983                u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
0010ac  e3866010          ORR      r6,r6,#0x10
;;;984    
;;;985                /* write value to register */
;;;986                vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
0010b0  e51f02b0          LDR      r0,|L1.3592|
0010b4  e0800004          ADD      r0,r0,r4
0010b8  e5806404          STR      r6,[r0,#0x404]
;;;987    
;;;988                /* wait until current program access cycle is completed */
;;;989                while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
0010bc  e320f000          NOP      
                  |L1.4288|
0010c0  e1a00004          MOV      r0,r4
0010c4  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0010c8  e3500000          CMP      r0,#0
0010cc  0afffffb          BEQ      |L1.4288|
;;;990    
;;;991                if ( QSPIC_CNTRL_2 == eController )
0010d0  e3540a01          CMP      r4,#0x1000
0010d4  1a000003          BNE      |L1.4328|
;;;992                {
;;;993                    /* retrieve the status */
;;;994                    *pu8Status = u8GetQSPIC_SecBufDatN(eController, 0);
0010d8  e59f0df0          LDR      r0,|L1.7888|
0010dc  e7d40000          LDRB     r0,[r4,r0]
0010e0  e5c70000          STRB     r0,[r7,#0]
0010e4  ea000003          B        |L1.4344|
                  |L1.4328|
;;;995                }
;;;996                else
;;;997                {
;;;998                    /* retrieve the status */
;;;999                    *pu8Status = u8GetQSPIC_PriBufDatN(eController, 1);
0010e8  e59f0ddc          LDR      r0,|L1.7884|
0010ec  e0800004          ADD      r0,r0,r4
0010f0  e5d00001          LDRB     r0,[r0,#1]
0010f4  e5c70000          STRB     r0,[r7,#0]
                  |L1.4344|
;;;1000               }
;;;1001   
;;;1002               i32Res = C_SUCCESS;
0010f8  e3a08000          MOV      r8,#0
0010fc  ea000000          B        |L1.4356|
                  |L1.4352|
;;;1003           }
;;;1004       }
;;;1005       else
;;;1006       {
;;;1007           i32Res = C_FAILED;
001100  e3e08000          MVN      r8,#0
                  |L1.4356|
;;;1008       }
;;;1009   
;;;1010       return i32Res;
001104  e1a00008          MOV      r0,r8
;;;1011   }
001108  e8bd81f0          POP      {r4-r8,pc}
;;;1012   
                          ENDP

                  i32QSPIC_PgrmStatusFlagRead PROC
;;;1015   
;;;1016   int32_t i32QSPIC_PgrmStatusFlagRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Status)
00110c  e92d41f0          PUSH     {r4-r8,lr}
;;;1017   {
001110  e1a04000          MOV      r4,r0
001114  e1a05001          MOV      r5,r1
001118  e1a07002          MOV      r7,r2
;;;1018       int32_t i32Res = C_SUCCESS;
00111c  e3a08000          MOV      r8,#0
;;;1019   
;;;1020       /* default values for Prg Access Ctrl value is as follows:
;;;1021        * Primary and secondary buffer size = 0, both buffers are disabled
;;;1022        * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1023        * SpiCycGo = Program Register Access is initiated.
;;;1024        */
;;;1025       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001120  e3a06001          MOV      r6,#1
;;;1026   
;;;1027       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001124  e3540000          CMP      r4,#0
001128  0a000002          BEQ      |L1.4408|
00112c  e51f0330          LDR      r0,|L1.3588|
001130  e1540000          CMP      r4,r0
001134  1a000003          BNE      |L1.4424|
                  |L1.4408|
;;;1028                       (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
001138  e3550000          CMP      r5,#0
00113c  0a000005          BEQ      |L1.4440|
001140  e3550001          CMP      r5,#1
001144  0a000003          BEQ      |L1.4440|
                  |L1.4424|
;;;1029           || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001148  e3540a01          CMP      r4,#0x1000
00114c  1a00002a          BNE      |L1.4604|
001150  e3550000          CMP      r5,#0
001154  1a000028          BNE      |L1.4604|
                  |L1.4440|
;;;1030       {
;;;1031           /* check for valid status pointer */
;;;1032           if (C_NULL == pu8Status)
001158  e3570000          CMP      r7,#0
00115c  1a000001          BNE      |L1.4456|
;;;1033           {
;;;1034               i32Res = C_FAILED;
001160  e3e08000          MVN      r8,#0
001164  ea000025          B        |L1.4608|
                  |L1.4456|
;;;1035           }
;;;1036           else
;;;1037           {
;;;1038               /* wait for cycle completion of previous program access */
;;;1039               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001168  e320f000          NOP      
                  |L1.4460|
00116c  e1a00004          MOV      r0,r4
001170  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001174  e3500001          CMP      r0,#1
001178  0afffffb          BEQ      |L1.4460|
;;;1040   
;;;1041               /* set up STATUS READ opcode */
;;;1042               vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_RFST_READ);
00117c  e3a00070          MOV      r0,#0x70
001180  e59f1d44          LDR      r1,|L1.7884|
001184  e7c40001          STRB     r0,[r4,r1]
;;;1043   
;;;1044               if (QSPIC_DEV_1 == eDevice )
001188  e3550001          CMP      r5,#1
00118c  1a000000          BNE      |L1.4500|
;;;1045               {
;;;1046                   /* set SPI_CS1_N accordingly */
;;;1047                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001190  e3866002          ORR      r6,r6,#2
                  |L1.4500|
;;;1048               }
;;;1049   
;;;1050               if ( QSPIC_CNTRL_2 == eController )
001194  e3540a01          CMP      r4,#0x1000
001198  1a000001          BNE      |L1.4516|
;;;1051               {
;;;1052                   /* for QSPIC_CNTRL_2 the data is always transmitted in secondary buffer */
;;;1053                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
00119c  e3866020          ORR      r6,r6,#0x20
0011a0  ea000000          B        |L1.4520|
                  |L1.4516|
;;;1054               }
;;;1055               else
;;;1056               {
;;;1057                   /* for other controllers the data is transmitted in primary buffer */
;;;1058                   /* set primary buffer byte counter 1 */
;;;1059                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
0011a4  e3866801          ORR      r6,r6,#0x10000
                  |L1.4520|
;;;1060               }
;;;1061               /* enable primary buffer */
;;;1062               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
0011a8  e3866010          ORR      r6,r6,#0x10
;;;1063   
;;;1064               /* write value to register */
;;;1065               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
0011ac  e51f03ac          LDR      r0,|L1.3592|
0011b0  e0800004          ADD      r0,r0,r4
0011b4  e5806404          STR      r6,[r0,#0x404]
;;;1066   
;;;1067               /* wait until current program access cycle is completed */
;;;1068               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
0011b8  e320f000          NOP      
                  |L1.4540|
0011bc  e1a00004          MOV      r0,r4
0011c0  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0011c4  e3500000          CMP      r0,#0
0011c8  0afffffb          BEQ      |L1.4540|
;;;1069   
;;;1070               if ( QSPIC_CNTRL_2 == eController )
0011cc  e3540a01          CMP      r4,#0x1000
0011d0  1a000003          BNE      |L1.4580|
;;;1071               {
;;;1072                   /* retrieve the status */
;;;1073                   *pu8Status = u8GetQSPIC_SecBufDatN(eController, 0);
0011d4  e59f0cf4          LDR      r0,|L1.7888|
0011d8  e7d40000          LDRB     r0,[r4,r0]
0011dc  e5c70000          STRB     r0,[r7,#0]
0011e0  ea000003          B        |L1.4596|
                  |L1.4580|
;;;1074               }
;;;1075               else
;;;1076               {
;;;1077                   /* retrieve the status */
;;;1078                   *pu8Status = u8GetQSPIC_PriBufDatN(eController, 1);
0011e4  e59f0ce0          LDR      r0,|L1.7884|
0011e8  e0800004          ADD      r0,r0,r4
0011ec  e5d00001          LDRB     r0,[r0,#1]
0011f0  e5c70000          STRB     r0,[r7,#0]
                  |L1.4596|
;;;1079               }
;;;1080   
;;;1081               i32Res = C_SUCCESS;
0011f4  e3a08000          MOV      r8,#0
0011f8  ea000000          B        |L1.4608|
                  |L1.4604|
;;;1082           }
;;;1083       }
;;;1084       else
;;;1085       {
;;;1086           i32Res = C_FAILED;
0011fc  e3e08000          MVN      r8,#0
                  |L1.4608|
;;;1087       }
;;;1088   
;;;1089       return i32Res;
001200  e1a00008          MOV      r0,r8
;;;1090   }
001204  e8bd81f0          POP      {r4-r8,pc}
;;;1091   
                          ENDP

                  i32QSPIC_PgrmClearStatus PROC
;;;1094   
;;;1095   int32_t i32QSPIC_PgrmClearStatus(qspic_cntrl_e eController, qspic_dev_e eDevice)
001208  e92d40f0          PUSH     {r4-r7,lr}
;;;1096   {
00120c  e1a04000          MOV      r4,r0
001210  e1a05001          MOV      r5,r1
;;;1097       int32_t i32Res = C_SUCCESS;
001214  e3a07000          MOV      r7,#0
;;;1098       /* default values for Prg Access Ctrl value is as follows:
;;;1099         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1100         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1101         * SpiCycGo = Program Register Access is initiated.
;;;1102       */
;;;1103       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001218  e3a06001          MOV      r6,#1
;;;1104   
;;;1105   
;;;1106       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
00121c  e3540000          CMP      r4,#0
001220  0a000002          BEQ      |L1.4656|
001224  e51f0428          LDR      r0,|L1.3588|
001228  e1540000          CMP      r4,r0
00122c  1a000003          BNE      |L1.4672|
                  |L1.4656|
;;;1107                       (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
001230  e3550000          CMP      r5,#0
001234  0a000005          BEQ      |L1.4688|
001238  e3550001          CMP      r5,#1
00123c  0a000003          BEQ      |L1.4688|
                  |L1.4672|
;;;1108           || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001240  e3540a01          CMP      r4,#0x1000
001244  1a000016          BNE      |L1.4772|
001248  e3550000          CMP      r5,#0
00124c  1a000014          BNE      |L1.4772|
                  |L1.4688|
;;;1109       {
;;;1110           /* wait for cycle completion of previous program access */
;;;1111           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001250  e320f000          NOP      
                  |L1.4692|
001254  e1a00004          MOV      r0,r4
001258  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
00125c  e3500001          CMP      r0,#1
001260  0afffffb          BEQ      |L1.4692|
;;;1112   
;;;1113           /* set up WRITE ENABLE opcode */
;;;1114           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_STS_CLEAR);
001264  e3a00030          MOV      r0,#0x30
001268  e59f1c5c          LDR      r1,|L1.7884|
00126c  e7c40001          STRB     r0,[r4,r1]
;;;1115   
;;;1116           if (QSPIC_DEV_1 == eDevice )
001270  e3550001          CMP      r5,#1
001274  1a000000          BNE      |L1.4732|
;;;1117           {
;;;1118               /* set SPI_CS1_N accordingly */
;;;1119               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001278  e3866002          ORR      r6,r6,#2
                  |L1.4732|
;;;1120           }
;;;1121   
;;;1122           /* enable primary buffer */
;;;1123           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
00127c  e3866010          ORR      r6,r6,#0x10
;;;1124   
;;;1125           /* write value to register */
;;;1126           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001280  e51f0480          LDR      r0,|L1.3592|
001284  e0800004          ADD      r0,r0,r4
001288  e5806404          STR      r6,[r0,#0x404]
;;;1127   
;;;1128           /* wait until current program access cycle is completed */
;;;1129           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
00128c  e320f000          NOP      
                  |L1.4752|
001290  e1a00004          MOV      r0,r4
001294  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001298  e3500000          CMP      r0,#0
00129c  0afffffb          BEQ      |L1.4752|
0012a0  ea000000          B        |L1.4776|
                  |L1.4772|
;;;1130       }
;;;1131       else
;;;1132       {
;;;1133           i32Res = C_FAILED;
0012a4  e3e07000          MVN      r7,#0
                  |L1.4776|
;;;1134       }
;;;1135   
;;;1136       return i32Res;
0012a8  e1a00007          MOV      r0,r7
;;;1137   }
0012ac  e8bd80f0          POP      {r4-r7,pc}
;;;1138   
                          ENDP

                  i32QSPIC_PgrmReleaseDP PROC
;;;1141   
;;;1142   int32_t i32QSPIC_PgrmReleaseDP(qspic_cntrl_e eController, qspic_dev_e eDevice)
0012b0  e92d40f0          PUSH     {r4-r7,lr}
;;;1143   {
0012b4  e1a04000          MOV      r4,r0
0012b8  e1a05001          MOV      r5,r1
;;;1144       int32_t i32Res = C_SUCCESS;
0012bc  e3a07000          MOV      r7,#0
;;;1145       /* default values for Prg Access Ctrl value is as follows:
;;;1146         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1147         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1148         * SpiCycGo = Program Register Access is initiated.
;;;1149       */
;;;1150       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
0012c0  e3a06001          MOV      r6,#1
;;;1151   
;;;1152   
;;;1153       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
0012c4  e3540000          CMP      r4,#0
0012c8  0a000002          BEQ      |L1.4824|
0012cc  e51f04d0          LDR      r0,|L1.3588|
0012d0  e1540000          CMP      r4,r0
0012d4  1a000003          BNE      |L1.4840|
                  |L1.4824|
;;;1154                       ((eDevice==QSPIC_DEV_0) || ( eDevice==QSPIC_DEV_1)) )
0012d8  e3550000          CMP      r5,#0
0012dc  0a000005          BEQ      |L1.4856|
0012e0  e3550001          CMP      r5,#1
0012e4  0a000003          BEQ      |L1.4856|
                  |L1.4840|
;;;1155           || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
0012e8  e3540a01          CMP      r4,#0x1000
0012ec  1a000016          BNE      |L1.4940|
0012f0  e3550000          CMP      r5,#0
0012f4  1a000014          BNE      |L1.4940|
                  |L1.4856|
;;;1156       {
;;;1157           /* wait for cycle completion of previous program access */
;;;1158           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
0012f8  e320f000          NOP      
                  |L1.4860|
0012fc  e1a00004          MOV      r0,r4
001300  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001304  e3500001          CMP      r0,#1
001308  0afffffb          BEQ      |L1.4860|
;;;1159   
;;;1160           /* set up WRITE ENABLE opcode */
;;;1161           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_RELEASE_DP);
00130c  e3a000ab          MOV      r0,#0xab
001310  e59f1bb4          LDR      r1,|L1.7884|
001314  e7c40001          STRB     r0,[r4,r1]
;;;1162   
;;;1163           if (QSPIC_DEV_1 == eDevice )
001318  e3550001          CMP      r5,#1
00131c  1a000000          BNE      |L1.4900|
;;;1164           {
;;;1165               /* set SPI_CS1_N accordingly */
;;;1166               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001320  e3866002          ORR      r6,r6,#2
                  |L1.4900|
;;;1167           }
;;;1168   
;;;1169           /* enable primary buffer */
;;;1170           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001324  e3866010          ORR      r6,r6,#0x10
;;;1171   
;;;1172           /* write value to register */
;;;1173           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001328  e51f0528          LDR      r0,|L1.3592|
00132c  e0800004          ADD      r0,r0,r4
001330  e5806404          STR      r6,[r0,#0x404]
;;;1174   
;;;1175           /* wait until current program access cycle is completed */
;;;1176           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001334  e320f000          NOP      
                  |L1.4920|
001338  e1a00004          MOV      r0,r4
00133c  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001340  e3500000          CMP      r0,#0
001344  0afffffb          BEQ      |L1.4920|
001348  ea000000          B        |L1.4944|
                  |L1.4940|
;;;1177       }
;;;1178       else
;;;1179       {
;;;1180           i32Res = C_FAILED;
00134c  e3e07000          MVN      r7,#0
                  |L1.4944|
;;;1181       }
;;;1182   
;;;1183       return i32Res;
001350  e1a00007          MOV      r0,r7
;;;1184   }
001354  e8bd80f0          POP      {r4-r7,pc}
;;;1185   
                          ENDP

                  i32QSPIC_PgrmGetID PROC
;;;1776   /****************************************************************************/
;;;1777   int32_t i32QSPIC_PgrmGetID(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8ManID, uint8_t* const pu8DevID)
001358  e92d4ff0          PUSH     {r4-r11,lr}
;;;1778   {
00135c  e1a04000          MOV      r4,r0
001360  e1a06001          MOV      r6,r1
001364  e1a0a002          MOV      r10,r2
001368  e1a0b003          MOV      r11,r3
;;;1779       int32_t i32Res;
;;;1780       /* default values for Prg Access Ctrl value is as follows:
;;;1781         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1782         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1783         * SpiCycGo = Program Register Access is initiated.
;;;1784       */
;;;1785       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
00136c  e3a05001          MOV      r5,#1
;;;1786       uint32_t u32Address1, u32Address2;
;;;1787   
;;;1788       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001370  e3540000          CMP      r4,#0
001374  0a000002          BEQ      |L1.4996|
001378  e51f057c          LDR      r0,|L1.3588|
00137c  e1540000          CMP      r4,r0
001380  1a000003          BNE      |L1.5012|
                  |L1.4996|
;;;1789                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
001384  e3560000          CMP      r6,#0
001388  0a000005          BEQ      |L1.5028|
00138c  e3560001          CMP      r6,#1
001390  0a000003          BEQ      |L1.5028|
                  |L1.5012|
;;;1790               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001394  e3540a01          CMP      r4,#0x1000
001398  1a00004b          BNE      |L1.5324|
00139c  e3560000          CMP      r6,#0
0013a0  1a000049          BNE      |L1.5324|
                  |L1.5028|
;;;1791       {
;;;1792           /* check for valid data buffer pointer */
;;;1793           if( (C_NULL == pu8ManID) || (C_NULL == pu8DevID) )
0013a4  e35a0000          CMP      r10,#0
0013a8  0a000001          BEQ      |L1.5044|
0013ac  e35b0000          CMP      r11,#0
0013b0  1a000001          BNE      |L1.5052|
                  |L1.5044|
;;;1794           {
;;;1795               i32Res = C_FAILED;
0013b4  e3e07000          MVN      r7,#0
0013b8  ea000044          B        |L1.5328|
                  |L1.5052|
;;;1796           }
;;;1797           else
;;;1798           {
;;;1799               /* wait for cycle completion of previous program access */
;;;1800               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
0013bc  e320f000          NOP      
                  |L1.5056|
0013c0  e1a00004          MOV      r0,r4
0013c4  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
0013c8  e3500001          CMP      r0,#1
0013cc  0afffffb          BEQ      |L1.5056|
;;;1801   
;;;1802               vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_READ_ID);     /* set up READ ID opcode */
0013d0  e3a00090          MOV      r0,#0x90
0013d4  e59f1af0          LDR      r1,|L1.7884|
0013d8  e7c40001          STRB     r0,[r4,r1]
;;;1803   
;;;1804               if (QSPIC_CNTRL_2 == eController)
0013dc  e3540a01          CMP      r4,#0x1000
0013e0  1a000002          BNE      |L1.5104|
;;;1805               {
;;;1806                   u32Address1 = 0x12;
0013e4  e3a08012          MOV      r8,#0x12
;;;1807                   u32Address2 = 0x08;
0013e8  e3a09008          MOV      r9,#8
0013ec  ea000001          B        |L1.5112|
                  |L1.5104|
;;;1808               }
;;;1809               else
;;;1810               {
;;;1811                   u32Address1 = 0x0;
0013f0  e3a08000          MOV      r8,#0
;;;1812                   u32Address2 = 0x0;
0013f4  e3a09000          MOV      r9,#0
                  |L1.5112|
;;;1813               }
;;;1814   
;;;1815               if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
0013f8  e51f05f4          LDR      r0,|L1.3596|
0013fc  e5d00000          LDRB     r0,[r0,#0]  ; ePrgAddressByteCnt
001400  e3500000          CMP      r0,#0
001404  1a00000b          BNE      |L1.5176|
;;;1816               {
;;;1817                   vSetQSPIC_PriBufDatN(eController, 1, u32Address1);
001408  e59f1abc          LDR      r1,|L1.7884|
00140c  e0811004          ADD      r1,r1,r4
001410  e5c18001          STRB     r8,[r1,#1]
;;;1818                   vSetQSPIC_PriBufDatN(eController, 2, u32Address2);
001414  e59f1ab0          LDR      r1,|L1.7884|
001418  e0811004          ADD      r1,r1,r4
00141c  e5c19002          STRB     r9,[r1,#2]
;;;1819                   vSetQSPIC_PriBufDatN(eController, 3, 0x00);
001420  e3a00000          MOV      r0,#0
001424  e59f1aa0          LDR      r1,|L1.7884|
001428  e0811004          ADD      r1,r1,r4
00142c  e5c10003          STRB     r0,[r1,#3]
;;;1820   
;;;1821                   /* set primary buffer byte counter (3 byte addres plus 1 byte dummy byte) */
;;;1822                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_3;
001430  e3855803          ORR      r5,r5,#0x30000
001434  ea00000d          B        |L1.5232|
                  |L1.5176|
;;;1823               }
;;;1824               else
;;;1825               {
;;;1826                   vSetQSPIC_PriBufDatN(eController, 1, u32Address1);
001438  e59f1a8c          LDR      r1,|L1.7884|
00143c  e0811004          ADD      r1,r1,r4
001440  e5c18001          STRB     r8,[r1,#1]
;;;1827                   vSetQSPIC_PriBufDatN(eController, 2, u32Address2);
001444  e59f1a80          LDR      r1,|L1.7884|
001448  e0811004          ADD      r1,r1,r4
00144c  e5c19002          STRB     r9,[r1,#2]
;;;1828                   vSetQSPIC_PriBufDatN(eController, 3, 0x00);
001450  e3a00000          MOV      r0,#0
001454  e59f1a70          LDR      r1,|L1.7884|
001458  e0811004          ADD      r1,r1,r4
00145c  e5c10003          STRB     r0,[r1,#3]
;;;1829                   vSetQSPIC_PriBufDatN(eController, 4, 0x00);
001460  e59f1a64          LDR      r1,|L1.7884|
001464  e0811004          ADD      r1,r1,r4
001468  e5c10004          STRB     r0,[r1,#4]
;;;1830   
;;;1831                   /* set primary buffer byte counter (4 byte address plus 1 byte dummy byte) */
;;;1832                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
00146c  e3855701          ORR      r5,r5,#0x40000
                  |L1.5232|
;;;1833   
;;;1834               }
;;;1835   
;;;1836               if (QSPIC_DEV_1 == eDevice )
001470  e3560001          CMP      r6,#1
001474  1a000000          BNE      |L1.5244|
;;;1837               {
;;;1838                   /* set SPI_CS1_N accordingly */
;;;1839                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001478  e3855002          ORR      r5,r5,#2
                  |L1.5244|
;;;1840               }
;;;1841   
;;;1842               /* enable primary buffer */
;;;1843               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
00147c  e3855010          ORR      r5,r5,#0x10
;;;1844   
;;;1845               /* set secondary buffer byte counter */
;;;1846               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_CNT_1;
001480  e3855401          ORR      r5,r5,#0x1000000
;;;1847   
;;;1848               /* enable secondary buffer */
;;;1849               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
001484  e3855020          ORR      r5,r5,#0x20
;;;1850   
;;;1851               /* write value to register */
;;;1852               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001488  e51f0688          LDR      r0,|L1.3592|
00148c  e0800004          ADD      r0,r0,r4
001490  e5805404          STR      r5,[r0,#0x404]
;;;1853   
;;;1854               /* wait until current program access cycle is completed */
;;;1855               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001494  e320f000          NOP      
                  |L1.5272|
001498  e1a00004          MOV      r0,r4
00149c  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0014a0  e3500000          CMP      r0,#0
0014a4  0afffffb          BEQ      |L1.5272|
;;;1856   
;;;1857               *pu8ManID = u8GetQSPIC_SecBufDatN(eController, 0);
0014a8  e59f0a20          LDR      r0,|L1.7888|
0014ac  e7d40000          LDRB     r0,[r4,r0]
0014b0  e5ca0000          STRB     r0,[r10,#0]
;;;1858               *pu8DevID = u8GetQSPIC_SecBufDatN(eController, 1);
0014b4  e59f0a14          LDR      r0,|L1.7888|
0014b8  e0800004          ADD      r0,r0,r4
0014bc  e5d00001          LDRB     r0,[r0,#1]
0014c0  e5cb0000          STRB     r0,[r11,#0]
;;;1859   
;;;1860               i32Res = C_SUCCESS;
0014c4  e3a07000          MOV      r7,#0
0014c8  ea000000          B        |L1.5328|
                  |L1.5324|
;;;1861           }
;;;1862       }
;;;1863       else
;;;1864       {
;;;1865           i32Res = C_FAILED;
0014cc  e3e07000          MVN      r7,#0
                  |L1.5328|
;;;1866       }
;;;1867   
;;;1868       return i32Res;
0014d0  e1a00007          MOV      r0,r7
;;;1869   }
0014d4  e8bd8ff0          POP      {r4-r11,pc}
;;;1870   
                          ENDP

                  i32QSPIC_PgrmConfigurationRead PROC
;;;1188   
;;;1189   int32_t i32QSPIC_PgrmConfigurationRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Configuration)
0014d8  e92d41fc          PUSH     {r2-r8,lr}
;;;1190   {
0014dc  e1a04000          MOV      r4,r0
0014e0  e1a06001          MOV      r6,r1
0014e4  e1a07002          MOV      r7,r2
;;;1191       int32_t i32Res = C_SUCCESS;
0014e8  e3a08000          MOV      r8,#0
;;;1192       uint8_t u8ManID = 0;
0014ec  e3a00000          MOV      r0,#0
0014f0  e58d0004          STR      r0,[sp,#4]
;;;1193       uint8_t u8DevID = 0;
0014f4  e58d0000          STR      r0,[sp,#0]
;;;1194       /* default values for Prg Access Ctrl value is as follows:
;;;1195         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1196         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1197         * SpiCycGo = Program Register Access is initiated.
;;;1198       */
;;;1199       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
0014f8  e3a05001          MOV      r5,#1
;;;1200   
;;;1201   
;;;1202       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
0014fc  e3540000          CMP      r4,#0
001500  0a000002          BEQ      |L1.5392|
001504  e51f0708          LDR      r0,|L1.3588|
001508  e1540000          CMP      r4,r0
00150c  1a000003          BNE      |L1.5408|
                  |L1.5392|
;;;1203                       (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
001510  e3560000          CMP      r6,#0
001514  0a000005          BEQ      |L1.5424|
001518  e3560001          CMP      r6,#1
00151c  0a000003          BEQ      |L1.5424|
                  |L1.5408|
;;;1204           || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001520  e3540a01          CMP      r4,#0x1000
001524  1a000057          BNE      |L1.5768|
001528  e3560000          CMP      r6,#0
00152c  1a000055          BNE      |L1.5768|
                  |L1.5424|
;;;1205       {
;;;1206           /* check for valid status pointer */
;;;1207           if( C_NULL == pu8Configuration )
001530  e3570000          CMP      r7,#0
001534  1a000001          BNE      |L1.5440|
;;;1208           {
;;;1209               i32Res = C_FAILED;
001538  e3e08000          MVN      r8,#0
00153c  ea000052          B        |L1.5772|
                  |L1.5440|
;;;1210           }
;;;1211           else
;;;1212           {
;;;1213               i32Res = i32QSPIC_PgrmGetID(eController, eDevice, &u8ManID, &u8DevID);
001540  e1a0300d          MOV      r3,sp
001544  e28d2004          ADD      r2,sp,#4
001548  e1a01006          MOV      r1,r6
00154c  e1a00004          MOV      r0,r4
001550  ebfffffe          BL       i32QSPIC_PgrmGetID
001554  e1a08000          MOV      r8,r0
;;;1214               if( C_SUCCESS == i32Res )
001558  e3580000          CMP      r8,#0
00155c  1a00004a          BNE      |L1.5772|
;;;1215               {
;;;1216                   switch( u8ManID )
001560  e5dd0004          LDRB     r0,[sp,#4]
001564  e3500001          CMP      r0,#1
001568  0a000026          BEQ      |L1.5640|
00156c  e35000c2          CMP      r0,#0xc2
001570  1a000040          BNE      |L1.5752|
;;;1217                   {
;;;1218                       /* Macronix */
;;;1219                       case 0xC2:
;;;1220                           /* wait for cycle completion of previous program access */
;;;1221                           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001574  e320f000          NOP      
                  |L1.5496|
001578  e1a00004          MOV      r0,r4
00157c  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001580  e3500001          CMP      r0,#1
001584  0afffffb          BEQ      |L1.5496|
;;;1222   
;;;1223                           /* set up STATUS READ opcode */
;;;1224                           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_CFGM_READ);
001588  e3a00015          MOV      r0,#0x15
00158c  e59f1938          LDR      r1,|L1.7884|
001590  e7c40001          STRB     r0,[r4,r1]
;;;1225   
;;;1226                           if (QSPIC_DEV_1 == eDevice )
001594  e3560001          CMP      r6,#1
001598  1a000000          BNE      |L1.5536|
;;;1227                           {
;;;1228                               /* set SPI_CS1_N accordingly */
;;;1229                               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
00159c  e3855002          ORR      r5,r5,#2
                  |L1.5536|
;;;1230                           }
;;;1231                           if ( QSPIC_CNTRL_2 == eController )
0015a0  e3540a01          CMP      r4,#0x1000
0015a4  1a000001          BNE      |L1.5552|
;;;1232                           {
;;;1233                               /* for QSPIC_CNTRL_2 the data is always transmitted in secondary buffer */
;;;1234                               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
0015a8  e3855020          ORR      r5,r5,#0x20
0015ac  ea000000          B        |L1.5556|
                  |L1.5552|
;;;1235                           }
;;;1236                           else
;;;1237                           {
;;;1238                             /* for other controllers the data is transmitted in primary buffer */
;;;1239                             /* set primary buffer byte counter 1 */
;;;1240                             u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
0015b0  e3855801          ORR      r5,r5,#0x10000
                  |L1.5556|
;;;1241                           }
;;;1242                           /* enable primary buffer */
;;;1243                           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
0015b4  e3855010          ORR      r5,r5,#0x10
;;;1244   
;;;1245                           /* write value to register */
;;;1246                           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
0015b8  e51f07b8          LDR      r0,|L1.3592|
0015bc  e0800004          ADD      r0,r0,r4
0015c0  e5805404          STR      r5,[r0,#0x404]
;;;1247   
;;;1248                           /* wait until current program access cycle is completed */
;;;1249                           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
0015c4  e320f000          NOP      
                  |L1.5576|
0015c8  e1a00004          MOV      r0,r4
0015cc  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0015d0  e3500000          CMP      r0,#0
0015d4  0afffffb          BEQ      |L1.5576|
;;;1250   
;;;1251                           if ( QSPIC_CNTRL_2 == eController )
0015d8  e3540a01          CMP      r4,#0x1000
0015dc  1a000003          BNE      |L1.5616|
;;;1252                           {
;;;1253                              /* retrieve the status */
;;;1254                              *pu8Configuration = u8GetQSPIC_SecBufDatN(eController, 0);
0015e0  e59f08e8          LDR      r0,|L1.7888|
0015e4  e7d40000          LDRB     r0,[r4,r0]
0015e8  e5c70000          STRB     r0,[r7,#0]
0015ec  ea000003          B        |L1.5632|
                  |L1.5616|
;;;1255                           }
;;;1256                           else
;;;1257                           {
;;;1258                              /* retrieve the status */
;;;1259                              *pu8Configuration = u8GetQSPIC_PriBufDatN(eController, 1);
0015f0  e59f08d4          LDR      r0,|L1.7884|
0015f4  e0800004          ADD      r0,r0,r4
0015f8  e5d00001          LDRB     r0,[r0,#1]
0015fc  e5c70000          STRB     r0,[r7,#0]
                  |L1.5632|
;;;1260                           }
;;;1261                           i32Res = C_SUCCESS;
001600  e3a08000          MOV      r8,#0
;;;1262   
;;;1263                           break;
001604  ea00001e          B        |L1.5764|
                  |L1.5640|
;;;1264   
;;;1265                       /* Spansion */
;;;1266                       case 0x01:
001608  e320f000          NOP      
;;;1267                           /* wait for cycle completion of previous program access */
;;;1268                           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
00160c  e320f000          NOP      
                  |L1.5648|
001610  e1a00004          MOV      r0,r4
001614  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001618  e3500001          CMP      r0,#1
00161c  0afffffb          BEQ      |L1.5648|
;;;1269   
;;;1270                           /* set up STATUS READ opcode */
;;;1271                           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_CFG_READ);
001620  e3a00035          MOV      r0,#0x35
001624  e59f18a0          LDR      r1,|L1.7884|
001628  e7c40001          STRB     r0,[r4,r1]
;;;1272   
;;;1273                           if (QSPIC_DEV_1 == eDevice )
00162c  e3560001          CMP      r6,#1
001630  1a000000          BNE      |L1.5688|
;;;1274                           {
;;;1275                               /* set SPI_CS1_N accordingly */
;;;1276                               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001634  e3855002          ORR      r5,r5,#2
                  |L1.5688|
;;;1277                           }
;;;1278                           /* set primary buffer byte counter 1 */
;;;1279                           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_1;
001638  e3855801          ORR      r5,r5,#0x10000
;;;1280   
;;;1281                           /* enable primary buffer */
;;;1282                           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
00163c  e3855010          ORR      r5,r5,#0x10
;;;1283   
;;;1284                           /* write value to register */
;;;1285                           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001640  e51f0840          LDR      r0,|L1.3592|
001644  e0800004          ADD      r0,r0,r4
001648  e5805404          STR      r5,[r0,#0x404]
;;;1286   
;;;1287                           /* wait until current program access cycle is completed */
;;;1288                           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
00164c  e320f000          NOP      
                  |L1.5712|
001650  e1a00004          MOV      r0,r4
001654  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001658  e3500000          CMP      r0,#0
00165c  0afffffb          BEQ      |L1.5712|
;;;1289   
;;;1290                           /* retrieve the status */
;;;1291                           *pu8Configuration = u8GetQSPIC_PriBufDatN(eController, 1);
001660  e59f0864          LDR      r0,|L1.7884|
001664  e0800004          ADD      r0,r0,r4
001668  e5d00001          LDRB     r0,[r0,#1]
00166c  e5c70000          STRB     r0,[r7,#0]
;;;1292   
;;;1293                           i32Res = C_SUCCESS;
001670  e3a08000          MOV      r8,#0
;;;1294                           break;
001674  ea000002          B        |L1.5764|
                  |L1.5752|
;;;1295   
;;;1296                       default:
001678  e320f000          NOP      
;;;1297                           i32Res = C_FAILED;
00167c  e3e08000          MVN      r8,#0
;;;1298                           break;
001680  e320f000          NOP      
                  |L1.5764|
001684  ea000000          B        |L1.5772|
                  |L1.5768|
;;;1299                   }
;;;1300               }
;;;1301           }
;;;1302       }
;;;1303       else
;;;1304       {
;;;1305           i32Res = C_FAILED;
001688  e3e08000          MVN      r8,#0
                  |L1.5772|
;;;1306       }
;;;1307   
;;;1308       return i32Res;
00168c  e1a00008          MOV      r0,r8
;;;1309   }
001690  e8bd81fc          POP      {r2-r8,pc}
;;;1310   
                          ENDP

                  i32QSPIC_PgrmConfigurationWrite PROC
;;;1313   
;;;1314   int32_t i32QSPIC_PgrmConfigurationWrite(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Status,  uint8_t u8Conf)
001694  e92d43f0          PUSH     {r4-r9,lr}
;;;1315   {
001698  e1a04000          MOV      r4,r0
00169c  e1a05001          MOV      r5,r1
0016a0  e1a07002          MOV      r7,r2
0016a4  e1a08003          MOV      r8,r3
;;;1316       int32_t i32Res = C_SUCCESS;
0016a8  e3a09000          MOV      r9,#0
;;;1317       /* default values for Prg Access Ctrl value is as follows:
;;;1318         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1319         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1320         * SpiCycGo = Program Register Access is initiated.
;;;1321       */
;;;1322       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
0016ac  e3a06001          MOV      r6,#1
;;;1323   
;;;1324   
;;;1325       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
0016b0  e3540000          CMP      r4,#0
0016b4  0a000002          BEQ      |L1.5828|
0016b8  e51f08bc          LDR      r0,|L1.3588|
0016bc  e1540000          CMP      r4,r0
0016c0  1a000003          BNE      |L1.5844|
                  |L1.5828|
;;;1326                       (( QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1 == eDevice )))
0016c4  e3550000          CMP      r5,#0
0016c8  0a000005          BEQ      |L1.5860|
0016cc  e3550001          CMP      r5,#1
0016d0  0a000003          BEQ      |L1.5860|
                  |L1.5844|
;;;1327           || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
0016d4  e3540a01          CMP      r4,#0x1000
0016d8  1a00001d          BNE      |L1.5972|
0016dc  e3550000          CMP      r5,#0
0016e0  1a00001b          BNE      |L1.5972|
                  |L1.5860|
;;;1328       {
;;;1329   
;;;1330           /* wait for cycle completion of previous program access */
;;;1331           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
0016e4  e320f000          NOP      
                  |L1.5864|
0016e8  e1a00004          MOV      r0,r4
0016ec  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
0016f0  e3500001          CMP      r0,#1
0016f4  0afffffb          BEQ      |L1.5864|
;;;1332   
;;;1333           /* set up WRITE REGISTER (WRR) opcode */
;;;1334           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_WRITE_REG);
0016f8  e3a00001          MOV      r0,#1
0016fc  e59f17c8          LDR      r1,|L1.7884|
001700  e7c40001          STRB     r0,[r4,r1]
;;;1335   
;;;1336           if (QSPIC_DEV_1 == eDevice )
001704  e3550001          CMP      r5,#1
001708  1a000000          BNE      |L1.5904|
;;;1337           {
;;;1338               /* set SPI_CS1_N accordingly */
;;;1339               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
00170c  e3866002          ORR      r6,r6,#2
                  |L1.5904|
;;;1340           }
;;;1341   
;;;1342           /* enable primary buffer */
;;;1343           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001710  e3866010          ORR      r6,r6,#0x10
;;;1344   
;;;1345           vSetQSPIC_SecBufDatN(eController, 0, u8Status);
001714  e59f07b4          LDR      r0,|L1.7888|
001718  e7c47000          STRB     r7,[r4,r0]
;;;1346           vSetQSPIC_SecBufDatN(eController, 1, u8Conf);
00171c  e0800004          ADD      r0,r0,r4
001720  e5c08001          STRB     r8,[r0,#1]
;;;1347   
;;;1348           /* set secondary buffer byte counter */
;;;1349           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_CNT_1;
001724  e3866401          ORR      r6,r6,#0x1000000
;;;1350   
;;;1351           /* enable secondary buffer */
;;;1352           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
001728  e3866020          ORR      r6,r6,#0x20
;;;1353   
;;;1354           /* write value to register */
;;;1355           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
00172c  e51f092c          LDR      r0,|L1.3592|
001730  e0800004          ADD      r0,r0,r4
001734  e5806404          STR      r6,[r0,#0x404]
;;;1356   
;;;1357           /* wait until current program access cycle is completed */
;;;1358           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001738  e320f000          NOP      
                  |L1.5948|
00173c  e1a00004          MOV      r0,r4
001740  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001744  e3500000          CMP      r0,#0
001748  0afffffb          BEQ      |L1.5948|
;;;1359   
;;;1360           i32Res = C_SUCCESS;
00174c  e3a09000          MOV      r9,#0
001750  ea000000          B        |L1.5976|
                  |L1.5972|
;;;1361       }
;;;1362       else
;;;1363       {
;;;1364           i32Res = C_FAILED;
001754  e3e09000          MVN      r9,#0
                  |L1.5976|
;;;1365       }
;;;1366   
;;;1367       return i32Res;
001758  e1a00009          MOV      r0,r9
;;;1368   }
00175c  e8bd83f0          POP      {r4-r9,pc}
;;;1369   
                          ENDP

                  i32QSPIC_PgrmWriteEnable PROC
;;;1372   
;;;1373   int32_t i32QSPIC_PgrmWriteEnable(qspic_cntrl_e eController, qspic_dev_e eDevice)
001760  e92d40f0          PUSH     {r4-r7,lr}
;;;1374   {
001764  e1a04000          MOV      r4,r0
001768  e1a05001          MOV      r5,r1
;;;1375       int32_t i32Res = C_SUCCESS;
00176c  e3a07000          MOV      r7,#0
;;;1376       /* default values for Prg Access Ctrl value is as follows:
;;;1377         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1378         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1379         * SpiCycGo = Program Register Access is initiated.
;;;1380       */
;;;1381       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001770  e3a06001          MOV      r6,#1
;;;1382   
;;;1383   
;;;1384       if ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001774  e3540000          CMP      r4,#0
001778  0a000002          BEQ      |L1.6024|
00177c  e51f0980          LDR      r0,|L1.3588|
001780  e1540000          CMP      r4,r0
001784  1a000018          BNE      |L1.6124|
                  |L1.6024|
;;;1385                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)) )
001788  e3550000          CMP      r5,#0
00178c  0a000001          BEQ      |L1.6040|
001790  e3550001          CMP      r5,#1
001794  1a000014          BNE      |L1.6124|
                  |L1.6040|
;;;1386       {
;;;1387           /* wait for cycle completion of previous program access */
;;;1388           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001798  e320f000          NOP      
                  |L1.6044|
00179c  e1a00004          MOV      r0,r4
0017a0  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
0017a4  e3500001          CMP      r0,#1
0017a8  0afffffb          BEQ      |L1.6044|
;;;1389   
;;;1390           /* set up WRITE ENABLE opcode */
;;;1391           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_WRITE_EN);
0017ac  e3a00006          MOV      r0,#6
0017b0  e59f1714          LDR      r1,|L1.7884|
0017b4  e7c40001          STRB     r0,[r4,r1]
;;;1392   
;;;1393           if (QSPIC_DEV_1 == eDevice )
0017b8  e3550001          CMP      r5,#1
0017bc  1a000000          BNE      |L1.6084|
;;;1394           {
;;;1395               /* set SPI_CS1_N accordingly */
;;;1396               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
0017c0  e3866002          ORR      r6,r6,#2
                  |L1.6084|
;;;1397           }
;;;1398   
;;;1399           /* enable primary buffer */
;;;1400           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
0017c4  e3866010          ORR      r6,r6,#0x10
;;;1401   
;;;1402           /* write value to register */
;;;1403           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
0017c8  e51f09c8          LDR      r0,|L1.3592|
0017cc  e0800004          ADD      r0,r0,r4
0017d0  e5806404          STR      r6,[r0,#0x404]
;;;1404   
;;;1405           /* wait until current program access cycle is completed */
;;;1406           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
0017d4  e320f000          NOP      
                  |L1.6104|
0017d8  e1a00004          MOV      r0,r4
0017dc  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0017e0  e3500000          CMP      r0,#0
0017e4  0afffffb          BEQ      |L1.6104|
0017e8  ea000000          B        |L1.6128|
                  |L1.6124|
;;;1407       }
;;;1408       else
;;;1409       {
;;;1410           i32Res = C_FAILED;
0017ec  e3e07000          MVN      r7,#0
                  |L1.6128|
;;;1411       }
;;;1412   
;;;1413       return i32Res;
0017f0  e1a00007          MOV      r0,r7
;;;1414   }
0017f4  e8bd80f0          POP      {r4-r7,pc}
;;;1415   
                          ENDP

                  i32QSPIC_PgrmWriteDisable PROC
;;;1418   
;;;1419   int32_t i32QSPIC_PgrmWriteDisable(qspic_cntrl_e eController, qspic_dev_e eDevice)
0017f8  e92d40f0          PUSH     {r4-r7,lr}
;;;1420   {
0017fc  e1a04000          MOV      r4,r0
001800  e1a05001          MOV      r5,r1
;;;1421       int32_t i32Res = C_SUCCESS;
001804  e3a07000          MOV      r7,#0
;;;1422       /* default values for Prg Access Ctrl value is as follows:
;;;1423         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1424         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1425         * SpiCycGo = Program Register Access is initiated.
;;;1426       */
;;;1427       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001808  e3a06001          MOV      r6,#1
;;;1428   
;;;1429   
;;;1430       if ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
00180c  e3540000          CMP      r4,#0
001810  0a000002          BEQ      |L1.6176|
001814  e51f0a18          LDR      r0,|L1.3588|
001818  e1540000          CMP      r4,r0
00181c  1a000018          BNE      |L1.6276|
                  |L1.6176|
;;;1431                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)) )
001820  e3550000          CMP      r5,#0
001824  0a000001          BEQ      |L1.6192|
001828  e3550001          CMP      r5,#1
00182c  1a000014          BNE      |L1.6276|
                  |L1.6192|
;;;1432       {
;;;1433           /* wait for cycle completion of previous program access */
;;;1434           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001830  e320f000          NOP      
                  |L1.6196|
001834  e1a00004          MOV      r0,r4
001838  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
00183c  e3500001          CMP      r0,#1
001840  0afffffb          BEQ      |L1.6196|
;;;1435   
;;;1436           /* set up WRITE DISABLE opcode */
;;;1437           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_WRITE_DIS);
001844  e3a00004          MOV      r0,#4
001848  e59f167c          LDR      r1,|L1.7884|
00184c  e7c40001          STRB     r0,[r4,r1]
;;;1438   
;;;1439           if (QSPIC_DEV_1 == eDevice )
001850  e3550001          CMP      r5,#1
001854  1a000000          BNE      |L1.6236|
;;;1440           {
;;;1441               /* set SPI_CS1_N accordingly */
;;;1442               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001858  e3866002          ORR      r6,r6,#2
                  |L1.6236|
;;;1443           }
;;;1444   
;;;1445           /* enable primary buffer */
;;;1446           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
00185c  e3866010          ORR      r6,r6,#0x10
;;;1447   
;;;1448           /* write value to register */
;;;1449           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001860  e51f0a60          LDR      r0,|L1.3592|
001864  e0800004          ADD      r0,r0,r4
001868  e5806404          STR      r6,[r0,#0x404]
;;;1450   
;;;1451           /* wait until current program access cycle is completed */
;;;1452           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
00186c  e320f000          NOP      
                  |L1.6256|
001870  e1a00004          MOV      r0,r4
001874  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001878  e3500000          CMP      r0,#0
00187c  0afffffb          BEQ      |L1.6256|
001880  ea000000          B        |L1.6280|
                  |L1.6276|
;;;1453       }
;;;1454       else
;;;1455       {
;;;1456           i32Res = C_FAILED;
001884  e3e07000          MVN      r7,#0
                  |L1.6280|
;;;1457       }
;;;1458   
;;;1459       return i32Res;
001888  e1a00007          MOV      r0,r7
;;;1460   }
00188c  e8bd80f0          POP      {r4-r7,pc}
;;;1461   
                          ENDP

                  i32QSPIC_PgrmSectErase PROC
;;;1464   
;;;1465   int32_t i32QSPIC_PgrmSectErase(qspic_cntrl_e eController, qspic_dev_e eDevice, qspic_opcode_e eOpcode, uint32_t u32SpiPhysAddr)
001890  e92d47f0          PUSH     {r4-r10,lr}
;;;1466   {
001894  e1a04000          MOV      r4,r0
001898  e1a06001          MOV      r6,r1
00189c  e1a08002          MOV      r8,r2
0018a0  e1a05003          MOV      r5,r3
;;;1467       int32_t i32Res = C_SUCCESS;
0018a4  e3a0a000          MOV      r10,#0
;;;1468       uint32_t u32Mask;
;;;1469       /* default values for Prg Access Ctrl value is as follows:
;;;1470         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1471         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1472         * SpiCycGo = Program Register Access is initiated.
;;;1473       */
;;;1474       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
0018a8  e3a07001          MOV      r7,#1
;;;1475   
;;;1476   
;;;1477       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
0018ac  e3540000          CMP      r4,#0
0018b0  0a000002          BEQ      |L1.6336|
0018b4  e51f0ab8          LDR      r0,|L1.3588|
0018b8  e1540000          CMP      r4,r0
0018bc  1a000003          BNE      |L1.6352|
                  |L1.6336|
;;;1478                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
0018c0  e3560000          CMP      r6,#0
0018c4  0a000005          BEQ      |L1.6368|
0018c8  e3560001          CMP      r6,#1
0018cc  0a000003          BEQ      |L1.6368|
                  |L1.6352|
;;;1479               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
0018d0  e3540a01          CMP      r4,#0x1000
0018d4  1a00003a          BNE      |L1.6596|
0018d8  e3560000          CMP      r6,#0
0018dc  1a000038          BNE      |L1.6596|
                  |L1.6368|
;;;1480       {
;;;1481           /* wait for cycle completion of previous program access */
;;;1482           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
0018e0  e320f000          NOP      
                  |L1.6372|
0018e4  e1a00004          MOV      r0,r4
0018e8  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
0018ec  e3500001          CMP      r0,#1
0018f0  0afffffb          BEQ      |L1.6372|
;;;1483   
;;;1484           vSetQSPIC_PriBufDatN(eController, 0, eOpcode);                                      /* set up ERASE opcode */
0018f4  e59f05d0          LDR      r0,|L1.7884|
0018f8  e7c48000          STRB     r8,[r4,r0]
;;;1485   
;;;1486           /* check address byte count and set address accordingly */
;;;1487           if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
0018fc  e51f0af8          LDR      r0,|L1.3596|
001900  e5d00000          LDRB     r0,[r0,#0]  ; ePrgAddressByteCnt
001904  e3500000          CMP      r0,#0
001908  1a00000c          BNE      |L1.6464|
;;;1488           {
;;;1489               vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
00190c  e1a00825          LSR      r0,r5,#16
001910  e59f15b4          LDR      r1,|L1.7884|
001914  e0811004          ADD      r1,r1,r4
001918  e5c10001          STRB     r0,[r1,#1]
;;;1490               vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
00191c  e1a00425          LSR      r0,r5,#8
001920  e59f15a4          LDR      r1,|L1.7884|
001924  e0811004          ADD      r1,r1,r4
001928  e5c10002          STRB     r0,[r1,#2]
;;;1491               vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
00192c  e59f1598          LDR      r1,|L1.7884|
001930  e0811004          ADD      r1,r1,r4
001934  e5c15003          STRB     r5,[r1,#3]
;;;1492   
;;;1493               /* set primary buffer byte counter */
;;;1494               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_3;
001938  e3877803          ORR      r7,r7,#0x30000
00193c  ea000013          B        |L1.6544|
                  |L1.6464|
;;;1495          }
;;;1496           else
;;;1497           {
;;;1498               u32Mask = ~(biGetQSPIC_FlshMemMap0_FBA(eController) >> 8);
001940  e51f0b40          LDR      r0,|L1.3592|
001944  e7940000          LDR      r0,[r4,r0]
001948  e1a00820          LSR      r0,r0,#16
00194c  e1e09440          MVN      r9,r0,ASR #8
;;;1499               vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 24) & u32Mask));   /* SPI physical addr[31:23] */
001950  e0090c25          AND      r0,r9,r5,LSR #24
001954  e59f1570          LDR      r1,|L1.7884|
001958  e0811004          ADD      r1,r1,r4
00195c  e5c10001          STRB     r0,[r1,#1]
;;;1500               vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
001960  e1a00825          LSR      r0,r5,#16
001964  e59f1560          LDR      r1,|L1.7884|
001968  e0811004          ADD      r1,r1,r4
00196c  e5c10002          STRB     r0,[r1,#2]
;;;1501               vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
001970  e1a00425          LSR      r0,r5,#8
001974  e59f1550          LDR      r1,|L1.7884|
001978  e0811004          ADD      r1,r1,r4
00197c  e5c10003          STRB     r0,[r1,#3]
;;;1502               vSetQSPIC_PriBufDatN(eController, 4, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
001980  e59f1544          LDR      r1,|L1.7884|
001984  e0811004          ADD      r1,r1,r4
001988  e5c15004          STRB     r5,[r1,#4]
;;;1503   
;;;1504               /* set primary buffer byte counter */
;;;1505               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
00198c  e3877701          ORR      r7,r7,#0x40000
                  |L1.6544|
;;;1506           }
;;;1507   
;;;1508           if (QSPIC_DEV_1 == eDevice )
001990  e3560001          CMP      r6,#1
001994  1a000000          BNE      |L1.6556|
;;;1509           {
;;;1510               /* set SPI_CS1_N accordingly */
;;;1511               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001998  e3877002          ORR      r7,r7,#2
                  |L1.6556|
;;;1512           }
;;;1513   
;;;1514           /* enable primary buffer */
;;;1515           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
00199c  e3877010          ORR      r7,r7,#0x10
;;;1516   
;;;1517            /* write value to register */
;;;1518           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
0019a0  e51f0ba0          LDR      r0,|L1.3592|
0019a4  e0800004          ADD      r0,r0,r4
0019a8  e5807404          STR      r7,[r0,#0x404]
;;;1519   
;;;1520           /* wait until current program access cycle is completed */
;;;1521           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
0019ac  e320f000          NOP      
                  |L1.6576|
0019b0  e1a00004          MOV      r0,r4
0019b4  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0019b8  e3500000          CMP      r0,#0
0019bc  0afffffb          BEQ      |L1.6576|
0019c0  ea000000          B        |L1.6600|
                  |L1.6596|
;;;1522       }
;;;1523       else
;;;1524       {
;;;1525           i32Res = C_FAILED;
0019c4  e3e0a000          MVN      r10,#0
                  |L1.6600|
;;;1526       }
;;;1527   
;;;1528       return i32Res;
0019c8  e1a0000a          MOV      r0,r10
;;;1529   }
0019cc  e8bd87f0          POP      {r4-r10,pc}
;;;1530   
                          ENDP

                  i32QSPIC_PgrmChipErase PROC
;;;1533   
;;;1534   int32_t i32QSPIC_PgrmChipErase(qspic_cntrl_e eController, qspic_dev_e eDevice)
0019d0  e92d40f0          PUSH     {r4-r7,lr}
;;;1535   {
0019d4  e1a04000          MOV      r4,r0
0019d8  e1a05001          MOV      r5,r1
;;;1536       int32_t i32Res = C_SUCCESS;
0019dc  e3a07000          MOV      r7,#0
;;;1537       /* default values for Prg Access Ctrl value is as follows:
;;;1538         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1539         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1540         * SpiCycGo = Program Register Access is initiated.
;;;1541       */
;;;1542       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
0019e0  e3a06001          MOV      r6,#1
;;;1543   
;;;1544   
;;;1545       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
0019e4  e3540000          CMP      r4,#0
0019e8  0a000002          BEQ      |L1.6648|
0019ec  e51f0bf0          LDR      r0,|L1.3588|
0019f0  e1540000          CMP      r4,r0
0019f4  1a000003          BNE      |L1.6664|
                  |L1.6648|
;;;1546                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
0019f8  e3550000          CMP      r5,#0
0019fc  0a000005          BEQ      |L1.6680|
001a00  e3550001          CMP      r5,#1
001a04  0a000003          BEQ      |L1.6680|
                  |L1.6664|
;;;1547               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001a08  e3540a01          CMP      r4,#0x1000
001a0c  1a000016          BNE      |L1.6764|
001a10  e3550000          CMP      r5,#0
001a14  1a000014          BNE      |L1.6764|
                  |L1.6680|
;;;1548       {
;;;1549           /* wait for cycle completion of previous program access */
;;;1550           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001a18  e320f000          NOP      
                  |L1.6684|
001a1c  e1a00004          MOV      r0,r4
001a20  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001a24  e3500001          CMP      r0,#1
001a28  0afffffb          BEQ      |L1.6684|
;;;1551   
;;;1552           /* set up FULL CHIP ERASE opcode */
;;;1553           vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_CHIP_ERASE);
001a2c  e3a000c7          MOV      r0,#0xc7
001a30  e59f1494          LDR      r1,|L1.7884|
001a34  e7c40001          STRB     r0,[r4,r1]
;;;1554   
;;;1555           if (QSPIC_DEV_1 == eDevice )
001a38  e3550001          CMP      r5,#1
001a3c  1a000000          BNE      |L1.6724|
;;;1556           {
;;;1557               /* set SPI_CS1_N accordingly */
;;;1558               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001a40  e3866002          ORR      r6,r6,#2
                  |L1.6724|
;;;1559           }
;;;1560   
;;;1561            /* enable primary buffer */
;;;1562           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001a44  e3866010          ORR      r6,r6,#0x10
;;;1563   
;;;1564           /* write value to register */
;;;1565           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001a48  e51f0c48          LDR      r0,|L1.3592|
001a4c  e0800004          ADD      r0,r0,r4
001a50  e5806404          STR      r6,[r0,#0x404]
;;;1566   
;;;1567           /* wait until current program access cycle is completed */
;;;1568           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001a54  e320f000          NOP      
                  |L1.6744|
001a58  e1a00004          MOV      r0,r4
001a5c  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001a60  e3500000          CMP      r0,#0
001a64  0afffffb          BEQ      |L1.6744|
001a68  ea000000          B        |L1.6768|
                  |L1.6764|
;;;1569       }
;;;1570       else
;;;1571       {
;;;1572           i32Res = C_FAILED;
001a6c  e3e07000          MVN      r7,#0
                  |L1.6768|
;;;1573       }
;;;1574   
;;;1575       return i32Res;
001a70  e1a00007          MOV      r0,r7
;;;1576   }
001a74  e8bd80f0          POP      {r4-r7,pc}
;;;1577   
                          ENDP

                  i32QSPIC_PgrmPagePgrm PROC
;;;1580   
;;;1581   int32_t i32QSPIC_PgrmPagePgrm(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32SpiPhysAddr, uint16_t u16DataCount, uint8_t* const pu8Data)
001a78  e92d4ffc          PUSH     {r2-r11,lr}
;;;1582   {
001a7c  e1a04000          MOV      r4,r0
001a80  e1a08001          MOV      r8,r1
001a84  e1a05002          MOV      r5,r2
001a88  e1a0a003          MOV      r10,r3
;;;1583       uint16_t u16DataIndex;
;;;1584       uint32_t u32Cnt;
;;;1585       uint8_t  *pu8Buffer;
;;;1586       int32_t  i32Res;
;;;1587       uint32_t u32Mask;
;;;1588       /* default values for Prg Access Ctrl value is as follows:
;;;1589         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1590         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1591         * SpiCycGo = Program Register Access is initiated.
;;;1592       */
;;;1593       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001a8c  e3a06001          MOV      r6,#1
;;;1594   
;;;1595   
;;;1596       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001a90  e3540000          CMP      r4,#0
001a94  0a000002          BEQ      |L1.6820|
001a98  e51f0c9c          LDR      r0,|L1.3588|
001a9c  e1540000          CMP      r4,r0
001aa0  1a000003          BNE      |L1.6836|
                  |L1.6820|
;;;1597                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
001aa4  e3580000          CMP      r8,#0
001aa8  0a000005          BEQ      |L1.6852|
001aac  e3580001          CMP      r8,#1
001ab0  0a000003          BEQ      |L1.6852|
                  |L1.6836|
;;;1598               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001ab4  e3540a01          CMP      r4,#0x1000
001ab8  1a000055          BNE      |L1.7188|
001abc  e3580000          CMP      r8,#0
001ac0  1a000053          BNE      |L1.7188|
                  |L1.6852|
;;;1599       {
;;;1600           /* get result buffer pointer */
;;;1601           pu8Buffer = pu8Data;
001ac4  e59db02c          LDR      r11,[sp,#0x2c]
;;;1602   
;;;1603           /* check for valid data buffer pointer */
;;;1604           if (C_NULL == pu8Buffer)
001ac8  e35b0000          CMP      r11,#0
001acc  1a000001          BNE      |L1.6872|
;;;1605           {
;;;1606               i32Res = C_FAILED;
001ad0  e3e09000          MVN      r9,#0
001ad4  ea00004f          B        |L1.7192|
                  |L1.6872|
;;;1607           }
;;;1608           else
;;;1609           {
;;;1610               /* wait for cycle completion of previous program access */
;;;1611               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001ad8  e320f000          NOP      
                  |L1.6876|
001adc  e1a00004          MOV      r0,r4
001ae0  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001ae4  e3500001          CMP      r0,#1
001ae8  0afffffb          BEQ      |L1.6876|
;;;1612   
;;;1613               vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_PAGE_PGRM);                       /* set up PAGE PROGRAM opcode */
001aec  e3a00002          MOV      r0,#2
001af0  e59f13d4          LDR      r1,|L1.7884|
001af4  e7c40001          STRB     r0,[r4,r1]
;;;1614   
;;;1615               if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
001af8  e51f0cf4          LDR      r0,|L1.3596|
001afc  e5d00000          LDRB     r0,[r0,#0]  ; ePrgAddressByteCnt
001b00  e3500000          CMP      r0,#0
001b04  1a00000b          BNE      |L1.6968|
;;;1616               {
;;;1617                   vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
001b08  e1a00825          LSR      r0,r5,#16
001b0c  e0811004          ADD      r1,r1,r4
001b10  e5c10001          STRB     r0,[r1,#1]
;;;1618                   vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
001b14  e1a00425          LSR      r0,r5,#8
001b18  e59f13ac          LDR      r1,|L1.7884|
001b1c  e0811004          ADD      r1,r1,r4
001b20  e5c10002          STRB     r0,[r1,#2]
;;;1619                   vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
001b24  e59f13a0          LDR      r1,|L1.7884|
001b28  e0811004          ADD      r1,r1,r4
001b2c  e5c15003          STRB     r5,[r1,#3]
;;;1620   
;;;1621                   /* set primary buffer byte counter */
;;;1622                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_3;
001b30  e3866803          ORR      r6,r6,#0x30000
001b34  ea000015          B        |L1.7056|
                  |L1.6968|
;;;1623               }
;;;1624               else
;;;1625               {
;;;1626                   u32Mask = ~(biGetQSPIC_FlshMemMap0_FBA(eController) >> 8);
001b38  e51f0d38          LDR      r0,|L1.3592|
001b3c  e7940000          LDR      r0,[r4,r0]
001b40  e1a00820          LSR      r0,r0,#16
001b44  e1e00440          MVN      r0,r0,ASR #8
001b48  e58d0000          STR      r0,[sp,#0]
;;;1627                   vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 24) & u32Mask));   /* SPI physical addr[31:23] */
001b4c  e59d0000          LDR      r0,[sp,#0]
001b50  e0000c25          AND      r0,r0,r5,LSR #24
001b54  e59f1370          LDR      r1,|L1.7884|
001b58  e0811004          ADD      r1,r1,r4
001b5c  e5c10001          STRB     r0,[r1,#1]
;;;1628                   vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
001b60  e1a00825          LSR      r0,r5,#16
001b64  e59f1360          LDR      r1,|L1.7884|
001b68  e0811004          ADD      r1,r1,r4
001b6c  e5c10002          STRB     r0,[r1,#2]
;;;1629                   vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
001b70  e1a00425          LSR      r0,r5,#8
001b74  e59f1350          LDR      r1,|L1.7884|
001b78  e0811004          ADD      r1,r1,r4
001b7c  e5c10003          STRB     r0,[r1,#3]
;;;1630                   vSetQSPIC_PriBufDatN(eController, 4, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
001b80  e59f1344          LDR      r1,|L1.7884|
001b84  e0811004          ADD      r1,r1,r4
001b88  e5c15004          STRB     r5,[r1,#4]
;;;1631   
;;;1632                   /* set primary buffer byte counter */
;;;1633                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
001b8c  e3866701          ORR      r6,r6,#0x40000
                  |L1.7056|
;;;1634               }
;;;1635   
;;;1636               for (u16DataIndex = 0; u16DataIndex < u16DataCount; u16DataIndex++)
001b90  e3a07000          MOV      r7,#0
001b94  ea000005          B        |L1.7088|
                  |L1.7064|
;;;1637               {
;;;1638                   vSetQSPIC_SecBufDatN(eController, u16DataIndex, pu8Buffer[u16DataIndex]);
001b98  e7db0007          LDRB     r0,[r11,r7]
001b9c  e59f132c          LDR      r1,|L1.7888|
001ba0  e0811004          ADD      r1,r1,r4
001ba4  e7c10007          STRB     r0,[r1,r7]
001ba8  e2870001          ADD      r0,r7,#1              ;1636
001bac  e6ff7070          UXTH     r7,r0                 ;1636
                  |L1.7088|
001bb0  e157000a          CMP      r7,r10                ;1636
001bb4  bafffff7          BLT      |L1.7064|
;;;1639               }
;;;1640   
;;;1641               if (QSPIC_DEV_1 == eDevice )
001bb8  e3580001          CMP      r8,#1
001bbc  1a000000          BNE      |L1.7108|
;;;1642               {
;;;1643                   /* set SPI_CS1_N accordingly */
;;;1644                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001bc0  e3866002          ORR      r6,r6,#2
                  |L1.7108|
;;;1645               }
;;;1646   
;;;1647               /* enable primary buffer */
;;;1648               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001bc4  e3866010          ORR      r6,r6,#0x10
;;;1649   
;;;1650               /* set secondary buffer byte counter */
;;;1651               /* follwoing code simplified:
;;;1652                * u32PrgAccCtrl = u32PrgAccCtrl | ( (((uint32_t) (u16DataCount-1U) ) << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
;;;1653                * */
;;;1654               u32Cnt = ((uint32_t) u16DataCount) -1U;
001bc8  e24a0001          SUB      r0,r10,#1
001bcc  e58d0004          STR      r0,[sp,#4]
;;;1655               u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
001bd0  e59d0004          LDR      r0,[sp,#4]
001bd4  e1a00c00          LSL      r0,r0,#24
001bd8  e58d0004          STR      r0,[sp,#4]
;;;1656               u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
001bdc  e59d0004          LDR      r0,[sp,#4]
001be0  e20004ff          AND      r0,r0,#0xff000000
001be4  e1866000          ORR      r6,r6,r0
;;;1657   
;;;1658               /* enable secondary buffer */
;;;1659               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
001be8  e3866020          ORR      r6,r6,#0x20
;;;1660   
;;;1661               /* write value to register */
;;;1662               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001bec  e51f0dec          LDR      r0,|L1.3592|
001bf0  e0800004          ADD      r0,r0,r4
001bf4  e5806404          STR      r6,[r0,#0x404]
;;;1663   
;;;1664               /* wait until current program access cycle is completed */
;;;1665               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001bf8  e320f000          NOP      
                  |L1.7164|
001bfc  e1a00004          MOV      r0,r4
001c00  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001c04  e3500000          CMP      r0,#0
001c08  0afffffb          BEQ      |L1.7164|
;;;1666   
;;;1667               i32Res = C_SUCCESS;
001c0c  e3a09000          MOV      r9,#0
001c10  ea000000          B        |L1.7192|
                  |L1.7188|
;;;1668           }
;;;1669       }
;;;1670       else
;;;1671       {
;;;1672           i32Res = C_FAILED;
001c14  e3e09000          MVN      r9,#0
                  |L1.7192|
;;;1673       }
;;;1674   
;;;1675       return i32Res;
001c18  e1a00009          MOV      r0,r9
;;;1676   }
001c1c  e8bd8ffc          POP      {r2-r11,pc}
;;;1677   
                          ENDP

                  i32QSPIC_PgrmFastRead PROC
;;;1680   
;;;1681   int32_t i32QSPIC_PgrmFastRead(qspic_cntrl_e eController, qspic_dev_e eDevice, uint32_t u32SpiPhysAddr, uint16_t u16DataCount, uint8_t* const pu8Data)
001c20  e92d4ffc          PUSH     {r2-r11,lr}
;;;1682   {
001c24  e1a04000          MOV      r4,r0
001c28  e1a08001          MOV      r8,r1
001c2c  e1a05002          MOV      r5,r2
001c30  e1a0a003          MOV      r10,r3
001c34  e59db02c          LDR      r11,[sp,#0x2c]
;;;1683       uint16_t u16DataIndex;
;;;1684       int32_t  i32Res;
;;;1685       uint32_t u32Cnt;
;;;1686       uint32_t u32Mask;
;;;1687       /* default values for Prg Access Ctrl value is as follows:
;;;1688         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1689         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1690         * SpiCycGo = Program Register Access is initiated.
;;;1691       */
;;;1692       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001c38  e3a06001          MOV      r6,#1
;;;1693   
;;;1694   
;;;1695       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001c3c  e3540000          CMP      r4,#0
001c40  0a000002          BEQ      |L1.7248|
001c44  e51f0e48          LDR      r0,|L1.3588|
001c48  e1540000          CMP      r4,r0
001c4c  1a000003          BNE      |L1.7264|
                  |L1.7248|
;;;1696                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
001c50  e3580000          CMP      r8,#0
001c54  0a000005          BEQ      |L1.7280|
001c58  e3580001          CMP      r8,#1
001c5c  0a000003          BEQ      |L1.7280|
                  |L1.7264|
;;;1697               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001c60  e3540a01          CMP      r4,#0x1000
001c64  1a000054          BNE      |L1.7612|
001c68  e3580000          CMP      r8,#0
001c6c  1a000052          BNE      |L1.7612|
                  |L1.7280|
;;;1698       {
;;;1699           /* check for valid data buffer pointer */
;;;1700           if (C_NULL == pu8Data)
001c70  e35b0000          CMP      r11,#0
001c74  1a000001          BNE      |L1.7296|
;;;1701           {
;;;1702               i32Res = C_FAILED;
001c78  e3e09000          MVN      r9,#0
001c7c  ea00004f          B        |L1.7616|
                  |L1.7296|
;;;1703           }
;;;1704           else
;;;1705           {
;;;1706               /* wait for cycle completion of previous program access */
;;;1707               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001c80  e320f000          NOP      
                  |L1.7300|
001c84  e1a00004          MOV      r0,r4
001c88  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001c8c  e3500001          CMP      r0,#1
001c90  0afffffb          BEQ      |L1.7300|
;;;1708   
;;;1709               vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_FAST_READ);                       /* set up FAST READ opcode */
001c94  e3a0000b          MOV      r0,#0xb
001c98  e59f122c          LDR      r1,|L1.7884|
001c9c  e7c40001          STRB     r0,[r4,r1]
;;;1710   
;;;1711               if (ePrgAddressByteCnt == QSPI_ADDR_3BYTE)
001ca0  e51f0e9c          LDR      r0,|L1.3596|
001ca4  e5d00000          LDRB     r0,[r0,#0]  ; ePrgAddressByteCnt
001ca8  e3500000          CMP      r0,#0
001cac  1a00000b          BNE      |L1.7392|
;;;1712               {
;;;1713                   vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
001cb0  e1a00825          LSR      r0,r5,#16
001cb4  e0811004          ADD      r1,r1,r4
001cb8  e5c10001          STRB     r0,[r1,#1]
;;;1714                   vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
001cbc  e1a00425          LSR      r0,r5,#8
001cc0  e59f1204          LDR      r1,|L1.7884|
001cc4  e0811004          ADD      r1,r1,r4
001cc8  e5c10002          STRB     r0,[r1,#2]
;;;1715                   vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
001ccc  e59f11f8          LDR      r1,|L1.7884|
001cd0  e0811004          ADD      r1,r1,r4
001cd4  e5c15003          STRB     r5,[r1,#3]
;;;1716   
;;;1717                   /* set primary buffer byte counter (3 byte address plus 1 dummy byte) */
;;;1718                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_4;
001cd8  e3866701          ORR      r6,r6,#0x40000
001cdc  ea000015          B        |L1.7480|
                  |L1.7392|
;;;1719               }
;;;1720               else
;;;1721               {
;;;1722                   u32Mask = ~(biGetQSPIC_FlshMemMap0_FBA(eController) >> 8);
001ce0  e51f0ee0          LDR      r0,|L1.3592|
001ce4  e7940000          LDR      r0,[r4,r0]
001ce8  e1a00820          LSR      r0,r0,#16
001cec  e1e00440          MVN      r0,r0,ASR #8
001cf0  e58d0000          STR      r0,[sp,#0]
;;;1723                   vSetQSPIC_PriBufDatN(eController, 1, (uint8_t)((u32SpiPhysAddr >> 24) & u32Mask));   /* SPI physical addr[31:23] */
001cf4  e59d0000          LDR      r0,[sp,#0]
001cf8  e0000c25          AND      r0,r0,r5,LSR #24
001cfc  e59f11c8          LDR      r1,|L1.7884|
001d00  e0811004          ADD      r1,r1,r4
001d04  e5c10001          STRB     r0,[r1,#1]
;;;1724                   vSetQSPIC_PriBufDatN(eController, 2, (uint8_t)((u32SpiPhysAddr >> 16) & 0xFFU));     /* SPI physical addr[23:16] */
001d08  e1a00825          LSR      r0,r5,#16
001d0c  e59f11b8          LDR      r1,|L1.7884|
001d10  e0811004          ADD      r1,r1,r4
001d14  e5c10002          STRB     r0,[r1,#2]
;;;1725                   vSetQSPIC_PriBufDatN(eController, 3, (uint8_t)((u32SpiPhysAddr >>  8) & 0xFFU));     /* SPI physical addr[15:8] */
001d18  e1a00425          LSR      r0,r5,#8
001d1c  e59f11a8          LDR      r1,|L1.7884|
001d20  e0811004          ADD      r1,r1,r4
001d24  e5c10003          STRB     r0,[r1,#3]
;;;1726                   vSetQSPIC_PriBufDatN(eController, 4, (uint8_t)((u32SpiPhysAddr >>  0) & 0xFFU));     /* SPI physical addr[7:0] */
001d28  e59f119c          LDR      r1,|L1.7884|
001d2c  e0811004          ADD      r1,r1,r4
001d30  e5c15004          STRB     r5,[r1,#4]
;;;1727   
;;;1728                   /* set primary buffer byte counter (4 byte address plus 1 dummy byte) */
;;;1729                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_BUF_CNT_5;
001d34  e3866805          ORR      r6,r6,#0x50000
                  |L1.7480|
;;;1730               }
;;;1731   
;;;1732               if (QSPIC_DEV_1 == eDevice )
001d38  e3580001          CMP      r8,#1
001d3c  1a000000          BNE      |L1.7492|
;;;1733               {
;;;1734                   /* set SPI_CS1_N accordingly */
;;;1735                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001d40  e3866002          ORR      r6,r6,#2
                  |L1.7492|
;;;1736               }
;;;1737   
;;;1738               /* enable primary buffer */
;;;1739               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001d44  e3866010          ORR      r6,r6,#0x10
;;;1740   
;;;1741               /* set secondary buffer byte counter */
;;;1742               /* follwoing code simplified:
;;;1743                *   u32PrgAccCtrl = u32PrgAccCtrl | (  (((uint32_t ) (u16DataCount-1) )  << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
;;;1744                */
;;;1745               u32Cnt = ((uint32_t) u16DataCount) -1U;
001d48  e24a0001          SUB      r0,r10,#1
001d4c  e58d0004          STR      r0,[sp,#4]
;;;1746               u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
001d50  e59d0004          LDR      r0,[sp,#4]
001d54  e1a00c00          LSL      r0,r0,#24
001d58  e58d0004          STR      r0,[sp,#4]
;;;1747               u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
001d5c  e59d0004          LDR      r0,[sp,#4]
001d60  e20004ff          AND      r0,r0,#0xff000000
001d64  e1866000          ORR      r6,r6,r0
;;;1748   
;;;1749               /* enable secondary buffer */
;;;1750               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
001d68  e3866020          ORR      r6,r6,#0x20
;;;1751   
;;;1752               /* write value to register */
;;;1753               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001d6c  e51f0f6c          LDR      r0,|L1.3592|
001d70  e0800004          ADD      r0,r0,r4
001d74  e5806404          STR      r6,[r0,#0x404]
;;;1754   
;;;1755               /* wait until current program access cycle is completed */
;;;1756               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001d78  e320f000          NOP      
                  |L1.7548|
001d7c  e1a00004          MOV      r0,r4
001d80  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001d84  e3500000          CMP      r0,#0
001d88  0afffffb          BEQ      |L1.7548|
;;;1757   
;;;1758               /* copy reading result into result buffer array */
;;;1759               for (u16DataIndex = 0; u16DataIndex < u16DataCount; u16DataIndex++)
001d8c  e3a07000          MOV      r7,#0
001d90  ea000005          B        |L1.7596|
                  |L1.7572|
;;;1760               {
;;;1761                   pu8Data[u16DataIndex] = u8GetQSPIC_SecBufDatN(eController, u16DataIndex);
001d94  e59f0134          LDR      r0,|L1.7888|
001d98  e0800004          ADD      r0,r0,r4
001d9c  e7d00007          LDRB     r0,[r0,r7]
001da0  e7cb0007          STRB     r0,[r11,r7]
001da4  e2870001          ADD      r0,r7,#1              ;1759
001da8  e6ff7070          UXTH     r7,r0                 ;1759
                  |L1.7596|
001dac  e157000a          CMP      r7,r10                ;1759
001db0  bafffff7          BLT      |L1.7572|
;;;1762               }
;;;1763   
;;;1764               i32Res = C_SUCCESS;
001db4  e3a09000          MOV      r9,#0
001db8  ea000000          B        |L1.7616|
                  |L1.7612|
;;;1765           }
;;;1766       }
;;;1767       else
;;;1768       {
;;;1769           i32Res = C_FAILED;
001dbc  e3e09000          MVN      r9,#0
                  |L1.7616|
;;;1770       }
;;;1771   
;;;1772       return i32Res;
001dc0  e1a00009          MOV      r0,r9
;;;1773   }
001dc4  e8bd8ffc          POP      {r2-r11,pc}
;;;1774   
                          ENDP

                  i32QSPIC_PgrmGetExtendedID PROC
;;;1873   
;;;1874   int32_t i32QSPIC_PgrmGetExtendedID(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t* const pu8Information)
001dc8  e92d41f0          PUSH     {r4-r8,lr}
;;;1875   {
001dcc  e1a04000          MOV      r4,r0
001dd0  e1a06001          MOV      r6,r1
001dd4  e1a05002          MOV      r5,r2
;;;1876       int32_t i32Res = C_SUCCESS;
001dd8  e3a08000          MOV      r8,#0
;;;1877       /* default values for Prg Access Ctrl value is as follows:
;;;1878         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1879         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1880         * SpiCycGo = Program Register Access is initiated.
;;;1881       */
;;;1882       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001ddc  e3a07001          MOV      r7,#1
;;;1883   
;;;1884   
;;;1885       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001de0  e3540000          CMP      r4,#0
001de4  0a000002          BEQ      |L1.7668|
001de8  e51f0fec          LDR      r0,|L1.3588|
001dec  e1540000          CMP      r4,r0
001df0  1a000003          BNE      |L1.7684|
                  |L1.7668|
;;;1886                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
001df4  e3560000          CMP      r6,#0
001df8  0a000005          BEQ      |L1.7700|
001dfc  e3560001          CMP      r6,#1
001e00  0a000003          BEQ      |L1.7700|
                  |L1.7684|
;;;1887               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001e04  e3540a01          CMP      r4,#0x1000
001e08  1a00002c          BNE      |L1.7872|
001e0c  e3560000          CMP      r6,#0
001e10  1a00002a          BNE      |L1.7872|
                  |L1.7700|
;;;1888       {
;;;1889           /* check for valid status pointer */
;;;1890           if( C_NULL == pu8Information )
001e14  e3550000          CMP      r5,#0
001e18  1a000001          BNE      |L1.7716|
;;;1891           {
;;;1892               i32Res = C_FAILED;
001e1c  e3e08000          MVN      r8,#0
001e20  ea000027          B        |L1.7876|
                  |L1.7716|
;;;1893           }
;;;1894           else
;;;1895           {
;;;1896               /* wait for cycle completion of previous program access */
;;;1897               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001e24  e320f000          NOP      
                  |L1.7720|
001e28  e1a00004          MOV      r0,r4
001e2c  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001e30  e3500001          CMP      r0,#1
001e34  0afffffb          BEQ      |L1.7720|
;;;1898   
;;;1899               /* set up STATUS READ opcode */
;;;1900               vSetQSPIC_PriBufDatN(eController, 0, QSPIC_OPCODE_READ_EXTID);
001e38  e3a0009f          MOV      r0,#0x9f
001e3c  e59f1088          LDR      r1,|L1.7884|
001e40  e7c40001          STRB     r0,[r4,r1]
;;;1901   
;;;1902               if (QSPIC_DEV_1 == eDevice )
001e44  e3560001          CMP      r6,#1
001e48  1a000000          BNE      |L1.7760|
;;;1903               {
;;;1904                   /* set SPI_CS1_N accordingly */
;;;1905                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001e4c  e3877002          ORR      r7,r7,#2
                  |L1.7760|
;;;1906               }
;;;1907   
;;;1908               /* enable primary buffer */
;;;1909               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001e50  e3877010          ORR      r7,r7,#0x10
;;;1910   
;;;1911               /* set secondary buffer byte counter */
;;;1912               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_CNT_3;
001e54  e3877403          ORR      r7,r7,#0x3000000
;;;1913   
;;;1914   
;;;1915               /* enable secondary buffer */
;;;1916               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
001e58  e3877020          ORR      r7,r7,#0x20
;;;1917   
;;;1918               /* write value to register */
;;;1919               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001e5c  e59f0070          LDR      r0,|L1.7892|
001e60  e0800004          ADD      r0,r0,r4
001e64  e5807404          STR      r7,[r0,#0x404]
;;;1920   
;;;1921               /* wait until current program access cycle is completed */
;;;1922               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001e68  e320f000          NOP      
                  |L1.7788|
001e6c  e1a00004          MOV      r0,r4
001e70  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001e74  e3500000          CMP      r0,#0
001e78  0afffffb          BEQ      |L1.7788|
;;;1923   
;;;1924               /* Retrieve the status */
;;;1925               pu8Information[0] = u8GetQSPIC_SecBufDatN(eController, 0);
001e7c  e59f004c          LDR      r0,|L1.7888|
001e80  e7d40000          LDRB     r0,[r4,r0]
001e84  e5c50000          STRB     r0,[r5,#0]
;;;1926               pu8Information[1] = u8GetQSPIC_SecBufDatN(eController, 1);
001e88  e59f0040          LDR      r0,|L1.7888|
001e8c  e0800004          ADD      r0,r0,r4
001e90  e5d00001          LDRB     r0,[r0,#1]
001e94  e5c50001          STRB     r0,[r5,#1]
;;;1927               pu8Information[2] = u8GetQSPIC_SecBufDatN(eController, 2);
001e98  e59f0030          LDR      r0,|L1.7888|
001e9c  e0800004          ADD      r0,r0,r4
001ea0  e5d00002          LDRB     r0,[r0,#2]
001ea4  e5c50002          STRB     r0,[r5,#2]
;;;1928               pu8Information[3] = u8GetQSPIC_SecBufDatN(eController, 3);
001ea8  e59f0020          LDR      r0,|L1.7888|
001eac  e0800004          ADD      r0,r0,r4
001eb0  e5d00003          LDRB     r0,[r0,#3]
001eb4  e5c50003          STRB     r0,[r5,#3]
;;;1929   
;;;1930               i32Res = C_SUCCESS;
001eb8  e3a08000          MOV      r8,#0
001ebc  ea000000          B        |L1.7876|
                  |L1.7872|
;;;1931           }
;;;1932       }
;;;1933       else
;;;1934       {
;;;1935           i32Res = C_FAILED;
001ec0  e3e08000          MVN      r8,#0
                  |L1.7876|
;;;1936       }
;;;1937   
;;;1938       return i32Res;
001ec4  e1a00008          MOV      r0,r8
;;;1939   }
001ec8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7884|
                          DCD      0xc0109500
                  |L1.7888|
                          DCD      0xc0109600
                  |L1.7892|
                          DCD      0xc0109000
                          ENDP

                  i32QSPIC_WriteByte PROC
;;;1943   
;;;1944   int32_t i32QSPIC_WriteByte(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Value)
001ed8  e92d41f0          PUSH     {r4-r8,lr}
;;;1945   {
001edc  e1a04000          MOV      r4,r0
001ee0  e1a05001          MOV      r5,r1
001ee4  e1a07002          MOV      r7,r2
;;;1946       int32_t i32Res = C_SUCCESS;
001ee8  e3a08000          MOV      r8,#0
;;;1947       /* default values for Prg Access Ctrl value is as follows:
;;;1948         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1949         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;1950         * SpiCycGo = Program Register Access is initiated.
;;;1951       */
;;;1952       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001eec  e3a06001          MOV      r6,#1
;;;1953   
;;;1954   
;;;1955       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001ef0  e3540000          CMP      r4,#0
001ef4  0a000002          BEQ      |L1.7940|
001ef8  e59f0348          LDR      r0,|L1.8776|
001efc  e1540000          CMP      r4,r0
001f00  1a000003          BNE      |L1.7956|
                  |L1.7940|
;;;1956                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
001f04  e3550000          CMP      r5,#0
001f08  0a000005          BEQ      |L1.7972|
001f0c  e3550001          CMP      r5,#1
001f10  0a000003          BEQ      |L1.7972|
                  |L1.7956|
;;;1957               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001f14  e3540a01          CMP      r4,#0x1000
001f18  1a000015          BNE      |L1.8052|
001f1c  e3550000          CMP      r5,#0
001f20  1a000013          BNE      |L1.8052|
                  |L1.7972|
;;;1958       {
;;;1959           /* wait for cycle completion of previous program access */
;;;1960           while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001f24  e320f000          NOP      
                  |L1.7976|
001f28  e1a00004          MOV      r0,r4
001f2c  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001f30  e3500001          CMP      r0,#1
001f34  0afffffb          BEQ      |L1.7976|
;;;1961   
;;;1962           /* set up WRITE DISABLE opcode */
;;;1963           vSetQSPIC_PriBufDatN(eController, 0, u8Value);
001f38  e51f0074          LDR      r0,|L1.7884|
001f3c  e7c47000          STRB     r7,[r4,r0]
;;;1964   
;;;1965           if (QSPIC_DEV_1 == eDevice )
001f40  e3550001          CMP      r5,#1
001f44  1a000000          BNE      |L1.8012|
;;;1966           {
;;;1967               /* set SPI_CS1_N accordingly */
;;;1968               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
001f48  e3866002          ORR      r6,r6,#2
                  |L1.8012|
;;;1969           }
;;;1970   
;;;1971           /* enable primary buffer */
;;;1972           u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
001f4c  e3866010          ORR      r6,r6,#0x10
;;;1973   
;;;1974           /* write value to register */
;;;1975           vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
001f50  e51f0084          LDR      r0,|L1.7892|
001f54  e0800004          ADD      r0,r0,r4
001f58  e5806404          STR      r6,[r0,#0x404]
;;;1976   
;;;1977           /* wait until current program access cycle is completed */
;;;1978           while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
001f5c  e320f000          NOP      
                  |L1.8032|
001f60  e1a00004          MOV      r0,r4
001f64  ebfffffe          BL       boQSPIC_IsSpiCycleDone
001f68  e3500000          CMP      r0,#0
001f6c  0afffffb          BEQ      |L1.8032|
001f70  ea000000          B        |L1.8056|
                  |L1.8052|
;;;1979       }
;;;1980       else
;;;1981       {
;;;1982           i32Res = C_FAILED;
001f74  e3e08000          MVN      r8,#0
                  |L1.8056|
;;;1983       }
;;;1984   
;;;1985       return i32Res;
001f78  e1a00008          MOV      r0,r8
;;;1986   }
001f7c  e8bd81f0          POP      {r4-r8,pc}
;;;1987   
                          ENDP

                  i32QSPIC_PgrmGetRegister PROC
;;;1990   
;;;1991   int32_t i32QSPIC_PgrmGetRegister(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Command, uint16_t u16Count, uint8_t* pu8Information)
001f80  e92d4ff8          PUSH     {r3-r11,lr}
;;;1992   {
001f84  e1a04000          MOV      r4,r0
001f88  e1a05001          MOV      r5,r1
001f8c  e1a09002          MOV      r9,r2
001f90  e1a08003          MOV      r8,r3
001f94  e59da028          LDR      r10,[sp,#0x28]
;;;1993       int32_t  i32Res = C_SUCCESS;
001f98  e3a00000          MOV      r0,#0
001f9c  e58d0000          STR      r0,[sp,#0]
;;;1994       uint16_t u16Counter;
;;;1995       uint32_t u32Cnt;
;;;1996   
;;;1997       /* default values for Prg Access Ctrl value is as follows:
;;;1998         * Primary and secondary buffer size = 0, both buffers are disabled
;;;1999         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;2000         * SpiCycGo = Program Register Access is initiated.
;;;2001       */
;;;2002       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
001fa0  e3a07001          MOV      r7,#1
;;;2003   
;;;2004   
;;;2005       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
001fa4  e3540000          CMP      r4,#0
001fa8  0a000002          BEQ      |L1.8120|
001fac  e59f0294          LDR      r0,|L1.8776|
001fb0  e1540000          CMP      r4,r0
001fb4  1a000003          BNE      |L1.8136|
                  |L1.8120|
;;;2006                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
001fb8  e3550000          CMP      r5,#0
001fbc  0a000005          BEQ      |L1.8152|
001fc0  e3550001          CMP      r5,#1
001fc4  0a000003          BEQ      |L1.8152|
                  |L1.8136|
;;;2007               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
001fc8  e3540a01          CMP      r4,#0x1000
001fcc  1a000038          BNE      |L1.8372|
001fd0  e3550000          CMP      r5,#0
001fd4  1a000036          BNE      |L1.8372|
                  |L1.8152|
;;;2008       {
;;;2009           /* check for valid status pointer */
;;;2010           if( C_NULL == pu8Information )
001fd8  e35a0000          CMP      r10,#0
001fdc  1a000002          BNE      |L1.8172|
;;;2011           {
;;;2012               i32Res = C_FAILED;
001fe0  e3e00000          MVN      r0,#0
001fe4  e58d0000          STR      r0,[sp,#0]
001fe8  ea000033          B        |L1.8380|
                  |L1.8172|
;;;2013           }
;;;2014           else
;;;2015           {
;;;2016               /* wait for cycle completion of previous program access */
;;;2017               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
001fec  e320f000          NOP      
                  |L1.8176|
001ff0  e1a00004          MOV      r0,r4
001ff4  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
001ff8  e3500001          CMP      r0,#1
001ffc  0afffffb          BEQ      |L1.8176|
;;;2018   
;;;2019               /* set up STATUS READ opcode */
;;;2020               vSetQSPIC_PriBufDatN(eController, 0, u8Command);
002000  e51f013c          LDR      r0,|L1.7884|
002004  e7c49000          STRB     r9,[r4,r0]
;;;2021               vSetQSPIC_PriBufDatN(eController, 1, 0x00);
002008  e3a00000          MOV      r0,#0
00200c  e51f1148          LDR      r1,|L1.7884|
002010  e0811004          ADD      r1,r1,r4
002014  e5c10001          STRB     r0,[r1,#1]
;;;2022               vSetQSPIC_PriBufDatN(eController, 2, 0x00);
002018  e51f1154          LDR      r1,|L1.7884|
00201c  e0811004          ADD      r1,r1,r4
002020  e5c10002          STRB     r0,[r1,#2]
;;;2023               vSetQSPIC_PriBufDatN(eController, 3, 0x00);
002024  e51f1160          LDR      r1,|L1.7884|
002028  e0811004          ADD      r1,r1,r4
00202c  e5c10003          STRB     r0,[r1,#3]
;;;2024   
;;;2025               if (QSPIC_DEV_1 == eDevice )
002030  e3550001          CMP      r5,#1
002034  1a000000          BNE      |L1.8252|
;;;2026               {
;;;2027                   /* set SPI_CS1_N accordingly */
;;;2028                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
002038  e3877002          ORR      r7,r7,#2
                  |L1.8252|
;;;2029               }
;;;2030   
;;;2031               /* enable primary buffer */
;;;2032               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
00203c  e3877010          ORR      r7,r7,#0x10
;;;2033   
;;;2034               if (QSPIC_DEV_1 == eDevice )
002040  e3550001          CMP      r5,#1
002044  1a000000          BNE      |L1.8268|
;;;2035               {
;;;2036                   /* set SPI_CS1_N accordingly */
;;;2037                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
002048  e3877002          ORR      r7,r7,#2
                  |L1.8268|
;;;2038               }
;;;2039               /* set secondary buffer byte counter */
;;;2040               /* follwoing code simplified:
;;;2041                *   u32PrgAccCtrl = u32PrgAccCtrl | ( (((uint32_t) (u16Count-1) ) << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK);
;;;2042                */
;;;2043               u32Cnt = ((uint32_t) u16Count) -1U;
00204c  e248b001          SUB      r11,r8,#1
;;;2044               u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
002050  e1a0bc0b          LSL      r11,r11,#24
;;;2045               u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
002054  e20b04ff          AND      r0,r11,#0xff000000
002058  e1877000          ORR      r7,r7,r0
;;;2046   
;;;2047               /* enable secondary buffer */
;;;2048               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SEC_BUF_EN_BIT;
00205c  e3877020          ORR      r7,r7,#0x20
;;;2049   
;;;2050               /* write value to register */
;;;2051               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
002060  e51f0194          LDR      r0,|L1.7892|
002064  e0800004          ADD      r0,r0,r4
002068  e5807404          STR      r7,[r0,#0x404]
;;;2052   
;;;2053               /* wait until current program access cycle is completed */
;;;2054               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) ){}
00206c  e320f000          NOP      
                  |L1.8304|
002070  e1a00004          MOV      r0,r4
002074  ebfffffe          BL       boQSPIC_IsSpiCycleDone
002078  e3500000          CMP      r0,#0
00207c  0afffffb          BEQ      |L1.8304|
;;;2055   
;;;2056               /* Retrieve the status */
;;;2057               for (u16Counter=0; u16Counter<u16Count; u16Counter++)
002080  e3a06000          MOV      r6,#0
002084  ea000005          B        |L1.8352|
                  |L1.8328|
;;;2058               {
;;;2059                   *(pu8Information + u16Counter) = u8GetQSPIC_SecBufDatN(eController, u16Counter);
002088  e51f01c0          LDR      r0,|L1.7888|
00208c  e0800004          ADD      r0,r0,r4
002090  e7d00006          LDRB     r0,[r0,r6]
002094  e7ca0006          STRB     r0,[r10,r6]
002098  e2860001          ADD      r0,r6,#1              ;2057
00209c  e6ff6070          UXTH     r6,r0                 ;2057
                  |L1.8352|
0020a0  e1560008          CMP      r6,r8                 ;2057
0020a4  bafffff7          BLT      |L1.8328|
;;;2060               }
;;;2061   
;;;2062               i32Res = C_SUCCESS;
0020a8  e3a00000          MOV      r0,#0
0020ac  e58d0000          STR      r0,[sp,#0]
0020b0  ea000001          B        |L1.8380|
                  |L1.8372|
;;;2063           }
;;;2064       }
;;;2065       else
;;;2066       {
;;;2067           i32Res = C_FAILED;
0020b4  e3e00000          MVN      r0,#0
0020b8  e58d0000          STR      r0,[sp,#0]
                  |L1.8380|
;;;2068       }
;;;2069   
;;;2070       return i32Res;
0020bc  e59d0000          LDR      r0,[sp,#0]
;;;2071   }
0020c0  e8bd8ff8          POP      {r3-r11,pc}
;;;2072   
                          ENDP

                  i32QSPIC_PgrmWriteRegister PROC
;;;2075   
;;;2076   int32_t i32QSPIC_PgrmWriteRegister(qspic_cntrl_e eController, qspic_dev_e eDevice, uint8_t u8Command, uint16_t u16Count, uint8_t* pu8Information)
0020c4  e92d4ff8          PUSH     {r3-r11,lr}
;;;2077   {
0020c8  e1a04000          MOV      r4,r0
0020cc  e1a06001          MOV      r6,r1
0020d0  e1a09002          MOV      r9,r2
0020d4  e1a08003          MOV      r8,r3
0020d8  e59da028          LDR      r10,[sp,#0x28]
;;;2078       int32_t  i32Res = C_SUCCESS;
0020dc  e3a00000          MOV      r0,#0
0020e0  e58d0000          STR      r0,[sp,#0]
;;;2079       uint16_t u16DataIndex;
;;;2080       uint32_t u32Cnt;
;;;2081   
;;;2082       /* default values for Prg Access Ctrl value is as follows:
;;;2083         * Primary and secondary buffer size = 0, both buffers are disabled
;;;2084         * Chip select Number=0,SPI_CS0_N (Primary) -> QSPIC_DEV_0
;;;2085         * SpiCycGo = Program Register Access is initiated.
;;;2086       */
;;;2087       uint32_t u32PrgAccCtrl = QSPIC_PACTRL_SPI_CYC_GO_BIT;
0020e4  e3a07001          MOV      r7,#1
;;;2088   
;;;2089   
;;;2090       if ( ( ((QSPIC_CNTRL_0 == eController) || (QSPIC_CNTRL_1 == eController ))  &&
0020e8  e3540000          CMP      r4,#0
0020ec  0a000002          BEQ      |L1.8444|
0020f0  e59f0150          LDR      r0,|L1.8776|
0020f4  e1540000          CMP      r4,r0
0020f8  1a000003          BNE      |L1.8460|
                  |L1.8444|
;;;2091                           ((QSPIC_DEV_0 == eDevice) || ( QSPIC_DEV_1==eDevice)))
0020fc  e3560000          CMP      r6,#0
002100  0a000005          BEQ      |L1.8476|
002104  e3560001          CMP      r6,#1
002108  0a000003          BEQ      |L1.8476|
                  |L1.8460|
;;;2092               || (( QSPIC_CNTRL_2 == eController ) && ( QSPIC_DEV_0 == eDevice )) )
00210c  e3540a01          CMP      r4,#0x1000
002110  1a000035          BNE      |L1.8684|
002114  e3560000          CMP      r6,#0
002118  1a000033          BNE      |L1.8684|
                  |L1.8476|
;;;2093       {
;;;2094           /* check for valid status pointer */
;;;2095           if( C_NULL == pu8Information )
00211c  e35a0000          CMP      r10,#0
002120  1a000002          BNE      |L1.8496|
;;;2096           {
;;;2097               i32Res = C_FAILED;
002124  e3e00000          MVN      r0,#0
002128  e58d0000          STR      r0,[sp,#0]
00212c  ea000030          B        |L1.8692|
                  |L1.8496|
;;;2098           }
;;;2099           else
;;;2100           {
;;;2101               /* wait for cycle completion of previous program access */
;;;2102               while ( C_TRUE == boQSPIC_IsSpiCycleInPgrs(eController) ){}
002130  e320f000          NOP      
                  |L1.8500|
002134  e1a00004          MOV      r0,r4
002138  ebfffffe          BL       boQSPIC_IsSpiCycleInPgrs
00213c  e3500001          CMP      r0,#1
002140  0afffffb          BEQ      |L1.8500|
;;;2103   
;;;2104               /* set up STATUS READ opcode */
;;;2105               vSetQSPIC_PriBufDatN(eController, 0, u8Command);
002144  e51f0280          LDR      r0,|L1.7884|
002148  e7c49000          STRB     r9,[r4,r0]
;;;2106               vSetQSPIC_PriBufDatN(eController, 1, 0x00);
00214c  e3a00000          MOV      r0,#0
002150  e51f128c          LDR      r1,|L1.7884|
002154  e0811004          ADD      r1,r1,r4
002158  e5c10001          STRB     r0,[r1,#1]
;;;2107               vSetQSPIC_PriBufDatN(eController, 2, 0x00);
00215c  e51f1298          LDR      r1,|L1.7884|
002160  e0811004          ADD      r1,r1,r4
002164  e5c10002          STRB     r0,[r1,#2]
;;;2108               vSetQSPIC_PriBufDatN(eController, 3, 0x00);
002168  e51f12a4          LDR      r1,|L1.7884|
00216c  e0811004          ADD      r1,r1,r4
002170  e5c10003          STRB     r0,[r1,#3]
;;;2109   
;;;2110               for (u16DataIndex = 0; u16DataIndex < u16Count; u16DataIndex++)
002174  e3a05000          MOV      r5,#0
002178  ea000005          B        |L1.8596|
                  |L1.8572|
;;;2111               {
;;;2112                   vSetQSPIC_SecBufDatN(eController, u16DataIndex, pu8Information[u16DataIndex]);
00217c  e7da0005          LDRB     r0,[r10,r5]
002180  e51f12b8          LDR      r1,|L1.7888|
002184  e0811004          ADD      r1,r1,r4
002188  e7c10005          STRB     r0,[r1,r5]
00218c  e2850001          ADD      r0,r5,#1              ;2110
002190  e6ff5070          UXTH     r5,r0                 ;2110
                  |L1.8596|
002194  e1550008          CMP      r5,r8                 ;2110
002198  bafffff7          BLT      |L1.8572|
;;;2113               }
;;;2114   
;;;2115               if (QSPIC_DEV_1 == eDevice )
00219c  e3560001          CMP      r6,#1
0021a0  1a000000          BNE      |L1.8616|
;;;2116               {
;;;2117                   /* set SPI_CS1_N accordingly */
;;;2118                   u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_SPI_CS_DEV1_BIT;
0021a4  e3877002          ORR      r7,r7,#2
                  |L1.8616|
;;;2119               }
;;;2120   
;;;2121               /* enable primary buffer */
;;;2122               u32PrgAccCtrl = u32PrgAccCtrl | QSPIC_PACTRL_PRI_EN_BIT;
0021a8  e3877010          ORR      r7,r7,#0x10
;;;2123   
;;;2124               /* set secondary buffer byte counter */
;;;2125               /* follwoing code simplified:
;;;2126                *   u32PrgAccCtrl = u32PrgAccCtrl | ( (((uint32_t) (u16Count-1) ) << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT ) &  QSPIC_PACTRL_SEC_BUF_CNT_MASK);
;;;2127                */
;;;2128               u32Cnt = ((uint32_t) u16Count) -1U;
0021ac  e248b001          SUB      r11,r8,#1
;;;2129               u32Cnt = u32Cnt << QSPIC_PACTRL_SEC_BUF_CNT_SHIFT;
0021b0  e1a0bc0b          LSL      r11,r11,#24
;;;2130               u32PrgAccCtrl |=  ( u32Cnt &  QSPIC_PACTRL_SEC_BUF_CNT_MASK );
0021b4  e20b04ff          AND      r0,r11,#0xff000000
0021b8  e1877000          ORR      r7,r7,r0
;;;2131   
;;;2132               /* enable secondary buffer */
;;;2133               u32PrgAccCtrl = u32PrgAccCtrl | ( QSPIC_PACTRL_SEC_BUF_EN_BIT);
0021bc  e3877020          ORR      r7,r7,#0x20
;;;2134   
;;;2135               /* write value to register */
;;;2136               vSetQSPIC_PrgAccCtrl1 (eController, u32PrgAccCtrl );
0021c0  e51f02f4          LDR      r0,|L1.7892|
0021c4  e0800004          ADD      r0,r0,r4
0021c8  e5807404          STR      r7,[r0,#0x404]
;;;2137   
;;;2138               /* wait until current program access cycle is completed */
;;;2139               while ( C_FALSE == boQSPIC_IsSpiCycleDone(eController) )
0021cc  e320f000          NOP      
                  |L1.8656|
0021d0  e1a00004          MOV      r0,r4
0021d4  ebfffffe          BL       boQSPIC_IsSpiCycleDone
0021d8  e3500000          CMP      r0,#0
0021dc  0afffffb          BEQ      |L1.8656|
;;;2140               {
;;;2141                   ;
;;;2142               }
;;;2143   
;;;2144               /* Retrieve the status */
;;;2145   /*            for (u16DataIndex=0; u16DataIndex<=u16Count; u16DataIndex++)
;;;2146               {
;;;2147                   *(pu8Information + u16DataIndex) = u8GetQSPIC_SecBufDatN(eController, u16DataIndex);
;;;2148               }
;;;2149   */
;;;2150   
;;;2151               i32Res = C_SUCCESS;
0021e0  e3a00000          MOV      r0,#0
0021e4  e58d0000          STR      r0,[sp,#0]
0021e8  ea000001          B        |L1.8692|
                  |L1.8684|
;;;2152           }
;;;2153       }
;;;2154       else
;;;2155       {
;;;2156           i32Res = C_FAILED;
0021ec  e3e00000          MVN      r0,#0
0021f0  e58d0000          STR      r0,[sp,#0]
                  |L1.8692|
;;;2157       }
;;;2158   
;;;2159       return i32Res;
0021f4  e59d0000          LDR      r0,[sp,#0]
;;;2160   }
0021f8  e8bd8ff8          POP      {r3-r11,pc}
;;;2161   
                          ENDP

                  u32QSPIC_DirectReadWord PROC
;;;2165   
;;;2166   uint32_t u32QSPIC_DirectReadWord(uint32_t u32SpiPhysAddr)
0021fc  e92d4010          PUSH     {r4,lr}
;;;2167   {
002200  e1a04000          MOV      r4,r0
;;;2168       return (uint32_t) word_read((int32_t)u32SpiPhysAddr);
002204  e1a00004          MOV      r0,r4
002208  ebfffffe          BL       word_read
;;;2169   }
00220c  e8bd8010          POP      {r4,pc}
;;;2170   
                          ENDP

                  vQSPIC_DirectReadBurst4 PROC
;;;2173   
;;;2174   void vQSPIC_DirectReadBurst4(uint32_t u32SpiPhysAddr, uint32_t * pu32Data)
002210  e92d4070          PUSH     {r4-r6,lr}
;;;2175   {
002214  e1a04000          MOV      r4,r0
002218  e1a05001          MOV      r5,r1
;;;2176       read_burst4((int32_t)u32SpiPhysAddr, pu32Data);
00221c  e1a01005          MOV      r1,r5
002220  e1a00004          MOV      r0,r4
002224  ebfffffe          BL       read_burst4
;;;2177   }
002228  e8bd8070          POP      {r4-r6,pc}
;;;2178   
                          ENDP

                  vQSPIC_DirectReadBurst8 PROC
;;;2181   
;;;2182   void vQSPIC_DirectReadBurst8(uint32_t u32SpiPhysAddr, uint32_t * pu32Data)
00222c  e92d4070          PUSH     {r4-r6,lr}
;;;2183   {
002230  e1a04000          MOV      r4,r0
002234  e1a05001          MOV      r5,r1
;;;2184       read_burst8((int32_t)u32SpiPhysAddr, pu32Data);
002238  e1a01005          MOV      r1,r5
00223c  e1a00004          MOV      r0,r4
002240  ebfffffe          BL       read_burst8
;;;2185   }
002244  e8bd8070          POP      {r4-r6,pc}
;;;2186   
                          ENDP

                  |L1.8776|
                          DCD      0x00af8000

                          AREA ||.data||, DATA, ALIGN=0

                  au8LLDD_QSPIC_C_REVISION
000000  24526576          DCB      0x24,0x52,0x65,0x76
000004  6973696f          DCB      0x69,0x73,0x69,0x6f
000008  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00000c  2e343020          DCB      0x2e,0x34,0x30,0x20
000010  2400              DCB      0x24,0x00
                  au8LLDD_QSPIC_C_TAG
000012  244e              DCB      0x24,0x4e
000014  616d653a          DCB      0x61,0x6d,0x65,0x3a
000018  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00001c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000020  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_QSPIC_H_REVISION
000024  24526576          DCB      0x24,0x52,0x65,0x76
000028  6973696f          DCB      0x69,0x73,0x69,0x6f
00002c  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000030  2e333520          DCB      0x2e,0x33,0x35,0x20
000034  2400              DCB      0x24,0x00
                  au8LLDD_QSPIC_H_TAG
000036  244e              DCB      0x24,0x4e
000038  616d653a          DCB      0x61,0x6d,0x65,0x3a
00003c  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000040  445f315f          DCB      0x44,0x5f,0x31,0x5f
000044  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_QSPIC_IO_H_REVISION
000048  24526576          DCB      0x24,0x52,0x65,0x76
00004c  6973696f          DCB      0x69,0x73,0x69,0x6f
000050  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000054  2e323520          DCB      0x2e,0x32,0x35,0x20
000058  2400              DCB      0x24,0x00
                  au8LLDD_QSPIC_IO_H_TAG
00005a  244e              DCB      0x24,0x4e
00005c  616d653a          DCB      0x61,0x6d,0x65,0x3a
000060  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000064  445f315f          DCB      0x44,0x5f,0x31,0x5f
000068  36202400          DCB      0x36,0x20,0x24,0x00
                  ePrgAddressByteCnt
00006c  00                DCB      0x00
