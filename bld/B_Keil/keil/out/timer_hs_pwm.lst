L 1 "..\..\..\..\lldd\src\timer_hs_pwm.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : TIMER_HS_PWM low level driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : TIMER_HS_PWM
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.10 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "timer_hs_pwm_io.h"                  /* HS_PWM timer registers, bits and access macros defintion */
L 1 "..\..\..\..\lldd\hdr\timer_hs_pwm_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : HSPWM 
N/  Date of creation (y-m-d:time): 2015-02-18+01:00  :  15:40:00.056+01:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.12 $ 
N/  Excel Sheet ver.             : vv1.2
N/  Excel Sheet date             : 2014-Sep-17
N/  Excel Sheet author           : ZUL
N/##########################################################################*/
N
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : TIMER_HS_PWM low level device driver io-header file
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : TIMER_HS_PWM
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.12 $
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N
N#ifndef HSPWMIO_H
N#define HSPWMIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */ 
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 40 "..\..\..\..\lldd\hdr\timer_hs_pwm_io.h" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 230    /* Rule 6.4 [R] : nonstandard type for a bit field */
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
N#endif
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_TIMER_HS_PWM_IO_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_TIMER_HS_PWM_IO_H_TAG          "$Name: LLDD_1_6 $"
N     
N/****************************************************************************
N*                          CHANNEL SELECTION MACROS
N*             (Please use these macros to select module instances)
N*****************************************************************************/
N
Ntypedef enum tag_timer_hs_pwm_cntrl_def_e
N{
N  TIMER_HS_PWM_CNTRL_0__ = 0,
N  TIMER_HS_PWM_CNTRL_1__ = 0x1000,  
N  TIMER_HS_PWM_CNTRL_2__ = 0x2000,
N  TIMER_HS_PWM_CNTRL_3__ = 0x3000 
N} timer_hs_pwm_cntrl_def_e;
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: HSPWMCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0408000                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define HSPWMCR_REG__       0xC0408000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   TRUN	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   RSRVD1	:1; 	 /* 1..1  bit(s) R/W */
N  uint16_t   PREEN	:1; 	 /* 2..2  bit(s) R/W */
N  uint16_t   	:1; 	 /* 3..3  bit(s) R */
N  uint16_t   OL	:1; 	 /* 4..4  bit(s) R/W */
N  uint16_t   DB	:1; 	 /* 5..5  bit(s) R/W */
N  uint16_t   IE	:1; 	 /* 6..6  bit(s) R/W */
N  uint16_t   RSRVD7	:5; 	 /* 7..11  bit(s) R/W */
N  uint16_t   SCLK	:3; 	 /* 12..14  bit(s) R/W */
N  uint16_t   RSRVD15	:1; 	 /* 15..15  bit(s) R/W */                    
N} HSPWMCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} HSPWMCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16HSPWMCR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitHSPWMCR(ctrlr)     ((volatile HSPWMCR_bit_view_st *)\
N(HSPWMCR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_bitHSPWMCR(ctrlr)     ((volatile HSPWMCR_bit_view_st *)(HSPWMCR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8HSPWMCR(ctrlr)     ((volatile HSPWMCR_byte_view_st *)\
N(HSPWMCR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_u8HSPWMCR(ctrlr)     ((volatile HSPWMCR_byte_view_st *)(HSPWMCR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N            
N/* Pointer to HALFWORD */
N#define pu16HSPWMCR(ctrlr)     ((volatile u16HSPWMCR_halfword_view *)\
N(HSPWMCR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pu16HSPWMCR(ctrlr)     ((volatile u16HSPWMCR_halfword_view *)(HSPWMCR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetHSPWMCR_TRUN(ctrlr) (pst_bitHSPWMCR(ctrlr) -> TRUN)
N#define vSetHSPWMCR_TRUN(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> TRUN=(ParValue))
N#define biGetHSPWMCR_RSRVD1(ctrlr) (pst_bitHSPWMCR(ctrlr) -> RSRVD1)
N#define vSetHSPWMCR_RSRVD1(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> RSRVD1=(ParValue))
N#define biGetHSPWMCR_PREEN(ctrlr) (pst_bitHSPWMCR(ctrlr) -> PREEN)
N#define vSetHSPWMCR_PREEN(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> PREEN=(ParValue))
N#define biGetHSPWMCR_OL(ctrlr) (pst_bitHSPWMCR(ctrlr) -> OL)
N#define vSetHSPWMCR_OL(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> OL=(ParValue))
N#define biGetHSPWMCR_DB(ctrlr) (pst_bitHSPWMCR(ctrlr) -> DB)
N#define vSetHSPWMCR_DB(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> DB=(ParValue))
N#define biGetHSPWMCR_IE(ctrlr) (pst_bitHSPWMCR(ctrlr) -> IE)
N#define vSetHSPWMCR_IE(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> IE=(ParValue))
N#define biGetHSPWMCR_RSRVD7(ctrlr) (pst_bitHSPWMCR(ctrlr) -> RSRVD7)
N#define vSetHSPWMCR_RSRVD7(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> RSRVD7=(ParValue))
N#define biGetHSPWMCR_SCLK(ctrlr) (pst_bitHSPWMCR(ctrlr) -> SCLK)
N#define vSetHSPWMCR_SCLK(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> SCLK=(ParValue))
N#define biGetHSPWMCR_RSRVD15(ctrlr) (pst_bitHSPWMCR(ctrlr) -> RSRVD15)
N#define vSetHSPWMCR_RSRVD15(ctrlr,ParValue)  (pst_bitHSPWMCR(ctrlr) -> RSRVD15=(ParValue))
N            
N/* L-struct byte access */
N#define vSetHSPWMCRL(ctrlr,ParValue) (pst_u8HSPWMCR(ctrlr) -> u8L = (ParValue))
N#define u8GetHSPWMCRL(ctrlr) (pst_u8HSPWMCR(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetHSPWMCRH(ctrlr,ParValue) (pst_u8HSPWMCR(ctrlr) -> u8H = (ParValue))
N#define u8GetHSPWMCRH(ctrlr) (pst_u8HSPWMCR(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetHSPWMCR(ctrlr,ParValue) (*pu16HSPWMCR(ctrlr)  = (ParValue))
N#define u16GetHSPWMCR(ctrlr) (*pu16HSPWMCR(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: HSPWMPDR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0408004                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define HSPWMPDR_REG__       0xC0408004U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   HSPWMPDR	:16; 	 /* 0..15  bit(s) R/W */                    
N} HSPWMPDR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} HSPWMPDR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16HSPWMPDR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitHSPWMPDR(ctrlr)     ((volatile HSPWMPDR_bit_view_st *)\
N(HSPWMPDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_bitHSPWMPDR(ctrlr)     ((volatile HSPWMPDR_bit_view_st *)(HSPWMPDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8HSPWMPDR(ctrlr)     ((volatile HSPWMPDR_byte_view_st *)\
N(HSPWMPDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_u8HSPWMPDR(ctrlr)     ((volatile HSPWMPDR_byte_view_st *)(HSPWMPDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N            
N/* Pointer to HALFWORD */
N#define pu16HSPWMPDR(ctrlr)     ((volatile u16HSPWMPDR_halfword_view *)\
N(HSPWMPDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pu16HSPWMPDR(ctrlr)     ((volatile u16HSPWMPDR_halfword_view *)(HSPWMPDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetHSPWMPDR_HSPWMPDR(ctrlr) (pst_bitHSPWMPDR(ctrlr) -> HSPWMPDR)
N#define vSetHSPWMPDR_HSPWMPDR(ctrlr,ParValue)  (pst_bitHSPWMPDR(ctrlr) -> HSPWMPDR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetHSPWMPDRL(ctrlr,ParValue) (pst_u8HSPWMPDR(ctrlr) -> u8L = (ParValue))
N#define u8GetHSPWMPDRL(ctrlr) (pst_u8HSPWMPDR(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetHSPWMPDRH(ctrlr,ParValue) (pst_u8HSPWMPDR(ctrlr) -> u8H = (ParValue))
N#define u8GetHSPWMPDRH(ctrlr) (pst_u8HSPWMPDR(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetHSPWMPDR(ctrlr,ParValue) (*pu16HSPWMPDR(ctrlr)  = (ParValue))
N#define u16GetHSPWMPDR(ctrlr) (*pu16HSPWMPDR(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: HSPWMDDR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0408008                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define HSPWMDDR_REG__       0xC0408008U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   HSPWMDDR	:16; 	 /* 0..15  bit(s) R/W */                    
N} HSPWMDDR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} HSPWMDDR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16HSPWMDDR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitHSPWMDDR(ctrlr)     ((volatile HSPWMDDR_bit_view_st *)\
N(HSPWMDDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_bitHSPWMDDR(ctrlr)     ((volatile HSPWMDDR_bit_view_st *)(HSPWMDDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8HSPWMDDR(ctrlr)     ((volatile HSPWMDDR_byte_view_st *)\
N(HSPWMDDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_u8HSPWMDDR(ctrlr)     ((volatile HSPWMDDR_byte_view_st *)(HSPWMDDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N            
N/* Pointer to HALFWORD */
N#define pu16HSPWMDDR(ctrlr)     ((volatile u16HSPWMDDR_halfword_view *)\
N(HSPWMDDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pu16HSPWMDDR(ctrlr)     ((volatile u16HSPWMDDR_halfword_view *)(HSPWMDDR_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetHSPWMDDR_HSPWMDDR(ctrlr) (pst_bitHSPWMDDR(ctrlr) -> HSPWMDDR)
N#define vSetHSPWMDDR_HSPWMDDR(ctrlr,ParValue)  (pst_bitHSPWMDDR(ctrlr) -> HSPWMDDR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetHSPWMDDRL(ctrlr,ParValue) (pst_u8HSPWMDDR(ctrlr) -> u8L = (ParValue))
N#define u8GetHSPWMDDRL(ctrlr) (pst_u8HSPWMDDR(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetHSPWMDDRH(ctrlr,ParValue) (pst_u8HSPWMDDR(ctrlr) -> u8H = (ParValue))
N#define u8GetHSPWMDDRH(ctrlr) (pst_u8HSPWMDDR(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetHSPWMDDR(ctrlr,ParValue) (*pu16HSPWMDDR(ctrlr)  = (ParValue))
N#define u16GetHSPWMDDR(ctrlr) (*pu16HSPWMDDR(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: HSPWMCNT                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC040800C                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define HSPWMCNT_REG__       0xC040800CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   HSPWMCNT	:16; 	 /* 0..15  bit(s) R/W */                    
N} HSPWMCNT_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} HSPWMCNT_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16HSPWMCNT_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitHSPWMCNT(ctrlr)     ((volatile HSPWMCNT_bit_view_st *)\
N(HSPWMCNT_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_bitHSPWMCNT(ctrlr)     ((volatile HSPWMCNT_bit_view_st *)(HSPWMCNT_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8HSPWMCNT(ctrlr)     ((volatile HSPWMCNT_byte_view_st *)\
N(HSPWMCNT_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pst_u8HSPWMCNT(ctrlr)     ((volatile HSPWMCNT_byte_view_st *)(HSPWMCNT_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N            
N/* Pointer to HALFWORD */
N#define pu16HSPWMCNT(ctrlr)     ((volatile u16HSPWMCNT_halfword_view *)\
N(HSPWMCNT_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
X#define pu16HSPWMCNT(ctrlr)     ((volatile u16HSPWMCNT_halfword_view *)(HSPWMCNT_REG__  + ((uint8_t)(ctrlr) * 0x1000U) ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetHSPWMCNT_HSPWMCNT(ctrlr) (pst_bitHSPWMCNT(ctrlr) -> HSPWMCNT)
N#define vSetHSPWMCNT_HSPWMCNT(ctrlr,ParValue)  (pst_bitHSPWMCNT(ctrlr) -> HSPWMCNT=(ParValue))
N            
N/* L-struct byte access */
N#define vSetHSPWMCNTL(ctrlr,ParValue) (pst_u8HSPWMCNT(ctrlr) -> u8L = (ParValue))
N#define u8GetHSPWMCNTL(ctrlr) (pst_u8HSPWMCNT(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetHSPWMCNTH(ctrlr,ParValue) (pst_u8HSPWMCNT(ctrlr) -> u8H = (ParValue))
N#define u8GetHSPWMCNTH(ctrlr) (pst_u8HSPWMCNT(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetHSPWMCNT(ctrlr,ParValue) (*pu16HSPWMCNT(ctrlr)  = (ParValue))
N#define u16GetHSPWMCNT(ctrlr) (*pu16HSPWMCNT(ctrlr) )
N
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 230 / 6.4 - bitwise operation may not be performed on signed integer types
N** | CONS.  : allow
N** | REASON : to use macros generated by converter tool 
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N    
N
N#endif /* HSPWMIO_H */ 
N    
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 23 "..\..\..\..\lldd\src\timer_hs_pwm.c" 2
N#include "timer_hs_pwm.h"                     /* Timer LLDD definitions */
L 1 "..\..\..\..\lldd\inc\timer_hs_pwm.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : TIMER_HS_PWM low level driver header file
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : TIMER_HS_PWM
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.10 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef TIMER_HS_PWM_H
N#define TIMER_HS_PWM_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"                      /* Core specific primitive type definitions */
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_TIMER_HS_PWM_H_REVISION     "$Revision: 1.10 $"
N#define LLDD_TIMER_HS_PWM_H_TAG          "$Name: LLDD_1_6 $"
N
N/****************************************************************************
N*                          CHANNEL SELECTION MACROS
N*             (Please use these macros to select module instances)
N*****************************************************************************/
N
Ntypedef enum tag_timer_hs_pwm_cntrl_e
N{
N  TIMER_HS_PWM_CNTRL_0 =0,
N  TIMER_HS_PWM_CNTRL_1 =0x1000,  
N  TIMER_HS_PWM_CNTRL_2 =0x2000,
N  TIMER_HS_PWM_CNTRL_3 =0x3000 
N} timer_hs_pwm_cntrl_e;
N
N/*********************************************/
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
N/* TBRUN.DBE / TBRUN.SYNC / TBRUN.OFI - double buffer/synchronous reset/overflow interrupt selection */
Ntypedef enum tag_timer_hs_pwm_en_e
N{
N    TIMER_HS_PWM_DISABLE = 0x0,                    /* Double buffer disabled */
N    TIMER_HS_PWM_ENABLE  = 0x1                     /* Double buffering enabled */
N} timer_hs_pwm_en_e;
N
N/* PWMCR.SCLK / HSPWMCR.SCLK / GPWMCR.SCLK - prescaler selection */
Ntypedef enum tag_timer_hs_pwm_sclk_e
N{
N    TIMER_HS_PWM_SCLK_DIV1   = 0x0,            /* IM-Bus frequency [40 MHz] / G-Bus frequency [140 MHz] / Dot Clock */
N    TIMER_HS_PWM_SCLK_DIV2   = 0x1,            /* IM-Bus/G-Bus/Dot-Clock frequency / 2 */
N    TIMER_HS_PWM_SCLK_DIV4   = 0x2,            /* IM-Bus/G-Bus/Dot-Clock frequency / 4 */
N    TIMER_HS_PWM_SCLK_DIV8   = 0x3,            /* IM-Bus/G-Bus/Dot-Clock frequency / 8 */
N    TIMER_HS_PWM_SCLK_DIV16  = 0x4,            /* IM-Bus/G-Bus/Dot-Clock frequency / 16 */
N    TIMER_HS_PWM_SCLK_DIV32  = 0x5,            /* IM-Bus/G-Bus/Dot-Clock frequency / 32 */
N    TIMER_HS_PWM_SCLK_DIV64  = 0x6,            /* IM-Bus/G-Bus/Dot-Clock frequency / 64 */
N    TIMER_HS_PWM_SCLK_DIV128 = 0x7             /* IM-Bus/G-Bus/Dot-Clock frequency / 128 */
N} timer_hs_pwm_sclk_e;
N
N/* PWMCR.RC / GPWMCR.RC - reset of the counter */
Ntypedef enum tag_timer_hs_pwm_rc_e
N{
N    TIMER_HS_PWM_PDR_ONLY   = 0x0,              /* Reset on PWMPDR match only */
N    TIMER_HS_PWM_PDR_HSYNC  = 0x1,              /* Reset on HSync edge and on PWMPDR match */
N    TIMER_HS_PWM_PDR_VSYNC  = 0x2,              /* Reset on VSync edge and on PWMPDR match */
N    TIMER_HS_PWM_PDR_HVSYNC = 0x3               /* Reset on HSync, Vsync and on PWMPDR match */
N} timer_hs_pwm_rc_e;
N
N/* PWMCR.VED / PWMCR.HED / GPWMCR.VED / GPWMCR.HED  - sync edge detection */
Ntypedef enum tag_timer_hs_pwm_ved_e
N{
N    TIMER_HS_PWM_SYNC_POS = 0x0,                   /* Positive V/HSync edge detected */
N    TIMER_HS_PWM_SYNC_NEG = 0x1                    /* Negative V/HSync edge detected */
N} timer_hs_pwm_ved_e;
N
N/* PWMCR.OL / HSPWMCR.OL / GPWMCR.OL - output level */
Ntypedef enum tag_timer_hs_pwm_ol_e
N{
N    TIMER_HS_PWM_LEVEL_LO = 0x0,                   /* PWM starts active low (low duty cycle) */
N    TIMER_HS_PWM_LEVEL_HI = 0x1                    /* PWM starts active high (high duty cycle) */
N} timer_hs_pwm_ol_e;
N
N/* PWMCR.GDC / GPWMCR.GDC - display synchronization signals */
Ntypedef enum tag_timer_hs_pwm_gdc_e
N{
N    TIMER_HS_PWM_HSYNC   = 0x0,                    /* HSync selected */
N    TIMER_HS_PWM_DOTCLK  = 0x1,                    /* DotClock selected */
N    TIMER_HS_PWM_PRESCAL = 0x2                     /* Prescaler selected */
N} timer_hs_pwm_gdc_e;
N
N/* GPWMCR.TCORE_EN - timer_hs_pwm core control */
Ntypedef enum tag_timer_hs_pwm_tcore_e
N{
N    TIMER_HS_PWM_CORE_DISABLE = 0x0,               /* Timer is disabled */
N    TIMER_HS_PWM_CORE_ENABLE  = 0x1                /* Timer is enabled */
N} timer_hs_pwm_tcore_e;
N
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N
N/* PWM timer configuration  */
Ntypedef struct tag_timer_hs_pwm_Cfg_st
N{
N    timer_hs_pwm_sclk_e  ePrescalClk;              /* Peripheral clock prescaler */
N    timer_hs_pwm_en_e    eIrqEn;                   /* Period end interrupt enable/disable */
N    timer_hs_pwm_en_e    eDblBuffEn;               /* Double-buffer on/off */
N    timer_hs_pwm_ol_e    eOutLevel;                /* Output level */
N} timer_hs_pwm_Cfg_st;
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IORevision     - pointer to PWM IO header revision string
N *                pau8IOTag          - pointer to PWM IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                              uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                              uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/****************************************************************************
N *
N * Function:      boTIMER_HS_PWM_Config
N *
N * Purpose:       Configure a HSPWM timer
N *
N * Inputs:        eCntrl  PWM timer ccontroller
N *                eCfg    Target configuration
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE  on success
N *                C_FALSE on inalid PWM channel type
N *
N * Limitations:   Only High-Speed (HS) PWM timer channels may be provided
N *
N ***************************************************************************/
Nbool_t boTIMER_HS_PWM_Config(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_Cfg_st stCfg);
N
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_SetPeriod
N *
N * Purpose:       Preset the PWM timer period
N *
N * Inputs:        eCntrl    PWM timer ccontroller
N *                usPeriod  PWM timer period
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_SetPeriod(timer_hs_pwm_cntrl_e eCntrl, uint16_t u16Period);
N
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_SetDuty
N *
N * Purpose:       Preset the PWM timer duty
N *
N * Inputs:        eCntrl  PWM timer ccontroller
N *                usDuty  PWM Timer duty cycle
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_SetDuty(timer_hs_pwm_cntrl_e eCntrl, uint16_t u16Duty);
N
N
N/****************************************************************************
N *
N * Function:      u16TIMER_HS_PWM_GetDuty
N *
N * Purpose:       Retrieve the PWM timer duty
N *
N * Inputs:        eCntrl  PWM timer ccontroller
N *
N * Outputs:       Current duty cycle value
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16TIMER_HS_PWM_GetDuty(timer_hs_pwm_cntrl_e eCntrl);
N
N
N/****************************************************************************
N *
N * Function:      i32TIMER_HS_PWM_SetWaveform
N *
N * Purpose:       Set the PWM timer square waveform
N *
N * Inputs:        eCntrl     PWM timer ccontroller
N *                usPeriod   PWM timer period
N *                usDuty     PWM timer duty cycle [range 0-100]
N *                eOutLevel  PWM output level 
N *
N * Outputs:       none
N *
N * Return Values: 0-100  achieved duty-cycle value on success 
N *                0xFF   on error
N *
N * Limitations:   The timer must be stopped if doublebuffering is switched
N *                off in order to be successfully configured. If this is
N *                however not the case, the function will immediately return
N *                with 0xFF, without setting any parameters
N *
N ***************************************************************************/
Nint32_t i32TIMER_HS_PWM_SetWaveform(timer_hs_pwm_cntrl_e eCntrl, uint16_t u16Period, uint16_t u16Duty, timer_hs_pwm_ol_e eOutLevel);
N
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_SetPrescaler
N *
N * Purpose:       Set the PWM timer prescaler divider
N *
N * Inputs:        eCntrl    PWM timer ccontroller
N *                ePrescal  Division factor
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_SetPrescaler(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_sclk_e ePrescal);
N
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_IrqEnable
N *
N * Purpose:       Enable/disable the interrupt request
N *
N * Inputs:        eCntrl    PWM timer ccontroller
N *                eEnable   On/off request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_IrqEnable(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_en_e eEnable);
N
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_DBuffEnable
N *
N * Purpose:       Enable/disable the double buffeing
N *
N * Inputs:        eCntrl   PWM timer ccontroller
N *                eEnable  On/off request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_DBuffEnable(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_en_e eEnable);
N
N
N/****************************************************************************
N *
N * Function:      i32TIMER_HS_PWM_SetOutLevel
N *
N * Purpose:       Set the PWM initial output level
N *
N * Inputs:        eCntrl    PWM timer ccontroller
N *                eLevel    Desired output level
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS  on sucess
N *                C_FAILED   if timer runs
N *
N * Limitations:   This function cannot change the setting of output level
N *                when the PWM Timer is running. In this case, the function
N *                will immediately return with error
N *
N ***************************************************************************/
Nint32_t i32TIMER_HS_PWM_SetOutLevel(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_ol_e eLevel);
N
N
N/****************************************************************************
N *
N * Function:      vTIMER_HS_PWM_Enable
N *
N * Purpose:       Enable/disables the PWM timer
N *
N * Inputs:        eCntrl   PWM timer ccontroller
N *                eEnable  Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vTIMER_HS_PWM_Enable(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_en_e eEnable);
N
N
N/****************************************************************************
N *
N * Function:      u16TIMER_HS_PWM_GetCountVal
N *
N * Purpose:       Retrieve the current value of the PWM counter
N *
N * Inputs:        eCntrl  PWM timer ccontroller
N *
N * Outputs:       none
N *
N * Return Values: current PWM counter value
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint16_t u16TIMER_HS_PWM_GetCountVal(timer_hs_pwm_cntrl_e eCntrl);
N
N/****************************************************************************/
N
N
N#endif /* TIMER_HS_PWM_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\timer_hs_pwm.c" 2
N
N/*********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1847  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to non-integer type "type" not allowed */
S  #pragma ghs nowarning 1864  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to narrower underlying type, "type", not allowed */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to underlying type, "type", changes signedness */
S  #pragma ghs nowarning 1867  /* Rule 10.1 [R] : implicit conversion of complex expression from underlying type, "type", to underlying type, "type", not allowed */
S
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */  
S  #pragma ghs nowarning 1834  /* Rule 11.3 [A] : disable casting error (used for result of i/o header amcros) */
N#endif  
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N#define LLDD_TIMER_HS_PWM_C_REVISION     "$Revision: 1.10 $"
N#define LLDD_TIMER_HS_PWM_C_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
Nstatic uint8_t au8LLDD_TIMER_HS_PWM_C_REVISION[]    = LLDD_TIMER_HS_PWM_C_REVISION;
Xstatic uint8_t au8LLDD_TIMER_HS_PWM_C_REVISION[]    = "$Revision: 1.10 $";
Nstatic uint8_t au8LLDD_TIMER_HS_PWM_C_TAG[]         = LLDD_TIMER_HS_PWM_C_TAG;
Xstatic uint8_t au8LLDD_TIMER_HS_PWM_C_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_TIMER_HS_PWM_H_REVISION[]    = LLDD_TIMER_HS_PWM_H_REVISION;
Xstatic uint8_t au8LLDD_TIMER_HS_PWM_H_REVISION[]    = "$Revision: 1.10 $";
Nstatic uint8_t au8LLDD_TIMER_HS_PWM_H_TAG[]         = LLDD_TIMER_HS_PWM_H_TAG;
Xstatic uint8_t au8LLDD_TIMER_HS_PWM_H_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_TIMER_HS_PWM_IO_H_REVISION[] = LLDD_TIMER_HS_PWM_IO_H_REVISION;
Xstatic uint8_t au8LLDD_TIMER_HS_PWM_IO_H_REVISION[] = "$Revision: 1.12 $";
Nstatic uint8_t au8LLDD_TIMER_HS_PWM_IO_H_TAG[]      = LLDD_TIMER_HS_PWM_IO_H_TAG;
Xstatic uint8_t au8LLDD_TIMER_HS_PWM_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N/*********************************************/
N
N/* indicator if PWM is running */
Nstatic uint8_t au8HSPWMRunning[4] =
N{
N    0U,
N    0U,
N    0U,
N    0U
N};
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function definition         *
N**********************************************/
N
Nvoid vTIMER_HS_PWM_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                              uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                              uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N   *pau8ModuleRevision = &au8LLDD_TIMER_HS_PWM_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_TIMER_HS_PWM_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_TIMER_HS_PWM_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_TIMER_HS_PWM_H_TAG[0];
N   *pau8IORevision     = &au8LLDD_TIMER_HS_PWM_IO_H_REVISION[0];
N   *pau8IOTag          = &au8LLDD_TIMER_HS_PWM_IO_H_TAG[0];
N}
N
N/****************************************************************************/
N
N
Nbool_t boTIMER_HS_PWM_Config(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_Cfg_st stCfg)
N{
N    bool_t boResult = C_FALSE;
X    bool_t boResult = (0);
N
N    /* High-speed (HS) PWM timers */
N    vSetHSPWMCR_SCLK(eCntrl, stCfg.ePrescalClk);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> SCLK=(stCfg . ePrescalClk));
N    vSetHSPWMCR_IE(eCntrl, stCfg.eIrqEn);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> IE=(stCfg . eIrqEn));
N    vSetHSPWMCR_DB(eCntrl, stCfg.eDblBuffEn);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> DB=(stCfg . eDblBuffEn));
N    vSetHSPWMCR_OL(eCntrl, stCfg.eOutLevel);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> OL=(stCfg . eOutLevel));
N
N    /* 1: Enable Prescaler */    
N    vSetHSPWMCR_PREEN(eCntrl, 1);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> PREEN=(1));
N    boResult = C_TRUE;
X    boResult = (1);
N
N    /* Configuration result */
N    return boResult;
N}
N
N/****************************************************************************/
N
N
Nvoid vTIMER_HS_PWM_SetPeriod(timer_hs_pwm_cntrl_e eCntrl, uint16_t u16Period)
N{
N    vSetHSPWMPDR_HSPWMPDR(eCntrl, u16Period);
X    (((volatile HSPWMPDR_bit_view_st *)(0xC0408004U + ((uint8_t)(eCntrl) * 0x1000U) )) -> HSPWMPDR=(u16Period));
N}
N
N/****************************************************************************/
N
N
Nvoid vTIMER_HS_PWM_SetDuty(timer_hs_pwm_cntrl_e eCntrl, uint16_t u16Duty)
N{
N    vSetHSPWMDDR_HSPWMDDR(eCntrl, u16Duty);
X    (((volatile HSPWMDDR_bit_view_st *)(0xC0408008U + ((uint8_t)(eCntrl) * 0x1000U) )) -> HSPWMDDR=(u16Duty));
N}
N
N/****************************************************************************/
N
N
Nuint16_t u16TIMER_HS_PWM_GetDuty(timer_hs_pwm_cntrl_e eCntrl)
N{
N    uint16_t u16Res;
N
N    u16Res = u16GetHSPWMDDR(eCntrl);            
X    u16Res = (*((volatile u16HSPWMDDR_halfword_view *)(0xC0408008U + ((uint8_t)(eCntrl) * 0x1000U) )) );            
N
N    return u16Res;
N}
N
N/****************************************************************************/
N
N
Nint32_t i32TIMER_HS_PWM_SetWaveform(timer_hs_pwm_cntrl_e eCntrl, uint16_t u16Period, uint16_t u16Duty, timer_hs_pwm_ol_e eOutLevel)
N{
N    int32_t i32Res;
N    uint16_t u16DutyVal;
N    timer_hs_pwm_en_e eCurStat = TIMER_HS_PWM_DISABLE;
N    timer_hs_pwm_en_e eBuffType = TIMER_HS_PWM_DISABLE;
N
N    eCurStat = (timer_hs_pwm_en_e)biGetHSPWMCR_TRUN(eCntrl);
X    eCurStat = (timer_hs_pwm_en_e)(((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> TRUN);
N    eBuffType = (timer_hs_pwm_en_e)biGetHSPWMCR_DB(eCntrl);
X    eBuffType = (timer_hs_pwm_en_e)(((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> DB);
N
N    /* check if change is allowed */
N    if( ( TIMER_HS_PWM_ENABLE != eCurStat ) || ( TIMER_HS_PWM_DISABLE != eBuffType ) )
N    {
N        if(u16Duty <= 100)
N        {
N            if ((u16Duty != 0) && (u16Duty != 100))
N            {
N                /* Duty-counter value */
N                u16DutyVal = (u16Period * u16Duty)/100;
N
N                vSetHSPWMPDR_HSPWMPDR(eCntrl, u16Period);
X                (((volatile HSPWMPDR_bit_view_st *)(0xC0408004U + ((uint8_t)(eCntrl) * 0x1000U) )) -> HSPWMPDR=(u16Period));
N                vSetHSPWMDDR_HSPWMDDR(eCntrl, u16DutyVal);
X                (((volatile HSPWMDDR_bit_view_st *)(0xC0408008U + ((uint8_t)(eCntrl) * 0x1000U) )) -> HSPWMDDR=(u16DutyVal));
N
N                /* enable timer if coming from 0% and 100% */
N                if (au8HSPWMRunning[eCntrl] == 1U)
N                {
N                    vSetHSPWMCR_TRUN(eCntrl, TIMER_HS_PWM_ENABLE);
X                    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> TRUN=(TIMER_HS_PWM_ENABLE));
N                }
N
N        /* Achieved Duty-cycle */
N                i32Res = (u16DutyVal* 100) / u16Period;
N            }
N            else
N            {
N                /* special treatment for 0% and 100% */
N                if (u16Duty == 0)
N                {
N                    /* 0% */
N                    vSetHSPWMCR_TRUN(eCntrl, TIMER_HS_PWM_DISABLE);
X                    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> TRUN=(TIMER_HS_PWM_DISABLE));
N                    vSetHSPWMCR_OL(eCntrl, eOutLevel);
X                    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> OL=(eOutLevel));
N
N            /* Achieved Duty-cycle */
N                    i32Res = 0;
N                }
N                else
N                {
N                    /* 100% */
N                    vSetHSPWMCR_TRUN(eCntrl, TIMER_HS_PWM_DISABLE);
X                    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> TRUN=(TIMER_HS_PWM_DISABLE));
N                    if (TIMER_HS_PWM_LEVEL_HI == eOutLevel)
N                    {
N                        vSetHSPWMCR_OL(eCntrl, TIMER_HS_PWM_LEVEL_LO);
X                        (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> OL=(TIMER_HS_PWM_LEVEL_LO));
N                    }
N                    else
N                    {
N                        vSetHSPWMCR_OL(eCntrl, TIMER_HS_PWM_LEVEL_HI);
X                        (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> OL=(TIMER_HS_PWM_LEVEL_HI));
N                    }
N
N            /* Achieved Duty-cycle */
N                    i32Res = 100;
N                }
N            }
N        }
N        else
N        {
N            /* Duty Cycle parameter out of range */
N            i32Res = 0xff;
N        }
N    }
N    else
N    {
N        /* PWM Timer running, no change allowed */
N        i32Res = 0xff;
N    }
N
N    return i32Res;
N}
N
N/****************************************************************************/
N
N
Nvoid vTIMER_HS_PWM_SetPrescaler(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_sclk_e ePrescal)
N{
N    vSetHSPWMCR_SCLK(eCntrl, ePrescal);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> SCLK=(ePrescal));
N}
N
N/****************************************************************************/
N
N
Nvoid vTIMER_HS_PWM_IrqEnable(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_en_e eEnable)
N{
N    vSetHSPWMCR_IE(eCntrl, eEnable);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> IE=(eEnable));
N}
N
N/****************************************************************************/
N
N
Nvoid vTIMER_HS_PWM_DBuffEnable(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_en_e eEnable)
N{
N    vSetHSPWMCR_DB(eCntrl, eEnable);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> DB=(eEnable));
N}
N
N/****************************************************************************/
N
N
Nint32_t i32TIMER_HS_PWM_SetOutLevel(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_ol_e eLevel)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    timer_hs_pwm_en_e eCurStat = TIMER_HS_PWM_DISABLE;
N
N    eCurStat = (timer_hs_pwm_en_e)biGetHSPWMCR_TRUN(eCntrl);
X    eCurStat = (timer_hs_pwm_en_e)(((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> TRUN);
N
N    /* Change allowed only when Timer is not Running */
N    if( TIMER_HS_PWM_ENABLE != eCurStat )
N    {
N        /* Change Output Level */
N        vSetHSPWMCR_OL(eCntrl, eLevel);
X        (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> OL=(eLevel));
N    }
N    else
N    {
N        /* No change allowed (PWM Timer running) */
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N/****************************************************************************/
N
N
Nvoid vTIMER_HS_PWM_Enable(timer_hs_pwm_cntrl_e eCntrl, timer_hs_pwm_en_e eEnable)
N{
N    vSetHSPWMCR_TRUN(eCntrl, eEnable);
X    (((volatile HSPWMCR_bit_view_st *)(0xC0408000U + ((uint8_t)(eCntrl) * 0x1000U) )) -> TRUN=(eEnable));
N    au8HSPWMRunning[eCntrl] = (uint8_t)eEnable;
N}
N
N/****************************************************************************/
N
N
Nuint16_t u16TIMER_HS_PWM_GetCountVal(timer_hs_pwm_cntrl_e eCntrl)
N{
N    return (uint16_t) biGetHSPWMCNT_HSPWMCNT(eCntrl);
X    return (uint16_t) (((volatile HSPWMCNT_bit_view_st *)(0xC040800CU + ((uint8_t)(eCntrl) * 0x1000U) )) -> HSPWMCNT);
N}
N
N/****************************************************************************/
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1847 / 10.3 - cast of complex integer expression with underlying type
N** |                        "type" to non-integer type "type" not allowed 
N** | CONS.  : disable
N** | REASON : to use macros from i/o header files, unavoidable when addressing 
N** |          memory mapped registers 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1864 /10.1  - implicit conversion from underlying type, "type", 
N** |                        to narrower underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : to use macros from i/o header files 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1866 /10.1  -  implicit conversion from underlying type, "type",  
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1867 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
