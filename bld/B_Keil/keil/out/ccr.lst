L 1 "..\..\..\..\lldd\src\ccr.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION :
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      :
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.28 $
N*   DATE        : $Date: 2015/05/18 13:49:55 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "ccr_pdh_io.h"
L 1 "..\..\..\..\lldd\hdr\ccr_pdh_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : SysCon_PDH 
N/  Date of creation (y-m-d:time): 2015-01-20+01:00  :  10:13:41.386+01:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.16 $ 
N/  Excel Sheet ver.             : vv9.19
N/  Excel Sheet date             : 2014-Oct-24
N/  Excel Sheet author           : BEL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : CCR_PDH low level driver io-header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : CCR
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.16 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef SysCon_PDHIO_H
N#define SysCon_PDHIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */ 
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 40 "..\..\..\..\lldd\hdr\ccr_pdh_io.h" 2
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_CCR_PDH_IO_H_REVISION     "$Revision: 1.16 $"
N#define LLDD_CCR_PDH_IO_H_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N/* disable following Misra errors for io files */
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : disable No reuse of identifiers */
S  #pragma ghs nowarning 230   /* Rule 6.4  [R] : Bitfields can only have `unsigned int' or `signed int' types */
N#endif
N 
N/**********************************************
N*                 globale variables           *
N**********************************************/
N#ifdef FPGA
Sextern volatile uint16_t u16CcrBootPins;
N#endif     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_KEYR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000400                             
N*       ACCESS  : 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_KEYR_REG__       0xC0000400U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   KEYVAL	:32; 	 /* 0..31  bit(s) R/W */                    
N} PDHR_KEYR_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32PDHR_KEYR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_KEYR()     ((volatile PDHR_KEYR_bit_view_st *)\
N(PDHR_KEYR_REG__ ))
X#define pst_bitPDHR_KEYR()     ((volatile PDHR_KEYR_bit_view_st *)(PDHR_KEYR_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32PDHR_KEYR()     ((volatile u32PDHR_KEYR_word_view *)\
N(PDHR_KEYR_REG__ ))
X#define pu32PDHR_KEYR()     ((volatile u32PDHR_KEYR_word_view *)(PDHR_KEYR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_KEYR_KEYVAL() (pst_bitPDHR_KEYR() -> KEYVAL)
N#define vSetPDHR_KEYR_KEYVAL(ParValue)  (pst_bitPDHR_KEYR() -> KEYVAL=(ParValue))
N            
N/* Word access */
N#define vSetPDHR_KEYR(ParValue)  (*pu32PDHR_KEYR() = (ParValue))
N#define u32GetPDHR_KEYR()  (*pu32PDHR_KEYR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_VER                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000040C                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_VER_REG__       0xC000040CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   VER	:2; 	 /* 0..1  bit(s) R */
N  uint16_t   	:6; 	 /* 2..7  bit(s) R */
N  uint16_t   FLASH_SIZE	:2; 	 /* 8..9  bit(s) R */ 
N  uint16_t   	:6; 	 /* 10..31  bit(s) R */                    
N} PDHR_VER_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_VER_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_VER_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_VER()     ((volatile PDHR_VER_bit_view_st *)\
N(PDHR_VER_REG__ ))
X#define pst_bitPDHR_VER()     ((volatile PDHR_VER_bit_view_st *)(PDHR_VER_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_VER()     ((volatile PDHR_VER_byte_view_st *)\
N(PDHR_VER_REG__ ))
X#define pst_u8PDHR_VER()     ((volatile PDHR_VER_byte_view_st *)(PDHR_VER_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_VER()     ((volatile u16PDHR_VER_halfword_view *)\
N(PDHR_VER_REG__ ))
X#define pu16PDHR_VER()     ((volatile u16PDHR_VER_halfword_view *)(PDHR_VER_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetPDHR_VER_VER() (pst_bitPDHR_VER() -> VER)            
N#define biGetPDHR_VER_FLASH_SIZE() (pst_bitPDHR_VER() -> FLASH_SIZE)
N            
N/* L-struct byte access */
N
N#define u8GetPDHR_VERL() (pst_u8PDHR_VER() -> u8L)
N/* H-struct byte access */
N
N#define u8GetPDHR_VERH() (pst_u8PDHR_VER() -> u8H)
N            
N/* Half-word access */ 
N
N#define u16GetPDHR_VER() (*pu16PDHR_VER() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_DBG                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000410                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_DBG_REG__       0xC0000410U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   CR4DEBUG	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   	:7; 	 /* 1..7  bit(s) R */
N  uint16_t   CM3DEBUG	:1; 	 /* 8..8  bit(s) R */ 
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */                    
N} PDHR_DBG_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_DBG_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_DBG_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_DBG()     ((volatile PDHR_DBG_bit_view_st *)\
N(PDHR_DBG_REG__ ))
X#define pst_bitPDHR_DBG()     ((volatile PDHR_DBG_bit_view_st *)(PDHR_DBG_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_DBG()     ((volatile PDHR_DBG_byte_view_st *)\
N(PDHR_DBG_REG__ ))
X#define pst_u8PDHR_DBG()     ((volatile PDHR_DBG_byte_view_st *)(PDHR_DBG_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_DBG()     ((volatile u16PDHR_DBG_halfword_view *)\
N(PDHR_DBG_REG__ ))
X#define pu16PDHR_DBG()     ((volatile u16PDHR_DBG_halfword_view *)(PDHR_DBG_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_DBG_CR4DEBUG() (pst_bitPDHR_DBG() -> CR4DEBUG)
N#define vSetPDHR_DBG_CR4DEBUG(ParValue)  (pst_bitPDHR_DBG() -> CR4DEBUG=(ParValue))            
N#define biGetPDHR_DBG_CM3DEBUG() (pst_bitPDHR_DBG() -> CM3DEBUG)
N            
N/* L-struct byte access */
N#define vSetPDHR_DBGL(ParValue) (pst_u8PDHR_DBG() -> u8L = (ParValue))
N#define u8GetPDHR_DBGL() (pst_u8PDHR_DBG() -> u8L)
N/* H-struct byte access */
N#define vSetPDHR_DBGH(ParValue) (pst_u8PDHR_DBG() -> u8H = (ParValue))
N#define u8GetPDHR_DBGH() (pst_u8PDHR_DBG() -> u8H)
N            
N/* Half-word access */ 
N#define vSetPDHR_DBG(ParValue) (*pu16PDHR_DBG()  = (ParValue))
N#define u16GetPDHR_DBG() (*pu16PDHR_DBG() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_VREGCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000414                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_VREGCR_REG__       0xC0000414U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   VREG_IT	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   	:5; 	 /* 3..7  bit(s) R */
N  uint32_t   VREG_VT	:5; 	 /* 8..12  bit(s) R/W */
N  uint32_t   	:3; 	 /* 13..15  bit(s) R */
N  uint32_t   VREG_TT	:3; 	 /* 16..18  bit(s) R/W */ 
N  uint32_t   	:13; 	 /* 19..31  bit(s) R */                    
N} PDHR_VREGCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} PDHR_VREGCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} PDHR_VREGCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32PDHR_VREGCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_VREGCR()     ((volatile PDHR_VREGCR_bit_view_st *)\
N(PDHR_VREGCR_REG__ ))
X#define pst_bitPDHR_VREGCR()     ((volatile PDHR_VREGCR_bit_view_st *)(PDHR_VREGCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_VREGCR()     ((volatile PDHR_VREGCR_byte_view_st *)\
N(PDHR_VREGCR_REG__ ))
X#define pst_u8PDHR_VREGCR()     ((volatile PDHR_VREGCR_byte_view_st *)(PDHR_VREGCR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16PDHR_VREGCR()     ((volatile PDHR_VREGCR_halfword_view_st *)\
N(PDHR_VREGCR_REG__ ))
X#define pst_u16PDHR_VREGCR()     ((volatile PDHR_VREGCR_halfword_view_st *)(PDHR_VREGCR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32PDHR_VREGCR()     ((volatile u32PDHR_VREGCR_word_view *)\
N(PDHR_VREGCR_REG__ ))
X#define pu32PDHR_VREGCR()     ((volatile u32PDHR_VREGCR_word_view *)(PDHR_VREGCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_VREGCR_VREG_IT() (pst_bitPDHR_VREGCR() -> VREG_IT)
N#define vSetPDHR_VREGCR_VREG_IT(ParValue)  (pst_bitPDHR_VREGCR() -> VREG_IT=(ParValue))
N#define biGetPDHR_VREGCR_VREG_VT() (pst_bitPDHR_VREGCR() -> VREG_VT)
N#define vSetPDHR_VREGCR_VREG_VT(ParValue)  (pst_bitPDHR_VREGCR() -> VREG_VT=(ParValue))
N#define biGetPDHR_VREGCR_VREG_TT() (pst_bitPDHR_VREGCR() -> VREG_TT)
N#define vSetPDHR_VREGCR_VREG_TT(ParValue)  (pst_bitPDHR_VREGCR() -> VREG_TT=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetPDHR_VREGCRLL(ParValue) (pst_u8PDHR_VREGCR() -> u8LL = (ParValue))
N#define u8GetPDHR_VREGCRLL() (pst_u8PDHR_VREGCR() -> u8LL)
N/* LH-struct byte access */
N#define vSetPDHR_VREGCRLH(ParValue) (pst_u8PDHR_VREGCR() -> u8LH = (ParValue))
N#define u8GetPDHR_VREGCRLH() (pst_u8PDHR_VREGCR() -> u8LH)
N/* HL-struct byte access */
N#define vSetPDHR_VREGCRHL(ParValue) (pst_u8PDHR_VREGCR() -> u8HL = (ParValue))
N#define u8GetPDHR_VREGCRHL() (pst_u8PDHR_VREGCR() -> u8HL)
N/* HH-struct byte access */
N#define vSetPDHR_VREGCRHH(ParValue) (pst_u8PDHR_VREGCR() -> u8HH = (ParValue))
N#define u8GetPDHR_VREGCRHH() (pst_u8PDHR_VREGCR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetPDHR_VREGCRL(ParValue) (pst_u16PDHR_VREGCR() -> u16L = (ParValue))
N#define u16GetPDHR_VREGCRL() (pst_u16PDHR_VREGCR() -> u16L)
N#define vSetPDHR_VREGCRH(ParValue) (pst_u16PDHR_VREGCR() -> u16H = (ParValue))
N#define u16GetPDHR_VREGCRH() (pst_u16PDHR_VREGCR() -> u16H)
N            
N/* Word access */
N#define vSetPDHR_VREGCR(ParValue)  (*pu32PDHR_VREGCR() = (ParValue))
N#define u32GetPDHR_VREGCR()  (*pu32PDHR_VREGCR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_ANACR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000418                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_ANACR_REG__       0xC0000418U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   RCOSC_ADJUST	:4; 	 /* 0..3  bit(s) R/W */
N  uint32_t   	:12; 	 /* 4..15  bit(s) R */
N  uint32_t   LVD_THRSH	:3; 	 /* 16..18  bit(s) R/W */ 
N  uint32_t   	:13; 	 /* 19..31  bit(s) R */                    
N} PDHR_ANACR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} PDHR_ANACR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} PDHR_ANACR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32PDHR_ANACR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_ANACR()     ((volatile PDHR_ANACR_bit_view_st *)\
N(PDHR_ANACR_REG__ ))
X#define pst_bitPDHR_ANACR()     ((volatile PDHR_ANACR_bit_view_st *)(PDHR_ANACR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_ANACR()     ((volatile PDHR_ANACR_byte_view_st *)\
N(PDHR_ANACR_REG__ ))
X#define pst_u8PDHR_ANACR()     ((volatile PDHR_ANACR_byte_view_st *)(PDHR_ANACR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16PDHR_ANACR()     ((volatile PDHR_ANACR_halfword_view_st *)\
N(PDHR_ANACR_REG__ ))
X#define pst_u16PDHR_ANACR()     ((volatile PDHR_ANACR_halfword_view_st *)(PDHR_ANACR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32PDHR_ANACR()     ((volatile u32PDHR_ANACR_word_view *)\
N(PDHR_ANACR_REG__ ))
X#define pu32PDHR_ANACR()     ((volatile u32PDHR_ANACR_word_view *)(PDHR_ANACR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_ANACR_RCOSC_ADJUST() (pst_bitPDHR_ANACR() -> RCOSC_ADJUST)
N#define vSetPDHR_ANACR_RCOSC_ADJUST(ParValue)  (pst_bitPDHR_ANACR() -> RCOSC_ADJUST=(ParValue))
N#define biGetPDHR_ANACR_LVD_THRSH() (pst_bitPDHR_ANACR() -> LVD_THRSH)
N#define vSetPDHR_ANACR_LVD_THRSH(ParValue)  (pst_bitPDHR_ANACR() -> LVD_THRSH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetPDHR_ANACRLL(ParValue) (pst_u8PDHR_ANACR() -> u8LL = (ParValue))
N#define u8GetPDHR_ANACRLL() (pst_u8PDHR_ANACR() -> u8LL)
N/* LH-struct byte access */
N#define vSetPDHR_ANACRLH(ParValue) (pst_u8PDHR_ANACR() -> u8LH = (ParValue))
N#define u8GetPDHR_ANACRLH() (pst_u8PDHR_ANACR() -> u8LH)
N/* HL-struct byte access */
N#define vSetPDHR_ANACRHL(ParValue) (pst_u8PDHR_ANACR() -> u8HL = (ParValue))
N#define u8GetPDHR_ANACRHL() (pst_u8PDHR_ANACR() -> u8HL)
N/* HH-struct byte access */
N#define vSetPDHR_ANACRHH(ParValue) (pst_u8PDHR_ANACR() -> u8HH = (ParValue))
N#define u8GetPDHR_ANACRHH() (pst_u8PDHR_ANACR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetPDHR_ANACRL(ParValue) (pst_u16PDHR_ANACR() -> u16L = (ParValue))
N#define u16GetPDHR_ANACRL() (pst_u16PDHR_ANACR() -> u16L)
N#define vSetPDHR_ANACRH(ParValue) (pst_u16PDHR_ANACR() -> u16H = (ParValue))
N#define u16GetPDHR_ANACRH() (pst_u16PDHR_ANACR() -> u16H)
N            
N/* Word access */
N#define vSetPDHR_ANACR(ParValue)  (*pu32PDHR_ANACR() = (ParValue))
N#define u32GetPDHR_ANACR()  (*pu32PDHR_ANACR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_ALAMCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000041C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_ALAMCR_REG__       0xC000041CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ALM_THRSH0	:6; 	 /* 0..5  bit(s) R/W */
N  uint32_t   VMAIN_DROP	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   V33_DROP	:1; 	 /* 7..7  bit(s) R/W */
N  uint32_t   ALM_EN_0	:1; 	 /* 8..8  bit(s) R/W */
N  uint32_t   ALM_EN	:1; 	 /* 9..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   ALM_THRSH1	:6; 	 /* 16..21  bit(s) R/W */
N  uint32_t   VSUB_DROP	:1; 	 /* 22..22  bit(s) R/W */
N  uint32_t   	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   ALM_EN_1	:1; 	 /* 24..24  bit(s) R/W */ 
N  uint32_t   	:7; 	 /* 25..31  bit(s) R */                    
N} PDHR_ALAMCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} PDHR_ALAMCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} PDHR_ALAMCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32PDHR_ALAMCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_ALAMCR()     ((volatile PDHR_ALAMCR_bit_view_st *)\
N(PDHR_ALAMCR_REG__ ))
X#define pst_bitPDHR_ALAMCR()     ((volatile PDHR_ALAMCR_bit_view_st *)(PDHR_ALAMCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_ALAMCR()     ((volatile PDHR_ALAMCR_byte_view_st *)\
N(PDHR_ALAMCR_REG__ ))
X#define pst_u8PDHR_ALAMCR()     ((volatile PDHR_ALAMCR_byte_view_st *)(PDHR_ALAMCR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16PDHR_ALAMCR()     ((volatile PDHR_ALAMCR_halfword_view_st *)\
N(PDHR_ALAMCR_REG__ ))
X#define pst_u16PDHR_ALAMCR()     ((volatile PDHR_ALAMCR_halfword_view_st *)(PDHR_ALAMCR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32PDHR_ALAMCR()     ((volatile u32PDHR_ALAMCR_word_view *)\
N(PDHR_ALAMCR_REG__ ))
X#define pu32PDHR_ALAMCR()     ((volatile u32PDHR_ALAMCR_word_view *)(PDHR_ALAMCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_ALAMCR_ALM_THRSH0() (pst_bitPDHR_ALAMCR() -> ALM_THRSH0)
N#define vSetPDHR_ALAMCR_ALM_THRSH0(ParValue)  (pst_bitPDHR_ALAMCR() -> ALM_THRSH0=(ParValue))
N#define biGetPDHR_ALAMCR_VMAIN_DROP() (pst_bitPDHR_ALAMCR() -> VMAIN_DROP)
N#define vSetPDHR_ALAMCR_VMAIN_DROP(ParValue)  (pst_bitPDHR_ALAMCR() -> VMAIN_DROP=(ParValue))
N#define biGetPDHR_ALAMCR_V33_DROP() (pst_bitPDHR_ALAMCR() -> V33_DROP)
N#define vSetPDHR_ALAMCR_V33_DROP(ParValue)  (pst_bitPDHR_ALAMCR() -> V33_DROP=(ParValue))
N#define biGetPDHR_ALAMCR_ALM_EN_0() (pst_bitPDHR_ALAMCR() -> ALM_EN_0)
N#define vSetPDHR_ALAMCR_ALM_EN_0(ParValue)  (pst_bitPDHR_ALAMCR() -> ALM_EN_0=(ParValue))
N#define biGetPDHR_ALAMCR_ALM_EN() (pst_bitPDHR_ALAMCR() -> ALM_EN)
N#define vSetPDHR_ALAMCR_ALM_EN(ParValue)  (pst_bitPDHR_ALAMCR() -> ALM_EN=(ParValue))
N#define biGetPDHR_ALAMCR_ALM_THRSH1() (pst_bitPDHR_ALAMCR() -> ALM_THRSH1)
N#define vSetPDHR_ALAMCR_ALM_THRSH1(ParValue)  (pst_bitPDHR_ALAMCR() -> ALM_THRSH1=(ParValue))
N#define biGetPDHR_ALAMCR_VSUB_DROP() (pst_bitPDHR_ALAMCR() -> VSUB_DROP)
N#define vSetPDHR_ALAMCR_VSUB_DROP(ParValue)  (pst_bitPDHR_ALAMCR() -> VSUB_DROP=(ParValue))
N#define biGetPDHR_ALAMCR_ALM_EN_1() (pst_bitPDHR_ALAMCR() -> ALM_EN_1)
N#define vSetPDHR_ALAMCR_ALM_EN_1(ParValue)  (pst_bitPDHR_ALAMCR() -> ALM_EN_1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetPDHR_ALAMCRLL(ParValue) (pst_u8PDHR_ALAMCR() -> u8LL = (ParValue))
N#define u8GetPDHR_ALAMCRLL() (pst_u8PDHR_ALAMCR() -> u8LL)
N/* LH-struct byte access */
N#define vSetPDHR_ALAMCRLH(ParValue) (pst_u8PDHR_ALAMCR() -> u8LH = (ParValue))
N#define u8GetPDHR_ALAMCRLH() (pst_u8PDHR_ALAMCR() -> u8LH)
N/* HL-struct byte access */
N#define vSetPDHR_ALAMCRHL(ParValue) (pst_u8PDHR_ALAMCR() -> u8HL = (ParValue))
N#define u8GetPDHR_ALAMCRHL() (pst_u8PDHR_ALAMCR() -> u8HL)
N/* HH-struct byte access */
N#define vSetPDHR_ALAMCRHH(ParValue) (pst_u8PDHR_ALAMCR() -> u8HH = (ParValue))
N#define u8GetPDHR_ALAMCRHH() (pst_u8PDHR_ALAMCR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetPDHR_ALAMCRL(ParValue) (pst_u16PDHR_ALAMCR() -> u16L = (ParValue))
N#define u16GetPDHR_ALAMCRL() (pst_u16PDHR_ALAMCR() -> u16L)
N#define vSetPDHR_ALAMCRH(ParValue) (pst_u16PDHR_ALAMCR() -> u16H = (ParValue))
N#define u16GetPDHR_ALAMCRH() (pst_u16PDHR_ALAMCR() -> u16H)
N            
N/* Word access */
N#define vSetPDHR_ALAMCR(ParValue)  (*pu32PDHR_ALAMCR() = (ParValue))
N#define u32GetPDHR_ALAMCR()  (*pu32PDHR_ALAMCR() )                 
N
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_CSVOSC10M                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000420                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_CSVOSC10M_REG__       0xC0000420U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   CSV_OSC10MEN	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   	:7; 	 /* 1..7  bit(s) R */
N  uint16_t   CSV_OSC10MRST	:1; 	 /* 8..8  bit(s) R/W */ 
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */                    
N} PDHR_CSVOSC10M_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_CSVOSC10M_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_CSVOSC10M_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_CSVOSC10M()     ((volatile PDHR_CSVOSC10M_bit_view_st *)\
N(PDHR_CSVOSC10M_REG__ ))
X#define pst_bitPDHR_CSVOSC10M()     ((volatile PDHR_CSVOSC10M_bit_view_st *)(PDHR_CSVOSC10M_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_CSVOSC10M()     ((volatile PDHR_CSVOSC10M_byte_view_st *)\
N(PDHR_CSVOSC10M_REG__ ))
X#define pst_u8PDHR_CSVOSC10M()     ((volatile PDHR_CSVOSC10M_byte_view_st *)(PDHR_CSVOSC10M_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_CSVOSC10M()     ((volatile u16PDHR_CSVOSC10M_halfword_view *)\
N(PDHR_CSVOSC10M_REG__ ))
X#define pu16PDHR_CSVOSC10M()     ((volatile u16PDHR_CSVOSC10M_halfword_view *)(PDHR_CSVOSC10M_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_CSVOSC10M_CSV_OSC10MEN() (pst_bitPDHR_CSVOSC10M() -> CSV_OSC10MEN)
N#define vSetPDHR_CSVOSC10M_CSV_OSC10MEN(ParValue)  (pst_bitPDHR_CSVOSC10M() -> CSV_OSC10MEN=(ParValue))
N#define biGetPDHR_CSVOSC10M_CSV_OSC10MRST() (pst_bitPDHR_CSVOSC10M() -> CSV_OSC10MRST)
N#define vSetPDHR_CSVOSC10M_CSV_OSC10MRST(ParValue)  (pst_bitPDHR_CSVOSC10M() -> CSV_OSC10MRST=(ParValue))
N            
N/* L-struct byte access */
N#define vSetPDHR_CSVOSC10ML(ParValue) (pst_u8PDHR_CSVOSC10M() -> u8L = (ParValue))
N#define u8GetPDHR_CSVOSC10ML() (pst_u8PDHR_CSVOSC10M() -> u8L)
N/* H-struct byte access */
N#define vSetPDHR_CSVOSC10MH(ParValue) (pst_u8PDHR_CSVOSC10M() -> u8H = (ParValue))
N#define u8GetPDHR_CSVOSC10MH() (pst_u8PDHR_CSVOSC10M() -> u8H)
N            
N/* Half-word access */ 
N#define vSetPDHR_CSVOSC10M(ParValue) (*pu16PDHR_CSVOSC10M()  = (ParValue))
N#define u16GetPDHR_CSVOSC10M() (*pu16PDHR_CSVOSC10M() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_CSVOSC32KEN                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000424                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_CSVOSC32KEN_REG__       0xC0000424U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   CSV_OSC32KEN	:1; 	 /* 0..0  bit(s) R/W */ 
N  uint8_t   	:7; 	 /* 1..31  bit(s) R */                    
N} PDHR_CSVOSC32KEN_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8PDHR_CSVOSC32KEN_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_CSVOSC32KEN()     ((volatile PDHR_CSVOSC32KEN_bit_view_st *)\
N(PDHR_CSVOSC32KEN_REG__ ))
X#define pst_bitPDHR_CSVOSC32KEN()     ((volatile PDHR_CSVOSC32KEN_bit_view_st *)(PDHR_CSVOSC32KEN_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8PDHR_CSVOSC32KEN()     ((volatile u8PDHR_CSVOSC32KEN_byte_view *)\
N(PDHR_CSVOSC32KEN_REG__ ))
X#define pu8PDHR_CSVOSC32KEN()     ((volatile u8PDHR_CSVOSC32KEN_byte_view *)(PDHR_CSVOSC32KEN_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_CSVOSC32KEN_CSV_OSC32KEN() (pst_bitPDHR_CSVOSC32KEN() -> CSV_OSC32KEN)
N#define vSetPDHR_CSVOSC32KEN_CSV_OSC32KEN(ParValue)  (pst_bitPDHR_CSVOSC32KEN() -> CSV_OSC32KEN=(ParValue))
N            
N/* byte access */
N#define vSetPDHR_CSVOSC32KEN(ParValue) (*pu8PDHR_CSVOSC32KEN() = (ParValue))
N#define u8GetPDHR_CSVOSC32KEN() (*pu8PDHR_CSVOSC32KEN() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_CFGR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000428                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_CFGR_REG__       0xC0000428U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   OSC32KD	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   	:7; 	 /* 1..7  bit(s) R */
N  uint16_t   SMC3VONLY	:1; 	 /* 8..8  bit(s) R/W */ 
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */                    
N} PDHR_CFGR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_CFGR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_CFGR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_CFGR()     ((volatile PDHR_CFGR_bit_view_st *)\
N(PDHR_CFGR_REG__ ))
X#define pst_bitPDHR_CFGR()     ((volatile PDHR_CFGR_bit_view_st *)(PDHR_CFGR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_CFGR()     ((volatile PDHR_CFGR_byte_view_st *)\
N(PDHR_CFGR_REG__ ))
X#define pst_u8PDHR_CFGR()     ((volatile PDHR_CFGR_byte_view_st *)(PDHR_CFGR_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_CFGR()     ((volatile u16PDHR_CFGR_halfword_view *)\
N(PDHR_CFGR_REG__ ))
X#define pu16PDHR_CFGR()     ((volatile u16PDHR_CFGR_halfword_view *)(PDHR_CFGR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_CFGR_OSC32KD() (pst_bitPDHR_CFGR() -> OSC32KD)
N#define vSetPDHR_CFGR_OSC32KD(ParValue)  (pst_bitPDHR_CFGR() -> OSC32KD=(ParValue))
N#define biGetPDHR_CFGR_SMC3VONLY() (pst_bitPDHR_CFGR() -> SMC3VONLY)
N#define vSetPDHR_CFGR_SMC3VONLY(ParValue)  (pst_bitPDHR_CFGR() -> SMC3VONLY=(ParValue))
N            
N/* L-struct byte access */
N#define vSetPDHR_CFGRL(ParValue) (pst_u8PDHR_CFGR() -> u8L = (ParValue))
N#define u8GetPDHR_CFGRL() (pst_u8PDHR_CFGR() -> u8L)
N/* H-struct byte access */
N#define vSetPDHR_CFGRH(ParValue) (pst_u8PDHR_CFGR() -> u8H = (ParValue))
N#define u8GetPDHR_CFGRH() (pst_u8PDHR_CFGR() -> u8H)
N            
N/* Half-word access */ 
N#define vSetPDHR_CFGR(ParValue) (*pu16PDHR_CFGR()  = (ParValue))
N#define u16GetPDHR_CFGR() (*pu16PDHR_CFGR() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_SBCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000042C                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_SBCR_REG__       0xC000042CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   OSC10MSTBC	:5; 	 /* 0..4  bit(s) R/W */
N  uint16_t   	:3; 	 /* 5..7  bit(s) R */
N  uint16_t   OSC32KSTBC	:5; 	 /* 8..12  bit(s) R/W */ 
N  uint16_t   	:3; 	 /* 13..31  bit(s) R */                    
N} PDHR_SBCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_SBCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_SBCR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_SBCR()     ((volatile PDHR_SBCR_bit_view_st *)\
N(PDHR_SBCR_REG__ ))
X#define pst_bitPDHR_SBCR()     ((volatile PDHR_SBCR_bit_view_st *)(PDHR_SBCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_SBCR()     ((volatile PDHR_SBCR_byte_view_st *)\
N(PDHR_SBCR_REG__ ))
X#define pst_u8PDHR_SBCR()     ((volatile PDHR_SBCR_byte_view_st *)(PDHR_SBCR_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_SBCR()     ((volatile u16PDHR_SBCR_halfword_view *)\
N(PDHR_SBCR_REG__ ))
X#define pu16PDHR_SBCR()     ((volatile u16PDHR_SBCR_halfword_view *)(PDHR_SBCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_SBCR_OSC10MSTBC() (pst_bitPDHR_SBCR() -> OSC10MSTBC)
N#define vSetPDHR_SBCR_OSC10MSTBC(ParValue)  (pst_bitPDHR_SBCR() -> OSC10MSTBC=(ParValue))
N#define biGetPDHR_SBCR_OSC32KSTBC() (pst_bitPDHR_SBCR() -> OSC32KSTBC)
N#define vSetPDHR_SBCR_OSC32KSTBC(ParValue)  (pst_bitPDHR_SBCR() -> OSC32KSTBC=(ParValue))
N            
N/* L-struct byte access */
N#define vSetPDHR_SBCRL(ParValue) (pst_u8PDHR_SBCR() -> u8L = (ParValue))
N#define u8GetPDHR_SBCRL() (pst_u8PDHR_SBCR() -> u8L)
N/* H-struct byte access */
N#define vSetPDHR_SBCRH(ParValue) (pst_u8PDHR_SBCR() -> u8H = (ParValue))
N#define u8GetPDHR_SBCRH() (pst_u8PDHR_SBCR() -> u8H)
N            
N/* Half-word access */ 
N#define vSetPDHR_SBCR(ParValue) (*pu16PDHR_SBCR()  = (ParValue))
N#define u16GetPDHR_SBCR() (*pu16PDHR_SBCR() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_BOOTOPT                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000430                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifdef FPGA
S#define PDHR_BOOTOPT_REG__       (&u16CcrBootPins)
N#else
N#define PDHR_BOOTOPT_REG__       0xC0000430U
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   BOOT_SRC	:3; 	 /* 0..2  bit(s) R */
N  uint16_t   BOOT_OPT	:2; 	 /* 3..4  bit(s) R */
N  uint16_t   NAND_XTRA_BLK	:1; 	 /* 5..5  bit(s) R */
N  uint16_t   NAND_ECC_TYPE	:1; 	 /* 6..6  bit(s) R */
N  uint16_t   PORT_SELECTION	:2; 	 /* 7..8  bit(s) R */
N  uint16_t   TSM_Debug	:1; 	 /* 9..9  bit(s) R */
N  uint16_t   CR4_START	:1; 	 /* 10..10  bit(s) R */
N  uint16_t   SSCEN	:1; 	 /* 11..11  bit(s) R */
N  uint16_t   FRQSEL	:1; 	 /* 12..12  bit(s) R */
N  uint16_t   	:1; 	 /* 13..13  bit(s) R */
N  uint16_t   STBCDIS	:1; 	 /* 14..14  bit(s) R */
N  uint16_t   TESTMODEN	:1; 	 /* 15..15  bit(s) R */                    
N} PDHR_BOOTOPT_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_BOOTOPT_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_BOOTOPT_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_BOOTOPT()     ((volatile PDHR_BOOTOPT_bit_view_st *)\
N(PDHR_BOOTOPT_REG__ ))
X#define pst_bitPDHR_BOOTOPT()     ((volatile PDHR_BOOTOPT_bit_view_st *)(PDHR_BOOTOPT_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_BOOTOPT()     ((volatile PDHR_BOOTOPT_byte_view_st *)\
N(PDHR_BOOTOPT_REG__ ))
X#define pst_u8PDHR_BOOTOPT()     ((volatile PDHR_BOOTOPT_byte_view_st *)(PDHR_BOOTOPT_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_BOOTOPT()     ((volatile u16PDHR_BOOTOPT_halfword_view *)\
N(PDHR_BOOTOPT_REG__ ))
X#define pu16PDHR_BOOTOPT()     ((volatile u16PDHR_BOOTOPT_halfword_view *)(PDHR_BOOTOPT_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetPDHR_BOOTOPT_BOOT_SRC() (pst_bitPDHR_BOOTOPT() -> BOOT_SRC)            
N#define biGetPDHR_BOOTOPT_BOOT_OPT() (pst_bitPDHR_BOOTOPT() -> BOOT_OPT)            
N#define biGetPDHR_BOOTOPT_NAND_XTRA_BLK() (pst_bitPDHR_BOOTOPT() -> NAND_XTRA_BLK)            
N#define biGetPDHR_BOOTOPT_NAND_ECC_TYPE() (pst_bitPDHR_BOOTOPT() -> NAND_ECC_TYPE)            
N#define biGetPDHR_BOOTOPT_PORT_SELECTION() (pst_bitPDHR_BOOTOPT() -> PORT_SELECTION)            
N#define biGetPDHR_BOOTOPT_TSM_Debug() (pst_bitPDHR_BOOTOPT() -> TSM_Debug)
N#define biGetPDHR_BOOTOPT_CR4_START() (pst_bitPDHR_BOOTOPT() -> CR4_START)            
N#define biGetPDHR_BOOTOPT_SSCEN() (pst_bitPDHR_BOOTOPT() -> SSCEN)            
N#define biGetPDHR_BOOTOPT_FRQSEL() (pst_bitPDHR_BOOTOPT() -> FRQSEL)            
N#define biGetPDHR_BOOTOPT_STBCDIS() (pst_bitPDHR_BOOTOPT() -> STBCDIS)            
N#define biGetPDHR_BOOTOPT_TESTMODEN() (pst_bitPDHR_BOOTOPT() -> TESTMODEN)
N            
N/* L-struct byte access */
N
N#define u8GetPDHR_BOOTOPTL() (pst_u8PDHR_BOOTOPT() -> u8L)
N/* H-struct byte access */
N
N#define u8GetPDHR_BOOTOPTH() (pst_u8PDHR_BOOTOPT() -> u8H)
N            
N/* Half-word access */ 
N
N#define u16GetPDHR_BOOTOPT() (*pu16PDHR_BOOTOPT() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_INTSR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000434                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_INTSR_REG__       0xC0000434U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   CSV10MINT	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   	:7; 	 /* 1..7  bit(s) R */
N  uint32_t   CSV32KINT	:1; 	 /* 8..8  bit(s) R */
N  uint32_t   	:7; 	 /* 9..15  bit(s) R */
N  uint32_t   ERRINT0	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   ERRINT1	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   ERRINT2	:1; 	 /* 18..18  bit(s) R */
N  uint32_t   	:5; 	 /* 19..23  bit(s) R */
N  uint32_t   BKPRAM_ECCNMI	:1; 	 /* 24..24  bit(s) R */
N  uint32_t   MM_ECCNMI	:1; 	 /* 25..25  bit(s) R */
N  uint32_t   STPU_NMI	:1; 	 /* 26..26  bit(s) R */
N  uint32_t   WDT_NMI	:1; 	 /* 27..27  bit(s) R */
N  uint32_t   IO_NMI	:1; 	 /* 28..28  bit(s) R */ 
N  uint32_t   	:3; 	 /* 29..31  bit(s) R */                    
N} PDHR_INTSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} PDHR_INTSR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} PDHR_INTSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32PDHR_INTSR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_INTSR()     ((volatile PDHR_INTSR_bit_view_st *)\
N(PDHR_INTSR_REG__ ))
X#define pst_bitPDHR_INTSR()     ((volatile PDHR_INTSR_bit_view_st *)(PDHR_INTSR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_INTSR()     ((volatile PDHR_INTSR_byte_view_st *)\
N(PDHR_INTSR_REG__ ))
X#define pst_u8PDHR_INTSR()     ((volatile PDHR_INTSR_byte_view_st *)(PDHR_INTSR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16PDHR_INTSR()     ((volatile PDHR_INTSR_halfword_view_st *)\
N(PDHR_INTSR_REG__ ))
X#define pst_u16PDHR_INTSR()     ((volatile PDHR_INTSR_halfword_view_st *)(PDHR_INTSR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32PDHR_INTSR()     ((volatile u32PDHR_INTSR_word_view *)\
N(PDHR_INTSR_REG__ ))
X#define pu32PDHR_INTSR()     ((volatile u32PDHR_INTSR_word_view *)(PDHR_INTSR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetPDHR_INTSR_CSV10MINT() (pst_bitPDHR_INTSR() -> CSV10MINT)            
N#define biGetPDHR_INTSR_CSV32KINT() (pst_bitPDHR_INTSR() -> CSV32KINT)            
N#define biGetPDHR_INTSR_ERRINT0() (pst_bitPDHR_INTSR() -> ERRINT0)            
N#define biGetPDHR_INTSR_ERRINT1() (pst_bitPDHR_INTSR() -> ERRINT1)            
N#define biGetPDHR_INTSR_ERRINT2() (pst_bitPDHR_INTSR() -> ERRINT2)            
N#define biGetPDHR_INTSR_BKPRAM_ECCNMI() (pst_bitPDHR_INTSR() -> BKPRAM_ECCNMI)            
N#define biGetPDHR_INTSR_MM_ECCNMI() (pst_bitPDHR_INTSR() -> MM_ECCNMI)            
N#define biGetPDHR_INTSR_STPU_NMI() (pst_bitPDHR_INTSR() -> STPU_NMI)            
N#define biGetPDHR_INTSR_WDT_NMI() (pst_bitPDHR_INTSR() -> WDT_NMI)            
N#define biGetPDHR_INTSR_IO_NMI() (pst_bitPDHR_INTSR() -> IO_NMI)
N            
N/* LL-struct byte access */
N
N#define u8GetPDHR_INTSRLL() (pst_u8PDHR_INTSR() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetPDHR_INTSRLH() (pst_u8PDHR_INTSR() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetPDHR_INTSRHL() (pst_u8PDHR_INTSR() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetPDHR_INTSRHH() (pst_u8PDHR_INTSR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N
N#define u16GetPDHR_INTSRL() (pst_u16PDHR_INTSR() -> u16L)
N
N#define u16GetPDHR_INTSRH() (pst_u16PDHR_INTSR() -> u16H)
N            
N/* Word access */
N
N#define u32GetPDHR_INTSR()  (*pu32PDHR_INTSR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_INTCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000438                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_INTCR_REG__       0xC0000438U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   CSV10MINTC	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   	:7; 	 /* 1..7  bit(s) R */
N  uint32_t   CSV32KINTC	:1; 	 /* 8..8  bit(s) R/W */
N  uint32_t   	:7; 	 /* 9..15  bit(s) R */
N  uint32_t   ERRINT0C	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   ERRINT1C	:1; 	 /* 17..17  bit(s) R/W */
N  uint32_t   ERRINT2C	:1; 	 /* 18..18  bit(s) R/W */
N  uint32_t   	:9; 	 /* 19..27  bit(s) R */
N  uint32_t   IO_NMIC	:1; 	 /* 28..28  bit(s) R/W */ 
N  uint32_t   	:3; 	 /* 29..31  bit(s) R */                    
N} PDHR_INTCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} PDHR_INTCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} PDHR_INTCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32PDHR_INTCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_INTCR()     ((volatile PDHR_INTCR_bit_view_st *)\
N(PDHR_INTCR_REG__ ))
X#define pst_bitPDHR_INTCR()     ((volatile PDHR_INTCR_bit_view_st *)(PDHR_INTCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_INTCR()     ((volatile PDHR_INTCR_byte_view_st *)\
N(PDHR_INTCR_REG__ ))
X#define pst_u8PDHR_INTCR()     ((volatile PDHR_INTCR_byte_view_st *)(PDHR_INTCR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16PDHR_INTCR()     ((volatile PDHR_INTCR_halfword_view_st *)\
N(PDHR_INTCR_REG__ ))
X#define pst_u16PDHR_INTCR()     ((volatile PDHR_INTCR_halfword_view_st *)(PDHR_INTCR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32PDHR_INTCR()     ((volatile u32PDHR_INTCR_word_view *)\
N(PDHR_INTCR_REG__ ))
X#define pu32PDHR_INTCR()     ((volatile u32PDHR_INTCR_word_view *)(PDHR_INTCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_INTCR_CSV10MINTC() (pst_bitPDHR_INTCR() -> CSV10MINTC)
N#define vSetPDHR_INTCR_CSV10MINTC(ParValue)  (pst_bitPDHR_INTCR() -> CSV10MINTC=(ParValue))
N#define biGetPDHR_INTCR_CSV32KINTC() (pst_bitPDHR_INTCR() -> CSV32KINTC)
N#define vSetPDHR_INTCR_CSV32KINTC(ParValue)  (pst_bitPDHR_INTCR() -> CSV32KINTC=(ParValue))
N#define biGetPDHR_INTCR_ERRINT0C() (pst_bitPDHR_INTCR() -> ERRINT0C)
N#define vSetPDHR_INTCR_ERRINT0C(ParValue)  (pst_bitPDHR_INTCR() -> ERRINT0C=(ParValue))
N#define biGetPDHR_INTCR_ERRINT1C() (pst_bitPDHR_INTCR() -> ERRINT1C)
N#define vSetPDHR_INTCR_ERRINT1C(ParValue)  (pst_bitPDHR_INTCR() -> ERRINT1C=(ParValue))
N#define biGetPDHR_INTCR_ERRINT2C() (pst_bitPDHR_INTCR() -> ERRINT2C)
N#define vSetPDHR_INTCR_ERRINT2C(ParValue)  (pst_bitPDHR_INTCR() -> ERRINT2C=(ParValue))
N#define biGetPDHR_INTCR_IO_NMIC() (pst_bitPDHR_INTCR() -> IO_NMIC)
N#define vSetPDHR_INTCR_IO_NMIC(ParValue)  (pst_bitPDHR_INTCR() -> IO_NMIC=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetPDHR_INTCRLL(ParValue) (pst_u8PDHR_INTCR() -> u8LL = (ParValue))
N#define u8GetPDHR_INTCRLL() (pst_u8PDHR_INTCR() -> u8LL)
N/* LH-struct byte access */
N#define vSetPDHR_INTCRLH(ParValue) (pst_u8PDHR_INTCR() -> u8LH = (ParValue))
N#define u8GetPDHR_INTCRLH() (pst_u8PDHR_INTCR() -> u8LH)
N/* HL-struct byte access */
N#define vSetPDHR_INTCRHL(ParValue) (pst_u8PDHR_INTCR() -> u8HL = (ParValue))
N#define u8GetPDHR_INTCRHL() (pst_u8PDHR_INTCR() -> u8HL)
N/* HH-struct byte access */
N#define vSetPDHR_INTCRHH(ParValue) (pst_u8PDHR_INTCR() -> u8HH = (ParValue))
N#define u8GetPDHR_INTCRHH() (pst_u8PDHR_INTCR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetPDHR_INTCRL(ParValue) (pst_u16PDHR_INTCR() -> u16L = (ParValue))
N#define u16GetPDHR_INTCRL() (pst_u16PDHR_INTCR() -> u16L)
N#define vSetPDHR_INTCRH(ParValue) (pst_u16PDHR_INTCR() -> u16H = (ParValue))
N#define u16GetPDHR_INTCRH() (pst_u16PDHR_INTCR() -> u16H)
N            
N/* Word access */
N#define vSetPDHR_INTCR(ParValue)  (*pu32PDHR_INTCR() = (ParValue))
N#define u32GetPDHR_INTCR()  (*pu32PDHR_INTCR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_ECCEN                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000043C                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_ECCEN_REG__       0xC000043CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   BKPRAM_ECCEN	:2; 	 /* 0..1  bit(s) R/W */
N  uint16_t   	:6; 	 /* 2..7  bit(s) R */
N  uint16_t   MM_ECCEN	:2; 	 /* 8..9  bit(s) R/W */ 
N  uint16_t   	:6; 	 /* 10..31  bit(s) R */                    
N} PDHR_ECCEN_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_ECCEN_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_ECCEN_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_ECCEN()     ((volatile PDHR_ECCEN_bit_view_st *)\
N(PDHR_ECCEN_REG__ ))
X#define pst_bitPDHR_ECCEN()     ((volatile PDHR_ECCEN_bit_view_st *)(PDHR_ECCEN_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_ECCEN()     ((volatile PDHR_ECCEN_byte_view_st *)\
N(PDHR_ECCEN_REG__ ))
X#define pst_u8PDHR_ECCEN()     ((volatile PDHR_ECCEN_byte_view_st *)(PDHR_ECCEN_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_ECCEN()     ((volatile u16PDHR_ECCEN_halfword_view *)\
N(PDHR_ECCEN_REG__ ))
X#define pu16PDHR_ECCEN()     ((volatile u16PDHR_ECCEN_halfword_view *)(PDHR_ECCEN_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_ECCEN_BKPRAM_ECCEN() (pst_bitPDHR_ECCEN() -> BKPRAM_ECCEN)
N#define vSetPDHR_ECCEN_BKPRAM_ECCEN(ParValue)  (pst_bitPDHR_ECCEN() -> BKPRAM_ECCEN=(ParValue))
N#define biGetPDHR_ECCEN_MM_ECCEN() (pst_bitPDHR_ECCEN() -> MM_ECCEN)
N#define vSetPDHR_ECCEN_MM_ECCEN(ParValue)  (pst_bitPDHR_ECCEN() -> MM_ECCEN=(ParValue))
N            
N/* L-struct byte access */
N#define vSetPDHR_ECCENL(ParValue) (pst_u8PDHR_ECCEN() -> u8L = (ParValue))
N#define u8GetPDHR_ECCENL() (pst_u8PDHR_ECCEN() -> u8L)
N/* H-struct byte access */
N#define vSetPDHR_ECCENH(ParValue) (pst_u8PDHR_ECCEN() -> u8H = (ParValue))
N#define u8GetPDHR_ECCENH() (pst_u8PDHR_ECCEN() -> u8H)
N            
N/* Half-word access */ 
N#define vSetPDHR_ECCEN(ParValue) (*pu16PDHR_ECCEN()  = (ParValue))
N#define u16GetPDHR_ECCEN() (*pu16PDHR_ECCEN() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_PRVSTATE                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000440                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_PRVSTATE_REG__       0xC0000440U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   STB_MODE	:1; 	 /* 0..0  bit(s) R */
N  uint8_t   SLPOSC10_MODE	:1; 	 /* 1..1  bit(s) R */
N  uint8_t   SLPRCOSC_MODE	:1; 	 /* 2..2  bit(s) R */
N  uint8_t   STOPR_MODE	:1; 	 /* 3..3  bit(s) R */
N  uint8_t   STOP_MODE	:1; 	 /* 4..4  bit(s) R */ 
N  uint8_t   	:3; 	 /* 5..31  bit(s) R */                    
N} PDHR_PRVSTATE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8PDHR_PRVSTATE_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_PRVSTATE()     ((volatile PDHR_PRVSTATE_bit_view_st *)\
N(PDHR_PRVSTATE_REG__ ))
X#define pst_bitPDHR_PRVSTATE()     ((volatile PDHR_PRVSTATE_bit_view_st *)(PDHR_PRVSTATE_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8PDHR_PRVSTATE()     ((volatile u8PDHR_PRVSTATE_byte_view *)\
N(PDHR_PRVSTATE_REG__ ))
X#define pu8PDHR_PRVSTATE()     ((volatile u8PDHR_PRVSTATE_byte_view *)(PDHR_PRVSTATE_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetPDHR_PRVSTATE_STB_MODE() (pst_bitPDHR_PRVSTATE() -> STB_MODE)            
N#define biGetPDHR_PRVSTATE_SLPOSC10_MODE() (pst_bitPDHR_PRVSTATE() -> SLPOSC10_MODE)            
N#define biGetPDHR_PRVSTATE_SLPRCOSC_MODE() (pst_bitPDHR_PRVSTATE() -> SLPRCOSC_MODE)            
N#define biGetPDHR_PRVSTATE_STOPR_MODE() (pst_bitPDHR_PRVSTATE() -> STOPR_MODE)            
N#define biGetPDHR_PRVSTATE_STOP_MODE() (pst_bitPDHR_PRVSTATE() -> STOP_MODE)
N            
N/* byte access */
N
N#define u8GetPDHR_PRVSTATE() (*pu8PDHR_PRVSTATE() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_IOWKP_CFG                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000444                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_IOWKP_CFG_REG__       0xC0000444U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WAK_SEL0	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   WAKINTEN0	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   WAK_SEL1	:3; 	 /* 4..6  bit(s) R/W */
N  uint32_t   WAKINTEN1	:1; 	 /* 7..7  bit(s) R/W */
N  uint32_t   WAK_SEL2	:3; 	 /* 8..10  bit(s) R/W */
N  uint32_t   WAKINTEN2	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   WAK_SEL3	:3; 	 /* 12..14  bit(s) R/W */
N  uint32_t   WAKINTEN3	:1; 	 /* 15..15  bit(s) R/W */
N  uint32_t   WAK_SEL4	:3; 	 /* 16..18  bit(s) R/W */
N  uint32_t   WAKINTEN4	:1; 	 /* 19..19  bit(s) R/W */
N  uint32_t   WAK_SEL5	:3; 	 /* 20..22  bit(s) R/W */
N  uint32_t   WAKINTEN5	:1; 	 /* 23..23  bit(s) R/W */
N  uint32_t   WAK_SEL6	:3; 	 /* 24..26  bit(s) R/W */
N  uint32_t   WAKINTEN6	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   WAK_SEL7	:3; 	 /* 28..30  bit(s) R/W */ 
N  uint32_t   WAKINTEN7	:1; 	 /* 31..31  bit(s) R/W */                    
N} PDHR_IOWKP_CFG_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} PDHR_IOWKP_CFG_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} PDHR_IOWKP_CFG_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32PDHR_IOWKP_CFG_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_IOWKP_CFG()     ((volatile PDHR_IOWKP_CFG_bit_view_st *)\
N(PDHR_IOWKP_CFG_REG__ ))
X#define pst_bitPDHR_IOWKP_CFG()     ((volatile PDHR_IOWKP_CFG_bit_view_st *)(PDHR_IOWKP_CFG_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_IOWKP_CFG()     ((volatile PDHR_IOWKP_CFG_byte_view_st *)\
N(PDHR_IOWKP_CFG_REG__ ))
X#define pst_u8PDHR_IOWKP_CFG()     ((volatile PDHR_IOWKP_CFG_byte_view_st *)(PDHR_IOWKP_CFG_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16PDHR_IOWKP_CFG()     ((volatile PDHR_IOWKP_CFG_halfword_view_st *)\
N(PDHR_IOWKP_CFG_REG__ ))
X#define pst_u16PDHR_IOWKP_CFG()     ((volatile PDHR_IOWKP_CFG_halfword_view_st *)(PDHR_IOWKP_CFG_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32PDHR_IOWKP_CFG()     ((volatile u32PDHR_IOWKP_CFG_word_view *)\
N(PDHR_IOWKP_CFG_REG__ ))
X#define pu32PDHR_IOWKP_CFG()     ((volatile u32PDHR_IOWKP_CFG_word_view *)(PDHR_IOWKP_CFG_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_IOWKP_CFG_WAK_SEL0() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL0)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL0(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL0=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN0() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN0)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN0(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN0=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL1() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL1)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL1(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL1=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN1() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN1)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN1(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN1=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL2() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL2)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL2(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL2=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN2() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN2)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN2(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN2=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL3() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL3)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL3(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL3=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN3() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN3)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN3(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN3=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL4() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL4)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL4(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL4=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN4() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN4)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN4(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN4=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL5() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL5)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL5(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL5=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN5() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN5)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN5(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN5=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL6() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL6)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL6(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL6=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN6() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN6)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN6(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN6=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAK_SEL7() (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL7)
N#define vSetPDHR_IOWKP_CFG_WAK_SEL7(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAK_SEL7=(ParValue))
N#define biGetPDHR_IOWKP_CFG_WAKINTEN7() (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN7)
N#define vSetPDHR_IOWKP_CFG_WAKINTEN7(ParValue)  (pst_bitPDHR_IOWKP_CFG() -> WAKINTEN7=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetPDHR_IOWKP_CFGLL(ParValue) (pst_u8PDHR_IOWKP_CFG() -> u8LL = (ParValue))
N#define u8GetPDHR_IOWKP_CFGLL() (pst_u8PDHR_IOWKP_CFG() -> u8LL)
N/* LH-struct byte access */
N#define vSetPDHR_IOWKP_CFGLH(ParValue) (pst_u8PDHR_IOWKP_CFG() -> u8LH = (ParValue))
N#define u8GetPDHR_IOWKP_CFGLH() (pst_u8PDHR_IOWKP_CFG() -> u8LH)
N/* HL-struct byte access */
N#define vSetPDHR_IOWKP_CFGHL(ParValue) (pst_u8PDHR_IOWKP_CFG() -> u8HL = (ParValue))
N#define u8GetPDHR_IOWKP_CFGHL() (pst_u8PDHR_IOWKP_CFG() -> u8HL)
N/* HH-struct byte access */
N#define vSetPDHR_IOWKP_CFGHH(ParValue) (pst_u8PDHR_IOWKP_CFG() -> u8HH = (ParValue))
N#define u8GetPDHR_IOWKP_CFGHH() (pst_u8PDHR_IOWKP_CFG() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetPDHR_IOWKP_CFGL(ParValue) (pst_u16PDHR_IOWKP_CFG() -> u16L = (ParValue))
N#define u16GetPDHR_IOWKP_CFGL() (pst_u16PDHR_IOWKP_CFG() -> u16L)
N#define vSetPDHR_IOWKP_CFGH(ParValue) (pst_u16PDHR_IOWKP_CFG() -> u16H = (ParValue))
N#define u16GetPDHR_IOWKP_CFGH() (pst_u16PDHR_IOWKP_CFG() -> u16H)
N            
N/* Word access */
N#define vSetPDHR_IOWKP_CFG(ParValue)  (*pu32PDHR_IOWKP_CFG() = (ParValue))
N#define u32GetPDHR_IOWKP_CFG()  (*pu32PDHR_IOWKP_CFG() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_WAKINTS                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000448                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_WAKINTS_REG__       0xC0000448U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   WAKINTS0	:1; 	 /* 0..0  bit(s) R */
N  uint16_t   WAKINTS1	:1; 	 /* 1..1  bit(s) R */
N  uint16_t   WAKINTS2	:1; 	 /* 2..2  bit(s) R */
N  uint16_t   WAKINTS3	:1; 	 /* 3..3  bit(s) R */
N  uint16_t   WAKINTS4	:1; 	 /* 4..4  bit(s) R */
N  uint16_t   WAKINTS5	:1; 	 /* 5..5  bit(s) R */
N  uint16_t   WAKINTS6	:1; 	 /* 6..6  bit(s) R */
N  uint16_t   WAKINTS7	:1; 	 /* 7..7  bit(s) R */
N  uint16_t   NMI	:1; 	 /* 8..8  bit(s) R */
N  uint16_t   ALARM	:1; 	 /* 9..9  bit(s) R */
N  uint16_t   RTC	:1; 	 /* 10..10  bit(s) R */ 
N  uint16_t   	:5; 	 /* 11..31  bit(s) R */                    
N} PDHR_WAKINTS_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_WAKINTS_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_WAKINTS_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_WAKINTS()     ((volatile PDHR_WAKINTS_bit_view_st *)\
N(PDHR_WAKINTS_REG__ ))
X#define pst_bitPDHR_WAKINTS()     ((volatile PDHR_WAKINTS_bit_view_st *)(PDHR_WAKINTS_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_WAKINTS()     ((volatile PDHR_WAKINTS_byte_view_st *)\
N(PDHR_WAKINTS_REG__ ))
X#define pst_u8PDHR_WAKINTS()     ((volatile PDHR_WAKINTS_byte_view_st *)(PDHR_WAKINTS_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_WAKINTS()     ((volatile u16PDHR_WAKINTS_halfword_view *)\
N(PDHR_WAKINTS_REG__ ))
X#define pu16PDHR_WAKINTS()     ((volatile u16PDHR_WAKINTS_halfword_view *)(PDHR_WAKINTS_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetPDHR_WAKINTS_WAKINTS0() (pst_bitPDHR_WAKINTS() -> WAKINTS0)            
N#define biGetPDHR_WAKINTS_WAKINTS1() (pst_bitPDHR_WAKINTS() -> WAKINTS1)            
N#define biGetPDHR_WAKINTS_WAKINTS2() (pst_bitPDHR_WAKINTS() -> WAKINTS2)            
N#define biGetPDHR_WAKINTS_WAKINTS3() (pst_bitPDHR_WAKINTS() -> WAKINTS3)            
N#define biGetPDHR_WAKINTS_WAKINTS4() (pst_bitPDHR_WAKINTS() -> WAKINTS4)            
N#define biGetPDHR_WAKINTS_WAKINTS5() (pst_bitPDHR_WAKINTS() -> WAKINTS5)            
N#define biGetPDHR_WAKINTS_WAKINTS6() (pst_bitPDHR_WAKINTS() -> WAKINTS6)            
N#define biGetPDHR_WAKINTS_WAKINTS7() (pst_bitPDHR_WAKINTS() -> WAKINTS7)            
N#define biGetPDHR_WAKINTS_NMI() (pst_bitPDHR_WAKINTS() -> NMI)            
N#define biGetPDHR_WAKINTS_ALARM() (pst_bitPDHR_WAKINTS() -> ALARM)            
N#define biGetPDHR_WAKINTS_RTC() (pst_bitPDHR_WAKINTS() -> RTC)
N            
N/* L-struct byte access */
N
N#define u8GetPDHR_WAKINTSL() (pst_u8PDHR_WAKINTS() -> u8L)
N/* H-struct byte access */
N
N#define u8GetPDHR_WAKINTSH() (pst_u8PDHR_WAKINTS() -> u8H)
N            
N/* Half-word access */ 
N
N#define u16GetPDHR_WAKINTS() (*pu16PDHR_WAKINTS() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: PDHR_WAKINTC                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000044C                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define PDHR_WAKINTC_REG__       0xC000044CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   WAKINTC0	:1; 	 /* 0..0  bit(s) R/W */
N  uint16_t   WAKINTC1	:1; 	 /* 1..1  bit(s) R/W */
N  uint16_t   WAKINTC2	:1; 	 /* 2..2  bit(s) R/W */
N  uint16_t   WAKINTC3	:1; 	 /* 3..3  bit(s) R/W */
N  uint16_t   WAKINTC4	:1; 	 /* 4..4  bit(s) R/W */
N  uint16_t   WAKINTC5	:1; 	 /* 5..5  bit(s) R/W */
N  uint16_t   WAKINTC6	:1; 	 /* 6..6  bit(s) R/W */
N  uint16_t   WAKINTC7	:1; 	 /* 7..7  bit(s) R/W */
N  uint16_t   NMI_SC	:1; 	 /* 8..8  bit(s) R/W */
N  uint16_t   ALARM_SC	:1; 	 /* 9..9  bit(s) R/W */
N  uint16_t   RTC_SC	:1; 	 /* 10..10  bit(s) R/W */ 
N  uint16_t   	:5; 	 /* 11..31  bit(s) R */                    
N} PDHR_WAKINTC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} PDHR_WAKINTC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16PDHR_WAKINTC_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitPDHR_WAKINTC()     ((volatile PDHR_WAKINTC_bit_view_st *)\
N(PDHR_WAKINTC_REG__ ))
X#define pst_bitPDHR_WAKINTC()     ((volatile PDHR_WAKINTC_bit_view_st *)(PDHR_WAKINTC_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8PDHR_WAKINTC()     ((volatile PDHR_WAKINTC_byte_view_st *)\
N(PDHR_WAKINTC_REG__ ))
X#define pst_u8PDHR_WAKINTC()     ((volatile PDHR_WAKINTC_byte_view_st *)(PDHR_WAKINTC_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16PDHR_WAKINTC()     ((volatile u16PDHR_WAKINTC_halfword_view *)\
N(PDHR_WAKINTC_REG__ ))
X#define pu16PDHR_WAKINTC()     ((volatile u16PDHR_WAKINTC_halfword_view *)(PDHR_WAKINTC_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetPDHR_WAKINTC_WAKINTC0() (pst_bitPDHR_WAKINTC() -> WAKINTC0)
N#define vSetPDHR_WAKINTC_WAKINTC0(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC0=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC1() (pst_bitPDHR_WAKINTC() -> WAKINTC1)
N#define vSetPDHR_WAKINTC_WAKINTC1(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC1=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC2() (pst_bitPDHR_WAKINTC() -> WAKINTC2)
N#define vSetPDHR_WAKINTC_WAKINTC2(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC2=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC3() (pst_bitPDHR_WAKINTC() -> WAKINTC3)
N#define vSetPDHR_WAKINTC_WAKINTC3(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC3=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC4() (pst_bitPDHR_WAKINTC() -> WAKINTC4)
N#define vSetPDHR_WAKINTC_WAKINTC4(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC4=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC5() (pst_bitPDHR_WAKINTC() -> WAKINTC5)
N#define vSetPDHR_WAKINTC_WAKINTC5(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC5=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC6() (pst_bitPDHR_WAKINTC() -> WAKINTC6)
N#define vSetPDHR_WAKINTC_WAKINTC6(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC6=(ParValue))
N#define biGetPDHR_WAKINTC_WAKINTC7() (pst_bitPDHR_WAKINTC() -> WAKINTC7)
N#define vSetPDHR_WAKINTC_WAKINTC7(ParValue)  (pst_bitPDHR_WAKINTC() -> WAKINTC7=(ParValue))
N#define biGetPDHR_WAKINTC_NMI_SC() (pst_bitPDHR_WAKINTC() -> NMI_SC)
N#define vSetPDHR_WAKINTC_NMI_SC(ParValue)  (pst_bitPDHR_WAKINTC() -> NMI_SC=(ParValue))
N#define biGetPDHR_WAKINTC_ALARM_SC() (pst_bitPDHR_WAKINTC() -> ALARM_SC)
N#define vSetPDHR_WAKINTC_ALARM_SC(ParValue)  (pst_bitPDHR_WAKINTC() -> ALARM_SC=(ParValue))
N#define biGetPDHR_WAKINTC_RTC_SC() (pst_bitPDHR_WAKINTC() -> RTC_SC)
N#define vSetPDHR_WAKINTC_RTC_SC(ParValue)  (pst_bitPDHR_WAKINTC() -> RTC_SC=(ParValue))
N            
N/* L-struct byte access */
N#define vSetPDHR_WAKINTCL(ParValue) (pst_u8PDHR_WAKINTC() -> u8L = (ParValue))
N#define u8GetPDHR_WAKINTCL() (pst_u8PDHR_WAKINTC() -> u8L)
N/* H-struct byte access */
N#define vSetPDHR_WAKINTCH(ParValue) (pst_u8PDHR_WAKINTC() -> u8H = (ParValue))
N#define u8GetPDHR_WAKINTCH() (pst_u8PDHR_WAKINTC() -> u8H)
N            
N/* Half-word access */ 
N#define vSetPDHR_WAKINTC(ParValue) (*pu16PDHR_WAKINTC()  = (ParValue))
N#define u16GetPDHR_WAKINTC() (*pu16PDHR_WAKINTC() )
N
N/******************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */ 
N/******************************************************************************/
N    
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :   Deactivated:
N** |     Not requested Rules: 
N** |         Rule 5.7  [A] : No reuse of identifiers
N** |
N** |     Requested Rules:
N** |         Rule 6.4  [R] : Bitfields can only have `unsigned int' or `signed int' types
N** |                         Used for bit definitons generated by converter tool
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************/
N
N#endif /* SysCon_PDHIO_H */ 
N    
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 23 "..\..\..\..\lldd\src\ccr.c" 2
N#include "ccr_pds_io.h"
L 1 "..\..\..\..\lldd\hdr\ccr_pds_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : SysCon_PDS 
N/  Date of creation (y-m-d:time): 2015-05-27+02:00  :  10:51:15.232+02:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.13 $ 
N/  Excel Sheet ver.             : vv9.18
N/  Excel Sheet date             : 2015-May-19
N/  Excel Sheet author           : BEL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : CCD_PDS low level driver io-header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : CCR
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.13 $ 
N*   DATE        : $Date: 2015/05/27 09:37:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef SysCon_PDSIO_H
N#define SysCon_PDSIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */ 
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_CCR_PDS_IO_H_REVISION     "$Revision: 1.13 $"
N#define LLDD_CCR_PDS_IO_H_TAG          "$Name: LLDD_1_6 $"
N     
N/*********************************************/
N/* disable following Misra errors for io files */
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1840   /* Rule 5.7  [A] : No reuse of identifiers */
S  #pragma ghs nowarning 230    /* Rule 6.4  [R] : Bitfields can only have `unsigned int' or `signed int' types */
S  #pragma ghs nowarning 1752   /* Rule 17.4 [R] : No pointer arithmetic other than array indexing */
N#endif 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_KEYR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000000                             
N*       ACCESS  : 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_KEYR_REG__       0xC0000000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   KEYVAL	:32; 	 /* 0..31  bit(s) R/W */                    
N} CCR_KEYR_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32CCR_KEYR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_KEYR()     ((volatile CCR_KEYR_bit_view_st *)\
N(CCR_KEYR_REG__ ))
X#define pst_bitCCR_KEYR()     ((volatile CCR_KEYR_bit_view_st *)(CCR_KEYR_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32CCR_KEYR()     ((volatile u32CCR_KEYR_word_view *)\
N(CCR_KEYR_REG__ ))
X#define pu32CCR_KEYR()     ((volatile u32CCR_KEYR_word_view *)(CCR_KEYR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_KEYR_KEYVAL() (pst_bitCCR_KEYR() -> KEYVAL)
N#define vSetCCR_KEYR_KEYVAL(ParValue)  (pst_bitCCR_KEYR() -> KEYVAL=(ParValue))
N            
N/* Word access */
N#define vSetCCR_KEYR(ParValue)  (*pu32CCR_KEYR() = (ParValue))
N#define u32GetCCR_KEYR()  (*pu32CCR_KEYR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVM1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000004                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVM1_REG__       0xC0000004U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GDC0	:12; 	 /* 0..11  bit(s) R/W */
N  uint32_t   	:4; 	 /* 12..15  bit(s) R */
N  uint32_t   GDC1	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_CLKDIVM1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_CLKDIVM1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_CLKDIVM1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_CLKDIVM1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVM1()     ((volatile CCR_CLKDIVM1_bit_view_st *)\
N(CCR_CLKDIVM1_REG__ ))
X#define pst_bitCCR_CLKDIVM1()     ((volatile CCR_CLKDIVM1_bit_view_st *)(CCR_CLKDIVM1_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKDIVM1()     ((volatile CCR_CLKDIVM1_byte_view_st *)\
N(CCR_CLKDIVM1_REG__ ))
X#define pst_u8CCR_CLKDIVM1()     ((volatile CCR_CLKDIVM1_byte_view_st *)(CCR_CLKDIVM1_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_CLKDIVM1()     ((volatile CCR_CLKDIVM1_halfword_view_st *)\
N(CCR_CLKDIVM1_REG__ ))
X#define pst_u16CCR_CLKDIVM1()     ((volatile CCR_CLKDIVM1_halfword_view_st *)(CCR_CLKDIVM1_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_CLKDIVM1()     ((volatile u32CCR_CLKDIVM1_word_view *)\
N(CCR_CLKDIVM1_REG__ ))
X#define pu32CCR_CLKDIVM1()     ((volatile u32CCR_CLKDIVM1_word_view *)(CCR_CLKDIVM1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVM1_GDC0() (pst_bitCCR_CLKDIVM1() -> GDC0)
N#define vSetCCR_CLKDIVM1_GDC0(ParValue)  (pst_bitCCR_CLKDIVM1() -> GDC0=(ParValue))
N#define biGetCCR_CLKDIVM1_GDC1() (pst_bitCCR_CLKDIVM1() -> GDC1)
N#define vSetCCR_CLKDIVM1_GDC1(ParValue)  (pst_bitCCR_CLKDIVM1() -> GDC1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_CLKDIVM1LL(ParValue) (pst_u8CCR_CLKDIVM1() -> u8LL = (ParValue))
N#define u8GetCCR_CLKDIVM1LL() (pst_u8CCR_CLKDIVM1() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_CLKDIVM1LH(ParValue) (pst_u8CCR_CLKDIVM1() -> u8LH = (ParValue))
N#define u8GetCCR_CLKDIVM1LH() (pst_u8CCR_CLKDIVM1() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_CLKDIVM1HL(ParValue) (pst_u8CCR_CLKDIVM1() -> u8HL = (ParValue))
N#define u8GetCCR_CLKDIVM1HL() (pst_u8CCR_CLKDIVM1() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_CLKDIVM1HH(ParValue) (pst_u8CCR_CLKDIVM1() -> u8HH = (ParValue))
N#define u8GetCCR_CLKDIVM1HH() (pst_u8CCR_CLKDIVM1() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_CLKDIVM1L(ParValue) (pst_u16CCR_CLKDIVM1() -> u16L = (ParValue))
N#define u16GetCCR_CLKDIVM1L() (pst_u16CCR_CLKDIVM1() -> u16L)
N#define vSetCCR_CLKDIVM1H(ParValue) (pst_u16CCR_CLKDIVM1() -> u16H = (ParValue))
N#define u16GetCCR_CLKDIVM1H() (pst_u16CCR_CLKDIVM1() -> u16H)
N            
N/* Word access */
N#define vSetCCR_CLKDIVM1(ParValue)  (*pu32CCR_CLKDIVM1() = (ParValue))
N#define u32GetCCR_CLKDIVM1()  (*pu32CCR_CLKDIVM1() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVM2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000008                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVM2_REG__       0xC0000008U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   QSPI0	:5; 	 /* 0..4  bit(s) R/W */
N  uint32_t   	:3; 	 /* 5..7  bit(s) R */
N  uint32_t   QSPI1	:5; 	 /* 8..12  bit(s) R/W */
N  uint32_t   	:3; 	 /* 13..15  bit(s) R */
N  uint32_t   QSPI2	:5; 	 /* 16..20  bit(s) R/W */
N  uint32_t   	:3; 	 /* 21..23  bit(s) R */
N  uint32_t   SDRAMIF	:4; 	 /* 24..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_CLKDIVM2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_CLKDIVM2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_CLKDIVM2_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_CLKDIVM2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVM2()     ((volatile CCR_CLKDIVM2_bit_view_st *)\
N(CCR_CLKDIVM2_REG__ ))
X#define pst_bitCCR_CLKDIVM2()     ((volatile CCR_CLKDIVM2_bit_view_st *)(CCR_CLKDIVM2_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKDIVM2()     ((volatile CCR_CLKDIVM2_byte_view_st *)\
N(CCR_CLKDIVM2_REG__ ))
X#define pst_u8CCR_CLKDIVM2()     ((volatile CCR_CLKDIVM2_byte_view_st *)(CCR_CLKDIVM2_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_CLKDIVM2()     ((volatile CCR_CLKDIVM2_halfword_view_st *)\
N(CCR_CLKDIVM2_REG__ ))
X#define pst_u16CCR_CLKDIVM2()     ((volatile CCR_CLKDIVM2_halfword_view_st *)(CCR_CLKDIVM2_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_CLKDIVM2()     ((volatile u32CCR_CLKDIVM2_word_view *)\
N(CCR_CLKDIVM2_REG__ ))
X#define pu32CCR_CLKDIVM2()     ((volatile u32CCR_CLKDIVM2_word_view *)(CCR_CLKDIVM2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVM2_QSPI0() (pst_bitCCR_CLKDIVM2() -> QSPI0)
N#define vSetCCR_CLKDIVM2_QSPI0(ParValue)  (pst_bitCCR_CLKDIVM2() -> QSPI0=(ParValue))
N#define biGetCCR_CLKDIVM2_QSPI1() (pst_bitCCR_CLKDIVM2() -> QSPI1)
N#define vSetCCR_CLKDIVM2_QSPI1(ParValue)  (pst_bitCCR_CLKDIVM2() -> QSPI1=(ParValue))
N#define biGetCCR_CLKDIVM2_QSPI2() (pst_bitCCR_CLKDIVM2() -> QSPI2)
N#define vSetCCR_CLKDIVM2_QSPI2(ParValue)  (pst_bitCCR_CLKDIVM2() -> QSPI2=(ParValue))
N#define biGetCCR_CLKDIVM2_SDRAMIF() (pst_bitCCR_CLKDIVM2() -> SDRAMIF)
N#define vSetCCR_CLKDIVM2_SDRAMIF(ParValue)  (pst_bitCCR_CLKDIVM2() -> SDRAMIF=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_CLKDIVM2LL(ParValue) (pst_u8CCR_CLKDIVM2() -> u8LL = (ParValue))
N#define u8GetCCR_CLKDIVM2LL() (pst_u8CCR_CLKDIVM2() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_CLKDIVM2LH(ParValue) (pst_u8CCR_CLKDIVM2() -> u8LH = (ParValue))
N#define u8GetCCR_CLKDIVM2LH() (pst_u8CCR_CLKDIVM2() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_CLKDIVM2HL(ParValue) (pst_u8CCR_CLKDIVM2() -> u8HL = (ParValue))
N#define u8GetCCR_CLKDIVM2HL() (pst_u8CCR_CLKDIVM2() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_CLKDIVM2HH(ParValue) (pst_u8CCR_CLKDIVM2() -> u8HH = (ParValue))
N#define u8GetCCR_CLKDIVM2HH() (pst_u8CCR_CLKDIVM2() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_CLKDIVM2L(ParValue) (pst_u16CCR_CLKDIVM2() -> u16L = (ParValue))
N#define u16GetCCR_CLKDIVM2L() (pst_u16CCR_CLKDIVM2() -> u16L)
N#define vSetCCR_CLKDIVM2H(ParValue) (pst_u16CCR_CLKDIVM2() -> u16H = (ParValue))
N#define u16GetCCR_CLKDIVM2H() (pst_u16CCR_CLKDIVM2() -> u16H)
N            
N/* Word access */
N#define vSetCCR_CLKDIVM2(ParValue)  (*pu32CCR_CLKDIVM2() = (ParValue))
N#define u32GetCCR_CLKDIVM2()  (*pu32CCR_CLKDIVM2() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVM3                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000000C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVM3_REG__       0xC000000CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   I2S	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   PL353	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_CLKDIVM3_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_CLKDIVM3_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_CLKDIVM3_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_CLKDIVM3_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVM3()     ((volatile CCR_CLKDIVM3_bit_view_st *)\
N(CCR_CLKDIVM3_REG__ ))
X#define pst_bitCCR_CLKDIVM3()     ((volatile CCR_CLKDIVM3_bit_view_st *)(CCR_CLKDIVM3_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKDIVM3()     ((volatile CCR_CLKDIVM3_byte_view_st *)\
N(CCR_CLKDIVM3_REG__ ))
X#define pst_u8CCR_CLKDIVM3()     ((volatile CCR_CLKDIVM3_byte_view_st *)(CCR_CLKDIVM3_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_CLKDIVM3()     ((volatile CCR_CLKDIVM3_halfword_view_st *)\
N(CCR_CLKDIVM3_REG__ ))
X#define pst_u16CCR_CLKDIVM3()     ((volatile CCR_CLKDIVM3_halfword_view_st *)(CCR_CLKDIVM3_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_CLKDIVM3()     ((volatile u32CCR_CLKDIVM3_word_view *)\
N(CCR_CLKDIVM3_REG__ ))
X#define pu32CCR_CLKDIVM3()     ((volatile u32CCR_CLKDIVM3_word_view *)(CCR_CLKDIVM3_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVM3_I2S() (pst_bitCCR_CLKDIVM3() -> I2S)
N#define vSetCCR_CLKDIVM3_I2S(ParValue)  (pst_bitCCR_CLKDIVM3() -> I2S=(ParValue))
N#define biGetCCR_CLKDIVM3_PL353() (pst_bitCCR_CLKDIVM3() -> PL353)
N#define vSetCCR_CLKDIVM3_PL353(ParValue)  (pst_bitCCR_CLKDIVM3() -> PL353=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_CLKDIVM3LL(ParValue) (pst_u8CCR_CLKDIVM3() -> u8LL = (ParValue))
N#define u8GetCCR_CLKDIVM3LL() (pst_u8CCR_CLKDIVM3() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_CLKDIVM3LH(ParValue) (pst_u8CCR_CLKDIVM3() -> u8LH = (ParValue))
N#define u8GetCCR_CLKDIVM3LH() (pst_u8CCR_CLKDIVM3() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_CLKDIVM3HL(ParValue) (pst_u8CCR_CLKDIVM3() -> u8HL = (ParValue))
N#define u8GetCCR_CLKDIVM3HL() (pst_u8CCR_CLKDIVM3() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_CLKDIVM3HH(ParValue) (pst_u8CCR_CLKDIVM3() -> u8HH = (ParValue))
N#define u8GetCCR_CLKDIVM3HH() (pst_u8CCR_CLKDIVM3() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_CLKDIVM3L(ParValue) (pst_u16CCR_CLKDIVM3() -> u16L = (ParValue))
N#define u16GetCCR_CLKDIVM3L() (pst_u16CCR_CLKDIVM3() -> u16L)
N#define vSetCCR_CLKDIVM3H(ParValue) (pst_u16CCR_CLKDIVM3() -> u16H = (ParValue))
N#define u16GetCCR_CLKDIVM3H() (pst_u16CCR_CLKDIVM3() -> u16H)
N            
N/* Word access */
N#define vSetCCR_CLKDIVM3(ParValue)  (*pu32CCR_CLKDIVM3() = (ParValue))
N#define u32GetCCR_CLKDIVM3()  (*pu32CCR_CLKDIVM3() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVNM1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVNM1_REG__       0xC0000010U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GDC0	:12; 	 /* 0..11  bit(s) R/W */
N  uint32_t   	:4; 	 /* 12..15  bit(s) R */
N  uint32_t   GDC1	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_CLKDIVNM1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_CLKDIVNM1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_CLKDIVNM1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_CLKDIVNM1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVNM1()     ((volatile CCR_CLKDIVNM1_bit_view_st *)\
N(CCR_CLKDIVNM1_REG__ ))
X#define pst_bitCCR_CLKDIVNM1()     ((volatile CCR_CLKDIVNM1_bit_view_st *)(CCR_CLKDIVNM1_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKDIVNM1()     ((volatile CCR_CLKDIVNM1_byte_view_st *)\
N(CCR_CLKDIVNM1_REG__ ))
X#define pst_u8CCR_CLKDIVNM1()     ((volatile CCR_CLKDIVNM1_byte_view_st *)(CCR_CLKDIVNM1_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_CLKDIVNM1()     ((volatile CCR_CLKDIVNM1_halfword_view_st *)\
N(CCR_CLKDIVNM1_REG__ ))
X#define pst_u16CCR_CLKDIVNM1()     ((volatile CCR_CLKDIVNM1_halfword_view_st *)(CCR_CLKDIVNM1_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_CLKDIVNM1()     ((volatile u32CCR_CLKDIVNM1_word_view *)\
N(CCR_CLKDIVNM1_REG__ ))
X#define pu32CCR_CLKDIVNM1()     ((volatile u32CCR_CLKDIVNM1_word_view *)(CCR_CLKDIVNM1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVNM1_GDC0() (pst_bitCCR_CLKDIVNM1() -> GDC0)
N#define vSetCCR_CLKDIVNM1_GDC0(ParValue)  (pst_bitCCR_CLKDIVNM1() -> GDC0=(ParValue))
N#define biGetCCR_CLKDIVNM1_GDC1() (pst_bitCCR_CLKDIVNM1() -> GDC1)
N#define vSetCCR_CLKDIVNM1_GDC1(ParValue)  (pst_bitCCR_CLKDIVNM1() -> GDC1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_CLKDIVNM1LL(ParValue) (pst_u8CCR_CLKDIVNM1() -> u8LL = (ParValue))
N#define u8GetCCR_CLKDIVNM1LL() (pst_u8CCR_CLKDIVNM1() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_CLKDIVNM1LH(ParValue) (pst_u8CCR_CLKDIVNM1() -> u8LH = (ParValue))
N#define u8GetCCR_CLKDIVNM1LH() (pst_u8CCR_CLKDIVNM1() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_CLKDIVNM1HL(ParValue) (pst_u8CCR_CLKDIVNM1() -> u8HL = (ParValue))
N#define u8GetCCR_CLKDIVNM1HL() (pst_u8CCR_CLKDIVNM1() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_CLKDIVNM1HH(ParValue) (pst_u8CCR_CLKDIVNM1() -> u8HH = (ParValue))
N#define u8GetCCR_CLKDIVNM1HH() (pst_u8CCR_CLKDIVNM1() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_CLKDIVNM1L(ParValue) (pst_u16CCR_CLKDIVNM1() -> u16L = (ParValue))
N#define u16GetCCR_CLKDIVNM1L() (pst_u16CCR_CLKDIVNM1() -> u16L)
N#define vSetCCR_CLKDIVNM1H(ParValue) (pst_u16CCR_CLKDIVNM1() -> u16H = (ParValue))
N#define u16GetCCR_CLKDIVNM1H() (pst_u16CCR_CLKDIVNM1() -> u16H)
N            
N/* Word access */
N#define vSetCCR_CLKDIVNM1(ParValue)  (*pu32CCR_CLKDIVNM1() = (ParValue))
N#define u32GetCCR_CLKDIVNM1()  (*pu32CCR_CLKDIVNM1() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVNM2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000014                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVNM2_REG__       0xC0000014U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   TRACE	:5; 	 /* 0..4  bit(s) R/W */
N  uint8_t   	:3; 	 /* 5..7  bit(s) R */                    
N} CCR_CLKDIVNM2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8CCR_CLKDIVNM2_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVNM2()     ((volatile CCR_CLKDIVNM2_bit_view_st *)\
N(CCR_CLKDIVNM2_REG__ ))
X#define pst_bitCCR_CLKDIVNM2()     ((volatile CCR_CLKDIVNM2_bit_view_st *)(CCR_CLKDIVNM2_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8CCR_CLKDIVNM2()     ((volatile u8CCR_CLKDIVNM2_byte_view *)\
N(CCR_CLKDIVNM2_REG__ ))
X#define pu8CCR_CLKDIVNM2()     ((volatile u8CCR_CLKDIVNM2_byte_view *)(CCR_CLKDIVNM2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVNM2_TRACE() (pst_bitCCR_CLKDIVNM2() -> TRACE)
N#define vSetCCR_CLKDIVNM2_TRACE(ParValue)  (pst_bitCCR_CLKDIVNM2() -> TRACE=(ParValue))
N            
N/* byte access */
N#define vSetCCR_CLKDIVNM2(ParValue) (*pu8CCR_CLKDIVNM2() = (ParValue))
N#define u8GetCCR_CLKDIVNM2() (*pu8CCR_CLKDIVNM2() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVNM3                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000018                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVNM3_REG__       0xC0000018U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   I2S	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   PL353	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_CLKDIVNM3_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_CLKDIVNM3_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_CLKDIVNM3_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_CLKDIVNM3_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVNM3()     ((volatile CCR_CLKDIVNM3_bit_view_st *)\
N(CCR_CLKDIVNM3_REG__ ))
X#define pst_bitCCR_CLKDIVNM3()     ((volatile CCR_CLKDIVNM3_bit_view_st *)(CCR_CLKDIVNM3_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKDIVNM3()     ((volatile CCR_CLKDIVNM3_byte_view_st *)\
N(CCR_CLKDIVNM3_REG__ ))
X#define pst_u8CCR_CLKDIVNM3()     ((volatile CCR_CLKDIVNM3_byte_view_st *)(CCR_CLKDIVNM3_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_CLKDIVNM3()     ((volatile CCR_CLKDIVNM3_halfword_view_st *)\
N(CCR_CLKDIVNM3_REG__ ))
X#define pst_u16CCR_CLKDIVNM3()     ((volatile CCR_CLKDIVNM3_halfword_view_st *)(CCR_CLKDIVNM3_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_CLKDIVNM3()     ((volatile u32CCR_CLKDIVNM3_word_view *)\
N(CCR_CLKDIVNM3_REG__ ))
X#define pu32CCR_CLKDIVNM3()     ((volatile u32CCR_CLKDIVNM3_word_view *)(CCR_CLKDIVNM3_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVNM3_I2S() (pst_bitCCR_CLKDIVNM3() -> I2S)
N#define vSetCCR_CLKDIVNM3_I2S(ParValue)  (pst_bitCCR_CLKDIVNM3() -> I2S=(ParValue))
N#define biGetCCR_CLKDIVNM3_PL353() (pst_bitCCR_CLKDIVNM3() -> PL353)
N#define vSetCCR_CLKDIVNM3_PL353(ParValue)  (pst_bitCCR_CLKDIVNM3() -> PL353=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_CLKDIVNM3LL(ParValue) (pst_u8CCR_CLKDIVNM3() -> u8LL = (ParValue))
N#define u8GetCCR_CLKDIVNM3LL() (pst_u8CCR_CLKDIVNM3() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_CLKDIVNM3LH(ParValue) (pst_u8CCR_CLKDIVNM3() -> u8LH = (ParValue))
N#define u8GetCCR_CLKDIVNM3LH() (pst_u8CCR_CLKDIVNM3() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_CLKDIVNM3HL(ParValue) (pst_u8CCR_CLKDIVNM3() -> u8HL = (ParValue))
N#define u8GetCCR_CLKDIVNM3HL() (pst_u8CCR_CLKDIVNM3() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_CLKDIVNM3HH(ParValue) (pst_u8CCR_CLKDIVNM3() -> u8HH = (ParValue))
N#define u8GetCCR_CLKDIVNM3HH() (pst_u8CCR_CLKDIVNM3() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_CLKDIVNM3L(ParValue) (pst_u16CCR_CLKDIVNM3() -> u16L = (ParValue))
N#define u16GetCCR_CLKDIVNM3L() (pst_u16CCR_CLKDIVNM3() -> u16L)
N#define vSetCCR_CLKDIVNM3H(ParValue) (pst_u16CCR_CLKDIVNM3() -> u16H = (ParValue))
N#define u16GetCCR_CLKDIVNM3H() (pst_u16CCR_CLKDIVNM3() -> u16H)
N            
N/* Word access */
N#define vSetCCR_CLKDIVNM3(ParValue)  (*pu32CCR_CLKDIVNM3() = (ParValue))
N#define u32GetCCR_CLKDIVNM3()  (*pu32CCR_CLKDIVNM3() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKDIVACK                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000001C                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKDIVACK_REG__       0xC000001CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   RELOADACK_MGDC0	:1; 	 /* 0..0  bit(s) R/W0C */
N  uint16_t   RELOADACK_MGDC1	:1; 	 /* 1..1  bit(s) R/W0C */
N  uint16_t   RELOADACK_MQSPI0	:1; 	 /* 2..2  bit(s) R/W0C */
N  uint16_t   RELOADACK_MQSPI1	:1; 	 /* 3..3  bit(s) R/W0C */
N  uint16_t   RELOADACK_MQSPI2	:1; 	 /* 4..4  bit(s) R/W0C */
N  uint16_t   RELOADACK_MSDRAM	:1; 	 /* 5..5  bit(s) R/W0C */
N  uint16_t   RELOADACK_MI2S	:1; 	 /* 6..6  bit(s) R/W0C */
N  uint16_t   RELOADACK_MPL353	:1; 	 /* 7..7  bit(s) R/W0C */
N  uint16_t   RELOADACK_NMGDC0	:1; 	 /* 8..8  bit(s) R/W0C */
N  uint16_t   RELOADACK_NMGDC1	:1; 	 /* 9..9  bit(s) R/W0C */
N  uint16_t   RELOADACK_NMTRACE	:1; 	 /* 10..10  bit(s) R/W0C */
N  uint16_t   	:3; 	 /* 11..13  bit(s) R */
N  uint16_t   RELOADACK_NMI2S	:1; 	 /* 14..14  bit(s) R/W0C */
N  uint16_t   RELOADACK_NMPL353	:1; 	 /* 15..15  bit(s) R/W0C */                    
N} CCR_CLKDIVACK_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} CCR_CLKDIVACK_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16CCR_CLKDIVACK_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKDIVACK()     ((volatile CCR_CLKDIVACK_bit_view_st *)\
N(CCR_CLKDIVACK_REG__ ))
X#define pst_bitCCR_CLKDIVACK()     ((volatile CCR_CLKDIVACK_bit_view_st *)(CCR_CLKDIVACK_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKDIVACK()     ((volatile CCR_CLKDIVACK_byte_view_st *)\
N(CCR_CLKDIVACK_REG__ ))
X#define pst_u8CCR_CLKDIVACK()     ((volatile CCR_CLKDIVACK_byte_view_st *)(CCR_CLKDIVACK_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16CCR_CLKDIVACK()     ((volatile u16CCR_CLKDIVACK_halfword_view *)\
N(CCR_CLKDIVACK_REG__ ))
X#define pu16CCR_CLKDIVACK()     ((volatile u16CCR_CLKDIVACK_halfword_view *)(CCR_CLKDIVACK_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKDIVACK_RELOADACK_MGDC0() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MGDC0)
N#define vClrCCR_CLKDIVACK_RELOADACK_MGDC0() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MGDC0=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MGDC1() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MGDC1)
N#define vClrCCR_CLKDIVACK_RELOADACK_MGDC1() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MGDC1=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MQSPI0() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MQSPI0)
N#define vClrCCR_CLKDIVACK_RELOADACK_MQSPI0() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MQSPI0=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MQSPI1() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MQSPI1)
N#define vClrCCR_CLKDIVACK_RELOADACK_MQSPI1() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MQSPI1=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MQSPI2() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MQSPI2)
N#define vClrCCR_CLKDIVACK_RELOADACK_MQSPI2() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MQSPI2=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MSDRAM() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MSDRAM)
N#define vClrCCR_CLKDIVACK_RELOADACK_MSDRAM() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MSDRAM=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MI2S() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MI2S)
N#define vClrCCR_CLKDIVACK_RELOADACK_MI2S() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MI2S=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_MPL353() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MPL353)
N#define vClrCCR_CLKDIVACK_RELOADACK_MPL353() (pst_bitCCR_CLKDIVACK() -> RELOADACK_MPL353=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_NMGDC0() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMGDC0)
N#define vClrCCR_CLKDIVACK_RELOADACK_NMGDC0() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMGDC0=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_NMGDC1() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMGDC1)
N#define vClrCCR_CLKDIVACK_RELOADACK_NMGDC1() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMGDC1=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_NMTRACE() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMTRACE)
N#define vClrCCR_CLKDIVACK_RELOADACK_NMTRACE() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMTRACE=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_NMI2S() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMI2S)
N#define vClrCCR_CLKDIVACK_RELOADACK_NMI2S() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMI2S=(0))
N#define biGetCCR_CLKDIVACK_RELOADACK_NMPL353() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMPL353)
N#define vClrCCR_CLKDIVACK_RELOADACK_NMPL353() (pst_bitCCR_CLKDIVACK() -> RELOADACK_NMPL353=(0))
N            
N/* L-struct byte access */
N#define vSetCCR_CLKDIVACKL(ParValue) (pst_u8CCR_CLKDIVACK() -> u8L = (ParValue))
N#define u8GetCCR_CLKDIVACKL() (pst_u8CCR_CLKDIVACK() -> u8L)
N/* H-struct byte access */
N#define vSetCCR_CLKDIVACKH(ParValue) (pst_u8CCR_CLKDIVACK() -> u8H = (ParValue))
N#define u8GetCCR_CLKDIVACKH() (pst_u8CCR_CLKDIVACK() -> u8H)
N            
N/* Half-word access */ 
N#define vSetCCR_CLKDIVACK(ParValue) (*pu16CCR_CLKDIVACK()  = (ParValue))
N#define u16GetCCR_CLKDIVACK() (*pu16CCR_CLKDIVACK() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_CLKSEL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000020                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_CLKSEL_REG__       0xC0000020U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   CLK_DOT0_SEL	:2; 	 /* 0..1  bit(s) R/W */
N  uint16_t   CLK_DOT1_SEL	:3; 	 /* 2..4  bit(s) R/W */
N  uint16_t   CLK_I2S_SEL	:2; 	 /* 5..6  bit(s) R/W */
N  uint16_t   	:1; 	 /* 7..7  bit(s) R */
N  uint16_t   CLK_PL353_SEL	:2; 	 /* 8..9  bit(s) R/W */
N  uint16_t   CLK_300_SEL	:1; 	 /* 10..10  bit(s) R/W */
N  uint16_t   	:1; 	 /* 11..11  bit(s) R */
N  uint16_t   CLK_ADC_SEL	:3; 	 /* 12..14  bit(s) R/W */ 
N  uint16_t   	:1; 	 /* 15..31  bit(s) R */                    
N} CCR_CLKSEL_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} CCR_CLKSEL_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16CCR_CLKSEL_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_CLKSEL()     ((volatile CCR_CLKSEL_bit_view_st *)\
N(CCR_CLKSEL_REG__ ))
X#define pst_bitCCR_CLKSEL()     ((volatile CCR_CLKSEL_bit_view_st *)(CCR_CLKSEL_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_CLKSEL()     ((volatile CCR_CLKSEL_byte_view_st *)\
N(CCR_CLKSEL_REG__ ))
X#define pst_u8CCR_CLKSEL()     ((volatile CCR_CLKSEL_byte_view_st *)(CCR_CLKSEL_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16CCR_CLKSEL()     ((volatile u16CCR_CLKSEL_halfword_view *)\
N(CCR_CLKSEL_REG__ ))
X#define pu16CCR_CLKSEL()     ((volatile u16CCR_CLKSEL_halfword_view *)(CCR_CLKSEL_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_CLKSEL_CLK_DOT0_SEL() (pst_bitCCR_CLKSEL() -> CLK_DOT0_SEL)
N#define vSetCCR_CLKSEL_CLK_DOT0_SEL(ParValue)  (pst_bitCCR_CLKSEL() -> CLK_DOT0_SEL=(ParValue))
N#define biGetCCR_CLKSEL_CLK_DOT1_SEL() (pst_bitCCR_CLKSEL() -> CLK_DOT1_SEL)
N#define vSetCCR_CLKSEL_CLK_DOT1_SEL(ParValue)  (pst_bitCCR_CLKSEL() -> CLK_DOT1_SEL=(ParValue))
N#define biGetCCR_CLKSEL_CLK_I2S_SEL() (pst_bitCCR_CLKSEL() -> CLK_I2S_SEL)
N#define vSetCCR_CLKSEL_CLK_I2S_SEL(ParValue)  (pst_bitCCR_CLKSEL() -> CLK_I2S_SEL=(ParValue))
N#define biGetCCR_CLKSEL_CLK_PL353_SEL() (pst_bitCCR_CLKSEL() -> CLK_PL353_SEL)
N#define vSetCCR_CLKSEL_CLK_PL353_SEL(ParValue)  (pst_bitCCR_CLKSEL() -> CLK_PL353_SEL=(ParValue))
N#define biGetCCR_CLKSEL_CLK_300_SEL() (pst_bitCCR_CLKSEL() -> CLK_300_SEL)
N#define vSetCCR_CLKSEL_CLK_300_SEL(ParValue)  (pst_bitCCR_CLKSEL() -> CLK_300_SEL=(ParValue))
N#define biGetCCR_CLKSEL_CLK_ADC_SEL() (pst_bitCCR_CLKSEL() -> CLK_ADC_SEL)
N#define vSetCCR_CLKSEL_CLK_ADC_SEL(ParValue)  (pst_bitCCR_CLKSEL() -> CLK_ADC_SEL=(ParValue))
N            
N/* L-struct byte access */
N#define vSetCCR_CLKSELL(ParValue) (pst_u8CCR_CLKSEL() -> u8L = (ParValue))
N#define u8GetCCR_CLKSELL() (pst_u8CCR_CLKSEL() -> u8L)
N/* H-struct byte access */
N#define vSetCCR_CLKSELH(ParValue) (pst_u8CCR_CLKSEL() -> u8H = (ParValue))
N#define u8GetCCR_CLKSELH() (pst_u8CCR_CLKSEL() -> u8H)
N            
N/* Half-word access */ 
N#define vSetCCR_CLKSEL(ParValue) (*pu16CCR_CLKSEL()  = (ParValue))
N#define u16GetCCR_CLKSEL() (*pu16CCR_CLKSEL() )     
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_PERICLKGATE                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000024                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_PERICLKGATE_REG__       0xC0000024U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   CLK_QSPI0_GATE	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   CLK_QSPI1_GATE	:1; 	 /* 1..1  bit(s) R/W */
N  uint32_t   CLK_QSPI2_GATE	:1; 	 /* 2..2  bit(s) R/W */
N  uint32_t   CLK_DMA_GATE	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   CLK_PARFL_GATE	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   CLK_DAP_GATE	:1; 	 /* 5..5  bit(s) R/W */
N  uint32_t   CLK_GA_GATE	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   	:3; 	 /* 7..9  bit(s) R */
N  uint32_t   CLK_PNG_GATE	:1; 	 /* 10..10  bit(s) R/W */
N  uint32_t   CLK_GDC0_GATE	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   CLK_GDC1_GATE	:1; 	 /* 12..12  bit(s) R/W */
N  uint32_t   CLK_FG_GATE	:1; 	 /* 13..13  bit(s) R/W */
N  uint32_t   CLK_MLB_GATE	:1; 	 /* 14..14  bit(s) R/W */
N  uint32_t   CLK_SDRAM_GATE	:1; 	 /* 15..15  bit(s) R/W */
N  uint32_t   CLK_SMC_GATE	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   CLK_I2S_GATE	:1; 	 /* 18..18  bit(s) R/W */
N  uint32_t   CLK_HSPWM_GATE	:1; 	 /* 19..19  bit(s) R/W */
N  uint32_t   CLK_I2SM_GATE	:1; 	 /* 20..20  bit(s) R/W */
N  uint32_t   CLK_TSM_GATE	:1; 	 /* 21..21  bit(s) R/W */ 
N  uint32_t   	:10; 	 /* 22..31  bit(s) R */                    
N} CCR_PERICLKGATE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_PERICLKGATE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_PERICLKGATE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_PERICLKGATE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_PERICLKGATE()     ((volatile CCR_PERICLKGATE_bit_view_st *)\
N(CCR_PERICLKGATE_REG__ ))
X#define pst_bitCCR_PERICLKGATE()     ((volatile CCR_PERICLKGATE_bit_view_st *)(CCR_PERICLKGATE_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_PERICLKGATE()     ((volatile CCR_PERICLKGATE_byte_view_st *)\
N(CCR_PERICLKGATE_REG__ ))
X#define pst_u8CCR_PERICLKGATE()     ((volatile CCR_PERICLKGATE_byte_view_st *)(CCR_PERICLKGATE_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_PERICLKGATE()     ((volatile CCR_PERICLKGATE_halfword_view_st *)\
N(CCR_PERICLKGATE_REG__ ))
X#define pst_u16CCR_PERICLKGATE()     ((volatile CCR_PERICLKGATE_halfword_view_st *)(CCR_PERICLKGATE_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_PERICLKGATE()     ((volatile u32CCR_PERICLKGATE_word_view *)\
N(CCR_PERICLKGATE_REG__ ))
X#define pu32CCR_PERICLKGATE()     ((volatile u32CCR_PERICLKGATE_word_view *)(CCR_PERICLKGATE_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_PERICLKGATE_CLK_QSPI0_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_QSPI0_GATE)
N#define vSetCCR_PERICLKGATE_CLK_QSPI0_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_QSPI0_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_QSPI1_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_QSPI1_GATE)
N#define vSetCCR_PERICLKGATE_CLK_QSPI1_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_QSPI1_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_QSPI2_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_QSPI2_GATE)
N#define vSetCCR_PERICLKGATE_CLK_QSPI2_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_QSPI2_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_DMA_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_DMA_GATE)
N#define vSetCCR_PERICLKGATE_CLK_DMA_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_DMA_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_PARFL_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_PARFL_GATE)
N#define vSetCCR_PERICLKGATE_CLK_PARFL_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_PARFL_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_DAP_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_DAP_GATE)
N#define vSetCCR_PERICLKGATE_CLK_DAP_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_DAP_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_GA_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_GA_GATE)
N#define vSetCCR_PERICLKGATE_CLK_GA_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_GA_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_PNG_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_PNG_GATE)
N#define vSetCCR_PERICLKGATE_CLK_PNG_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_PNG_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_GDC0_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_GDC0_GATE)
N#define vSetCCR_PERICLKGATE_CLK_GDC0_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_GDC0_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_GDC1_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_GDC1_GATE)
N#define vSetCCR_PERICLKGATE_CLK_GDC1_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_GDC1_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_FG_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_FG_GATE)
N#define vSetCCR_PERICLKGATE_CLK_FG_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_FG_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_MLB_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_MLB_GATE)
N#define vSetCCR_PERICLKGATE_CLK_MLB_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_MLB_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_SDRAM_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_SDRAM_GATE)
N#define vSetCCR_PERICLKGATE_CLK_SDRAM_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_SDRAM_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_SMC_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_SMC_GATE)
N#define vSetCCR_PERICLKGATE_CLK_SMC_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_SMC_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_I2S_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_I2S_GATE)
N#define vSetCCR_PERICLKGATE_CLK_I2S_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_I2S_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_HSPWM_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_HSPWM_GATE)
N#define vSetCCR_PERICLKGATE_CLK_HSPWM_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_HSPWM_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_I2SM_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_I2SM_GATE)
N#define vSetCCR_PERICLKGATE_CLK_I2SM_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_I2SM_GATE=(ParValue))
N#define biGetCCR_PERICLKGATE_CLK_TSM_GATE() (pst_bitCCR_PERICLKGATE() -> CLK_TSM_GATE)
N#define vSetCCR_PERICLKGATE_CLK_TSM_GATE(ParValue)  (pst_bitCCR_PERICLKGATE() -> CLK_TSM_GATE=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_PERICLKGATELL(ParValue) (pst_u8CCR_PERICLKGATE() -> u8LL = (ParValue))
N#define u8GetCCR_PERICLKGATELL() (pst_u8CCR_PERICLKGATE() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_PERICLKGATELH(ParValue) (pst_u8CCR_PERICLKGATE() -> u8LH = (ParValue))
N#define u8GetCCR_PERICLKGATELH() (pst_u8CCR_PERICLKGATE() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_PERICLKGATEHL(ParValue) (pst_u8CCR_PERICLKGATE() -> u8HL = (ParValue))
N#define u8GetCCR_PERICLKGATEHL() (pst_u8CCR_PERICLKGATE() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_PERICLKGATEHH(ParValue) (pst_u8CCR_PERICLKGATE() -> u8HH = (ParValue))
N#define u8GetCCR_PERICLKGATEHH() (pst_u8CCR_PERICLKGATE() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_PERICLKGATEL(ParValue) (pst_u16CCR_PERICLKGATE() -> u16L = (ParValue))
N#define u16GetCCR_PERICLKGATEL() (pst_u16CCR_PERICLKGATE() -> u16L)
N#define vSetCCR_PERICLKGATEH(ParValue) (pst_u16CCR_PERICLKGATE() -> u16H = (ParValue))
N#define u16GetCCR_PERICLKGATEH() (pst_u16CCR_PERICLKGATE() -> u16H)
N            
N/* Word access */
N#define vSetCCR_PERICLKGATE(ParValue)  (*pu32CCR_PERICLKGATE() = (ParValue))
N#define u32GetCCR_PERICLKGATE()  (*pu32CCR_PERICLKGATE() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_SBCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000028                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_SBCR_REG__       0xC0000028U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   PLLSTBC	:5; 	 /* 0..4  bit(s) R/W */ 
N  uint8_t   	:3; 	 /* 5..31  bit(s) R */                    
N} CCR_SBCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8CCR_SBCR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_SBCR()     ((volatile CCR_SBCR_bit_view_st *)\
N(CCR_SBCR_REG__ ))
X#define pst_bitCCR_SBCR()     ((volatile CCR_SBCR_bit_view_st *)(CCR_SBCR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8CCR_SBCR()     ((volatile u8CCR_SBCR_byte_view *)\
N(CCR_SBCR_REG__ ))
X#define pu8CCR_SBCR()     ((volatile u8CCR_SBCR_byte_view *)(CCR_SBCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_SBCR_PLLSTBC() (pst_bitCCR_SBCR() -> PLLSTBC)
N#define vSetCCR_SBCR_PLLSTBC(ParValue)  (pst_bitCCR_SBCR() -> PLLSTBC=(ParValue))
N            
N/* byte access */
N#define vSetCCR_SBCR(ParValue) (*pu8CCR_SBCR() = (ParValue))
N#define u8GetCCR_SBCR() (*pu8CCR_SBCR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_SBSR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000002C                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_SBSR_REG__       0xC000002CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   OSC10MRDY	:1; 	 /* 0..0  bit(s) R */
N  uint8_t   OSC32KRDY	:1; 	 /* 1..1  bit(s) R */
N  uint8_t   RC100KRDY	:1; 	 /* 2..2  bit(s) R */
N  uint8_t   MPLLRDY	:1; 	 /* 3..3  bit(s) R */
N  uint8_t   NMPLLRDY	:1; 	 /* 4..4  bit(s) R */ 
N  uint8_t   	:3; 	 /* 5..31  bit(s) R */                    
N} CCR_SBSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8CCR_SBSR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_SBSR()     ((volatile CCR_SBSR_bit_view_st *)\
N(CCR_SBSR_REG__ ))
X#define pst_bitCCR_SBSR()     ((volatile CCR_SBSR_bit_view_st *)(CCR_SBSR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8CCR_SBSR()     ((volatile u8CCR_SBSR_byte_view *)\
N(CCR_SBSR_REG__ ))
X#define pu8CCR_SBSR()     ((volatile u8CCR_SBSR_byte_view *)(CCR_SBSR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetCCR_SBSR_OSC10MRDY() (pst_bitCCR_SBSR() -> OSC10MRDY)            
N#define biGetCCR_SBSR_OSC32KRDY() (pst_bitCCR_SBSR() -> OSC32KRDY)            
N#define biGetCCR_SBSR_RC100KRDY() (pst_bitCCR_SBSR() -> RC100KRDY)            
N#define biGetCCR_SBSR_MPLLRDY() (pst_bitCCR_SBSR() -> MPLLRDY)            
N#define biGetCCR_SBSR_NMPLLRDY() (pst_bitCCR_SBSR() -> NMPLLRDY)
N            
N/* byte access */
N
N#define u8GetCCR_SBSR() (*pu8CCR_SBSR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_RSTCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000030                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_RSTCR_REG__       0xC0000030U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SW_FULL_RST	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   DBGRST	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   SW_PART_RST	:8; 	 /* 24..31  bit(s) R/W */                    
N} CCR_RSTCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_RSTCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_RSTCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_RSTCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_RSTCR()     ((volatile CCR_RSTCR_bit_view_st *)\
N(CCR_RSTCR_REG__ ))
X#define pst_bitCCR_RSTCR()     ((volatile CCR_RSTCR_bit_view_st *)(CCR_RSTCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_RSTCR()     ((volatile CCR_RSTCR_byte_view_st *)\
N(CCR_RSTCR_REG__ ))
X#define pst_u8CCR_RSTCR()     ((volatile CCR_RSTCR_byte_view_st *)(CCR_RSTCR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_RSTCR()     ((volatile CCR_RSTCR_halfword_view_st *)\
N(CCR_RSTCR_REG__ ))
X#define pst_u16CCR_RSTCR()     ((volatile CCR_RSTCR_halfword_view_st *)(CCR_RSTCR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_RSTCR()     ((volatile u32CCR_RSTCR_word_view *)\
N(CCR_RSTCR_REG__ ))
X#define pu32CCR_RSTCR()     ((volatile u32CCR_RSTCR_word_view *)(CCR_RSTCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_RSTCR_SW_FULL_RST() (pst_bitCCR_RSTCR() -> SW_FULL_RST)
N#define vSetCCR_RSTCR_SW_FULL_RST(ParValue)  (pst_bitCCR_RSTCR() -> SW_FULL_RST=(ParValue))
N#define biGetCCR_RSTCR_DBGRST() (pst_bitCCR_RSTCR() -> DBGRST)
N#define vSetCCR_RSTCR_DBGRST(ParValue)  (pst_bitCCR_RSTCR() -> DBGRST=(ParValue))
N#define biGetCCR_RSTCR_SW_PART_RST() (pst_bitCCR_RSTCR() -> SW_PART_RST)
N#define vSetCCR_RSTCR_SW_PART_RST(ParValue)  (pst_bitCCR_RSTCR() -> SW_PART_RST=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_RSTCRLL(ParValue) (pst_u8CCR_RSTCR() -> u8LL = (ParValue))
N#define u8GetCCR_RSTCRLL() (pst_u8CCR_RSTCR() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_RSTCRLH(ParValue) (pst_u8CCR_RSTCR() -> u8LH = (ParValue))
N#define u8GetCCR_RSTCRLH() (pst_u8CCR_RSTCR() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_RSTCRHL(ParValue) (pst_u8CCR_RSTCR() -> u8HL = (ParValue))
N#define u8GetCCR_RSTCRHL() (pst_u8CCR_RSTCR() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_RSTCRHH(ParValue) (pst_u8CCR_RSTCR() -> u8HH = (ParValue))
N#define u8GetCCR_RSTCRHH() (pst_u8CCR_RSTCR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_RSTCRL(ParValue) (pst_u16CCR_RSTCR() -> u16L = (ParValue))
N#define u16GetCCR_RSTCRL() (pst_u16CCR_RSTCR() -> u16L)
N#define vSetCCR_RSTCRH(ParValue) (pst_u16CCR_RSTCR() -> u16H = (ParValue))
N#define u16GetCCR_RSTCRH() (pst_u16CCR_RSTCR() -> u16H)
N            
N/* Word access */
N#define vSetCCR_RSTCR(ParValue)  (*pu32CCR_RSTCR() = (ParValue))
N#define u32GetCCR_RSTCR()  (*pu32CCR_RSTCR() )
N                 
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_SCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000003C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_SCR_REG__       0xC000003CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MODECFGR	:7; 	 /* 0..6  bit(s) R/W */
N  uint32_t   	:9; 	 /* 7..15  bit(s) R */
N  uint32_t   MODETRAN	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} CCR_SCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_SCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_SCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_SCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_SCR()     ((volatile CCR_SCR_bit_view_st *)\
N(CCR_SCR_REG__ ))
X#define pst_bitCCR_SCR()     ((volatile CCR_SCR_bit_view_st *)(CCR_SCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_SCR()     ((volatile CCR_SCR_byte_view_st *)\
N(CCR_SCR_REG__ ))
X#define pst_u8CCR_SCR()     ((volatile CCR_SCR_byte_view_st *)(CCR_SCR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_SCR()     ((volatile CCR_SCR_halfword_view_st *)\
N(CCR_SCR_REG__ ))
X#define pst_u16CCR_SCR()     ((volatile CCR_SCR_halfword_view_st *)(CCR_SCR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_SCR()     ((volatile u32CCR_SCR_word_view *)\
N(CCR_SCR_REG__ ))
X#define pu32CCR_SCR()     ((volatile u32CCR_SCR_word_view *)(CCR_SCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_SCR_MODECFGR() (pst_bitCCR_SCR() -> MODECFGR)
N#define vSetCCR_SCR_MODECFGR(ParValue)  (pst_bitCCR_SCR() -> MODECFGR=(ParValue))
N#define biGetCCR_SCR_MODETRAN() (pst_bitCCR_SCR() -> MODETRAN)
N#define vSetCCR_SCR_MODETRAN(ParValue)  (pst_bitCCR_SCR() -> MODETRAN=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_SCRLL(ParValue) (pst_u8CCR_SCR() -> u8LL = (ParValue))
N#define u8GetCCR_SCRLL() (pst_u8CCR_SCR() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_SCRLH(ParValue) (pst_u8CCR_SCR() -> u8LH = (ParValue))
N#define u8GetCCR_SCRLH() (pst_u8CCR_SCR() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_SCRHL(ParValue) (pst_u8CCR_SCR() -> u8HL = (ParValue))
N#define u8GetCCR_SCRHL() (pst_u8CCR_SCR() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_SCRHH(ParValue) (pst_u8CCR_SCR() -> u8HH = (ParValue))
N#define u8GetCCR_SCRHH() (pst_u8CCR_SCR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_SCRL(ParValue) (pst_u16CCR_SCR() -> u16L = (ParValue))
N#define u16GetCCR_SCRL() (pst_u16CCR_SCR() -> u16L)
N#define vSetCCR_SCRH(ParValue) (pst_u16CCR_SCR() -> u16H = (ParValue))
N#define u16GetCCR_SCRH() (pst_u16CCR_SCR() -> u16H)
N            
N/* Word access */
N#define vSetCCR_SCR(ParValue)  (*pu32CCR_SCR() = (ParValue))
N#define u32GetCCR_SCR()  (*pu32CCR_SCR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_INTER                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000040                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_INTER_REG__       0xC0000040U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MODEINTEN	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   	:15; 	 /* 1..15  bit(s) R */
N  uint32_t   ALARMINT0EN	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   ALARMINT1EN	:1; 	 /* 17..17  bit(s) R/W */ 
N  uint32_t   	:14; 	 /* 18..31  bit(s) R */                    
N} CCR_INTER_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_INTER_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_INTER_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_INTER_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_INTER()     ((volatile CCR_INTER_bit_view_st *)\
N(CCR_INTER_REG__ ))
X#define pst_bitCCR_INTER()     ((volatile CCR_INTER_bit_view_st *)(CCR_INTER_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_INTER()     ((volatile CCR_INTER_byte_view_st *)\
N(CCR_INTER_REG__ ))
X#define pst_u8CCR_INTER()     ((volatile CCR_INTER_byte_view_st *)(CCR_INTER_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_INTER()     ((volatile CCR_INTER_halfword_view_st *)\
N(CCR_INTER_REG__ ))
X#define pst_u16CCR_INTER()     ((volatile CCR_INTER_halfword_view_st *)(CCR_INTER_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_INTER()     ((volatile u32CCR_INTER_word_view *)\
N(CCR_INTER_REG__ ))
X#define pu32CCR_INTER()     ((volatile u32CCR_INTER_word_view *)(CCR_INTER_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_INTER_MODEINTEN() (pst_bitCCR_INTER() -> MODEINTEN)
N#define vSetCCR_INTER_MODEINTEN(ParValue)  (pst_bitCCR_INTER() -> MODEINTEN=(ParValue))
N#define biGetCCR_INTER_ALARMINT0EN() (pst_bitCCR_INTER() -> ALARMINT0EN)
N#define vSetCCR_INTER_ALARMINT0EN(ParValue)  (pst_bitCCR_INTER() -> ALARMINT0EN=(ParValue))
N#define biGetCCR_INTER_ALARMINT1EN() (pst_bitCCR_INTER() -> ALARMINT1EN)
N#define vSetCCR_INTER_ALARMINT1EN(ParValue)  (pst_bitCCR_INTER() -> ALARMINT1EN=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_INTERLL(ParValue) (pst_u8CCR_INTER() -> u8LL = (ParValue))
N#define u8GetCCR_INTERLL() (pst_u8CCR_INTER() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_INTERLH(ParValue) (pst_u8CCR_INTER() -> u8LH = (ParValue))
N#define u8GetCCR_INTERLH() (pst_u8CCR_INTER() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_INTERHL(ParValue) (pst_u8CCR_INTER() -> u8HL = (ParValue))
N#define u8GetCCR_INTERHL() (pst_u8CCR_INTER() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_INTERHH(ParValue) (pst_u8CCR_INTER() -> u8HH = (ParValue))
N#define u8GetCCR_INTERHH() (pst_u8CCR_INTER() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_INTERL(ParValue) (pst_u16CCR_INTER() -> u16L = (ParValue))
N#define u16GetCCR_INTERL() (pst_u16CCR_INTER() -> u16L)
N#define vSetCCR_INTERH(ParValue) (pst_u16CCR_INTER() -> u16H = (ParValue))
N#define u16GetCCR_INTERH() (pst_u16CCR_INTER() -> u16H)
N            
N/* Word access */
N#define vSetCCR_INTER(ParValue)  (*pu32CCR_INTER() = (ParValue))
N#define u32GetCCR_INTER()  (*pu32CCR_INTER() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_INTSR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000044                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_INTSR_REG__       0xC0000044U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MODEINT	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   	:15; 	 /* 1..15  bit(s) R */
N  uint32_t   ALARMINT0	:1; 	 /* 16..16  bit(s) R */
N  uint32_t   ALARMINT1	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   	:6; 	 /* 18..23  bit(s) R */
N  uint32_t   BKPRAM_ECCINT	:1; 	 /* 24..24  bit(s) R/W0C */
N  uint32_t   MM_ECCINT	:1; 	 /* 25..25  bit(s) R/W0C */ 
N  uint32_t   	:6; 	 /* 26..31  bit(s) R */                    
N} CCR_INTSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_INTSR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_INTSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_INTSR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_INTSR()     ((volatile CCR_INTSR_bit_view_st *)\
N(CCR_INTSR_REG__ ))
X#define pst_bitCCR_INTSR()     ((volatile CCR_INTSR_bit_view_st *)(CCR_INTSR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_INTSR()     ((volatile CCR_INTSR_byte_view_st *)\
N(CCR_INTSR_REG__ ))
X#define pst_u8CCR_INTSR()     ((volatile CCR_INTSR_byte_view_st *)(CCR_INTSR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_INTSR()     ((volatile CCR_INTSR_halfword_view_st *)\
N(CCR_INTSR_REG__ ))
X#define pst_u16CCR_INTSR()     ((volatile CCR_INTSR_halfword_view_st *)(CCR_INTSR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_INTSR()     ((volatile u32CCR_INTSR_word_view *)\
N(CCR_INTSR_REG__ ))
X#define pu32CCR_INTSR()     ((volatile u32CCR_INTSR_word_view *)(CCR_INTSR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetCCR_INTSR_MODEINT() (pst_bitCCR_INTSR() -> MODEINT)            
N#define biGetCCR_INTSR_ALARMINT0() (pst_bitCCR_INTSR() -> ALARMINT0)            
N#define biGetCCR_INTSR_ALARMINT1() (pst_bitCCR_INTSR() -> ALARMINT1)
N#define biGetCCR_INTSR_BKPRAM_ECCINT() (pst_bitCCR_INTSR() -> BKPRAM_ECCINT)
N#define vClrCCR_INTSR_BKPRAM_ECCINT() (pst_bitCCR_INTSR() -> BKPRAM_ECCINT=(0))
N#define biGetCCR_INTSR_MM_ECCINT() (pst_bitCCR_INTSR() -> MM_ECCINT)
N#define vClrCCR_INTSR_MM_ECCINT() (pst_bitCCR_INTSR() -> MM_ECCINT=(0))
N            
N/* LL-struct byte access */
N#define vSetCCR_INTSRLL(ParValue) (pst_u8CCR_INTSR() -> u8LL = (ParValue))
N#define u8GetCCR_INTSRLL() (pst_u8CCR_INTSR() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_INTSRLH(ParValue) (pst_u8CCR_INTSR() -> u8LH = (ParValue))
N#define u8GetCCR_INTSRLH() (pst_u8CCR_INTSR() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_INTSRHL(ParValue) (pst_u8CCR_INTSR() -> u8HL = (ParValue))
N#define u8GetCCR_INTSRHL() (pst_u8CCR_INTSR() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_INTSRHH(ParValue) (pst_u8CCR_INTSR() -> u8HH = (ParValue))
N#define u8GetCCR_INTSRHH() (pst_u8CCR_INTSR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_INTSRL(ParValue) (pst_u16CCR_INTSR() -> u16L = (ParValue))
N#define u16GetCCR_INTSRL() (pst_u16CCR_INTSR() -> u16L)
N#define vSetCCR_INTSRH(ParValue) (pst_u16CCR_INTSR() -> u16H = (ParValue))
N#define u16GetCCR_INTSRH() (pst_u16CCR_INTSR() -> u16H)
N            
N/* Word access */
N#define vSetCCR_INTSR(ParValue)  (*pu32CCR_INTSR() = (ParValue))
N#define u32GetCCR_INTSR()  (*pu32CCR_INTSR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_INTCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000048                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_INTCR_REG__       0xC0000048U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   MODEINTC	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   	:15; 	 /* 1..15  bit(s) R */
N  uint32_t   ALARMINT0C	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   ALARMINT1C	:1; 	 /* 17..17  bit(s) R/W */ 
N  uint32_t   	:14; 	 /* 18..31  bit(s) R */                    
N} CCR_INTCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_INTCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_INTCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_INTCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_INTCR()     ((volatile CCR_INTCR_bit_view_st *)\
N(CCR_INTCR_REG__ ))
X#define pst_bitCCR_INTCR()     ((volatile CCR_INTCR_bit_view_st *)(CCR_INTCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_INTCR()     ((volatile CCR_INTCR_byte_view_st *)\
N(CCR_INTCR_REG__ ))
X#define pst_u8CCR_INTCR()     ((volatile CCR_INTCR_byte_view_st *)(CCR_INTCR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_INTCR()     ((volatile CCR_INTCR_halfword_view_st *)\
N(CCR_INTCR_REG__ ))
X#define pst_u16CCR_INTCR()     ((volatile CCR_INTCR_halfword_view_st *)(CCR_INTCR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_INTCR()     ((volatile u32CCR_INTCR_word_view *)\
N(CCR_INTCR_REG__ ))
X#define pu32CCR_INTCR()     ((volatile u32CCR_INTCR_word_view *)(CCR_INTCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_INTCR_MODEINTC() (pst_bitCCR_INTCR() -> MODEINTC)
N#define vSetCCR_INTCR_MODEINTC(ParValue)  (pst_bitCCR_INTCR() -> MODEINTC=(ParValue))
N#define biGetCCR_INTCR_ALARMINT0C() (pst_bitCCR_INTCR() -> ALARMINT0C)
N#define vSetCCR_INTCR_ALARMINT0C(ParValue)  (pst_bitCCR_INTCR() -> ALARMINT0C=(ParValue))
N#define biGetCCR_INTCR_ALARMINT1C() (pst_bitCCR_INTCR() -> ALARMINT1C)
N#define vSetCCR_INTCR_ALARMINT1C(ParValue)  (pst_bitCCR_INTCR() -> ALARMINT1C=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_INTCRLL(ParValue) (pst_u8CCR_INTCR() -> u8LL = (ParValue))
N#define u8GetCCR_INTCRLL() (pst_u8CCR_INTCR() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_INTCRLH(ParValue) (pst_u8CCR_INTCR() -> u8LH = (ParValue))
N#define u8GetCCR_INTCRLH() (pst_u8CCR_INTCR() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_INTCRHL(ParValue) (pst_u8CCR_INTCR() -> u8HL = (ParValue))
N#define u8GetCCR_INTCRHL() (pst_u8CCR_INTCR() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_INTCRHH(ParValue) (pst_u8CCR_INTCR() -> u8HH = (ParValue))
N#define u8GetCCR_INTCRHH() (pst_u8CCR_INTCR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_INTCRL(ParValue) (pst_u16CCR_INTCR() -> u16L = (ParValue))
N#define u16GetCCR_INTCRL() (pst_u16CCR_INTCR() -> u16L)
N#define vSetCCR_INTCRH(ParValue) (pst_u16CCR_INTCR() -> u16H = (ParValue))
N#define u16GetCCR_INTCRH() (pst_u16CCR_INTCR() -> u16H)
N            
N/* Word access */
N#define vSetCCR_INTCR(ParValue)  (*pu32CCR_INTCR() = (ParValue))
N#define u32GetCCR_INTCR()  (*pu32CCR_INTCR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_SYSDSR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000004C                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_SYSDSR_REG__       0xC000004CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   MODESTAT	:7; 	 /* 0..6  bit(s) R */ 
N  uint8_t   	:1; 	 /* 7..31  bit(s) R */                    
N} CCR_SYSDSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8CCR_SYSDSR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_SYSDSR()     ((volatile CCR_SYSDSR_bit_view_st *)\
N(CCR_SYSDSR_REG__ ))
X#define pst_bitCCR_SYSDSR()     ((volatile CCR_SYSDSR_bit_view_st *)(CCR_SYSDSR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8CCR_SYSDSR()     ((volatile u8CCR_SYSDSR_byte_view *)\
N(CCR_SYSDSR_REG__ ))
X#define pu8CCR_SYSDSR()     ((volatile u8CCR_SYSDSR_byte_view *)(CCR_SYSDSR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetCCR_SYSDSR_MODESTAT() (pst_bitCCR_SYSDSR() -> MODESTAT)
N            
N/* byte access */
N
N#define u8GetCCR_SYSDSR() (*pu8CCR_SYSDSR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_SSCPLL_CTRL0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000050                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_SSCPLL_CTRL0_REG__       0xC0000050U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   SSCPLL_RESET	:1; 	 /* 0..0  bit(s) R/W */
N  uint8_t   	:3; 	 /* 1..3  bit(s) R */
N  uint8_t   	:1; 	 /* 4..4  bit(s) R */
N  uint8_t   	:1; 	 /* 5..5  bit(s) R */
N  uint8_t   SSCPLL_MODTYPE	:1; 	 /* 6..6  bit(s) R/W */
N  uint8_t   	:1; 	 /* 7..7  bit(s) R */                    
N} CCR_SSCPLL_CTRL0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8CCR_SSCPLL_CTRL0_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_SSCPLL_CTRL0()     ((volatile CCR_SSCPLL_CTRL0_bit_view_st *)\
N(CCR_SSCPLL_CTRL0_REG__ ))
X#define pst_bitCCR_SSCPLL_CTRL0()     ((volatile CCR_SSCPLL_CTRL0_bit_view_st *)(CCR_SSCPLL_CTRL0_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8CCR_SSCPLL_CTRL0()     ((volatile u8CCR_SSCPLL_CTRL0_byte_view *)\
N(CCR_SSCPLL_CTRL0_REG__ ))
X#define pu8CCR_SSCPLL_CTRL0()     ((volatile u8CCR_SSCPLL_CTRL0_byte_view *)(CCR_SSCPLL_CTRL0_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_SSCPLL_CTRL0_SSCPLL_RESET() (pst_bitCCR_SSCPLL_CTRL0() -> SSCPLL_RESET)
N#define vSetCCR_SSCPLL_CTRL0_SSCPLL_RESET(ParValue)  (pst_bitCCR_SSCPLL_CTRL0() -> SSCPLL_RESET=(ParValue))
N#define biGetCCR_SSCPLL_CTRL0_SSCPLL_MODTYPE() (pst_bitCCR_SSCPLL_CTRL0() -> SSCPLL_MODTYPE)
N#define vSetCCR_SSCPLL_CTRL0_SSCPLL_MODTYPE(ParValue)  (pst_bitCCR_SSCPLL_CTRL0() -> SSCPLL_MODTYPE=(ParValue))
N            
N/* byte access */
N#define vSetCCR_SSCPLL_CTRL0(ParValue) (*pu8CCR_SSCPLL_CTRL0() = (ParValue))
N#define u8GetCCR_SSCPLL_CTRL0() (*pu8CCR_SSCPLL_CTRL0() )
N
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_SSCPLL_CTRL2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000058                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_SSCPLL_CTRL2_REG__       0xC0000058U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SSCPLL_FNLEN	:7; 	 /* 0..6  bit(s) R/W */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   	:8; 	 /* 8..15  bit(s) R */ 
N  uint32_t   SSCPLL_DSFT	:16; 	 /* 16..31  bit(s) R/W */                    
N} CCR_SSCPLL_CTRL2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_SSCPLL_CTRL2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_SSCPLL_CTRL2_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_SSCPLL_CTRL2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_SSCPLL_CTRL2()     ((volatile CCR_SSCPLL_CTRL2_bit_view_st *)\
N(CCR_SSCPLL_CTRL2_REG__ ))
X#define pst_bitCCR_SSCPLL_CTRL2()     ((volatile CCR_SSCPLL_CTRL2_bit_view_st *)(CCR_SSCPLL_CTRL2_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_SSCPLL_CTRL2()     ((volatile CCR_SSCPLL_CTRL2_byte_view_st *)\
N(CCR_SSCPLL_CTRL2_REG__ ))
X#define pst_u8CCR_SSCPLL_CTRL2()     ((volatile CCR_SSCPLL_CTRL2_byte_view_st *)(CCR_SSCPLL_CTRL2_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_SSCPLL_CTRL2()     ((volatile CCR_SSCPLL_CTRL2_halfword_view_st *)\
N(CCR_SSCPLL_CTRL2_REG__ ))
X#define pst_u16CCR_SSCPLL_CTRL2()     ((volatile CCR_SSCPLL_CTRL2_halfword_view_st *)(CCR_SSCPLL_CTRL2_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_SSCPLL_CTRL2()     ((volatile u32CCR_SSCPLL_CTRL2_word_view *)\
N(CCR_SSCPLL_CTRL2_REG__ ))
X#define pu32CCR_SSCPLL_CTRL2()     ((volatile u32CCR_SSCPLL_CTRL2_word_view *)(CCR_SSCPLL_CTRL2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_SSCPLL_CTRL2_SSCPLL_FNLEN() (pst_bitCCR_SSCPLL_CTRL2() -> SSCPLL_FNLEN)
N#define vSetCCR_SSCPLL_CTRL2_SSCPLL_FNLEN(ParValue)  (pst_bitCCR_SSCPLL_CTRL2() -> SSCPLL_FNLEN=(ParValue))
N#define biGetCCR_SSCPLL_CTRL2_SSCPLL_DSFT() (pst_bitCCR_SSCPLL_CTRL2() -> SSCPLL_DSFT)
N#define vSetCCR_SSCPLL_CTRL2_SSCPLL_DSFT(ParValue)  (pst_bitCCR_SSCPLL_CTRL2() -> SSCPLL_DSFT=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_SSCPLL_CTRL2LL(ParValue) (pst_u8CCR_SSCPLL_CTRL2() -> u8LL = (ParValue))
N#define u8GetCCR_SSCPLL_CTRL2LL() (pst_u8CCR_SSCPLL_CTRL2() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_SSCPLL_CTRL2LH(ParValue) (pst_u8CCR_SSCPLL_CTRL2() -> u8LH = (ParValue))
N#define u8GetCCR_SSCPLL_CTRL2LH() (pst_u8CCR_SSCPLL_CTRL2() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_SSCPLL_CTRL2HL(ParValue) (pst_u8CCR_SSCPLL_CTRL2() -> u8HL = (ParValue))
N#define u8GetCCR_SSCPLL_CTRL2HL() (pst_u8CCR_SSCPLL_CTRL2() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_SSCPLL_CTRL2HH(ParValue) (pst_u8CCR_SSCPLL_CTRL2() -> u8HH = (ParValue))
N#define u8GetCCR_SSCPLL_CTRL2HH() (pst_u8CCR_SSCPLL_CTRL2() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_SSCPLL_CTRL2L(ParValue) (pst_u16CCR_SSCPLL_CTRL2() -> u16L = (ParValue))
N#define u16GetCCR_SSCPLL_CTRL2L() (pst_u16CCR_SSCPLL_CTRL2() -> u16L)
N#define vSetCCR_SSCPLL_CTRL2H(ParValue) (pst_u16CCR_SSCPLL_CTRL2() -> u16H = (ParValue))
N#define u16GetCCR_SSCPLL_CTRL2H() (pst_u16CCR_SSCPLL_CTRL2() -> u16H)
N            
N/* Word access */
N#define vSetCCR_SSCPLL_CTRL2(ParValue)  (*pu32CCR_SSCPLL_CTRL2() = (ParValue))
N#define u32GetCCR_SSCPLL_CTRL2()  (*pu32CCR_SSCPLL_CTRL2() )
N
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERIC_REG0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000064                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERIC_REG0_REG__       0xC0000064U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ALMWDT_RST_NMI	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   BEINJB	:1; 	 /* 1..1  bit(s) R/W */
N  uint32_t   BEPAB	:6; 	 /* 2..7  bit(s) R/W */
N  uint32_t   BEPBB	:6; 	 /* 8..13  bit(s) R/W */
N  uint32_t   	:2; 	 /* 14..15  bit(s) R */
N  uint32_t   QSPIC0_ADDRMODE	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   QSPIC1_ADDRMODE	:1; 	 /* 17..17  bit(s) R/W */ 
N  uint32_t   	:14; 	 /* 18..31  bit(s) R */                    
N} CCR_GENERIC_REG0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERIC_REG0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERIC_REG0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERIC_REG0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERIC_REG0()     ((volatile CCR_GENERIC_REG0_bit_view_st *)\
N(CCR_GENERIC_REG0_REG__ ))
X#define pst_bitCCR_GENERIC_REG0()     ((volatile CCR_GENERIC_REG0_bit_view_st *)(CCR_GENERIC_REG0_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERIC_REG0()     ((volatile CCR_GENERIC_REG0_byte_view_st *)\
N(CCR_GENERIC_REG0_REG__ ))
X#define pst_u8CCR_GENERIC_REG0()     ((volatile CCR_GENERIC_REG0_byte_view_st *)(CCR_GENERIC_REG0_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERIC_REG0()     ((volatile CCR_GENERIC_REG0_halfword_view_st *)\
N(CCR_GENERIC_REG0_REG__ ))
X#define pst_u16CCR_GENERIC_REG0()     ((volatile CCR_GENERIC_REG0_halfword_view_st *)(CCR_GENERIC_REG0_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERIC_REG0()     ((volatile u32CCR_GENERIC_REG0_word_view *)\
N(CCR_GENERIC_REG0_REG__ ))
X#define pu32CCR_GENERIC_REG0()     ((volatile u32CCR_GENERIC_REG0_word_view *)(CCR_GENERIC_REG0_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERIC_REG0_ALMWDT_RST_NMI() (pst_bitCCR_GENERIC_REG0() -> ALMWDT_RST_NMI)
N#define vSetCCR_GENERIC_REG0_ALMWDT_RST_NMI(ParValue)  (pst_bitCCR_GENERIC_REG0() -> ALMWDT_RST_NMI=(ParValue))
N#define biGetCCR_GENERIC_REG0_BEINJB() (pst_bitCCR_GENERIC_REG0() -> BEINJB)
N#define vSetCCR_GENERIC_REG0_BEINJB(ParValue)  (pst_bitCCR_GENERIC_REG0() -> BEINJB=(ParValue))
N#define biGetCCR_GENERIC_REG0_BEPAB() (pst_bitCCR_GENERIC_REG0() -> BEPAB)
N#define vSetCCR_GENERIC_REG0_BEPAB(ParValue)  (pst_bitCCR_GENERIC_REG0() -> BEPAB=(ParValue))
N#define biGetCCR_GENERIC_REG0_BEPBB() (pst_bitCCR_GENERIC_REG0() -> BEPBB)
N#define vSetCCR_GENERIC_REG0_BEPBB(ParValue)  (pst_bitCCR_GENERIC_REG0() -> BEPBB=(ParValue))
N#define biGetCCR_GENERIC_REG0_QSPIC0_ADDRMODE() (pst_bitCCR_GENERIC_REG0() -> QSPIC0_ADDRMODE)
N#define vSetCCR_GENERIC_REG0_QSPIC0_ADDRMODE(ParValue)  (pst_bitCCR_GENERIC_REG0() -> QSPIC0_ADDRMODE=(ParValue))
N#define biGetCCR_GENERIC_REG0_QSPIC1_ADDRMODE() (pst_bitCCR_GENERIC_REG0() -> QSPIC1_ADDRMODE)
N#define vSetCCR_GENERIC_REG0_QSPIC1_ADDRMODE(ParValue)  (pst_bitCCR_GENERIC_REG0() -> QSPIC1_ADDRMODE=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERIC_REG0LL(ParValue) (pst_u8CCR_GENERIC_REG0() -> u8LL = (ParValue))
N#define u8GetCCR_GENERIC_REG0LL() (pst_u8CCR_GENERIC_REG0() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERIC_REG0LH(ParValue) (pst_u8CCR_GENERIC_REG0() -> u8LH = (ParValue))
N#define u8GetCCR_GENERIC_REG0LH() (pst_u8CCR_GENERIC_REG0() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERIC_REG0HL(ParValue) (pst_u8CCR_GENERIC_REG0() -> u8HL = (ParValue))
N#define u8GetCCR_GENERIC_REG0HL() (pst_u8CCR_GENERIC_REG0() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERIC_REG0HH(ParValue) (pst_u8CCR_GENERIC_REG0() -> u8HH = (ParValue))
N#define u8GetCCR_GENERIC_REG0HH() (pst_u8CCR_GENERIC_REG0() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERIC_REG0L(ParValue) (pst_u16CCR_GENERIC_REG0() -> u16L = (ParValue))
N#define u16GetCCR_GENERIC_REG0L() (pst_u16CCR_GENERIC_REG0() -> u16L)
N#define vSetCCR_GENERIC_REG0H(ParValue) (pst_u16CCR_GENERIC_REG0() -> u16H = (ParValue))
N#define u16GetCCR_GENERIC_REG0H() (pst_u16CCR_GENERIC_REG0() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERIC_REG0(ParValue)  (*pu32CCR_GENERIC_REG0() = (ParValue))
N#define u32GetCCR_GENERIC_REG0()  (*pu32CCR_GENERIC_REG0() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERIC_REG1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000068                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERIC_REG1_REG__       0xC0000068U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   CANMODE	:4; 	 /* 0..3  bit(s) R/W */
N  uint32_t   ECCM	:2; 	 /* 4..5  bit(s) R/W */
N  uint32_t   	:2; 	 /* 6..7  bit(s) R */
N  uint32_t   TBIO0_DIR	:1; 	 /* 8..8  bit(s) R/W */
N  uint32_t   TBIO1_DIR	:1; 	 /* 9..9  bit(s) R/W */
N  uint32_t   TBIO2_DIR	:1; 	 /* 10..10  bit(s) R/W */
N  uint32_t   TBIO3_DIR	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   TBIO6_DIR	:1; 	 /* 12..12  bit(s) R/W */
N  uint32_t   TBIO7_DIR	:1; 	 /* 13..13  bit(s) R/W */
N  uint32_t   TBIO8_DIR	:1; 	 /* 14..14  bit(s) R/W */
N  uint32_t   TBIO9_SEL	:1; 	 /* 15..15  bit(s) R/W */
N  uint32_t   TBIN4_SEL	:4; 	 /* 16..19  bit(s) R/W */
N  uint32_t   TBIN5_SEL	:4; 	 /* 20..23  bit(s) R/W */
N  uint32_t   DISP0ON	:1; 	 /* 24..24  bit(s) R/W */
N  uint32_t   DISP1ON	:1; 	 /* 25..25  bit(s) R/W */
N  uint32_t   PNLON	:1; 	 /* 26..26  bit(s) R/W */
N  uint32_t   S0EXTS1	:1; 	 /* 27..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_GENERIC_REG1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERIC_REG1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERIC_REG1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERIC_REG1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERIC_REG1()     ((volatile CCR_GENERIC_REG1_bit_view_st *)\
N(CCR_GENERIC_REG1_REG__ ))
X#define pst_bitCCR_GENERIC_REG1()     ((volatile CCR_GENERIC_REG1_bit_view_st *)(CCR_GENERIC_REG1_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERIC_REG1()     ((volatile CCR_GENERIC_REG1_byte_view_st *)\
N(CCR_GENERIC_REG1_REG__ ))
X#define pst_u8CCR_GENERIC_REG1()     ((volatile CCR_GENERIC_REG1_byte_view_st *)(CCR_GENERIC_REG1_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERIC_REG1()     ((volatile CCR_GENERIC_REG1_halfword_view_st *)\
N(CCR_GENERIC_REG1_REG__ ))
X#define pst_u16CCR_GENERIC_REG1()     ((volatile CCR_GENERIC_REG1_halfword_view_st *)(CCR_GENERIC_REG1_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERIC_REG1()     ((volatile u32CCR_GENERIC_REG1_word_view *)\
N(CCR_GENERIC_REG1_REG__ ))
X#define pu32CCR_GENERIC_REG1()     ((volatile u32CCR_GENERIC_REG1_word_view *)(CCR_GENERIC_REG1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERIC_REG1_CANMODE() (pst_bitCCR_GENERIC_REG1() -> CANMODE)
N#define vSetCCR_GENERIC_REG1_CANMODE(ParValue)  (pst_bitCCR_GENERIC_REG1() -> CANMODE=(ParValue))
N#define biGetCCR_GENERIC_REG1_ECCM() (pst_bitCCR_GENERIC_REG1() -> ECCM)
N#define vSetCCR_GENERIC_REG1_ECCM(ParValue)  (pst_bitCCR_GENERIC_REG1() -> ECCM=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO0_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO0_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO0_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO0_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO1_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO1_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO1_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO1_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO2_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO2_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO2_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO2_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO3_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO3_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO3_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO3_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO6_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO6_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO6_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO6_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO7_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO7_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO7_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO7_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO8_DIR() (pst_bitCCR_GENERIC_REG1() -> TBIO8_DIR)
N#define vSetCCR_GENERIC_REG1_TBIO8_DIR(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO8_DIR=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIO9_SEL() (pst_bitCCR_GENERIC_REG1() -> TBIO9_SEL)
N#define vSetCCR_GENERIC_REG1_TBIO9_SEL(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIO9_SEL=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIN4_SEL() (pst_bitCCR_GENERIC_REG1() -> TBIN4_SEL)
N#define vSetCCR_GENERIC_REG1_TBIN4_SEL(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIN4_SEL=(ParValue))
N#define biGetCCR_GENERIC_REG1_TBIN5_SEL() (pst_bitCCR_GENERIC_REG1() -> TBIN5_SEL)
N#define vSetCCR_GENERIC_REG1_TBIN5_SEL(ParValue)  (pst_bitCCR_GENERIC_REG1() -> TBIN5_SEL=(ParValue))
N#define biGetCCR_GENERIC_REG1_DISP0ON() (pst_bitCCR_GENERIC_REG1() -> DISP0ON)
N#define vSetCCR_GENERIC_REG1_DISP0ON(ParValue)  (pst_bitCCR_GENERIC_REG1() -> DISP0ON=(ParValue))
N#define biGetCCR_GENERIC_REG1_DISP1ON() (pst_bitCCR_GENERIC_REG1() -> DISP1ON)
N#define vSetCCR_GENERIC_REG1_DISP1ON(ParValue)  (pst_bitCCR_GENERIC_REG1() -> DISP1ON=(ParValue))
N#define biGetCCR_GENERIC_REG1_PNLON() (pst_bitCCR_GENERIC_REG1() -> PNLON)
N#define vSetCCR_GENERIC_REG1_PNLON(ParValue)  (pst_bitCCR_GENERIC_REG1() -> PNLON=(ParValue))
N#define biGetCCR_GENERIC_REG1_S0EXTS1() (pst_bitCCR_GENERIC_REG1() -> S0EXTS1)
N#define vSetCCR_GENERIC_REG1_S0EXTS1(ParValue)  (pst_bitCCR_GENERIC_REG1() -> S0EXTS1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERIC_REG1LL(ParValue) (pst_u8CCR_GENERIC_REG1() -> u8LL = (ParValue))
N#define u8GetCCR_GENERIC_REG1LL() (pst_u8CCR_GENERIC_REG1() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERIC_REG1LH(ParValue) (pst_u8CCR_GENERIC_REG1() -> u8LH = (ParValue))
N#define u8GetCCR_GENERIC_REG1LH() (pst_u8CCR_GENERIC_REG1() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERIC_REG1HL(ParValue) (pst_u8CCR_GENERIC_REG1() -> u8HL = (ParValue))
N#define u8GetCCR_GENERIC_REG1HL() (pst_u8CCR_GENERIC_REG1() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERIC_REG1HH(ParValue) (pst_u8CCR_GENERIC_REG1() -> u8HH = (ParValue))
N#define u8GetCCR_GENERIC_REG1HH() (pst_u8CCR_GENERIC_REG1() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERIC_REG1L(ParValue) (pst_u16CCR_GENERIC_REG1() -> u16L = (ParValue))
N#define u16GetCCR_GENERIC_REG1L() (pst_u16CCR_GENERIC_REG1() -> u16L)
N#define vSetCCR_GENERIC_REG1H(ParValue) (pst_u16CCR_GENERIC_REG1() -> u16H = (ParValue))
N#define u16GetCCR_GENERIC_REG1H() (pst_u16CCR_GENERIC_REG1() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERIC_REG1(ParValue)  (*pu32CCR_GENERIC_REG1() = (ParValue))
N#define u32GetCCR_GENERIC_REG1()  (*pu32CCR_GENERIC_REG1() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERIC_REG2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000006C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERIC_REG2_REG__       0xC000006CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ADDR_MASK0_0	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   ADDR_MATCH0_0	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   ADDR_MASK0_1	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   ADDR_MATCH0_1	:8; 	 /* 24..31  bit(s) R/W */                    
N} CCR_GENERIC_REG2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERIC_REG2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERIC_REG2_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERIC_REG2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERIC_REG2()     ((volatile CCR_GENERIC_REG2_bit_view_st *)\
N(CCR_GENERIC_REG2_REG__ ))
X#define pst_bitCCR_GENERIC_REG2()     ((volatile CCR_GENERIC_REG2_bit_view_st *)(CCR_GENERIC_REG2_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERIC_REG2()     ((volatile CCR_GENERIC_REG2_byte_view_st *)\
N(CCR_GENERIC_REG2_REG__ ))
X#define pst_u8CCR_GENERIC_REG2()     ((volatile CCR_GENERIC_REG2_byte_view_st *)(CCR_GENERIC_REG2_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERIC_REG2()     ((volatile CCR_GENERIC_REG2_halfword_view_st *)\
N(CCR_GENERIC_REG2_REG__ ))
X#define pst_u16CCR_GENERIC_REG2()     ((volatile CCR_GENERIC_REG2_halfword_view_st *)(CCR_GENERIC_REG2_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERIC_REG2()     ((volatile u32CCR_GENERIC_REG2_word_view *)\
N(CCR_GENERIC_REG2_REG__ ))
X#define pu32CCR_GENERIC_REG2()     ((volatile u32CCR_GENERIC_REG2_word_view *)(CCR_GENERIC_REG2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERIC_REG2_ADDR_MASK0_0() (pst_bitCCR_GENERIC_REG2() -> ADDR_MASK0_0)
N#define vSetCCR_GENERIC_REG2_ADDR_MASK0_0(ParValue)  (pst_bitCCR_GENERIC_REG2() -> ADDR_MASK0_0=(ParValue))
N#define biGetCCR_GENERIC_REG2_ADDR_MATCH0_0() (pst_bitCCR_GENERIC_REG2() -> ADDR_MATCH0_0)
N#define vSetCCR_GENERIC_REG2_ADDR_MATCH0_0(ParValue)  (pst_bitCCR_GENERIC_REG2() -> ADDR_MATCH0_0=(ParValue))
N#define biGetCCR_GENERIC_REG2_ADDR_MASK0_1() (pst_bitCCR_GENERIC_REG2() -> ADDR_MASK0_1)
N#define vSetCCR_GENERIC_REG2_ADDR_MASK0_1(ParValue)  (pst_bitCCR_GENERIC_REG2() -> ADDR_MASK0_1=(ParValue))
N#define biGetCCR_GENERIC_REG2_ADDR_MATCH0_1() (pst_bitCCR_GENERIC_REG2() -> ADDR_MATCH0_1)
N#define vSetCCR_GENERIC_REG2_ADDR_MATCH0_1(ParValue)  (pst_bitCCR_GENERIC_REG2() -> ADDR_MATCH0_1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERIC_REG2LL(ParValue) (pst_u8CCR_GENERIC_REG2() -> u8LL = (ParValue))
N#define u8GetCCR_GENERIC_REG2LL() (pst_u8CCR_GENERIC_REG2() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERIC_REG2LH(ParValue) (pst_u8CCR_GENERIC_REG2() -> u8LH = (ParValue))
N#define u8GetCCR_GENERIC_REG2LH() (pst_u8CCR_GENERIC_REG2() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERIC_REG2HL(ParValue) (pst_u8CCR_GENERIC_REG2() -> u8HL = (ParValue))
N#define u8GetCCR_GENERIC_REG2HL() (pst_u8CCR_GENERIC_REG2() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERIC_REG2HH(ParValue) (pst_u8CCR_GENERIC_REG2() -> u8HH = (ParValue))
N#define u8GetCCR_GENERIC_REG2HH() (pst_u8CCR_GENERIC_REG2() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERIC_REG2L(ParValue) (pst_u16CCR_GENERIC_REG2() -> u16L = (ParValue))
N#define u16GetCCR_GENERIC_REG2L() (pst_u16CCR_GENERIC_REG2() -> u16L)
N#define vSetCCR_GENERIC_REG2H(ParValue) (pst_u16CCR_GENERIC_REG2() -> u16H = (ParValue))
N#define u16GetCCR_GENERIC_REG2H() (pst_u16CCR_GENERIC_REG2() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERIC_REG2(ParValue)  (*pu32CCR_GENERIC_REG2() = (ParValue))
N#define u32GetCCR_GENERIC_REG2()  (*pu32CCR_GENERIC_REG2() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERIC_REG3                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000070                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERIC_REG3_REG__       0xC0000070U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ADDR_MASK1_0	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   ADDR_MATCH1_0	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   ADDR_MASK1_1	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   ADDR_MATCH1_1	:8; 	 /* 24..31  bit(s) R/W */                    
N} CCR_GENERIC_REG3_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERIC_REG3_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERIC_REG3_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERIC_REG3_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERIC_REG3()     ((volatile CCR_GENERIC_REG3_bit_view_st *)\
N(CCR_GENERIC_REG3_REG__ ))
X#define pst_bitCCR_GENERIC_REG3()     ((volatile CCR_GENERIC_REG3_bit_view_st *)(CCR_GENERIC_REG3_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERIC_REG3()     ((volatile CCR_GENERIC_REG3_byte_view_st *)\
N(CCR_GENERIC_REG3_REG__ ))
X#define pst_u8CCR_GENERIC_REG3()     ((volatile CCR_GENERIC_REG3_byte_view_st *)(CCR_GENERIC_REG3_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERIC_REG3()     ((volatile CCR_GENERIC_REG3_halfword_view_st *)\
N(CCR_GENERIC_REG3_REG__ ))
X#define pst_u16CCR_GENERIC_REG3()     ((volatile CCR_GENERIC_REG3_halfword_view_st *)(CCR_GENERIC_REG3_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERIC_REG3()     ((volatile u32CCR_GENERIC_REG3_word_view *)\
N(CCR_GENERIC_REG3_REG__ ))
X#define pu32CCR_GENERIC_REG3()     ((volatile u32CCR_GENERIC_REG3_word_view *)(CCR_GENERIC_REG3_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERIC_REG3_ADDR_MASK1_0() (pst_bitCCR_GENERIC_REG3() -> ADDR_MASK1_0)
N#define vSetCCR_GENERIC_REG3_ADDR_MASK1_0(ParValue)  (pst_bitCCR_GENERIC_REG3() -> ADDR_MASK1_0=(ParValue))
N#define biGetCCR_GENERIC_REG3_ADDR_MATCH1_0() (pst_bitCCR_GENERIC_REG3() -> ADDR_MATCH1_0)
N#define vSetCCR_GENERIC_REG3_ADDR_MATCH1_0(ParValue)  (pst_bitCCR_GENERIC_REG3() -> ADDR_MATCH1_0=(ParValue))
N#define biGetCCR_GENERIC_REG3_ADDR_MASK1_1() (pst_bitCCR_GENERIC_REG3() -> ADDR_MASK1_1)
N#define vSetCCR_GENERIC_REG3_ADDR_MASK1_1(ParValue)  (pst_bitCCR_GENERIC_REG3() -> ADDR_MASK1_1=(ParValue))
N#define biGetCCR_GENERIC_REG3_ADDR_MATCH1_1() (pst_bitCCR_GENERIC_REG3() -> ADDR_MATCH1_1)
N#define vSetCCR_GENERIC_REG3_ADDR_MATCH1_1(ParValue)  (pst_bitCCR_GENERIC_REG3() -> ADDR_MATCH1_1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERIC_REG3LL(ParValue) (pst_u8CCR_GENERIC_REG3() -> u8LL = (ParValue))
N#define u8GetCCR_GENERIC_REG3LL() (pst_u8CCR_GENERIC_REG3() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERIC_REG3LH(ParValue) (pst_u8CCR_GENERIC_REG3() -> u8LH = (ParValue))
N#define u8GetCCR_GENERIC_REG3LH() (pst_u8CCR_GENERIC_REG3() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERIC_REG3HL(ParValue) (pst_u8CCR_GENERIC_REG3() -> u8HL = (ParValue))
N#define u8GetCCR_GENERIC_REG3HL() (pst_u8CCR_GENERIC_REG3() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERIC_REG3HH(ParValue) (pst_u8CCR_GENERIC_REG3() -> u8HH = (ParValue))
N#define u8GetCCR_GENERIC_REG3HH() (pst_u8CCR_GENERIC_REG3() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERIC_REG3L(ParValue) (pst_u16CCR_GENERIC_REG3() -> u16L = (ParValue))
N#define u16GetCCR_GENERIC_REG3L() (pst_u16CCR_GENERIC_REG3() -> u16L)
N#define vSetCCR_GENERIC_REG3H(ParValue) (pst_u16CCR_GENERIC_REG3() -> u16H = (ParValue))
N#define u16GetCCR_GENERIC_REG3H() (pst_u16CCR_GENERIC_REG3() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERIC_REG3(ParValue)  (*pu32CCR_GENERIC_REG3() = (ParValue))
N#define u32GetCCR_GENERIC_REG3()  (*pu32CCR_GENERIC_REG3() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERIC_REG4                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000074                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERIC_REG4_REG__       0xC0000074U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   BEINJ0	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   BEPA0	:4; 	 /* 1..4  bit(s) R/W */
N  uint32_t   BEPB0	:4; 	 /* 5..8  bit(s) R/W */
N  uint32_t   BEBSEL0	:3; 	 /* 9..11  bit(s) R/W */
N  uint32_t   	:4; 	 /* 12..15  bit(s) R */
N  uint32_t   BEINJ1	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   BEPA1	:4; 	 /* 17..20  bit(s) R/W */
N  uint32_t   BEPB1	:4; 	 /* 21..24  bit(s) R/W */
N  uint32_t   BEBSEL1	:3; 	 /* 25..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_GENERIC_REG4_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERIC_REG4_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERIC_REG4_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERIC_REG4_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERIC_REG4()     ((volatile CCR_GENERIC_REG4_bit_view_st *)\
N(CCR_GENERIC_REG4_REG__ ))
X#define pst_bitCCR_GENERIC_REG4()     ((volatile CCR_GENERIC_REG4_bit_view_st *)(CCR_GENERIC_REG4_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERIC_REG4()     ((volatile CCR_GENERIC_REG4_byte_view_st *)\
N(CCR_GENERIC_REG4_REG__ ))
X#define pst_u8CCR_GENERIC_REG4()     ((volatile CCR_GENERIC_REG4_byte_view_st *)(CCR_GENERIC_REG4_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERIC_REG4()     ((volatile CCR_GENERIC_REG4_halfword_view_st *)\
N(CCR_GENERIC_REG4_REG__ ))
X#define pst_u16CCR_GENERIC_REG4()     ((volatile CCR_GENERIC_REG4_halfword_view_st *)(CCR_GENERIC_REG4_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERIC_REG4()     ((volatile u32CCR_GENERIC_REG4_word_view *)\
N(CCR_GENERIC_REG4_REG__ ))
X#define pu32CCR_GENERIC_REG4()     ((volatile u32CCR_GENERIC_REG4_word_view *)(CCR_GENERIC_REG4_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERIC_REG4_BEINJ0() (pst_bitCCR_GENERIC_REG4() -> BEINJ0)
N#define vSetCCR_GENERIC_REG4_BEINJ0(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEINJ0=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEPA0() (pst_bitCCR_GENERIC_REG4() -> BEPA0)
N#define vSetCCR_GENERIC_REG4_BEPA0(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEPA0=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEPB0() (pst_bitCCR_GENERIC_REG4() -> BEPB0)
N#define vSetCCR_GENERIC_REG4_BEPB0(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEPB0=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEBSEL0() (pst_bitCCR_GENERIC_REG4() -> BEBSEL0)
N#define vSetCCR_GENERIC_REG4_BEBSEL0(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEBSEL0=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEINJ1() (pst_bitCCR_GENERIC_REG4() -> BEINJ1)
N#define vSetCCR_GENERIC_REG4_BEINJ1(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEINJ1=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEPA1() (pst_bitCCR_GENERIC_REG4() -> BEPA1)
N#define vSetCCR_GENERIC_REG4_BEPA1(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEPA1=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEPB1() (pst_bitCCR_GENERIC_REG4() -> BEPB1)
N#define vSetCCR_GENERIC_REG4_BEPB1(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEPB1=(ParValue))
N#define biGetCCR_GENERIC_REG4_BEBSEL1() (pst_bitCCR_GENERIC_REG4() -> BEBSEL1)
N#define vSetCCR_GENERIC_REG4_BEBSEL1(ParValue)  (pst_bitCCR_GENERIC_REG4() -> BEBSEL1=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERIC_REG4LL(ParValue) (pst_u8CCR_GENERIC_REG4() -> u8LL = (ParValue))
N#define u8GetCCR_GENERIC_REG4LL() (pst_u8CCR_GENERIC_REG4() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERIC_REG4LH(ParValue) (pst_u8CCR_GENERIC_REG4() -> u8LH = (ParValue))
N#define u8GetCCR_GENERIC_REG4LH() (pst_u8CCR_GENERIC_REG4() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERIC_REG4HL(ParValue) (pst_u8CCR_GENERIC_REG4() -> u8HL = (ParValue))
N#define u8GetCCR_GENERIC_REG4HL() (pst_u8CCR_GENERIC_REG4() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERIC_REG4HH(ParValue) (pst_u8CCR_GENERIC_REG4() -> u8HH = (ParValue))
N#define u8GetCCR_GENERIC_REG4HH() (pst_u8CCR_GENERIC_REG4() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERIC_REG4L(ParValue) (pst_u16CCR_GENERIC_REG4() -> u16L = (ParValue))
N#define u16GetCCR_GENERIC_REG4L() (pst_u16CCR_GENERIC_REG4() -> u16L)
N#define vSetCCR_GENERIC_REG4H(ParValue) (pst_u16CCR_GENERIC_REG4() -> u16H = (ParValue))
N#define u16GetCCR_GENERIC_REG4H() (pst_u16CCR_GENERIC_REG4() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERIC_REG4(ParValue)  (*pu32CCR_GENERIC_REG4() = (ParValue))
N#define u32GetCCR_GENERIC_REG4()  (*pu32CCR_GENERIC_REG4() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERIC_REG5                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000078                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERIC_REG5_REG__       0xC0000078U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   BEINJ2	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   BEPA2	:4; 	 /* 1..4  bit(s) R/W */
N  uint32_t   BEPB2	:4; 	 /* 5..8  bit(s) R/W */
N  uint32_t   BEBSEL2	:3; 	 /* 9..11  bit(s) R/W */
N  uint32_t   	:4; 	 /* 12..15  bit(s) R */
N  uint32_t   BEINJ3	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   BEPA3	:4; 	 /* 17..20  bit(s) R/W */
N  uint32_t   BEPB3	:4; 	 /* 21..24  bit(s) R/W */
N  uint32_t   BEBSEL3	:3; 	 /* 25..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_GENERIC_REG5_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERIC_REG5_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERIC_REG5_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERIC_REG5_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERIC_REG5()     ((volatile CCR_GENERIC_REG5_bit_view_st *)\
N(CCR_GENERIC_REG5_REG__ ))
X#define pst_bitCCR_GENERIC_REG5()     ((volatile CCR_GENERIC_REG5_bit_view_st *)(CCR_GENERIC_REG5_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERIC_REG5()     ((volatile CCR_GENERIC_REG5_byte_view_st *)\
N(CCR_GENERIC_REG5_REG__ ))
X#define pst_u8CCR_GENERIC_REG5()     ((volatile CCR_GENERIC_REG5_byte_view_st *)(CCR_GENERIC_REG5_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERIC_REG5()     ((volatile CCR_GENERIC_REG5_halfword_view_st *)\
N(CCR_GENERIC_REG5_REG__ ))
X#define pst_u16CCR_GENERIC_REG5()     ((volatile CCR_GENERIC_REG5_halfword_view_st *)(CCR_GENERIC_REG5_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERIC_REG5()     ((volatile u32CCR_GENERIC_REG5_word_view *)\
N(CCR_GENERIC_REG5_REG__ ))
X#define pu32CCR_GENERIC_REG5()     ((volatile u32CCR_GENERIC_REG5_word_view *)(CCR_GENERIC_REG5_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERIC_REG5_BEINJ2() (pst_bitCCR_GENERIC_REG5() -> BEINJ2)
N#define vSetCCR_GENERIC_REG5_BEINJ2(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEINJ2=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEPA2() (pst_bitCCR_GENERIC_REG5() -> BEPA2)
N#define vSetCCR_GENERIC_REG5_BEPA2(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEPA2=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEPB2() (pst_bitCCR_GENERIC_REG5() -> BEPB2)
N#define vSetCCR_GENERIC_REG5_BEPB2(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEPB2=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEBSEL2() (pst_bitCCR_GENERIC_REG5() -> BEBSEL2)
N#define vSetCCR_GENERIC_REG5_BEBSEL2(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEBSEL2=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEINJ3() (pst_bitCCR_GENERIC_REG5() -> BEINJ3)
N#define vSetCCR_GENERIC_REG5_BEINJ3(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEINJ3=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEPA3() (pst_bitCCR_GENERIC_REG5() -> BEPA3)
N#define vSetCCR_GENERIC_REG5_BEPA3(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEPA3=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEPB3() (pst_bitCCR_GENERIC_REG5() -> BEPB3)
N#define vSetCCR_GENERIC_REG5_BEPB3(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEPB3=(ParValue))
N#define biGetCCR_GENERIC_REG5_BEBSEL3() (pst_bitCCR_GENERIC_REG5() -> BEBSEL3)
N#define vSetCCR_GENERIC_REG5_BEBSEL3(ParValue)  (pst_bitCCR_GENERIC_REG5() -> BEBSEL3=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERIC_REG5LL(ParValue) (pst_u8CCR_GENERIC_REG5() -> u8LL = (ParValue))
N#define u8GetCCR_GENERIC_REG5LL() (pst_u8CCR_GENERIC_REG5() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERIC_REG5LH(ParValue) (pst_u8CCR_GENERIC_REG5() -> u8LH = (ParValue))
N#define u8GetCCR_GENERIC_REG5LH() (pst_u8CCR_GENERIC_REG5() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERIC_REG5HL(ParValue) (pst_u8CCR_GENERIC_REG5() -> u8HL = (ParValue))
N#define u8GetCCR_GENERIC_REG5HL() (pst_u8CCR_GENERIC_REG5() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERIC_REG5HH(ParValue) (pst_u8CCR_GENERIC_REG5() -> u8HH = (ParValue))
N#define u8GetCCR_GENERIC_REG5HH() (pst_u8CCR_GENERIC_REG5() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERIC_REG5L(ParValue) (pst_u16CCR_GENERIC_REG5() -> u16L = (ParValue))
N#define u16GetCCR_GENERIC_REG5L() (pst_u16CCR_GENERIC_REG5() -> u16L)
N#define vSetCCR_GENERIC_REG5H(ParValue) (pst_u16CCR_GENERIC_REG5() -> u16H = (ParValue))
N#define u16GetCCR_GENERIC_REG5H() (pst_u16CCR_GENERIC_REG5() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERIC_REG5(ParValue)  (*pu32CCR_GENERIC_REG5() = (ParValue))
N#define u32GetCCR_GENERIC_REG5()  (*pu32CCR_GENERIC_REG5() )
N
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERICAC_REG0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000084                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERICAC_REG0_REG__       0xC0000084U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WDT_ALMCLR	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   ECCECLRB	:1; 	 /* 1..1  bit(s) R/W */
N  uint32_t   ECCWCLRB	:1; 	 /* 2..2  bit(s) R/W */
N  uint32_t   	:5; 	 /* 3..7  bit(s) R */
N  uint32_t   ECCECLRS	:4; 	 /* 8..11  bit(s) R/W */
N  uint32_t   ECCWCLRS	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   CPXTSYN_PM	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   CPXTSYN_PNM	:1; 	 /* 17..17  bit(s) R/W */ 
N  uint32_t   	:14; 	 /* 18..31  bit(s) R */                    
N} CCR_GENERICAC_REG0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERICAC_REG0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERICAC_REG0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERICAC_REG0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERICAC_REG0()     ((volatile CCR_GENERICAC_REG0_bit_view_st *)\
N(CCR_GENERICAC_REG0_REG__ ))
X#define pst_bitCCR_GENERICAC_REG0()     ((volatile CCR_GENERICAC_REG0_bit_view_st *)(CCR_GENERICAC_REG0_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERICAC_REG0()     ((volatile CCR_GENERICAC_REG0_byte_view_st *)\
N(CCR_GENERICAC_REG0_REG__ ))
X#define pst_u8CCR_GENERICAC_REG0()     ((volatile CCR_GENERICAC_REG0_byte_view_st *)(CCR_GENERICAC_REG0_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERICAC_REG0()     ((volatile CCR_GENERICAC_REG0_halfword_view_st *)\
N(CCR_GENERICAC_REG0_REG__ ))
X#define pst_u16CCR_GENERICAC_REG0()     ((volatile CCR_GENERICAC_REG0_halfword_view_st *)(CCR_GENERICAC_REG0_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERICAC_REG0()     ((volatile u32CCR_GENERICAC_REG0_word_view *)\
N(CCR_GENERICAC_REG0_REG__ ))
X#define pu32CCR_GENERICAC_REG0()     ((volatile u32CCR_GENERICAC_REG0_word_view *)(CCR_GENERICAC_REG0_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetCCR_GENERICAC_REG0_WDT_ALMCLR() (pst_bitCCR_GENERICAC_REG0() -> WDT_ALMCLR)
N#define vSetCCR_GENERICAC_REG0_WDT_ALMCLR(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> WDT_ALMCLR=(ParValue))
N#define biGetCCR_GENERICAC_REG0_ECCECLRB() (pst_bitCCR_GENERICAC_REG0() -> ECCECLRB)
N#define vSetCCR_GENERICAC_REG0_ECCECLRB(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> ECCECLRB=(ParValue))
N#define biGetCCR_GENERICAC_REG0_ECCWCLRB() (pst_bitCCR_GENERICAC_REG0() -> ECCWCLRB)
N#define vSetCCR_GENERICAC_REG0_ECCWCLRB(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> ECCWCLRB=(ParValue))
N#define biGetCCR_GENERICAC_REG0_ECCECLRS() (pst_bitCCR_GENERICAC_REG0() -> ECCECLRS)
N#define vSetCCR_GENERICAC_REG0_ECCECLRS(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> ECCECLRS=(ParValue))
N#define biGetCCR_GENERICAC_REG0_ECCWCLRS() (pst_bitCCR_GENERICAC_REG0() -> ECCWCLRS)
N#define vSetCCR_GENERICAC_REG0_ECCWCLRS(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> ECCWCLRS=(ParValue))
N#define biGetCCR_GENERICAC_REG0_CPXTSYN_PM() (pst_bitCCR_GENERICAC_REG0() -> CPXTSYN_PM)
N#define vSetCCR_GENERICAC_REG0_CPXTSYN_PM(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> CPXTSYN_PM=(ParValue))
N#define biGetCCR_GENERICAC_REG0_CPXTSYN_PNM() (pst_bitCCR_GENERICAC_REG0() -> CPXTSYN_PNM)
N#define vSetCCR_GENERICAC_REG0_CPXTSYN_PNM(ParValue)  (pst_bitCCR_GENERICAC_REG0() -> CPXTSYN_PNM=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetCCR_GENERICAC_REG0LL(ParValue) (pst_u8CCR_GENERICAC_REG0() -> u8LL = (ParValue))
N#define u8GetCCR_GENERICAC_REG0LL() (pst_u8CCR_GENERICAC_REG0() -> u8LL)
N/* LH-struct byte access */
N#define vSetCCR_GENERICAC_REG0LH(ParValue) (pst_u8CCR_GENERICAC_REG0() -> u8LH = (ParValue))
N#define u8GetCCR_GENERICAC_REG0LH() (pst_u8CCR_GENERICAC_REG0() -> u8LH)
N/* HL-struct byte access */
N#define vSetCCR_GENERICAC_REG0HL(ParValue) (pst_u8CCR_GENERICAC_REG0() -> u8HL = (ParValue))
N#define u8GetCCR_GENERICAC_REG0HL() (pst_u8CCR_GENERICAC_REG0() -> u8HL)
N/* HH-struct byte access */
N#define vSetCCR_GENERICAC_REG0HH(ParValue) (pst_u8CCR_GENERICAC_REG0() -> u8HH = (ParValue))
N#define u8GetCCR_GENERICAC_REG0HH() (pst_u8CCR_GENERICAC_REG0() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetCCR_GENERICAC_REG0L(ParValue) (pst_u16CCR_GENERICAC_REG0() -> u16L = (ParValue))
N#define u16GetCCR_GENERICAC_REG0L() (pst_u16CCR_GENERICAC_REG0() -> u16L)
N#define vSetCCR_GENERICAC_REG0H(ParValue) (pst_u16CCR_GENERICAC_REG0() -> u16H = (ParValue))
N#define u16GetCCR_GENERICAC_REG0H() (pst_u16CCR_GENERICAC_REG0() -> u16H)
N            
N/* Word access */
N#define vSetCCR_GENERICAC_REG0(ParValue)  (*pu32CCR_GENERICAC_REG0() = (ParValue))
N#define u32GetCCR_GENERICAC_REG0()  (*pu32CCR_GENERICAC_REG0() )
N             
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERICSTAT_REG0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC000008C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERICSTAT_REG0_REG__       0xC000008CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WDT_ALARM	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   ECCERRB	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   ECCWRNB	:1; 	 /* 2..2  bit(s) R */
N  uint32_t   BEPOSB	:7; 	 /* 3..9  bit(s) R */
N  uint32_t   BERESB	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   CR4DBGNOPWRDWN	:1; 	 /* 16..16  bit(s) R */ 
N  uint32_t   	:15; 	 /* 17..31  bit(s) R */                    
N} CCR_GENERICSTAT_REG0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERICSTAT_REG0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERICSTAT_REG0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERICSTAT_REG0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERICSTAT_REG0()     ((volatile CCR_GENERICSTAT_REG0_bit_view_st *)\
N(CCR_GENERICSTAT_REG0_REG__ ))
X#define pst_bitCCR_GENERICSTAT_REG0()     ((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(CCR_GENERICSTAT_REG0_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERICSTAT_REG0()     ((volatile CCR_GENERICSTAT_REG0_byte_view_st *)\
N(CCR_GENERICSTAT_REG0_REG__ ))
X#define pst_u8CCR_GENERICSTAT_REG0()     ((volatile CCR_GENERICSTAT_REG0_byte_view_st *)(CCR_GENERICSTAT_REG0_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERICSTAT_REG0()     ((volatile CCR_GENERICSTAT_REG0_halfword_view_st *)\
N(CCR_GENERICSTAT_REG0_REG__ ))
X#define pst_u16CCR_GENERICSTAT_REG0()     ((volatile CCR_GENERICSTAT_REG0_halfword_view_st *)(CCR_GENERICSTAT_REG0_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERICSTAT_REG0()     ((volatile u32CCR_GENERICSTAT_REG0_word_view *)\
N(CCR_GENERICSTAT_REG0_REG__ ))
X#define pu32CCR_GENERICSTAT_REG0()     ((volatile u32CCR_GENERICSTAT_REG0_word_view *)(CCR_GENERICSTAT_REG0_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetCCR_GENERICSTAT_REG0_WDT_ALARM() (pst_bitCCR_GENERICSTAT_REG0() -> WDT_ALARM)            
N#define biGetCCR_GENERICSTAT_REG0_ECCERRB() (pst_bitCCR_GENERICSTAT_REG0() -> ECCERRB)            
N#define biGetCCR_GENERICSTAT_REG0_ECCWRNB() (pst_bitCCR_GENERICSTAT_REG0() -> ECCWRNB)            
N#define biGetCCR_GENERICSTAT_REG0_BEPOSB() (pst_bitCCR_GENERICSTAT_REG0() -> BEPOSB)            
N#define biGetCCR_GENERICSTAT_REG0_BERESB() (pst_bitCCR_GENERICSTAT_REG0() -> BERESB)            
N#define biGetCCR_GENERICSTAT_REG0_CR4DBGNOPWRDWN() (pst_bitCCR_GENERICSTAT_REG0() -> CR4DBGNOPWRDWN)
N            
N/* LL-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG0LL() (pst_u8CCR_GENERICSTAT_REG0() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG0LH() (pst_u8CCR_GENERICSTAT_REG0() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG0HL() (pst_u8CCR_GENERICSTAT_REG0() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG0HH() (pst_u8CCR_GENERICSTAT_REG0() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N
N#define u16GetCCR_GENERICSTAT_REG0L() (pst_u16CCR_GENERICSTAT_REG0() -> u16L)
N
N#define u16GetCCR_GENERICSTAT_REG0H() (pst_u16CCR_GENERICSTAT_REG0() -> u16H)
N            
N/* Word access */
N
N#define u32GetCCR_GENERICSTAT_REG0()  (*pu32CCR_GENERICSTAT_REG0() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: CCR_GENERICSTAT_REG1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0000090                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define CCR_GENERICSTAT_REG1_REG__       0xC0000090U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ECCERRS	:4; 	 /* 0..3  bit(s) R */
N  uint32_t   ECCWRNS	:4; 	 /* 4..7  bit(s) R */
N  uint32_t   BEPOSS	:20; 	 /* 8..27  bit(s) R */ 
N  uint32_t   BERESS	:4; 	 /* 28..31  bit(s) R */                    
N} CCR_GENERICSTAT_REG1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} CCR_GENERICSTAT_REG1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} CCR_GENERICSTAT_REG1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32CCR_GENERICSTAT_REG1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitCCR_GENERICSTAT_REG1()     ((volatile CCR_GENERICSTAT_REG1_bit_view_st *)\
N(CCR_GENERICSTAT_REG1_REG__ ))
X#define pst_bitCCR_GENERICSTAT_REG1()     ((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(CCR_GENERICSTAT_REG1_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8CCR_GENERICSTAT_REG1()     ((volatile CCR_GENERICSTAT_REG1_byte_view_st *)\
N(CCR_GENERICSTAT_REG1_REG__ ))
X#define pst_u8CCR_GENERICSTAT_REG1()     ((volatile CCR_GENERICSTAT_REG1_byte_view_st *)(CCR_GENERICSTAT_REG1_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16CCR_GENERICSTAT_REG1()     ((volatile CCR_GENERICSTAT_REG1_halfword_view_st *)\
N(CCR_GENERICSTAT_REG1_REG__ ))
X#define pst_u16CCR_GENERICSTAT_REG1()     ((volatile CCR_GENERICSTAT_REG1_halfword_view_st *)(CCR_GENERICSTAT_REG1_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32CCR_GENERICSTAT_REG1()     ((volatile u32CCR_GENERICSTAT_REG1_word_view *)\
N(CCR_GENERICSTAT_REG1_REG__ ))
X#define pu32CCR_GENERICSTAT_REG1()     ((volatile u32CCR_GENERICSTAT_REG1_word_view *)(CCR_GENERICSTAT_REG1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetCCR_GENERICSTAT_REG1_ECCERRS() (pst_bitCCR_GENERICSTAT_REG1() -> ECCERRS)            
N#define biGetCCR_GENERICSTAT_REG1_ECCWRNS() (pst_bitCCR_GENERICSTAT_REG1() -> ECCWRNS)            
N#define biGetCCR_GENERICSTAT_REG1_BEPOSS() (pst_bitCCR_GENERICSTAT_REG1() -> BEPOSS)            
N#define biGetCCR_GENERICSTAT_REG1_BERESS() (pst_bitCCR_GENERICSTAT_REG1() -> BERESS)
N            
N/* LL-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG1LL() (pst_u8CCR_GENERICSTAT_REG1() -> u8LL)
N/* LH-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG1LH() (pst_u8CCR_GENERICSTAT_REG1() -> u8LH)
N/* HL-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG1HL() (pst_u8CCR_GENERICSTAT_REG1() -> u8HL)
N/* HH-struct byte access */
N
N#define u8GetCCR_GENERICSTAT_REG1HH() (pst_u8CCR_GENERICSTAT_REG1() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N
N#define u16GetCCR_GENERICSTAT_REG1L() (pst_u16CCR_GENERICSTAT_REG1() -> u16L)
N
N#define u16GetCCR_GENERICSTAT_REG1H() (pst_u16CCR_GENERICSTAT_REG1() -> u16H)
N            
N/* Word access */
N
N#define u32GetCCR_GENERICSTAT_REG1()  (*pu32CCR_GENERICSTAT_REG1() )
N                 
N    
N/******************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */ 
N/******************************************************************************/
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :   Deactivated:
N** |     Not requested Rules: 
N** |         Rule 5.7  [A] : disable No reuse of identifiers
N** |
N** |     Requested Rules:
N** |         Rule 6.4  [R] : Bitfields can only have `unsigned int' or `signed int' types
N** |                         Used for bit definitons generated by converter tool
N** |         Rule 17.4 [R] : No pointer arithmetic other than array indexing:
N** |                         This is necessary to have access to macros generated by converter tool
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************/
N
N#endif /* SysCon_PDSIO_H */ 
N    
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 24 "..\..\..\..\lldd\src\ccr.c" 2
N#include "ccr.h"
L 1 "..\..\..\..\lldd\inc\ccr.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : CCR Low-level register
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : CCR
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.22 $
N*   DATE        : $Date: 2015/05/18 13:49:55 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CCR_LLDD_H
N#define CCR_LLDD_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_CCR_H_REVISION     "$Revision: 1.22 $"
N#define LLDD_CCR_H_TAG          "$Name: LLDD_1_6 $"
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1862  /* Rule 19.7 : disable function-like macro not allowed */
N#endif
N/*********************************************/
N
N/**********************************************
N*                    Macros                   *
N**********************************************/
N/* CCR unlock key value */
N#define CCR_KEY_VAL 0xA5C0F17BU
N
N/* CCR PDS unlock macro */
N#define vCCR_PDS_UNLOCK()(vSetCCR_KEYR_KEYVAL(CCR_KEY_VAL))
N
N/* CCR PDH unlock macro */
N#define vCCR_PDH_UNLOCK()(vSetPDHR_KEYR_KEYVAL(CCR_KEY_VAL))
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
Ntypedef enum tag_ccr_enable_e
N{
N  CCR_DISABLE = 0,  /* disable */
N  CCR_ENABLE  = 1   /* enable  */
N} ccr_enable_e;
N
Ntypedef enum tag_ccr_alarm_no_e
N{
N  CCR_ALARM_0  = 0,   /* Alarm 0 */
N  CCR_ALARM_1  = 1   /* Alarm 1  */
N} ccr_alarm_no_e;
N
N/* Controller selection */
Ntypedef enum tag_ccr_cntrl_e
N{
N    CCR_QSPI_0        =  0,   /* QSPI 0 */
N    CCR_QSPI_1        =  1,   /* QSPI 1 */
N    CCR_QSPI_INT      =  2,   /* QSPI Internal */
N    CCR_SDRAM         =  3,   /* SDRAM */
N    CCR_I2S           =  4,   /* I2S */
N    CCR_GDC_0         =  5,   /* GDC 0 */
N    CCR_GDC_1         =  6,   /* GDC 1 */
N    CCR_DMA           =  7,   /* DMA */
N    CCR_PARFLASH      =  8,   /* Parallel Flash */
N    CCR_DAP           =  9,   /*  */
N    CCR_GA            = 10,   /* GA Engine */
N    CCR_PNG           = 11,   /* PNG Decoder */
N    CCR_FG            = 12,   /* Framegrabber */
N    CCR_MLB           = 13,   /* MLB */
N    CCR_SMC           = 14,   /* Stepper Motor */
N    CCR_HSPWM         = 15,   /* HSPWM */
N    CCR_I2SM          = 16,   /* I2SM */
N    CCR_TSM           = 17,   /* TSM */
N    CCR_TRACE         = 18,   /* Trace */
N    CCR_320MHz        = 19    /* 320MHz */
N} ccr_cntrl_e;
N
N/* Modulation type */
Ntypedef enum tag_ccr_modulated_clk_e
N{
N    CCR_MODULATED     = 0,    /* modulated clock */
N    CCR_NON_MODULATED = 1     /* non modulated clock */
N} ccr_modulated_clk_e;
N
N/*  */
Ntypedef enum tag_ccr_clock_type_e
N{
N    CCR_MODULATED_GDC0       = 0,    /* Modulated clock for GDC0 */
N    CCR_MODULATED_GDC1       = 1,    /* Modulated clock for GDC1 */
N    CCR_NON_MODULATED_GDC0   = 2,    /* Non modulated clock for GDC0 */
N    CCR_NON_MODULATED_GDC1   = 3,    /* Non modulated clock for GDC1 */
N    CCR_DOTCLKIN             = 4,    /* DOTCLKIN for GDC0 or GDC1 */
N    CCR_MODULATED_I2S        = 5,    /* Modulated clock for I2S */
N    CCR_NON_MODULATED_I2S    = 6,    /* Non modulated clock for I2S */
N    CCR_I2SMCLKIN            = 7,    /* I2SMCLKIN for I2S */
N    CCR_MODULATED_320MHZ     = 8,    /* Modulated clock for 320MHz */
N    CCR_NON_MODULATED_320MHZ = 9     /* Non modulated clock for 320MHz */
N} ccr_clock_type_e;
N
N/* Clock divider values (input clock: 900MHz) */
Ntypedef enum tag_ccr_clk_freq_e
N{
N    CCR_CLKDIV_112_5MHz =  8,    /* 112,5 MHz output clk */
N    CCR_CLKDIV_100_0MHz =  9,    /* 100,0 MHz output clk */
N    CCR_CLKDIV_90_0MHz  = 10,    /*  90,0 MHz output clk */
N    CCR_CLKDIV_81_8MHz  = 11,    /*  81,8 MHz output clk */
N    CCR_CLKDIV_75_0MHz  = 12,    /*  75,0 MHz output clk */
N    CCR_CLKDIV_69_2MHz  = 13,    /*  69,2 MHz output clk */
N    CCR_CLKDIV_64_3MHz  = 14,    /*  64,3 MHz output clk */
N    CCR_CLKDIV_60_0MHz  = 15,    /*  60,0 MHz output clk */
N    CCR_CLKDIV_56_3MHz  = 16,    /*  56,3 MHz output clk */
N    CCR_CLKDIV_52_9MHz  = 17,    /*  52,9 MHz output clk */
N    CCR_CLKDIV_50_0MHz  = 18,    /*  50,0 MHz output clk */
N    CCR_CLKDIV_47_4MHz  = 19,    /*  47,4 MHz output clk */
N    CCR_CLKDIV_45_0MHz  = 20,    /*  45,0 MHz output clk */
N    CCR_CLKDIV_42_9MHz  = 21,    /*  42,9 MHz output clk */
N    CCR_CLKDIV_40_9MHz  = 22,    /*  40,9 MHz output clk */
N    CCR_CLKDIV_39_1MHz  = 23,    /*  39,1 MHz output clk */
N    CCR_CLKDIV_37_5MHz  = 24,    /*  37,5 MHz output clk */
N    CCR_CLKDIV_36_0MHz  = 25,    /*  36,0 MHz output clk */
N    CCR_CLKDIV_34_6MHz  = 26,    /*  34,6 MHz output clk */
N    CCR_CLKDIV_33_3MHz  = 27,    /*  33,3 MHz output clk */
N    CCR_CLKDIV_32_1MHz  = 28,    /*  32,1 MHz output clk */
N    CCR_CLKDIV_31_0MHz  = 29,    /*  31,0 MHz output clk */
N    CCR_CLKDIV_30_0MHz  = 30,    /*  30,0 MHz output clk */
N    CCR_CLKDIV_29_0MHz  = 31,    /*  29,0 MHz output clk */
N    CCR_CLKDIV_28_1MHz  = 32,    /*  28,1 MHz output clk */
N    CCR_CLKDIV_27_2MHz  = 33,    /*  27,2 MHz output clk */
N    CCR_CLKDIV_26_4MHz  = 34,    /*  26,4 MHz output clk */
N    CCR_CLKDIV_25_7MHz  = 35,    /*  25,7 MHz output clk */
N    CCR_CLKDIV_25_0MHz  = 36,    /*  25,0 MHz output clk */
N    CCR_CLKDIV_24_3MHz  = 37,    /*  24,3 MHz output clk */
N    CCR_CLKDIV_23_6MHz  = 38,    /*  23,6 MHz output clk */
N    CCR_CLKDIV_23_0MHz  = 39,    /*  23,0 MHz output clk */
N    CCR_CLKDIV_22_5MHz  = 40     /*  22,5 MHz output clk */
N} ccr_clk_freq_e;
N
N/* Clock stability */
Ntypedef enum tag_ccr_clock_stability_e
N{
N    CCR_CLOCK_NOT_STABLE     = 0,    /* Clock is not stable */
N    CCR_CLOCK_STABLE         = 1,    /* Clock is stable */
N    CCR_CLOCK_STABILITY_FAIL = 2     /* Clock stability faild */
N} ccr_clock_stability_e;
N
N/* Clocks */
Ntypedef enum tag_ccr_clocks_e
N{
N    CCR_OSC10M            = 0,    /* 10M clock */
N    CCR_OSC32K            = 1,    /* 32K clock */
N    CCR_RC100K            = 2,    /* RC100K clock */
N    CCR_MODULATED_PLL     = 3,    /* modulated PLL */
N    CCR_NON_MODULATED_PLL = 4     /* non-modulated PLL */
N} ccr_clocks_e;
N
N/* Reset types */
Ntypedef enum tag_reset_type_e
N{
N    CCR_FULL_RST    = 0,    /* Software full reset */
N    CCR_DBG_RST     = 1,    /* Debug reset */
N    CCR_SW_PART_RST = 2     /* Software part reset */
N} ccr_reset_type_e;
N
N/* target device mode */
Ntypedef enum tag_ccr_device_mode_e
N{
N    CCR_DEVICE_MODE_TRANSITION = 0x00000000,    /* M_PLL */
N    CCR_DEVICE_MODE_M_PLL      = 0x005C0001,    /* M_PLL */
N    CCR_DEVICE_MODE_M_OSC10    = 0x005C0002,    /* M_OSC10 */
N    CCR_DEVICE_MODE_STB_OSC10  = 0x005C0004,    /* STB_OSC10 */
N    CCR_DEVICE_MODE_SLP_OSC10  = 0x005C0008,    /* SLP_OSC10 */
N    CCR_DEVICE_MODE_SLP_RC10   = 0x005C0010,    /* SLP_RC10 */
N    CCR_DEVICE_MODE_STOP_R     = 0x005C0020,    /* STOP_R */
N    CCR_DEVICE_MODE_STOP       = 0x005C0040     /* STOP */
N} ccr_device_mode_e;
N
N/* Interupts */
Ntypedef enum tag_ccr_interrupts_e
N{
N    CCR_INTERRUPTS_STATE_CHANGE = 0,    /* state change interrupt*/
N    CCR_INTERRUPTS_ALARM_0      = 1,    /* alarm comparator 0 interrupt */
N    CCR_INTERRUPTS_ALARM_1      = 2,    /* alarm comparator 1 interrupt */
N    CCR_INTERRUPTS_BECC         = 3,    /* backup RAM ECC interrupt */
N    CCR_INTERRUPTS_MECC         = 4     /* main memory ECC interrupt */
N} ccr_interrupts_e;
N
N/* Interrupt occurred */
Ntypedef enum tag_ccr_int_occurred_e
N{
N  CCR_INT_NOT_OCCURRED = 0,  /* interrupt did not occur */
N  CCR_INT_OCCURRED     = 1   /* interrupt occurred */
N} ccr_int_occurred_e;
N
N/* Operation mode type */
Ntypedef enum tag_ccr_operation_mode_type_e
N{
N    CCR_SSCG_MODE_DECIMAL_FACTOR = 0,    /* Decimal factor mode */
N    CCR_SSCG_MODE_INTEGER_FACTOR = 1     /* Integer factor mode */
N} ccr_operation_mode_type_e;
N
N/* Modulation direction */
Ntypedef enum tag_ccr_modulation_direction
N{
N    CCR_SSCG_MD_DOWN_SPREAD   = 0,    /* modulation direction is down spread */
N    CCR_SSCG_MD_CENTER_SPREAD = 1     /* modulation direction is up spread */
N} ccr_modulation_direction;
N
N/* Feedback division ratio prescaler value */
Ntypedef enum tag_ccr_fdr_prescaler_e
N{
N    CCR_FDR_PRESCALER_1 = 0,    /* feedback division ratio not doubled */
N    CCR_FDR_PRESCALER_2 = 1     /* feedback division ratio doubled */
N} ccr_fdr_prescaler_e;
N
N/* Watchdof timer alarm output configuration */
Ntypedef enum tag_ccr_wdt_alarm_type_e
N{
N    CCR_WDT_ALARM_AS_NMI   = 0,    /* watchdog timer alarm as watchdog timer NMI */
N    CCR_WDT_ALARM_AS_RESET = 1     /* watchdog timer alarm as watchdog timer RESET */
N} ccr_wdt_alarm_type_e;
N
N/* CAN modes */
Ntypedef enum tag_ccr_can_mode_e
N{                                     /*             tranceiver , combined channels, sepatate channels, pin pairs, description */
N    CCR_CAN_MODE_T_1_1_1_1  = 0x0,    /* CAN mode  1:     yes   ,         -        ,         4        ,    4     ,   1+1+1+1   */
N    CCR_CAN_MODE_T_2_1_1    = 0x1,    /* CAN mode  2:     yes   ,         2        ,         2        ,    3     ,    2+1+1    */
N    CCR_CAN_MODE_T_2_2      = 0x2,    /* CAN mode  3:     yes   ,         4        ,         -        ,    2     ,     2+2     */
N    CCR_CAN_MODE_T_3_1      = 0x3,    /* CAN mode  4:     yes   ,         3        ,         1        ,    2     ,     3+1     */
N    CCR_CAN_MODE_T_ALL      = 0x4,    /* CAN mode  5:     yes   ,         4        ,         -        ,    1     , all to one  */
N    CCR_CAN_MODE_NT_1_1_1_1 = 0x8,    /* CAN mode  5:      no   ,         -        ,         4        ,    4     ,   1+1+1+1   */
N    CCR_CAN_MODE_NT_2_1_1   = 0x9,    /* CAN mode  6:      no   ,         2        ,         2        ,    3     ,    2+1+1    */
N    CCR_CAN_MODE_NT_2_2     = 0xA,    /* CAN mode  7:      no   ,         4        ,         -        ,    2     ,     2+2     */
N    CCR_CAN_MODE_NT_3_1     = 0xB,    /* CAN mode  8:      no   ,         3        ,         1        ,    2     ,     3+1     */
N    CCR_CAN_MODE_NT_ALL     = 0xC,    /* CAN mode  9:      no   ,         4        ,         -        ,    1     , all to all  */
N    CCR_CAN_MODE_NT_INTER   = 0xF     /* CAN mode 10:      no   ,         -        ,         4        ,    -     , internal    */
N} ccr_can_mode_e;
N
N/* ECC modes */
Ntypedef enum tag_ccr_ecc_mode_e
N{
N    CCR_ECC_MODE_256KB  = 0,    /* 256KB with ECC */
N    CCR_ECC_MODE_128KB  = 2,    /* 128KB with ECC */
N    CCR_ECC_MODE_NO_ECC = 3     /* without ECC */
N} ccr_ecc_mode_e;
N
N/* TBIO channel */
Ntypedef enum tag_ccr_tbio_channel_e
N{
N    CCR_TBIO_0 = 0,    /* TBIO channel 0 */
N    CCR_TBIO_1 = 1,    /* TBIO channel 1 */
N    CCR_TBIO_2 = 2,    /* TBIO channel 2 */
N    CCR_TBIO_3 = 3,    /* TBIO channel 3 */
N    CCR_TBIO_4 = 4,    /* TBIO channel 4 */
N    CCR_TBIO_5 = 5,    /* TBIO channel 5 */
N    CCR_TBIO_6 = 6,    /* TBIO channel 6 */
N    CCR_TBIO_7 = 7,    /* TBIO channel 7 */
N    CCR_TBIO_8 = 8,    /* TBIO channel 8 */
N    CCR_TBIO_9 = 9     /* TBIO channel 9 */
N} ccr_tbio_channel_e;
N
N/* TBIO port direction */
Ntypedef enum tag_ccr_tbio_direction_e
N{
N    CCR_TBIO_IN  = 0,    /* TBIO pin as input */
N    CCR_TBIO_OUT = 1     /* TBIO pin as output */
N} ccr_tbio_direction_e;
N
N/* TBIN0 signal select for Complex Timer 4 */
Ntypedef enum tag_ccr_tbin_source_ctimer4_e
N{
N    CCR_TBIN_CTIMER4_PWMOUT00       =  0,    /* TBIN0 signal for Complex Timer 4 is PWMOUT00 */
N    CCR_TBIN_CTIMER4_PWMOUT02       =  1,    /* TBIN0 signal for Complex Timer 4 is PWMOUT02 */
N    CCR_TBIN_CTIMER4_PWMOUT04       =  2,    /* TBIN0 signal for Complex Timer 4 is PWMOUT04 */
N    CCR_TBIN_CTIMER4_PWMOUT06       =  3,    /* TBIN0 signal for Complex Timer 4 is PWMOUT06 */
N    CCR_TBIN_CTIMER4_PWMOUT08       =  4,    /* TBIN0 signal for Complex Timer 4 is PWMOUT08 */
N    CCR_TBIN_CTIMER4_PWMOUT10       =  5,    /* TBIN0 signal for Complex Timer 4 is PWMOUT10 */
N    CCR_TBIN_CTIMER4_PWMOUT12       =  6,    /* TBIN0 signal for Complex Timer 4 is PWMOUT12 */
N    CCR_TBIN_CTIMER4_PWMOUT14       =  7,    /* TBIN0 signal for Complex Timer 4 is PWMOUT14 */
N    CCR_TBIN_CTIMER4_PWMOUT16       =  8,    /* TBIN0 signal for Complex Timer 4 is PWMOUT16 */
N    CCR_TBIN_CTIMER4_PWMOUT18       =  9,    /* TBIN0 signal for Complex Timer 4 is PWMOUT18 */
N    CCR_TBIN_CTIMER4_PWMOUT20       = 10,    /* TBIN0 signal for Complex Timer 4 is PWMOUT20 */
N    CCR_TBIN_CTIMER4_PWMOUT22       = 11,    /* TBIN0 signal for Complex Timer 4 is PWMOUT22 */
N    CCR_TBIN_CTIMER4_GDC_PWMOUT0    = 12,    /* TBIN0 signal for Complex Timer 4 is GDC_PWMOUT0 */
N    CCR_TBIN_CTIMER4_GDC_SIN_PLUS0  = 13,    /* TBIN0 signal for Complex Timer 4 is SIN_PLUS0 */
N    CCR_TBIN_CTIMER4_GDC_SIN_MINUS0 = 14     /* TBIN0 signal for Complex Timer 4 is SIN_MINUS0 */
N} ccr_tbin_source_ctimer4_e;
N
N/* TBIN0 signal select for Complex Timer 5 */
Ntypedef enum tag_ccr_tbin_source_ctimer5_e
N{
N    CCR_TBIN_CTIMER5_PWMOUT00       =  0,    /* TBIN0 signal for Complex Timer 4 is PWMOUT00 */
N    CCR_TBIN_CTIMER5_PWMOUT02       =  1,    /* TBIN0 signal for Complex Timer 4 is PWMOUT02 */
N    CCR_TBIN_CTIMER5_PWMOUT04       =  2,    /* TBIN0 signal for Complex Timer 4 is PWMOUT04 */
N    CCR_TBIN_CTIMER5_PWMOUT06       =  3,    /* TBIN0 signal for Complex Timer 4 is PWMOUT06 */
N    CCR_TBIN_CTIMER5_PWMOUT08       =  4,    /* TBIN0 signal for Complex Timer 4 is PWMOUT08 */
N    CCR_TBIN_CTIMER5_PWMOUT10       =  5,    /* TBIN0 signal for Complex Timer 4 is PWMOUT10 */
N    CCR_TBIN_CTIMER5_PWMOUT12       =  6,    /* TBIN0 signal for Complex Timer 4 is PWMOUT12 */
N    CCR_TBIN_CTIMER5_PWMOUT14       =  7,    /* TBIN0 signal for Complex Timer 4 is PWMOUT14 */
N    CCR_TBIN_CTIMER5_PWMOUT16       =  8,    /* TBIN0 signal for Complex Timer 4 is PWMOUT16 */
N    CCR_TBIN_CTIMER5_PWMOUT18       =  9,    /* TBIN0 signal for Complex Timer 4 is PWMOUT18 */
N    CCR_TBIN_CTIMER5_PWMOUT20       = 10,    /* TBIN0 signal for Complex Timer 4 is PWMOUT20 */
N    CCR_TBIN_CTIMER5_PWMOUT22       = 11,    /* TBIN0 signal for Complex Timer 4 is PWMOUT22 */
N    CCR_TBIN_CTIMER5_GDC_PWMOUT1    = 12,    /* TBIN0 signal for Complex Timer 4 is GDC_PWMOUT1 */
N    CCR_TBIN_CTIMER5_GDC_COS_PLUS0  = 13,    /* TBIN0 signal for Complex Timer 4 is COS_PLUS0 */
N    CCR_TBIN_CTIMER5_GDC_COS_MINUS0 = 14     /* TBIN0 signal for Complex Timer 4 is COS_MINUS0 */
N} ccr_tbin_source_ctimer5_e;
N
N/* Synchronisation between GDC0 and GDC1 */
Ntypedef enum tag_ccr_gdc_sync_e
N{
N    CCR_GDC_SYNC_INDEPENDANT   = 0,    /* independant operation of GDC1 */
N    CCR_GDC_SYNC_GDC1_USE_GDC0 = 1     /* GDC1 uses GDC0 synchronisation signals */
N} ccr_gdc_sync_e;
N
N/* NOR channel */
Ntypedef enum tag_ccr_nor_channel_e
N{
N    CCR_NOR_CHANNEL_0 = 0,    /* NOR channel 0 */
N    CCR_NOR_CHANNEL_1 = 1     /* NOR channel 1 */
N} ccr_nor_channel_e;
N
N/* NAND channel */
Ntypedef enum tag_ccr_nand_channel_e
N{
N    CCR_NAND_CHANNEL_0 = 0,    /* NAND channel 0 */
N    CCR_NAND_CHANNEL_1 = 1     /* NAND channel 1 */
N} ccr_nand_channel_e;
N
N/* SRAM channel */
Ntypedef enum tag_ccr_sram_channel_e
N{
N    CCR_SRAM_CHANNEL_0 = 0,    /* SRAM channel 0 */
N    CCR_SRAM_CHANNEL_1 = 1,    /* SRAM channel 1 */
N    CCR_SRAM_CHANNEL_2 = 2,    /* SRAM channel 2 */
N    CCR_SRAM_CHANNEL_3 = 3     /* SRAM channel 3 */
N} ccr_sram_channel_e;
N
N/* Complex timer */
Ntypedef enum tag_ccr_complex_timer_e
N{
N    CCR_COMPLEX_TIMER_0_TO_5 = 0,    /* Complex timer 0 to 5 */
N    CCR_COMPLEX_TIMER_6_TO_9 = 1     /* Complex timer 6 to 9 */
N} ccr_complex_timer_e;
N
N/* Device version */
Ntypedef enum tag_ccr_device_version_e
N{
N    DEVICE_CAP_BT_1  = 0,    /* TMPR461XBG-300 (BGA-328, no SIP Flash)   */
N    DEVICE_CAP_C     = 1,    /* TMPR462XBG-300 (BGA-328, with SIP Flash) */
N    DEVICE_CAP_BT_0  = 2,    /* TMPR460XBG-300 (BGA-244, no SIP Flash)   */
N    DEVICE_INVALID   = 3     /* Reserved   */
N} ccr_device_version_e;
N
N/* SIP Flash size */
Ntypedef enum tag_ccr_SIPflash_size_e
N{
N    CCR_SIP_FLASH_SIZE_2MB  = 0,    /*  2MB SIP FLASH size */
N    CCR_SIP_FLASH_SIZE_4MB  = 1,    /*  4MB SIP FLASH size */
N    CCR_SIP_FLASH_SIZE_8MB  = 2,    /*  8MB SIP FLASH size */
N    CCR_SIP_FLASH_SIZE_16MB = 3     /* 16MB SIP FLASH size */
N} ccr_SIPflash_size_e;
N
Ntypedef enum tag_processor_device_e
N{
N    CCR_CR4 = 0,    /* processor R4 */
N    CCR_M3  = 1     /* processor M3 */
N} ccr_processor_device_e;
N
N/* Voltage regulator current trim */
Ntypedef enum tag_vreg_current_trim_e
N{
N    CCR_VREG_CURRENT_TRIM_M_40_PROZ = 4,    /* -40% */
N    CCR_VREG_CURRENT_TRIM_M_30_PROZ = 5,    /* -30% */
N    CCR_VREG_CURRENT_TRIM_M_20_PROZ = 6,    /* -20% */
N    CCR_VREG_CURRENT_TRIM_M_10_PROZ = 7,    /* -10% */
N    CCR_VREG_CURRENT_TRIM_0_PROZ    = 0,    /*   0% */
N    CCR_VREG_CURRENT_TRIM_P_10_PROZ = 1,    /*  10% */
N    CCR_VREG_CURRENT_TRIM_P_20_PROZ = 2,    /*  20% */
N    CCR_VREG_CURRENT_TRIM_P_30_PROZ = 3     /*  30% */
N} ccr_vreg_current_trim_e;
N
N/* Voltage regulator reference voltage trim */
Ntypedef enum tag_vreg_ref_voltage_trim_e
N{
N    CCR_VREG_REF_VOLTAGE_TRIM_M_7_5_PROZ = 15,    /* -7.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_7_0_PROZ = 14,    /* -7.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_6_5_PROZ = 13,    /* -6.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_6_0_PROZ = 12,    /* -6.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_5_5_PROZ = 11,    /* -5.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_5_0_PROZ = 10,    /* -5.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_4_5_PROZ =  9,    /* -4.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_4_0_PROZ =  8,    /* -4.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_3_5_PROZ =  7,    /* -3.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_3_0_PROZ =  6,    /* -3.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_2_5_PROZ =  5,    /* -2.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_2_0_PROZ =  4,    /* -2.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_1_5_PROZ =  3,    /* -1.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_1_0_PROZ =  2,    /* -1.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_M_0_5_PROZ =  1,    /* -0.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_0_PROZ     =  0,    /*    0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_0_5_PROZ = 31,    /* 0.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_1_0_PROZ = 30,    /* 1.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_1_5_PROZ = 29,    /* 1.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_2_0_PROZ = 28,    /* 2.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_2_5_PROZ = 27,    /* 2.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_3_0_PROZ = 26,    /* 3.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_3_5_PROZ = 25,    /* 3.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_4_0_PROZ = 24,    /* 4.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_4_5_PROZ = 23,    /* 4.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_5_0_PROZ = 22,    /* 5.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_5_5_PROZ = 21,    /* 5.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_6_0_PROZ = 20,    /* 6.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_6_5_PROZ = 19,    /* 6.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_7_0_PROZ = 18,    /* 7.0% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_7_5_PROZ = 17,    /* 7.5% */
N    CCR_VREG_REF_VOLTAGE_TRIM_P_8_0_PROZ = 16     /* 8.0% */
N} ccr_vreg_ref_voltage_trim_e;
N
N/* Voltage regulator current trim */
Ntypedef enum tag_vreg_temperature_trim_e
N{
N    CCR_VREG_TEMPERATURE_TRIM_M_60_DEGC = 4,    /* -60degC */
N    CCR_VREG_TEMPERATURE_TRIM_M_50_DEGC = 5,    /* -50degC */
N    CCR_VREG_TEMPERATURE_TRIM_M_40_DEGC = 6,    /* -40degC */
N    CCR_VREG_TEMPERATURE_TRIM_M_25_DEGC = 7,    /* -25degC */
N    CCR_VREG_TEMPERATURE_TRIM_0_DEGC    = 0,    /*   0degC */
N    CCR_VREG_TEMPERATURE_TRIM_P_25_DEGC = 1,    /*  25degC */
N    CCR_VREG_TEMPERATURE_TRIM_P_50_DEGC = 2,    /*  50degC */
N    CCR_VREG_TEMPERATURE_TRIM_P_70_DEGC = 3     /*  70degC */
N} ccr_vreg_temperature_trim_e;
N
N/* Oscillator adjustment */
Ntypedef enum tag_osc_adjustment_e
N{
N    CCR_OSC_ADJUSTMENT_M_8 =  8,    /* -8 */
N    CCR_OSC_ADJUSTMENT_M_7 =  9,    /* -7 */
N    CCR_OSC_ADJUSTMENT_M_6 = 10,    /* -6 */
N    CCR_OSC_ADJUSTMENT_M_5 = 11,    /* -5 */
N    CCR_OSC_ADJUSTMENT_M_4 = 12,    /* -4 */
N    CCR_OSC_ADJUSTMENT_M_3 = 13,    /* -3 */
N    CCR_OSC_ADJUSTMENT_M_2 = 14,    /* -2 */
N    CCR_OSC_ADJUSTMENT_M_1 = 15,    /* -1 */
N    CCR_OSC_ADJUSTMENT_0   =  0,    /*  0 */
N    CCR_OSC_ADJUSTMENT_P_1 =  1,    /*  1 */
N    CCR_OSC_ADJUSTMENT_P_2 =  2,    /*  2 */
N    CCR_OSC_ADJUSTMENT_P_3 =  3,    /*  3 */
N    CCR_OSC_ADJUSTMENT_P_4 =  4,    /*  4 */
N    CCR_OSC_ADJUSTMENT_P_5 =  5,    /*  5 */
N    CCR_OSC_ADJUSTMENT_P_6 =  6,    /*  6 */
N    CCR_OSC_ADJUSTMENT_P_7 =  7     /*  7 */
N} ccr_osc_adjustment_e;
N
N/* Threshold for power-good sensing */
Ntypedef enum tag_threshold_power_good_sensing_e
N{
N    CCR_POWER_GOOD_SENSING_0 = 0,    /* threshold 0 */
N    CCR_POWER_GOOD_SENSING_1 = 1,    /* threshold 1 */
N    CCR_POWER_GOOD_SENSING_2 = 2,    /* threshold 2 */
N    CCR_POWER_GOOD_SENSING_3 = 3,    /* threshold 3 */
N    CCR_POWER_GOOD_SENSING_4 = 7,    /* threshold 4 */
N    CCR_POWER_GOOD_SENSING_5 = 6,    /* threshold 5 */
N    CCR_POWER_GOOD_SENSING_6 = 5,    /* threshold 6 */
N    CCR_POWER_GOOD_SENSING_7 = 4     /* threshold 7 */
N} ccr_threshold_power_good_sensing_e;
N
N/* SMC IO level */
Ntypedef enum tag_smc_io_level_e
N{
N    CCR_SMC_IO_LEVEL_5V0 = 0,    /* operate with 5V */
N    CCR_SMC_IO_LEVEL_3V3 = 1     /* operate with 3.3V */
N} ccr_smc_io_level_e;
N
N/* Interrupts */
Ntypedef enum tag_system_interrupt_e
N{
N    CCR_OSC10M_CLOCK_MISSING_INT = 0x00000001,    /* OSC10MHz */
N    CCR_OSC32K_CLOCK_MISSING_INT = 0x00000100,    /* OSC32KHz */
N    CCR_EROR_INT_0               = 0x00010000,    /* Error interrupt 0 */
N    CCR_EROR_INT_1               = 0x00020000,    /* Error interrupt 1 */
N    CCR_EROR_INT_2               = 0x00040000,    /* Error interrupt 2 */
N    CCR_BACKUP_ECC_RAM_INT       = 0x01000000,    /* Backup ECC-RAM */
N    CCR_MAIN_MEMORY_ECC_RAM_INT  = 0x02000000,    /* Main memory ECC-RAM */
N    CCR_STPU_INT                 = 0x04000000,    /* STPU */
N    CCR_WDT_INT                  = 0x08000000,    /* WDT */
N    CCR_IO_INT                   = 0x10000000     /* IO */
N} ccr_system_interrupt_e;
N
N/* ECC */
Ntypedef enum tag_ecc_e
N{
N    CCR_BACKUP_RAM_ECC  = 0,    /* Backup RAM ECC */
N    CCR_MAIN_MEMORY_ECC = 1     /* Main memory ECC */
N} ccr_ecc_e;
N
N/* ECC interrupt type */
Ntypedef enum tag_ecc_interrupt_type_e
N{
N    CCR_ECC_SYSC_INTR    = 0,    /* SYSC_INTR will be generated */
N    CCR_ECC_SYSC_NMI     = 1,    /* SYSC_NMI will be generated */
N    CCR_ECC_SW_FULL_RSTN = 2     /* SW_FULL_RSTN will be generated */
N} ccr_ecc_interrupt_type_e;
N
N/* Modes */
Ntypedef enum tag_modes_e
N{
N    CCR_STB_MODE      = 0,    /* mission state entered from STB_ISC10 */
N    CCR_SLPOSC10_MODE = 1,    /* mission state entered from SLP_OSC10 */
N    CCR_SLPRCOSC_MODE = 2,    /* mission state entered from SLP_RD100K */
N    CCR_STOPR_MODE    = 3,    /* mission state entered from STOP_R */
N    CCR_STOP_MODE     = 4     /* mission state entered from STOP */
N} ccr_modes_e;
N
N/* Wakeup attributes */
Ntypedef enum tag_wakeup_attribute_e
N{
N    CCR_LOW_LEVEL  = 0,    /* low level wakeup */
N    CCR_HIGH_LEVEL = 1,    /* high level wakeup */
N    CCR_FALL_EDGE  = 2,    /* falling edge wakeup */
N    CCR_RISE_EDGE  = 3     /* rising edge wakeup */
N} ccr_wakeup_attribute_e;
N
N/* Wakeup sources */
Ntypedef enum tag_wakeup_source_e
N{
N    CCR_WAKEUP_SOURCE_0     =  0,    /* wakeup source 0 */
N    CCR_WAKEUP_SOURCE_1     =  1,    /* wakeup source 1 */
N    CCR_WAKEUP_SOURCE_2     =  2,    /* wakeup source 2 */
N    CCR_WAKEUP_SOURCE_3     =  3,    /* wakeup source 3 */
N    CCR_WAKEUP_SOURCE_4     =  4,    /* wakeup source 4 */
N    CCR_WAKEUP_SOURCE_5     =  5,    /* wakeup source 5 */
N    CCR_WAKEUP_SOURCE_6     =  6,    /* wakeup source 6 */
N    CCR_WAKEUP_SOURCE_7     =  7,    /* wakeup source 7 */
N    CCR_WAKEUP_SOURCE_NMI   =  8,    /* wakeup source NMI */
N    CCR_WAKEUP_SOURCE_ALARM =  9,    /* wakeup source ALARM */
N    CCR_WAKEUP_SOURCE_RTC   = 10     /* wakeup source RTC */
N} ccr_wakeup_source_e;
N
N/*********************************************/
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N
N/* SSCG configuration structure */
Ntypedef struct tag_ccr_sscg_congig_st
N{
N    ccr_modulation_direction  eModulationDirection;
N    uint8_t                   u8ModulationCycleLengthFractionalN;
N    uint16_t                  u16ModulationDegree;
N} ccr_sscg_congig_st;
N
N/* SRAM bit error inspection configuration */
Ntypedef struct tag_ccr_sram_bit_error_insp_config_st
N{
N    uint8_t u8PosFirstError;     /* Position of first bit error to be injected in SRAM */
N    uint8_t u8PosSecondError;    /* Position of second bit error to be injected in SRAM */
N    uint8_t u8ByteSelect;        /* Byte select for bit error injection in SRAM */
N} ccr_sram_bit_error_insp_config_st;
N
N/*********************************************/
N
N/**********************************************
N*            Forward declarations             *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/****************************************************************************
N *
N * Function:      vCCR_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IOPDHRevision  - pointer to PDH IO header revision string
N *                pau8IOPDHTag       - pointer to PDH IO header tag string
N *                pau8IOPDSRevision  - pointer to PDS IO header revision string
N *                pau8IOPDSTag       - pointer to PDS IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vCCR_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                     uint8_t** pau8IOPDHRevision, uint8_t** pau8IOPDHTag,
N                     uint8_t** pau8IOPDSRevision, uint8_t** pau8IOPDSTag);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableModuleClock
N *
N * Purpose:       Enable or disable module clock
N *                Normally first the clock frequency should be set. Than the
N *                module should be switched on. Switching off the module is not
N *                necessary before setting the clock frequency.
N *
N * Inputs:        eCntrl     Controller
N *                eEn        CCR_Enable if clock should be enabled
N *                           CCR_Disable if clock should be disabled
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableModuleClock(ccr_cntrl_e eCntrl, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GetEnabledModuleClock
N *
N * Purpose:       Enable or disable module clock
N *                Normally first the clock frequency should be set. Than the
N *                module should be switched on. Switching off the module is not
N *                necessary before setting the clock frequency.
N *
N * Inputs:        eCntrl     Controller
N *                peEn       status of module clock
N *                           CCR_Enable clock is enabled
N *                           CCR_Disable clock is disabled
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on invalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GetEnabledModuleClock(ccr_cntrl_e eCntrl, ccr_enable_e * peEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetClockFreq
N *
N * Purpose:       Configures clock frequency
N *                Clock frequency can be changed every time because no glitch
N *                should occur during switching. To be on the save side every
N *                action of the module should be finished.
N *                Normally first the clock frequency should be set. Than the
N *                module should be switched on. Switching off the module is not
N *                necessary before setting the clock frequency.
N *
N * Inputs:        eCntrl     Controller
N *                eFreq      Target frequency
N *                eModulated modulation type
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetClockFreq(ccr_cntrl_e eCntrl, ccr_clk_freq_e eFreq, ccr_modulated_clk_e eModulated);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SelectClockType
N *
N * Purpose:       Select clock type
N *
N * Inputs:        eCntrl        Controller
N *                eClockType    Clock type
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SelectClockType(ccr_cntrl_e eCntrl, ccr_clock_type_e eClockType);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetPllClockStabilizationCompareValue
N *
N * Purpose:       Set Pll clock stabilization compare value
N *
N * Inputs:        u8Value    Stabilization compare value
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetPllClockStabilizationCompareValue(uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      eCCR_ReadClockStability
N *
N * Purpose:       Read stability value of different oscillators and PLLs
N *
N * Inputs:        eClk        Clock or PLL
N *
N * Outputs:       none
N *
N * Return Values: clock stability value
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_clock_stability_e eCCR_ReadClockStability(ccr_clocks_e eClk);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GenerateReset
N *
N * Purpose:       Generate different types of reset
N *
N * Inputs:        eResetType     Reset type
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GenerateReset(ccr_reset_type_e eResetType);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetDeviceMode
N *
N * Purpose:       Set device mode
N *
N * Inputs:        eMode     Device mode
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:   Transitions to STB_OSC10, SLP_OSC10, SLP_RC10, STOP_R
N *                and STOP are only possible in rom2ram-project without
N *                any probe connected.
N *
N ***************************************************************************/
Nint32_t i32CCR_SetDeviceMode(ccr_device_mode_e eMode);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableInterrupt
N *
N * Purpose:       Enable interrupts
N *
N * Inputs:        eInterrupt     Interrupt type
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableInterrupt(ccr_interrupts_e eInterrupt, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      u32CCR_GetInterruptStatusAll
N *
N * Purpose:       Read status of all interrupts
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Status of all interrupts
N *
N * Limitations:
N *
N ***************************************************************************/
Nuint32_t u32CCR_GetInterruptStatusAll(void);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GetInterruptStatus
N *
N * Purpose:       Read interrupt status
N *
N * Inputs:        eInterrupt     Interrupt type
N *
N * Outputs:       peIntOccurred  Status of interrupt
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GetInterruptStatusSingle(ccr_interrupts_e eInterrupt, ccr_int_occurred_e * peIntOccurred);
N
N/****************************************************************************
N *
N * Function:      vCCR_ClearInterruptsAll
N *
N * Purpose:       Clear all interrupts
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_ClearInterruptsAll(void);
N
N/****************************************************************************
N *
N * Function:      i32CCR_ClearInterruptSingle
N *
N * Purpose:       Clear single interrupt
N *
N * Inputs:        eInterrupt     Interrupt type
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_ClearInterruptSingle(ccr_interrupts_e eInterrupt);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetCurrentDeviceMode
N *
N * Purpose:       Read current device mode
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Device mode
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_device_mode_e eCCR_GetCurrentDeviceMode(void);
N
N/****************************************************************************
N *
N * Function:      vCCR_ConfigureSSCG
N *
N * Purpose:       Configure the SSCG and start it with new settings
N *
N * Inputs:        pstSSCGConfig    Pointer to SSCG-configuration
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_ConfigureSSCG(ccr_sscg_congig_st * pstSSCGConfig);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetWDTAlarmType
N *
N * Purpose:       Configure WDT alarm type
N *
N * Inputs:        eAlarmType    WDT alarm type
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetWDTAlarmType(ccr_wdt_alarm_type_e eAlarmType);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableBitErrorInjectionInRAM
N *
N * Purpose:       Enable or disable error injection in Back-up RAM
N *
N * Inputs:        eEn    Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableBitErrorInjectionInRAM(ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetPositionOfBitErrorInjectionInRAM
N *
N * Purpose:       Set bit positions to be injected in Back-up RAM
N *
N * Inputs:        u8FirstPosition     first position
N *                u8SecondPosition    second position
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetPositionOfBitErrorInjectionInRAM(uint8_t u8FirstPosition, uint8_t u8SecondPosition);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetCANMode
N *
N * Purpose:       Set CAN mode
N *
N * Inputs:        eCANMode     CAN mode
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetCANMode(ccr_can_mode_e eCANMode);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetECCMode
N *
N * Purpose:       Set ECC mode
N *
N * Inputs:        eECCMode     ECC mode
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetECCMode(ccr_ecc_mode_e eECCMode);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetTBIODirection
N *
N * Purpose:       Set TBIO port direction
N *
N * Inputs:        eTBIOChannel     TBIO channel
N *                eDirection       Pin direction
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetTBIODirection(ccr_tbio_channel_e eTBIOChannel, ccr_tbio_direction_e eDirection);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetInputForComplexTimer4
N *
N * Purpose:       Set signal for Complex Timer 4
N *
N * Inputs:        eSource     Source for timer
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetInputForComplexTimer4(ccr_tbin_source_ctimer4_e eSource);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetInputForComplexTimer5
N *
N * Purpose:       Set signal for Complex Timer 5
N *
N * Inputs:        eSource     Source for timer
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetInputForComplexTimer5(ccr_tbin_source_ctimer5_e eSource);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableGDC0Interface
N *
N * Purpose:       Enable/disable GDC0 interface
N *
N * Inputs:        eEn     Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableGDC0Interface(ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableGDC1Interface
N *
N * Purpose:       Enable/disable GDC1 interface
N *
N * Inputs:        eEn     Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableGDC1Interface(ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableGDCPanelInterface
N *
N * Purpose:       Enable/disable GDC panel interface
N *
N * Inputs:        eEn     Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableGDCPanelInterface(ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetGDCSynchronisation
N *
N * Purpose:       Set synchronisation type between GDC0 and GDC1
N *
N * Inputs:        eGDCSync     GDC synchronisation type
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_SetGDCSynchronisation(ccr_gdc_sync_e eGDCSync);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetNORAddressMask
N *
N * Purpose:       Set NOR-interface address mask
N *
N * Inputs:        eChannel          NOR-channel
N *                u16AddressMask    Address maks
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetNORAddressMask(ccr_nor_channel_e eChannel, uint16_t u16AddressMask);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetNORAddressMatch
N *
N * Purpose:       Set NOR-interface address match
N *
N * Inputs:        eChannel          NOR-channel
N *                u16AddressMask    Address match
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetNORAddressMatch(ccr_nor_channel_e eChannel, uint16_t u16AddressMatch);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetNANDAddressMask
N *
N * Purpose:       Set NAND-interface address mask
N *
N * Inputs:        eChannel          NAND-channel
N *                u16AddressMask    Address maks
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetNANDAddressMask(ccr_nand_channel_e eChannel, uint16_t u16AddressMask);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetNANDAddressMatch
N *
N * Purpose:       Set NAND-interface address match
N *
N * Inputs:        eChannel          NAND-channel
N *                u16AddressMask    Address match
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetNANDAddressMatch(ccr_nand_channel_e eChannel, uint16_t u16AddressMatch);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetNORChipSelect
N *
N * Purpose:       Set NAND-interface address mask & address match as a word
N *                for channel 0 and 1
N *
N * Inputs:        u32Value:   value
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid  vCCR_SetNORChipSelect(uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      vCCR_SetNANDChipSelect
N *
N * Purpose:       Set NOR-interface address mask & address match as a word
N *                for channel 0 and 1
N *
N * Inputs:        u32Value:  value
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid  vCCR_SetNANDChipSelect(uint32_t u32Value);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableSRAMBitErrorInspection
N *
N * Purpose:       Enable or disable SRAM bit error inspection
N *
N * Inputs:        eChannel    SRAM-channel
N *                eEn         Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableSRAMBitErrorInspection(ccr_sram_channel_e eChannel, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetSRAMBitErrorInspectionConfiguration
N *
N * Purpose:       Set SRAM bit error inspection configuration
N *
N * Inputs:        eChannel    SRAM-channel
N *                pstConfig   Pointer to configuration
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetSRAMBitErrorInspectionConfiguration(ccr_sram_channel_e eChannel, ccr_sram_bit_error_insp_config_st * pstConfig);
N
N/****************************************************************************
N *
N * Function:      vCCR_ClearWDTAlarm
N *
N * Purpose:       Clear WDT alarm bit
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_ClearWDTAlarm(void);
N
N/****************************************************************************
N *
N * Function:      vCCR_ClearErrorIrgFlagOfBackupRAM
N *
N * Purpose:       Clear error IRQ flag of Back-up RAM
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_ClearErrorIrgFlagOfBackupRAM(void);
N
N/****************************************************************************
N *
N * Function:      vCCR_ClearWarningIrgFlagOfBackupRAM
N *
N * Purpose:       Clear warning IRQ flag of Back-up RAM
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_ClearWarningIrgFlagOfBackupRAM(void);
N
N/****************************************************************************
N *
N * Function:      i32CCR_ClearErrorIrgFlagOfSRAM
N *
N * Purpose:       Clear error IRQ flag of SRAM
N *
N * Inputs:        eChannel    SRAM-channel
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_ClearErrorIrgFlagOfSRAM(ccr_sram_channel_e eChannel);
N
N/****************************************************************************
N *
N * Function:      i32CCR_ClearWarningIrgFlagOfSRAM
N *
N * Purpose:       Clear warning IRQ flag of SRAM
N *
N * Inputs:        eChannel    SRAM-channel
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_ClearWarningIrgFlagOfSRAM(ccr_sram_channel_e eChannel);
N
N/****************************************************************************
N *
N * Function:      i32CCR_IssueSynchronPulseToCTimer
N *
N * Purpose:       Issue synchronous pulse to complex timer 0 to 5 or  to 9
N *
N * Inputs:        eComplexTimer    Complex timers
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_IssueSynchronPulseToCTimer(ccr_complex_timer_e eComplexTimer);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetWDTAlarmStatusBit
N *
N * Purpose:       Get WDT alarm status bit
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Enable or disable
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetWDTAlarmStatusBit(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetIRQErrorFlafForBackupRAM
N *
N * Purpose:       Get IRQ flag for error condition for Back-up RAM
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Enable or disable
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetIRQErrorFlafForBackupRAM(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetIRQWarningFlafForBackupRAM
N *
N * Purpose:       Get IRQ flag for warning condition for Back-up RAM
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Enable or disable
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetIRQWarningFlafForBackupRAM(void);
N
N/****************************************************************************
N *
N * Function:      u8CCR_GetPosOfBitErrorInBackupRAM
N *
N * Purpose:       Get position of bit error for Back-up RAM
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Enable or disable
N *
N * Limitations:
N *
N ***************************************************************************/
Nuint8_t u8CCR_GetPosOfBitErrorInBackupRAM(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetLastCheckResultForBackupRAM
N *
N * Purpose:       Get last check result for Back-up RAM
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Enable or disable
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetLastCheckResultForBackupRAM(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetDebuggerCR4PowerDownRequestStatus
N *
N * Purpose:       Get status of debugger CR4 power down request
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Status
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetDebuggerCR4PowerDownRequestStatus(void);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GetSRAMIrgErrorCondition
N *
N * Purpose:       Get IRQ flag error condition for SRAM
N *
N * Inputs:        eChannel    SRAM-channel
N *                peEn        Pointer to bit result
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GetSRAMIrgErrorCondition(ccr_sram_channel_e eChannel, ccr_enable_e * peEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GetSRAMIrgWarningCondition
N *
N * Purpose:       Get IRQ flag warning condition for SRAM
N *
N * Inputs:        eChannel    SRAM-channel
N *                peEn        Pointer to bit result
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GetSRAMIrgWarningCondition(ccr_sram_channel_e eChannel, ccr_enable_e * peEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GetSRAMPositionOfBitError
N *
N * Purpose:       Get position of bit error for SRAM
N *
N * Inputs:        eChannel      SRAM-channel
N *                pu8Position   Pointer to position
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GetSRAMPositionOfBitError(ccr_sram_channel_e eChannel, uint8_t * pu8Position);
N
N/****************************************************************************
N *
N * Function:      i32CCR_GetSRAMLastCheckResult
N *
N * Purpose:       Get last check result for SRAM
N *
N * Inputs:        eChannel    SRAM-channel
N *                peEn        Pointer to bit result
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_GetSRAMLastCheckResult(ccr_sram_channel_e eChannel, ccr_enable_e * peEn);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetDeviceVersion
N *
N * Purpose:       Read device version
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: device version
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_device_version_e eCCR_GetDeviceVersion(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetSIPFlashSize
N *
N * Purpose:       Read size of SIP flash
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: SIP flash size
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_SIPflash_size_e eCCR_GetSIPFlashSize(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GeCR4DebugStatus
N *
N * Purpose:       Provides information about the availability of the debug port.
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: CCR_DISABLE - Debug Port DISABLED
N *                CCR_ENABLE  - Debug Port ENABLED
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GeCR4DebugStatus(void);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableR4DebugPort
N *
N * Purpose:       Enable or disable debug port of processors
N *
N * Inputs:        eProcessorType     Processor type
N *                eEn                Enable or disable
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableR4DebugPort(ccr_processor_device_e eProcessorType, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetVRegCurrentTrim
N *
N * Purpose:       Set voltage regulator current trim value
N *
N * Inputs:        eValue     voltage regulator current trim value
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetVRegCurrentTrim(ccr_vreg_current_trim_e eValue);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetVRegRefVoltageTrim
N *
N * Purpose:       Set voltage regulator reference voltage trim value
N *
N * Inputs:        eValue     voltage regulator reference voltage trim value
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetVRegRefVoltageTrim(ccr_vreg_ref_voltage_trim_e eValue);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetVRegTemperatureTrim
N *
N * Purpose:       Set voltage regulator temperature trim value
N *
N * Inputs:        eValue     voltage regulator temperature trim value
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetVRegTemperatureTrim(ccr_vreg_temperature_trim_e eValue);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetOscAdjustment
N *
N * Purpose:       Set oscillator adjustment value
N *
N * Inputs:        eValue     oscillator adjustment value
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetOscAdjustment(ccr_osc_adjustment_e eValue);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetThresholdPowerGoodSensing
N *
N * Purpose:       Set threshold for power good sensing
N *
N * Inputs:        eValue     threshold for power good sensing
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetThresholdPowerGoodSensing(ccr_threshold_power_good_sensing_e eValue);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetAlarmComparatorThreshold
N *
N * Purpose:       Set alarm comparator threshold for Alarm 0 or 1
N *
N * Inputs:        eAlarmNo :  alarm comparator 0 or 1
N *                u8Value     alarm comparator threshold setting (0..31)
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetAlarmComparatorThreshold(ccr_alarm_no_e eAlarmNo, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableAlarm
N *
N * Purpose:       Enables/Disables CCR alarm comparator
N *
N * Inputs:        eAlarmNo :  alarm comparator 0 or 1
N *                eEn      :  enable/disbale alarm
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableAlarm(ccr_alarm_no_e eAlarmNo, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableClockSupervisor
N *
N * Purpose:       Enable/disable clock supervisor
N *
N * Inputs:        eClocks    clock type
N *                eEN        enable or disable
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableClockSupervisor(ccr_clocks_e eClocks, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableOSC10MClockSupervisorOutputResetFunction
N *
N * Purpose:       Enable/disable OSC10M clock supervisor output reset function
N *
N * Inputs:        eEN     enable or disable
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableOSC10MClockSupervisorOutputResetFunction(ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_EnableOSC32KHz
N *
N * Purpose:       Enable/disable OSC32KHz
N *
N * Inputs:        eEN     enable or disable
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_EnableOSC32KHz(ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      vCCR_ConfigureSmcIOLevel
N *
N * Purpose:       Set SMC IO level
N *
N * Inputs:        eLevel     SMC IO level
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:
N *
N ***************************************************************************/
Nvoid vCCR_ConfigureSmcIOLevel(ccr_smc_io_level_e eLevel);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetClockStabilizationCompareValue
N *
N * Purpose:       Set Clock Stabilization Compare Value
N *
N * Inputs:        eClocks    clock type
N *                u8Value    clock stabilization compare value
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetClockStabilizationCompareValue(ccr_clocks_e eClocks, uint8_t u8Value);
N
N/****************************************************************************
N *
N * Function:      u16CCR_getBootOptions
N *
N * Purpose:       Read boot options
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Boot options
N *
N * Limitations:
N *
N ***************************************************************************/
Nuint16_t u16CCR_GetBootOptions(void);
N
N/****************************************************************************
N *
N * Function:      u32CCR_GetSystemIntStatusAll
N *
N * Purpose:       Read interrupt status of all interrupts
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: Interrupt status of all interrupts
N *
N * Limitations:
N *
N ***************************************************************************/
Nuint32_t u32CCR_GetSystemIntStatusAll(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetSystemIntStatusSingle
N *
N * Purpose:       Read interrupt status of a singe interrupt
N *
N * Inputs:        eInt    Interrupt
N *
N * Outputs:       none
N *
N * Return Values: enabled or disabled
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetSystemIntStatusSingle(ccr_system_interrupt_e eInt);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetClockStabilizationCompareValue
N *
N * Purpose:       Clear interrupt status of a single interrupt
N *
N * Inputs:        eInt    Interrupt
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_ClearSystemIntStatusSingle(ccr_system_interrupt_e eInt);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableECCInterrupt
N *
N * Purpose:       Enable ECC interrupt
N *
N * Inputs:        eEccType      ECC type
N *                eEccIntType   ECC inte3rrupt type
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableECCInterrupt(ccr_ecc_e eEccType, ccr_ecc_interrupt_type_e eEccIntType);
N
N/****************************************************************************
N *
N * Function:      u8CCR_GetDeviceModesAll
N *
N * Purpose:       Read all device modes
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nuint8_t u8CCR_GetDeviceModesAll(void);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetDeviceModesSingle
N *
N * Purpose:       read single device mode
N *
N * Inputs:        eMode      Device mode
N *
N * Outputs:       none
N *
N * Return Values: enabled or disabled
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetDeviceModesSingle(ccr_modes_e eMode);
N
N/****************************************************************************
N *
N * Function:      i32CCR_EnableWakeupSource
N *
N * Purpose:       Enable or disable wakeup source
N *
N * Inputs:        eSource    wakeup source
N *                eEn        enable or disable
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_EnableWakeupSource(ccr_wakeup_source_e eSource, ccr_enable_e eEn);
N
N/****************************************************************************
N *
N * Function:      i32CCR_SetWakeupAttribute
N *
N * Purpose:       Set wakeup attribute
N *
N * Inputs:        eSource       wakeup source
N *                eAttribute    wakeup attribute
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_SetWakeupAttribute(ccr_wakeup_source_e eSource, ccr_wakeup_attribute_e eAttribute);
N
N/****************************************************************************
N *
N * Function:      u16CCR_GetWakeupSourceInterruptAll
N *
N * Purpose:       Read all wakeup source interrupts
N *
N * Inputs:        eSource       wakeup source
N *
N * Outputs:       none
N *
N * Return Values: wakeup source interrupt status vector
N *
N * Limitations:
N *
N ***************************************************************************/
Nuint16_t u16CCR_GetWakeupSourceInterruptAll(ccr_wakeup_source_e eSource);
N
N/****************************************************************************
N *
N * Function:      eCCR_GetWakeupSourceInterruptSingle
N *
N * Purpose:       Read single wakeup source interrupts
N *
N * Inputs:        eSource       wakeup source
N *
N * Outputs:       none
N *
N * Return Values: enabled or disabled
N *
N * Limitations:
N *
N ***************************************************************************/
Nccr_enable_e eCCR_GetWakeupSourceInterruptSingle(ccr_wakeup_source_e eSource);
N
N/****************************************************************************
N *
N * Function:      i32CCR_ClearWakeupInterruptSource
N *
N * Purpose:       Clear wakeup interrupt source
N *
N * Inputs:        eSource       wakeup source
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid parameter range
N *
N * Limitations:
N *
N ***************************************************************************/
Nint32_t i32CCR_ClearWakeupInterruptSource(ccr_wakeup_source_e eSource);
N
N/****************************************************************************/
N
N
N#endif /* CCR_LLDD_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 25 "..\..\..\..\lldd\src\ccr.c" 2
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_CCR_C_REVISION     "$Revision: 1.28 $"
N#define LLDD_CCR_C_TAG          "$Name: LLDD_1_6 $"
N
N#define MAX_ALARM_THRESHOLD  31 /* (5 Bits: 2^5) */
N#define CCR_DEBUG_CTRL_BIT  (0x1U)
N
N/*********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1771  /* Rule 2.4  [A] : No `commented out' sections of code */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S  #pragma ghs nowarning 1834  /* Rule 5.7  [A] : No reuse of identifiers */
S
S  #pragma ghs nowarning 667   /* Rule 1.1  [R] : ISO 9899:1990 C conformance w/o extensions */
S  #pragma ghs nowarning 1800  /* Rule 8.1  [R] : Functions must always have prototype declarations */
S  #pragma ghs nowarning 1864  /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1865  /* Rule 10.1 [R] : Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
N #endif
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
Nstatic uint8_t au8LLDD_CCR_C_REVISION[]        = LLDD_CCR_C_REVISION;
Xstatic uint8_t au8LLDD_CCR_C_REVISION[]        = "$Revision: 1.28 $";
Nstatic uint8_t au8LLDD_CCR_C_TAG[]             = LLDD_CCR_C_TAG;
Xstatic uint8_t au8LLDD_CCR_C_TAG[]             = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_CCR_H_REVISION[]        = LLDD_CCR_H_REVISION;
Xstatic uint8_t au8LLDD_CCR_H_REVISION[]        = "$Revision: 1.22 $";
Nstatic uint8_t au8LLDD_CCR_H_TAG[]             = LLDD_CCR_H_TAG;
Xstatic uint8_t au8LLDD_CCR_H_TAG[]             = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_CCR_PDH_IO_H_REVISION[] = LLDD_CCR_PDH_IO_H_REVISION;
Xstatic uint8_t au8LLDD_CCR_PDH_IO_H_REVISION[] = "$Revision: 1.16 $";
Nstatic uint8_t au8LLDD_CCR_PDH_IO_H_TAG[]      = LLDD_CCR_PDH_IO_H_TAG;
Xstatic uint8_t au8LLDD_CCR_PDH_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_CCR_PDS_IO_H_REVISION[] = LLDD_CCR_PDS_IO_H_REVISION;
Xstatic uint8_t au8LLDD_CCR_PDS_IO_H_REVISION[] = "$Revision: 1.13 $";
Nstatic uint8_t au8LLDD_CCR_PDS_IO_H_TAG[]      = LLDD_CCR_PDS_IO_H_TAG;
Xstatic uint8_t au8LLDD_CCR_PDS_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N/*********************************************/
N
N/**********************************************
N*             Function definition             *
N*********************************************/
N
N/****************************************************************************/
Nvoid vCCR_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                     uint8_t** pau8IOPDHRevision, uint8_t** pau8IOPDHTag,
N                     uint8_t** pau8IOPDSRevision, uint8_t** pau8IOPDSTag)
N{
N   *pau8ModuleRevision = &au8LLDD_CCR_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_CCR_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_CCR_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_CCR_H_TAG[0];
N   *pau8IOPDHRevision  = &au8LLDD_CCR_PDH_IO_H_REVISION[0];
N   *pau8IOPDHTag       = &au8LLDD_CCR_PDH_IO_H_TAG[0];
N   *pau8IOPDSRevision  = &au8LLDD_CCR_PDS_IO_H_REVISION[0];
N   *pau8IOPDSTag       = &au8LLDD_CCR_PDS_IO_H_TAG[0];
N}
N
N/****************************************************************************/
Nint32_t i32CCR_EnableModuleClock(ccr_cntrl_e eCntrl, ccr_enable_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch (eCntrl)
N    {
N        case CCR_QSPI_0:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_QSPI0_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI0_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_QSPI0_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI0_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_QSPI_1:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_QSPI1_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI1_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_QSPI1_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI1_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_QSPI_INT:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_QSPI2_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI2_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_QSPI2_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI2_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_DMA:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_DMA_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_DMA_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_DMA_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_DMA_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_PARFLASH:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_PARFL_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_PARFL_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_PARFL_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_PARFL_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_DAP:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_DAP_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_DAP_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_DAP_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_DAP_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_GA:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_GA_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GA_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_GA_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GA_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_PNG:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_PNG_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_PNG_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_PNG_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_PNG_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_GDC_0:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_GDC0_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GDC0_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_GDC0_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GDC0_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_GDC_1:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_GDC1_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GDC1_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_GDC1_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GDC1_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_FG:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_FG_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_FG_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_FG_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_FG_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_MLB:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_MLB_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_MLB_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_MLB_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_MLB_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_SDRAM:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_SDRAM_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_SDRAM_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_SDRAM_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_SDRAM_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_SMC:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_SMC_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_SMC_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_SMC_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_SMC_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_I2S:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_I2S_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_I2S_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_I2S_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_I2S_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_HSPWM:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_HSPWM_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_HSPWM_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_HSPWM_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_HSPWM_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_I2SM:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_I2SM_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_I2SM_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_I2SM_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_I2SM_GATE=(1U));
N                }
N            }
N            break;
N        case CCR_TSM:
N            {
N                /* Unlock CCR for writing */
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N                /* set value */
N                if (eEn == CCR_ENABLE)
N                {
N                    vSetCCR_PERICLKGATE_CLK_TSM_GATE(0U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_TSM_GATE=(0U));
N                }
N                else
N                {
N                    vSetCCR_PERICLKGATE_CLK_TSM_GATE(1U);
X                    (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_TSM_GATE=(1U));
N                }
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N
N/****************************************************************************/
Nint32_t i32CCR_GetEnabledModuleClock(ccr_cntrl_e eCntrl, ccr_enable_e * peEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* default value is disabled */
N    *peEn = CCR_DISABLE;
N
N    switch (eCntrl)
N    {
N        case CCR_QSPI_0:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_QSPI0_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI0_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_QSPI_1:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_QSPI1_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI1_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_QSPI_INT:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_QSPI2_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_QSPI2_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_DMA:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_DMA_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_DMA_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_PARFLASH:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_PARFL_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_PARFL_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_DAP:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_DAP_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_DAP_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_GA:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_GA_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GA_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_PNG:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_PNG_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_PNG_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_GDC_0:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_GDC0_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GDC0_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_GDC_1:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_GDC1_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_GDC1_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_FG:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_FG_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_FG_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_MLB:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_MLB_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_MLB_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_SDRAM:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_SDRAM_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_SDRAM_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_SMC:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_SMC_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_SMC_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_I2S:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_I2S_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_I2S_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_HSPWM:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_HSPWM_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_HSPWM_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_I2SM:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_I2SM_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_I2SM_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        case CCR_TSM:
N            {
N                if ( 0 < biGetCCR_PERICLKGATE_CLK_TSM_GATE())
X                if ( 0 < (((volatile CCR_PERICLKGATE_bit_view_st *)(0xC0000024U )) -> CLK_TSM_GATE))
N                {
N                    *peEn = CCR_ENABLE;
N                }
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N/****************************************************************************/
Nint32_t i32CCR_SetClockFreq(ccr_cntrl_e eCntrl, ccr_clk_freq_e eFreq, ccr_modulated_clk_e eModulated)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eCntrl)
N    {
N        case CCR_QSPI_0:
N            {
N                if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVM2_QSPI0())
X                if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> QSPI0))
N                {
N                    /* Unlock CCR for writing */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vClrCCR_CLKDIVACK_RELOADACK_MQSPI0();
X                    (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MQSPI0=(0));
N
N                    /* Set Quad-SPI0 clock frequency */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_CLKDIVM2_QSPI0(eFreq);
X                    (((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> QSPI0=(eFreq));
N
N                    /* wait for stable clock */
N                    while( 0U == biGetCCR_CLKDIVACK_RELOADACK_MQSPI0())
X                    while( 0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MQSPI0))
N                    {
N                        ;
N                    }
N                }
N            }
N            break;
N        case CCR_QSPI_1:
N            {
N                if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVM2_QSPI1())
X                if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> QSPI1))
N                {
N                    /* Unlock CCR for writing */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vClrCCR_CLKDIVACK_RELOADACK_MQSPI1();
X                    (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MQSPI1=(0));
N
N                    /* Set Quad-SPI1 clock frequency */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_CLKDIVM2_QSPI1(eFreq);
X                    (((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> QSPI1=(eFreq));
N
N                    /* wait for stable clock */
N                    while(0U == biGetCCR_CLKDIVACK_RELOADACK_MQSPI1())
X                    while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MQSPI1))
N                    {
N                        ;
N                    }
N                }
N            }
N            break;
N        case CCR_QSPI_INT:
N            {
N                if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVM2_QSPI2())
X                if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> QSPI2))
N                {
N                    /* Unlock CCR for writing */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vClrCCR_CLKDIVACK_RELOADACK_MQSPI2();
X                    (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MQSPI2=(0));
N
N                    /* Set Quad-SPI internal clock frequency */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_CLKDIVM2_QSPI2(eFreq);
X                    (((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> QSPI2=(eFreq));
N
N                    /* wait for stable clock */
N                    while(0U == biGetCCR_CLKDIVACK_RELOADACK_MQSPI2())
X                    while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MQSPI2))
N                    {
N                        ;
N                    }
N                }
N            }
N            break;
N        case CCR_SDRAM:
N            {
N                if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVM2_SDRAMIF())
X                if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> SDRAMIF))
N                {
N                    /* Unlock CCR for writing */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vClrCCR_CLKDIVACK_RELOADACK_MSDRAM();
X                    (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MSDRAM=(0));
N
N                    /* Set SDRAM clock frequency */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_CLKDIVM2_SDRAMIF(eFreq);
X                    (((volatile CCR_CLKDIVM2_bit_view_st *)(0xC0000008U )) -> SDRAMIF=(eFreq));
N
N                    /* wait for stable clock */
N                    while(0U == biGetCCR_CLKDIVACK_RELOADACK_MSDRAM())
X                    while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MSDRAM))
N                    {
N                        ;
N                    }
N                }
N            }
N            break;
N        case CCR_GDC_0:
N            {
N                if (eModulated == CCR_MODULATED)
N                {
N                    if (eFreq != biGetCCR_CLKDIVM1_GDC0())
X                    if (eFreq != (((volatile CCR_CLKDIVM1_bit_view_st *)(0xC0000004U )) -> GDC0))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_MGDC0();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MGDC0=(0));
N
N                        /* Set GDC0 clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVM1_GDC0(eFreq);
X                        (((volatile CCR_CLKDIVM1_bit_view_st *)(0xC0000004U )) -> GDC0=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_MGDC0())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MGDC0))
N                        {
N                            ;
N                        }
N
N                        /* switch to modulated clock */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKSEL_CLK_DOT0_SEL(0x01);
X                        (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT0_SEL=(0x01));
N                    }
N                }
N                else
N                {
N                    if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVNM1_GDC0())
X                    if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVNM1_bit_view_st *)(0xC0000010U )) -> GDC0))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_NMGDC0();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMGDC0=(0));
N
N                        /* Set GDC0 clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVNM1_GDC0(eFreq);
X                        (((volatile CCR_CLKDIVNM1_bit_view_st *)(0xC0000010U )) -> GDC0=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_NMGDC0())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMGDC0))
N                        {
N                            ;
N                        }
N
N                        /* switch to non modulated clock */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKSEL_CLK_DOT0_SEL(0x02);
X                        (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT0_SEL=(0x02));
N                    }
N                }
N            }
N            break;
N        case CCR_GDC_1:
N            {
N                if (eModulated == CCR_MODULATED)
N                {
N                    if (eFreq != biGetCCR_CLKDIVM1_GDC1())
X                    if (eFreq != (((volatile CCR_CLKDIVM1_bit_view_st *)(0xC0000004U )) -> GDC1))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_MGDC1();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MGDC1=(0));
N
N                        /* Set GDC1 clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVM1_GDC1(eFreq);
X                        (((volatile CCR_CLKDIVM1_bit_view_st *)(0xC0000004U )) -> GDC1=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_MGDC1())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MGDC1))
N                        {
N                            ;
N                        }
N
N                        /* switch to modulated clock */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKSEL_CLK_DOT1_SEL(0x01);
X                        (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(0x01));
N                    }
N                }
N                else
N                {
N                    if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVNM1_GDC1())
X                    if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVNM1_bit_view_st *)(0xC0000010U )) -> GDC1))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_NMGDC1();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMGDC1=(0));
N
N                        /* Set GDC1 clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVNM1_GDC1(eFreq);
X                        (((volatile CCR_CLKDIVNM1_bit_view_st *)(0xC0000010U )) -> GDC1=(eFreq));
N
N                        /* wait for stable clock */
N                        while( 0U == biGetCCR_CLKDIVACK_RELOADACK_NMGDC1())
X                        while( 0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMGDC1))
N                        {
N                            ;
N                        }
N
N                        /* switch to non modulated clock */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKSEL_CLK_DOT1_SEL(0x02);
X                        (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(0x02));
N                    }
N                }
N            }
N            break;
N        case CCR_I2S:
N            {
N                if (eModulated == CCR_MODULATED)
N                {
N                    if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVM3_I2S())
X                    if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVM3_bit_view_st *)(0xC000000CU )) -> I2S))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_MI2S();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MI2S=(0));
N
N                        /* Set I2S clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVM3_I2S(eFreq);
X                        (((volatile CCR_CLKDIVM3_bit_view_st *)(0xC000000CU )) -> I2S=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_MI2S())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MI2S))
N                        {
N                            ;
N                        }
N                    }
N                }
N                else
N                {
N                    if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVNM3_I2S())
X                    if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVNM3_bit_view_st *)(0xC0000018U )) -> I2S))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_NMI2S();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMI2S=(0));
N
N                        /* Set I2S clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVNM3_I2S(eFreq);
X                        (((volatile CCR_CLKDIVNM3_bit_view_st *)(0xC0000018U )) -> I2S=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_NMI2S())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMI2S))
N                        {
N                            ;
N                        }
N                    }
N                }
N            }
N            break;
N        case CCR_PARFLASH:
N            {
N                if (eModulated == CCR_MODULATED)
N                {
N                    if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVM3_PL353())
X                    if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVM3_bit_view_st *)(0xC000000CU )) -> PL353))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_MPL353();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MPL353=(0));
N
N                        /* Set PL353 clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVM3_PL353(eFreq);
X                        (((volatile CCR_CLKDIVM3_bit_view_st *)(0xC000000CU )) -> PL353=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_MPL353())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_MPL353))
N                        {
N                            ;
N                        }
N                    }
N                }
N                else
N                {
N                    if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVNM3_PL353())
X                    if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVNM3_bit_view_st *)(0xC0000018U )) -> PL353))
N                    {
N                        /* Unlock CCR for writing */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vClrCCR_CLKDIVACK_RELOADACK_NMPL353();
X                        (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMPL353=(0));
N
N                        /* Set PL353 clock frequency */
N                        vCCR_PDS_UNLOCK();
X                        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                        vSetCCR_CLKDIVNM3_PL353(eFreq);
X                        (((volatile CCR_CLKDIVNM3_bit_view_st *)(0xC0000018U )) -> PL353=(eFreq));
N
N                        /* wait for stable clock */
N                        while(0U == biGetCCR_CLKDIVACK_RELOADACK_NMPL353())
X                        while(0U == (((volatile CCR_CLKDIVACK_bit_view_st *)(0xC000001CU )) -> RELOADACK_NMPL353))
N                        {
N                            ;
N                        }
N
N                    }
N                }
N            }
N            break;
N        case CCR_TRACE:
N            {
N                if (eFreq != (ccr_clk_freq_e)biGetCCR_CLKDIVNM2_TRACE())
X                if (eFreq != (ccr_clk_freq_e)(((volatile CCR_CLKDIVNM2_bit_view_st *)(0xC0000014U )) -> TRACE))
N                {
N                    /* Unlock CCR for writing */
N                    /* Set Quad-SPI input clock frequency */
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_CLKDIVNM2_TRACE((uint8_t)eFreq);
X                    (((volatile CCR_CLKDIVNM2_bit_view_st *)(0xC0000014U )) -> TRACE=((uint8_t)eFreq));
N
N                    /* wait for stable clock */
N/*                    while(0==biGetCCR_CLKDIVACK_RELOADACK_MSDRAM()){}; */
N                }
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N        break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SelectClockType(ccr_cntrl_e eCntrl, ccr_clock_type_e eClockType)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eCntrl)
N    {
N        case CCR_GDC_0:
N            {
N                switch(eClockType)
N                {
N                    case CCR_MODULATED_GDC0:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT0_SEL(1U);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT0_SEL=(1U));
N                        }
N                        break;
N                    case CCR_NON_MODULATED_GDC0:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT0_SEL(2);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT0_SEL=(2));
N                        }
N                        break;
N                    case CCR_DOTCLKIN:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT0_SEL(3);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT0_SEL=(3));
N                        }
N                        break;
N                    default:
N                        {
N                            i32Res = C_FAILED;
X                            i32Res = (-1);
N                        }
N            break;
N                }
N            }
N            break;
N        case CCR_GDC_1:
N            {
N                switch(eClockType)
N                {
N                    case CCR_MODULATED_GDC0:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT1_SEL(1U);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(1U));
N                        }
N                        break;
N                    case CCR_MODULATED_GDC1:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT1_SEL(2);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(2));
N                        }
N                        break;
N                    case CCR_NON_MODULATED_GDC0:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT1_SEL(3);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(3));
N                        }
N                        break;
N                    case CCR_NON_MODULATED_GDC1:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT1_SEL(4);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(4));
N                        }
N                        break;
N                    case CCR_DOTCLKIN:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_DOT1_SEL(5);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_DOT1_SEL=(5));
N                        }
N                        break;
N                    default:
N                        {
N                            i32Res = C_FAILED;
X                            i32Res = (-1);
N                        }
N            break;
N                }
N            }
N            break;
N        case CCR_I2S:
N            {
N                switch(eClockType)
N                {
N                    case CCR_MODULATED_I2S:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_I2S_SEL(1U);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_I2S_SEL=(1U));
N                        }
N                        break;
N                    case CCR_NON_MODULATED_I2S:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_I2S_SEL(2);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_I2S_SEL=(2));
N                        }
N                        break;
N                    case CCR_I2SMCLKIN:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_I2S_SEL(3);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_I2S_SEL=(3));
N                        }
N                        break;
N                    default:
N                        {
N                            i32Res = C_FAILED;
X                            i32Res = (-1);
N                        }
N            break;
N                }
N            }
N            break;
N        case CCR_320MHz:
N            {
N                switch(eClockType)
N                {
N                    case CCR_MODULATED_320MHZ:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_300_SEL(0U);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_300_SEL=(0U));
N                        }
N                        break;
N                    case CCR_NON_MODULATED_320MHZ:
N                        {
N                            vCCR_PDS_UNLOCK();
X                            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                            vSetCCR_CLKSEL_CLK_300_SEL(1U);
X                            (((volatile CCR_CLKSEL_bit_view_st *)(0xC0000020U )) -> CLK_300_SEL=(1U));
N                        }
N                        break;
N                    default:
N                        {
N                            i32Res = C_FAILED;
X                            i32Res = (-1);
N                        }
N            break;
N                }
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N        break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetPllClockStabilizationCompareValue(uint8_t u8Value)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_SBCR_PLLSTBC(u8Value);
X    (((volatile CCR_SBCR_bit_view_st *)(0xC0000028U )) -> PLLSTBC=(u8Value));
N}
N
N
N/****************************************************************************/
Nccr_clock_stability_e eCCR_ReadClockStability(ccr_clocks_e eClk)
N{
N    ccr_clock_stability_e eStability;
N
N    switch (eClk)
N    {
N        case CCR_OSC10M:
N            {
N                if (biGetCCR_SBSR_OSC10MRDY() == 0)
X                if ((((volatile CCR_SBSR_bit_view_st *)(0xC000002CU )) -> OSC10MRDY) == 0)
N                {
N                    eStability = CCR_CLOCK_NOT_STABLE;
N                }
N                else
N                {
N                    eStability = CCR_CLOCK_STABLE;
N                }
N            }
N            break;
N        case CCR_OSC32K:
N            {
N                if (biGetCCR_SBSR_OSC32KRDY() == 0)
X                if ((((volatile CCR_SBSR_bit_view_st *)(0xC000002CU )) -> OSC32KRDY) == 0)
N                {
N                    eStability = CCR_CLOCK_NOT_STABLE;
N                }
N                else
N                {
N                    eStability = CCR_CLOCK_STABLE;
N                }
N            }
N            break;
N        case CCR_RC100K:
N            {
N                if (biGetCCR_SBSR_RC100KRDY() == 0)
X                if ((((volatile CCR_SBSR_bit_view_st *)(0xC000002CU )) -> RC100KRDY) == 0)
N                {
N                    eStability = CCR_CLOCK_NOT_STABLE;
N                }
N                else
N                {
N                    eStability = CCR_CLOCK_STABLE;
N                }
N            }
N            break;
N        case CCR_MODULATED_PLL:
N            {
N                if (biGetCCR_SBSR_MPLLRDY() == 0)
X                if ((((volatile CCR_SBSR_bit_view_st *)(0xC000002CU )) -> MPLLRDY) == 0)
N                {
N                    eStability = CCR_CLOCK_NOT_STABLE;
N                }
N                else
N                {
N                    eStability = CCR_CLOCK_STABLE;
N                }
N            }
N            break;
N        case CCR_NON_MODULATED_PLL:
N            {
N                if (biGetCCR_SBSR_NMPLLRDY() == 0)
X                if ((((volatile CCR_SBSR_bit_view_st *)(0xC000002CU )) -> NMPLLRDY) == 0)
N                {
N                    eStability = CCR_CLOCK_NOT_STABLE;
N                }
N                else
N                {
N                    eStability = CCR_CLOCK_STABLE;
N                }
N            }
N            break;
N        default:
N            {
N                eStability = CCR_CLOCK_STABILITY_FAIL;
N            }
N        break;
N    }
N
N    return eStability;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_GenerateReset(ccr_reset_type_e eResetType)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eResetType)
N    {
N        case CCR_FULL_RST:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_RSTCR_SW_FULL_RST(0x5F);
X                (((volatile CCR_RSTCR_bit_view_st *)(0xC0000030U )) -> SW_FULL_RST=(0x5F));
N            }
N            break;
N        case CCR_DBG_RST:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_RSTCR_DBGRST(0xDE);
X                (((volatile CCR_RSTCR_bit_view_st *)(0xC0000030U )) -> DBGRST=(0xDE));
N            }
N            break;
N        case CCR_SW_PART_RST:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_RSTCR_SW_PART_RST(0x58);
X                (((volatile CCR_RSTCR_bit_view_st *)(0xC0000030U )) -> SW_PART_RST=(0x58));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N        break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
N__asm void __wfi(void)
N{
N    WFI
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetDeviceMode(ccr_device_mode_e eMode)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch (eMode)
N    {
N        case CCR_DEVICE_MODE_M_PLL:      /* M_PLL */
N            /* if Device is currently performing state transition, then wait: */
N            while (biGetCCR_SYSDSR_MODESTAT() == 0)
X            while ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) == 0)
N            {
N                ;
N            }
N            if (biGetCCR_SYSDSR_MODESTAT() != 1)
X            if ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) != 1)
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_SCR(eMode);
X                (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N
N                while (biGetCCR_SYSDSR_MODESTAT() == 0)
X                while ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) == 0)
N                {
N                    ;
N                }
N            }
N            else
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N        case CCR_DEVICE_MODE_M_OSC10:    /* M_OSC10 */
N            /* if Device is currently performing state transition, then wait: */
N            while (biGetCCR_SYSDSR_MODESTAT() == 0)
X            while ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) == 0)
N            {
N                ;
N            }
N            if (biGetCCR_SYSDSR_MODESTAT() != 2)
X            if ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) != 2)
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_SCR(eMode);
X                (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N
N                while (biGetCCR_SYSDSR_MODESTAT() == 0)
X                while ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) == 0)
N                {
N                    ;
N                }
N            }
N            else
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N        case CCR_DEVICE_MODE_STB_OSC10:  /* STB_OSC10 */
N            vCCR_PDS_UNLOCK();
X            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            vSetCCR_SCR(eMode);
X            (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N            __wfi();
N            break;
N        case CCR_DEVICE_MODE_SLP_OSC10:  /* SLP_OSC10 */
N            vCCR_PDS_UNLOCK();
X            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            vSetCCR_SCR(eMode);
X            (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N            __wfi();
N            break;
N        case CCR_DEVICE_MODE_SLP_RC10:   /* SLP_RC10 */
N            vCCR_PDS_UNLOCK();
X            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            vSetCCR_SCR(eMode);
X            (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N            __wfi();
N            break;
N        case CCR_DEVICE_MODE_STOP_R:     /* STOP_R */
N            /* if Device is currently performing state transition, then wait: */
N            while (biGetCCR_SYSDSR_MODESTAT() == 0)
X            while ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) == 0)
N            {
N                ;
N            }
N            vCCR_PDS_UNLOCK();
X            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            vSetCCR_SCR(eMode);
X            (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N            __wfi();
N            break;
N        case CCR_DEVICE_MODE_STOP:       /* STOP */
N            /* if Device is currently performing state transition, then wait: */
N            while (biGetCCR_SYSDSR_MODESTAT() == 0)
X            while ((((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT) == 0)
N            {
N                ;
N            }
N            vCCR_PDS_UNLOCK();
X            ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            vSetCCR_SCR(eMode);
X            (*((volatile u32CCR_SCR_word_view *)(0xC000003CU )) = (eMode));
N            __wfi();
N            break;
N        default:
N            i32Res = C_FAILED;
X            i32Res = (-1);
N        break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_EnableInterrupt(ccr_interrupts_e eInterrupt, ccr_enable_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eInterrupt)
N    {
N        case CCR_INTERRUPTS_STATE_CHANGE:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_INTER_MODEINTEN(eEn);
X                (((volatile CCR_INTER_bit_view_st *)(0xC0000040U )) -> MODEINTEN=(eEn));
N            }
N            break;
N        case CCR_INTERRUPTS_ALARM_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_INTER_ALARMINT0EN(eEn);
X                (((volatile CCR_INTER_bit_view_st *)(0xC0000040U )) -> ALARMINT0EN=(eEn));
N            }
N            break;
N        case CCR_INTERRUPTS_ALARM_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_INTER_ALARMINT1EN(eEn);
X                (((volatile CCR_INTER_bit_view_st *)(0xC0000040U )) -> ALARMINT1EN=(eEn));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N        break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nuint32_t u32CCR_GetInterruptStatusAll(void)
N{
N    return u32GetCCR_INTSR();
X    return (*((volatile u32CCR_INTSR_word_view *)(0xC0000044U )) );
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_GetInterruptStatusSingle(ccr_interrupts_e eInterrupt, ccr_int_occurred_e * peIntOccurred)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (0x00 != peIntOccurred)
N    {
N        switch(eInterrupt)
N        {
N            case CCR_INTERRUPTS_STATE_CHANGE:
N                {
N                    *peIntOccurred = (ccr_int_occurred_e)biGetCCR_INTSR_MODEINT();
X                    *peIntOccurred = (ccr_int_occurred_e)(((volatile CCR_INTSR_bit_view_st *)(0xC0000044U )) -> MODEINT);
N                }
N                break;
N            case CCR_INTERRUPTS_ALARM_0:
N                {
N                    *peIntOccurred = (ccr_int_occurred_e)biGetCCR_INTSR_ALARMINT0();
X                    *peIntOccurred = (ccr_int_occurred_e)(((volatile CCR_INTSR_bit_view_st *)(0xC0000044U )) -> ALARMINT0);
N                }
N                break;
N            case CCR_INTERRUPTS_ALARM_1:
N                {
N                    *peIntOccurred = (ccr_int_occurred_e)biGetCCR_INTSR_ALARMINT1();
X                    *peIntOccurred = (ccr_int_occurred_e)(((volatile CCR_INTSR_bit_view_st *)(0xC0000044U )) -> ALARMINT1);
N                }
N                break;
N            case CCR_INTERRUPTS_BECC:
N                {
N                    *peIntOccurred = (ccr_int_occurred_e)biGetCCR_INTSR_BKPRAM_ECCINT();
X                    *peIntOccurred = (ccr_int_occurred_e)(((volatile CCR_INTSR_bit_view_st *)(0xC0000044U )) -> BKPRAM_ECCINT);
N                }
N                break;
N            case CCR_INTERRUPTS_MECC:
N                {
N                    *peIntOccurred = (ccr_int_occurred_e)biGetCCR_INTSR_MM_ECCINT();
X                    *peIntOccurred = (ccr_int_occurred_e)(((volatile CCR_INTSR_bit_view_st *)(0xC0000044U )) -> MM_ECCINT);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N            break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_ClearInterruptsAll(void)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_INTCR(0x00030001);
X    (*((volatile u32CCR_INTCR_word_view *)(0xC0000048U )) = (0x00030001));
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_ClearInterruptSingle(ccr_interrupts_e eInterrupt)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eInterrupt)
N    {
N        case CCR_INTERRUPTS_STATE_CHANGE:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_INTCR_MODEINTC(1U);
X                (((volatile CCR_INTCR_bit_view_st *)(0xC0000048U )) -> MODEINTC=(1U));
N            }
N            break;
N        case CCR_INTERRUPTS_ALARM_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_INTCR_ALARMINT0C(1U);
X                (((volatile CCR_INTCR_bit_view_st *)(0xC0000048U )) -> ALARMINT0C=(1U));
N            }
N            break;
N        case CCR_INTERRUPTS_ALARM_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_INTCR_ALARMINT1C(1U);
X                (((volatile CCR_INTCR_bit_view_st *)(0xC0000048U )) -> ALARMINT1C=(1U));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N        break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nccr_device_mode_e eCCR_GetCurrentDeviceMode(void)
N{
N    uint32_t u32DeviceMode;
N    ccr_device_mode_e eResult;
N
N    u32DeviceMode = biGetCCR_SYSDSR_MODESTAT();
X    u32DeviceMode = (((volatile CCR_SYSDSR_bit_view_st *)(0xC000004CU )) -> MODESTAT);
N    switch (u32DeviceMode)
N    {
N        case 0x00000001:
N            {
N                eResult = CCR_DEVICE_MODE_M_PLL;
N            }
N            break;
N        case 0x00000010:
N            {
N                eResult = CCR_DEVICE_MODE_M_OSC10;
N            }
N            break;
N        case 0x00000100:
N            {
N                eResult = CCR_DEVICE_MODE_STB_OSC10;
N            }
N            break;
N        case 0x00001000:
N            {
N                eResult = CCR_DEVICE_MODE_SLP_OSC10;
N            }
N            break;
N        case 0x00010000:
N            {
N                eResult = CCR_DEVICE_MODE_SLP_RC10;
N            }
N            break;
N        case 0x00100000:
N            {
N                eResult = CCR_DEVICE_MODE_STOP_R;
N            }
N            break;
N        case 0x01000000:
N            {
N                eResult = CCR_DEVICE_MODE_STOP;
N            }
N            break;
N        default:
N            {
N                eResult = CCR_DEVICE_MODE_TRANSITION;
N            }
N            break;
N    }
N    return eResult;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_ConfigureSSCG(ccr_sscg_congig_st * pstSSCGConfig)
N{
N    if (0x00 != pstSSCGConfig)
N    {
N        vCCR_PDS_UNLOCK();
X        ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N         vSetCCR_SSCPLL_CTRL0_SSCPLL_MODTYPE( (uint8_t)(pstSSCGConfig->eModulationDirection) );
X         (((volatile CCR_SSCPLL_CTRL0_bit_view_st *)(0xC0000050U )) -> SSCPLL_MODTYPE=((uint8_t)(pstSSCGConfig->eModulationDirection)));
N
N         vCCR_PDS_UNLOCK();
X         ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N         vSetCCR_SSCPLL_CTRL2_SSCPLL_FNLEN( (uint8_t)(pstSSCGConfig->u8ModulationCycleLengthFractionalN) );
X         (((volatile CCR_SSCPLL_CTRL2_bit_view_st *)(0xC0000058U )) -> SSCPLL_FNLEN=((uint8_t)(pstSSCGConfig->u8ModulationCycleLengthFractionalN)));
N
N         vCCR_PDS_UNLOCK();
X         ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N         vSetCCR_SSCPLL_CTRL2_SSCPLL_DSFT( (uint32_t)(pstSSCGConfig->u16ModulationDegree) );
X         (((volatile CCR_SSCPLL_CTRL2_bit_view_st *)(0xC0000058U )) -> SSCPLL_DSFT=((uint32_t)(pstSSCGConfig->u16ModulationDegree)));
N
N         /* give reset to SSCG to apply new settings */
N         vCCR_PDS_UNLOCK();
X         ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N         vSetCCR_SSCPLL_CTRL0_SSCPLL_RESET(1U);
X         (((volatile CCR_SSCPLL_CTRL0_bit_view_st *)(0xC0000050U )) -> SSCPLL_RESET=(1U));
N    }
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetWDTAlarmType(ccr_wdt_alarm_type_e eAlarmType)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG0_ALMWDT_RST_NMI(eAlarmType);
X    (((volatile CCR_GENERIC_REG0_bit_view_st *)(0xC0000064U )) -> ALMWDT_RST_NMI=(eAlarmType));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableBitErrorInjectionInRAM(ccr_enable_e eEn)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG0_BEINJB(eEn);
X    (((volatile CCR_GENERIC_REG0_bit_view_st *)(0xC0000064U )) -> BEINJB=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetPositionOfBitErrorInjectionInRAM(uint8_t u8FirstPosition, uint8_t u8SecondPosition)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG0_BEPAB(u8FirstPosition);
X    (((volatile CCR_GENERIC_REG0_bit_view_st *)(0xC0000064U )) -> BEPAB=(u8FirstPosition));
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG0_BEPBB(u8SecondPosition);
X    (((volatile CCR_GENERIC_REG0_bit_view_st *)(0xC0000064U )) -> BEPBB=(u8SecondPosition));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetCANMode(ccr_can_mode_e eCANMode)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_CANMODE(eCANMode);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> CANMODE=(eCANMode));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetECCMode(ccr_ecc_mode_e eECCMode)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_ECCM(eECCMode);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> ECCM=(eECCMode));
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetTBIODirection(ccr_tbio_channel_e eTBIOChannel, ccr_tbio_direction_e eDirection)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eTBIOChannel)
N    {
N        case CCR_TBIO_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO0_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO0_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO1_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO1_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_2:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO2_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO2_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_3:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO3_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO3_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_6:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO6_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO6_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_7:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO7_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO7_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_8:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO8_DIR(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO8_DIR=(eDirection));
N            }
N            break;
N        case CCR_TBIO_9:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG1_TBIO9_SEL(eDirection);
X                (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIO9_SEL=(eDirection));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetInputForComplexTimer4(ccr_tbin_source_ctimer4_e eSource)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_TBIN4_SEL(eSource);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIN4_SEL=(eSource));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetInputForComplexTimer5(ccr_tbin_source_ctimer5_e eSource)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_TBIN5_SEL(eSource);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> TBIN5_SEL=(eSource));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableGDC0Interface(ccr_enable_e eEn)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_DISP0ON(eEn);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> DISP0ON=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableGDC1Interface(ccr_enable_e eEn)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_DISP1ON(eEn);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> DISP1ON=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableGDCPanelInterface(ccr_enable_e eEn)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_PNLON(eEn);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> PNLON=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_SetGDCSynchronisation(ccr_gdc_sync_e eGDCSync)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERIC_REG1_S0EXTS1(eGDCSync);
X    (((volatile CCR_GENERIC_REG1_bit_view_st *)(0xC0000068U )) -> S0EXTS1=(eGDCSync));
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetNORAddressMask(ccr_nor_channel_e eChannel, uint16_t u16AddressMask)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eChannel)
N    {
N        case CCR_NOR_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG2_ADDR_MASK0_0(u16AddressMask);
X                (((volatile CCR_GENERIC_REG2_bit_view_st *)(0xC000006CU )) -> ADDR_MASK0_0=(u16AddressMask));
N            }
N            break;
N        case CCR_NOR_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG2_ADDR_MASK0_1(u16AddressMask);
X                (((volatile CCR_GENERIC_REG2_bit_view_st *)(0xC000006CU )) -> ADDR_MASK0_1=(u16AddressMask));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetNORAddressMatch(ccr_nor_channel_e eChannel, uint16_t u16AddressMatch)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eChannel)
N    {
N        case CCR_NOR_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG2_ADDR_MATCH0_0(u16AddressMatch);
X                (((volatile CCR_GENERIC_REG2_bit_view_st *)(0xC000006CU )) -> ADDR_MATCH0_0=(u16AddressMatch));
N            }
N            break;
N        case CCR_NOR_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG2_ADDR_MATCH0_1(u16AddressMatch);
X                (((volatile CCR_GENERIC_REG2_bit_view_st *)(0xC000006CU )) -> ADDR_MATCH0_1=(u16AddressMatch));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetNANDAddressMask(ccr_nand_channel_e eChannel, uint16_t u16AddressMask)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eChannel)
N    {
N        case CCR_NAND_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG3_ADDR_MASK1_0(u16AddressMask);
X                (((volatile CCR_GENERIC_REG3_bit_view_st *)(0xC0000070U )) -> ADDR_MASK1_0=(u16AddressMask));
N            }
N            break;
N        case CCR_NAND_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG3_ADDR_MASK1_1(u16AddressMask);
X                (((volatile CCR_GENERIC_REG3_bit_view_st *)(0xC0000070U )) -> ADDR_MASK1_1=(u16AddressMask));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetNANDAddressMatch(ccr_nand_channel_e eChannel, uint16_t u16AddressMatch)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eChannel)
N    {
N        case CCR_NAND_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG3_ADDR_MATCH1_0(u16AddressMatch);
X                (((volatile CCR_GENERIC_REG3_bit_view_st *)(0xC0000070U )) -> ADDR_MATCH1_0=(u16AddressMatch));
N            }
N            break;
N        case CCR_NAND_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG3_ADDR_MATCH1_1(u16AddressMatch);
X                (((volatile CCR_GENERIC_REG3_bit_view_st *)(0xC0000070U )) -> ADDR_MATCH1_1=(u16AddressMatch));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid  vCCR_SetNORChipSelect(uint32_t u32Value)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N    /* write complete register for NOT chip select:*/
N    vSetCCR_GENERIC_REG2(u32Value);
X    (*((volatile u32CCR_GENERIC_REG2_word_view *)(0xC000006CU )) = (u32Value));
N}
N
N
N/****************************************************************************/
Nvoid  vCCR_SetNANDChipSelect(uint32_t u32Value)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N
N    /* write complete register for NOT chip select:*/
N    vSetCCR_GENERIC_REG3(u32Value);
X    (*((volatile u32CCR_GENERIC_REG3_word_view *)(0xC0000070U )) = (u32Value));
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_EnableSRAMBitErrorInspection(ccr_sram_channel_e eChannel, ccr_enable_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eChannel)
N    {
N        case CCR_SRAM_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG4_BEINJ0(eEn);
X                (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEINJ0=(eEn));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG4_BEINJ1(eEn);
X                (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEINJ1=(eEn));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_2:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG5_BEINJ2(eEn);
X                (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEINJ2=(eEn));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_3:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERIC_REG5_BEINJ3(eEn);
X                (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEINJ3=(eEn));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetSRAMBitErrorInspectionConfiguration(ccr_sram_channel_e eChannel, ccr_sram_bit_error_insp_config_st * pstConfig)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (0x00 != pstConfig)
N    {
N        switch(eChannel)
N        {
N            case CCR_SRAM_CHANNEL_0:
N                {
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG4_BEPA0(pstConfig -> u8PosFirstError);
X                    (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEPA0=(pstConfig -> u8PosFirstError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG4_BEPB0(pstConfig -> u8PosSecondError);
X                    (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEPB0=(pstConfig -> u8PosSecondError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG4_BEBSEL0(pstConfig -> u8ByteSelect);
X                    (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEBSEL0=(pstConfig -> u8ByteSelect));
N                }
N                break;
N            case CCR_SRAM_CHANNEL_1:
N                {
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG4_BEPA1(pstConfig -> u8PosFirstError);
X                    (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEPA1=(pstConfig -> u8PosFirstError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG4_BEPB1(pstConfig -> u8PosSecondError);
X                    (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEPB1=(pstConfig -> u8PosSecondError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG4_BEBSEL1(pstConfig -> u8ByteSelect);
X                    (((volatile CCR_GENERIC_REG4_bit_view_st *)(0xC0000074U )) -> BEBSEL1=(pstConfig -> u8ByteSelect));
N                }
N                break;
N            case CCR_SRAM_CHANNEL_2:
N                {
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG5_BEPA2(pstConfig -> u8PosFirstError);
X                    (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEPA2=(pstConfig -> u8PosFirstError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG5_BEPB2(pstConfig -> u8PosSecondError);
X                    (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEPB2=(pstConfig -> u8PosSecondError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG5_BEBSEL2(pstConfig -> u8ByteSelect);
X                    (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEBSEL2=(pstConfig -> u8ByteSelect));
N                }
N                break;
N            case CCR_SRAM_CHANNEL_3:
N                {
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG5_BEPA3(pstConfig -> u8PosFirstError);
X                    (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEPA3=(pstConfig -> u8PosFirstError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG5_BEPB3(pstConfig -> u8PosSecondError);
X                    (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEPB3=(pstConfig -> u8PosSecondError));
N                    vCCR_PDS_UNLOCK();
X                    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetCCR_GENERIC_REG5_BEBSEL3(pstConfig -> u8ByteSelect);
X                    (((volatile CCR_GENERIC_REG5_bit_view_st *)(0xC0000078U )) -> BEBSEL3=(pstConfig -> u8ByteSelect));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_ClearWDTAlarm(void)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERICAC_REG0_WDT_ALMCLR(1U);
X    (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> WDT_ALMCLR=(1U));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_ClearErrorIrgFlagOfBackupRAM(void)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERICAC_REG0_ECCECLRB(1U);
X    (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRB=(1U));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_ClearWarningIrgFlagOfBackupRAM(void)
N{
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERICAC_REG0_ECCWCLRB(1U);
X    (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCWCLRB=(1U));
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_ClearErrorIrgFlagOfSRAM(ccr_sram_channel_e eChannel)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERICAC_REG0_ECCECLRB(1U);
X    (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRB=(1U));
N
N    switch(eChannel)
N    {
N        case CCR_SRAM_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCECLRS(0x1);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRS=(0x1));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCECLRS(0x2);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRS=(0x2));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_2:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCECLRS(0x4);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRS=(0x4));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_3:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCECLRS(0x8);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRS=(0x8));
N            }
N            break;
N        default:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_ClearWarningIrgFlagOfSRAM(ccr_sram_channel_e eChannel)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERICAC_REG0_ECCECLRB(1U);
X    (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRB=(1U));
N
N    switch (eChannel)
N    {
N        case CCR_SRAM_CHANNEL_0:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCWCLRS(0x1);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCWCLRS=(0x1));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_1:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCWCLRS(0x2);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCWCLRS=(0x2));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_2:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCWCLRS(0x4);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCWCLRS=(0x4));
N            }
N            break;
N        case CCR_SRAM_CHANNEL_3:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_ECCWCLRS(0x8);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCWCLRS=(0x8));
N            }
N            break;
N        default:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_IssueSynchronPulseToCTimer(ccr_complex_timer_e eComplexTimer)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    vCCR_PDS_UNLOCK();
X    ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetCCR_GENERICAC_REG0_ECCECLRB(1U);
X    (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> ECCECLRB=(1U));
N
N    switch (eComplexTimer)
N    {
N        case CCR_COMPLEX_TIMER_0_TO_5:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_CPXTSYN_PM(1U);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> CPXTSYN_PM=(1U));
N            }
N            break;
N        case CCR_COMPLEX_TIMER_6_TO_9:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetCCR_GENERICAC_REG0_CPXTSYN_PNM(1U);
X                (((volatile CCR_GENERICAC_REG0_bit_view_st *)(0xC0000084U )) -> CPXTSYN_PNM=(1U));
N            }
N            break;
N        default:
N            {
N                vCCR_PDS_UNLOCK();
X                ((((volatile CCR_KEYR_bit_view_st *)(0xC0000000U )) -> KEYVAL=(0xA5C0F17BU)));
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetWDTAlarmStatusBit(void)
N{
N    return (ccr_enable_e)biGetCCR_GENERICSTAT_REG0_WDT_ALARM();
X    return (ccr_enable_e)(((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(0xC000008CU )) -> WDT_ALARM);
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetIRQErrorFlafForBackupRAM(void)
N{
N    return (ccr_enable_e)biGetCCR_GENERICSTAT_REG0_ECCERRB();
X    return (ccr_enable_e)(((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(0xC000008CU )) -> ECCERRB);
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetIRQWarningFlafForBackupRAM(void)
N{
N    return (ccr_enable_e)biGetCCR_GENERICSTAT_REG0_ECCWRNB();
X    return (ccr_enable_e)(((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(0xC000008CU )) -> ECCWRNB);
N}
N
N
N/****************************************************************************/
Nuint8_t u8CCR_GetPosOfBitErrorInBackupRAM(void)
N{
N    return (uint8_t)biGetCCR_GENERICSTAT_REG0_BEPOSB();
X    return (uint8_t)(((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(0xC000008CU )) -> BEPOSB);
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetLastCheckResultForBackupRAM(void)
N{
N    return (ccr_enable_e)biGetCCR_GENERICSTAT_REG0_BERESB();
X    return (ccr_enable_e)(((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(0xC000008CU )) -> BERESB);
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetDebuggerCR4PowerDownRequestStatus(void)
N{
N    return (ccr_enable_e)biGetCCR_GENERICSTAT_REG0_CR4DBGNOPWRDWN();
X    return (ccr_enable_e)(((volatile CCR_GENERICSTAT_REG0_bit_view_st *)(0xC000008CU )) -> CR4DBGNOPWRDWN);
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_GetSRAMIrgErrorCondition(ccr_sram_channel_e eChannel, ccr_enable_e * peEn)
N{
N    uint32_t u32Enb = 0U;
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    if (0x00 != peEn)
N    {
N        switch(eChannel)
N        {
N            case CCR_SRAM_CHANNEL_0:
N                {
N                    u32Enb = 0x1U & biGetCCR_GENERICSTAT_REG1_ECCERRS();
X                    u32Enb = 0x1U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCERRS);
N                }
N                break;
N            case CCR_SRAM_CHANNEL_1:
N                {
N                    u32Enb = ( 0x2U & biGetCCR_GENERICSTAT_REG1_ECCERRS() ) >> 1U;
X                    u32Enb = ( 0x2U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCERRS) ) >> 1U;
N                }
N                break;
N            case CCR_SRAM_CHANNEL_2:
N                {
N                    u32Enb = ( 0x4U & biGetCCR_GENERICSTAT_REG1_ECCERRS() ) >> 2U;
X                    u32Enb = ( 0x4U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCERRS) ) >> 2U;
N                }
N                break;
N            case CCR_SRAM_CHANNEL_3:
N                {
N                    u32Enb = ( 0x8U & biGetCCR_GENERICSTAT_REG1_ECCERRS() ) >> 3U;
X                    u32Enb = ( 0x8U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCERRS) ) >> 3U;
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N        if (C_SUCCESS == i32Res)
X        if ((0) == i32Res)
N        {
N            *peEn = (ccr_enable_e) u32Enb;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_GetSRAMIrgWarningCondition(ccr_sram_channel_e eChannel, ccr_enable_e * peEn)
N{
N    uint32_t u32Enb = 0U;
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    if (0x00 != peEn)
N    {
N        switch(eChannel)
N        {
N            case CCR_SRAM_CHANNEL_0:
N                {
N                    u32Enb = 0x1U & biGetCCR_GENERICSTAT_REG1_ECCWRNS();
X                    u32Enb = 0x1U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCWRNS);
N                }
N                break;
N            case CCR_SRAM_CHANNEL_1:
N                {
N                    u32Enb = ( 0x2U & biGetCCR_GENERICSTAT_REG1_ECCWRNS() ) >> 1U;
X                    u32Enb = ( 0x2U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCWRNS) ) >> 1U;
N                }
N                break;
N            case CCR_SRAM_CHANNEL_2:
N                {
N                    u32Enb = ( 0x4U & biGetCCR_GENERICSTAT_REG1_ECCWRNS() ) >> 2U;
X                    u32Enb = ( 0x4U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCWRNS) ) >> 2U;
N                }
N                break;
N            case CCR_SRAM_CHANNEL_3:
N                {
N                    u32Enb = ( 0x8U & biGetCCR_GENERICSTAT_REG1_ECCWRNS() ) >> 3U;
X                    u32Enb = ( 0x8U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> ECCWRNS) ) >> 3U;
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N        if (C_SUCCESS == i32Res)
X        if ((0) == i32Res)
N        {
N            *peEn = (ccr_enable_e) u32Enb;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_GetSRAMPositionOfBitError(ccr_sram_channel_e eChannel, uint8_t * pu8Position)
N{
N    uint32_t u32Position = 0U;
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (0x00 != pu8Position)
N    {
N        switch(eChannel)
N        {
N            case CCR_SRAM_CHANNEL_0:
N                {
N                    u32Position = 0x1FU & biGetCCR_GENERICSTAT_REG1_BEPOSS();
X                    u32Position = 0x1FU & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BEPOSS);
N                }
N                break;
N            case CCR_SRAM_CHANNEL_1:
N                {
N                    u32Position = 0x1FU & (biGetCCR_GENERICSTAT_REG1_BEPOSS() >> 5);
X                    u32Position = 0x1FU & ((((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BEPOSS) >> 5);
N                }
N                break;
N            case CCR_SRAM_CHANNEL_2:
N                {
N                    u32Position = 0x1FU & (biGetCCR_GENERICSTAT_REG1_BEPOSS() >> 10);
X                    u32Position = 0x1FU & ((((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BEPOSS) >> 10);
N                }
N                break;
N            case CCR_SRAM_CHANNEL_3:
N                {
N                    u32Position = 0x1FU & (biGetCCR_GENERICSTAT_REG1_BEPOSS() >> 15);
X                    u32Position = 0x1FU & ((((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BEPOSS) >> 15);
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N        if (C_SUCCESS == i32Res)
X        if ((0) == i32Res)
N        {
N            *pu8Position = (uint8_t) u32Position;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_GetSRAMLastCheckResult(ccr_sram_channel_e eChannel, ccr_enable_e * peEn)
N{
N    uint32_t u32Enb = 0U;
N    int32_t  i32Res = C_SUCCESS;
X    int32_t  i32Res = (0);
N
N    if (0x00 != peEn)
N    {
N        switch(eChannel)
N        {
N            case CCR_SRAM_CHANNEL_0:
N                {
N                    u32Enb = 0x1U & biGetCCR_GENERICSTAT_REG1_BERESS();
X                    u32Enb = 0x1U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BERESS);
N                }
N                break;
N            case CCR_SRAM_CHANNEL_1:
N                {
N                    u32Enb = ( 0x2U & biGetCCR_GENERICSTAT_REG1_BERESS() ) >> 1U;
X                    u32Enb = ( 0x2U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BERESS) ) >> 1U;
N                }
N                break;
N            case CCR_SRAM_CHANNEL_2:
N                {
N                    u32Enb = ( 0x4U & biGetCCR_GENERICSTAT_REG1_BERESS() ) >> 2U;
X                    u32Enb = ( 0x4U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BERESS) ) >> 2U;
N                }
N                break;
N            case CCR_SRAM_CHANNEL_3:
N                {
N                    u32Enb = ( 0x8U & biGetCCR_GENERICSTAT_REG1_BERESS() ) >> 3U;
X                    u32Enb = ( 0x8U & (((volatile CCR_GENERICSTAT_REG1_bit_view_st *)(0xC0000090U )) -> BERESS) ) >> 3U;
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N        if (C_SUCCESS == i32Res)
X        if ((0) == i32Res)
N        {
N            *peEn = (ccr_enable_e) u32Enb;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nccr_device_version_e eCCR_GetDeviceVersion(void)
N{
N    return (ccr_device_version_e)biGetPDHR_VER_VER();
X    return (ccr_device_version_e)(((volatile PDHR_VER_bit_view_st *)(0xC000040CU )) -> VER);
N}
N
N
N/****************************************************************************/
Nccr_SIPflash_size_e eCCR_GetSIPFlashSize(void)
N{
N    return (ccr_SIPflash_size_e)biGetPDHR_VER_FLASH_SIZE();
X    return (ccr_SIPflash_size_e)(((volatile PDHR_VER_bit_view_st *)(0xC000040CU )) -> FLASH_SIZE);
N}
N
N/****************************************************************************/
Nccr_enable_e eCCR_GeCR4DebugStatus(void)
N{
N    uint32_t      u32Cr4Dbg;
N    ccr_enable_e  eResult;
N
N    /* Check the JTAG port control-bit value */
N    u32Cr4Dbg = biGetPDHR_DBG_CR4DEBUG();
X    u32Cr4Dbg = (((volatile PDHR_DBG_bit_view_st *)(0xC0000410U )) -> CR4DEBUG);
N
N    /* if bit value is '1' - JTAG is Disabled */
N    if(CCR_DEBUG_CTRL_BIT == (u32Cr4Dbg & CCR_DEBUG_CTRL_BIT))
X    if((0x1U) == (u32Cr4Dbg & (0x1U)))
N    {
N        eResult = CCR_DISABLE;
N    }
N    else   /* if bit value is '0' - JTAG is Enabled */
N    {
N        eResult = CCR_ENABLE;
N    }
N    return eResult;
N}
N
N/****************************************************************************/
Nint32_t i32CCR_EnableR4DebugPort(ccr_processor_device_e eProcessorType, ccr_enable_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eProcessorType)
N    {
N        case CCR_CR4:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                if (CCR_ENABLE == eEn)
N                {
N                    vSetPDHR_DBG_CR4DEBUG((uint16_t)CCR_DISABLE);
X                    (((volatile PDHR_DBG_bit_view_st *)(0xC0000410U )) -> CR4DEBUG=((uint16_t)CCR_DISABLE));
N                }
N                else
N                {
N                    vSetPDHR_DBG_CR4DEBUG((uint16_t)CCR_ENABLE);
X                    (((volatile PDHR_DBG_bit_view_st *)(0xC0000410U )) -> CR4DEBUG=((uint16_t)CCR_ENABLE));
N                }
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetVRegCurrentTrim(ccr_vreg_current_trim_e eValue)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eValue <= CCR_VREG_CURRENT_TRIM_M_10_PROZ)
N    {
N        vCCR_PDH_UNLOCK();
X        ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N        vSetPDHR_VREGCR_VREG_IT(eValue);
X        (((volatile PDHR_VREGCR_bit_view_st *)(0xC0000414U )) -> VREG_IT=(eValue));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetVRegRefVoltageTrim(ccr_vreg_ref_voltage_trim_e eValue)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eValue <= CCR_VREG_REF_VOLTAGE_TRIM_P_0_5_PROZ)
N    {
N        vCCR_PDH_UNLOCK();
X        ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N        vSetPDHR_VREGCR_VREG_VT(eValue);
X        (((volatile PDHR_VREGCR_bit_view_st *)(0xC0000414U )) -> VREG_VT=(eValue));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetVRegTemperatureTrim(ccr_vreg_temperature_trim_e eValue)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eValue <= CCR_VREG_TEMPERATURE_TRIM_M_25_DEGC)
N    {
N        vCCR_PDH_UNLOCK();
X        ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N        vSetPDHR_VREGCR_VREG_TT(eValue);
X        (((volatile PDHR_VREGCR_bit_view_st *)(0xC0000414U )) -> VREG_TT=(eValue));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetOscAdjustment(ccr_osc_adjustment_e eValue)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eValue <= CCR_OSC_ADJUSTMENT_M_1)
N    {
N        vCCR_PDH_UNLOCK();
X        ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N        vSetPDHR_ANACR_RCOSC_ADJUST(eValue);
X        (((volatile PDHR_ANACR_bit_view_st *)(0xC0000418U )) -> RCOSC_ADJUST=(eValue));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetThresholdPowerGoodSensing(ccr_threshold_power_good_sensing_e eValue)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eValue <= CCR_POWER_GOOD_SENSING_4)
N    {
N        vCCR_PDH_UNLOCK();
X        ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N        vSetPDHR_ANACR_LVD_THRSH(eValue);
X        (((volatile PDHR_ANACR_bit_view_st *)(0xC0000418U )) -> LVD_THRSH=(eValue));
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetAlarmComparatorThreshold(ccr_alarm_no_e eAlarmNo, uint8_t u8Value)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (u8Value <= MAX_ALARM_THRESHOLD)
X    if (u8Value <= 31)
N    {
N        vCCR_PDH_UNLOCK();
X        ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N        if (CCR_ALARM_0 == eAlarmNo)
N        {
N            vSetPDHR_ALAMCR_ALM_THRSH0(u8Value);
X            (((volatile PDHR_ALAMCR_bit_view_st *)(0xC000041CU )) -> ALM_THRSH0=(u8Value));
N        }
N        else
N        {
N            vSetPDHR_ALAMCR_ALM_THRSH1(u8Value);
X            (((volatile PDHR_ALAMCR_bit_view_st *)(0xC000041CU )) -> ALM_THRSH1=(u8Value));
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableAlarm(ccr_alarm_no_e eAlarmNo, ccr_enable_e eEn)
N{
N    vCCR_PDH_UNLOCK();
X    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N
N    if (CCR_ALARM_0 == eAlarmNo)
N    {
N        vSetPDHR_ALAMCR_ALM_EN_0(eEn);
X        (((volatile PDHR_ALAMCR_bit_view_st *)(0xC000041CU )) -> ALM_EN_0=(eEn));
N    }
N    else
N    {
N        vSetPDHR_ALAMCR_ALM_EN_1(eEn);
X        (((volatile PDHR_ALAMCR_bit_view_st *)(0xC000041CU )) -> ALM_EN_1=(eEn));
N    }
N}
N
N/****************************************************************************/
Nint32_t i32CCR_EnableClockSupervisor(ccr_clocks_e eClocks, ccr_enable_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eClocks <= CCR_OSC32K)
N    {
N        switch (eClocks)
N        {
N            case CCR_OSC10M:
N                {
N                    vCCR_PDH_UNLOCK();
X                    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetPDHR_CSVOSC10M_CSV_OSC10MEN((uint16_t)eEn);
X                    (((volatile PDHR_CSVOSC10M_bit_view_st *)(0xC0000420U )) -> CSV_OSC10MEN=((uint16_t)eEn));
N                }
N                break;
N            case CCR_OSC32K:
N                {
N                    vCCR_PDH_UNLOCK();
X                    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetPDHR_CSVOSC32KEN_CSV_OSC32KEN((uint8_t)eEn);
X                    (((volatile PDHR_CSVOSC32KEN_bit_view_st *)(0xC0000424U )) -> CSV_OSC32KEN=((uint8_t)eEn));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableOSC10MClockSupervisorOutputResetFunction(ccr_enable_e eEn)
N{
N    vCCR_PDH_UNLOCK();
X    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetPDHR_CSVOSC10M_CSV_OSC10MRST(eEn);
X    (((volatile PDHR_CSVOSC10M_bit_view_st *)(0xC0000420U )) -> CSV_OSC10MRST=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_EnableOSC32KHz(ccr_enable_e eEn)
N{
N    vCCR_PDH_UNLOCK();
X    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetPDHR_CFGR_OSC32KD(eEn);
X    (((volatile PDHR_CFGR_bit_view_st *)(0xC0000428U )) -> OSC32KD=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vCCR_ConfigureSmcIOLevel(ccr_smc_io_level_e eLevel)
N{
N    vCCR_PDH_UNLOCK();
X    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N    vSetPDHR_CFGR_SMC3VONLY(eLevel);
X    (((volatile PDHR_CFGR_bit_view_st *)(0xC0000428U )) -> SMC3VONLY=(eLevel));
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetClockStabilizationCompareValue(ccr_clocks_e eClocks, uint8_t u8Value)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    if (eClocks <= CCR_OSC32K)
N    {
N        switch (eClocks)
N        {
N            case CCR_OSC10M:
N                {
N                    vCCR_PDH_UNLOCK();
X                    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetPDHR_SBCR_OSC10MSTBC(u8Value);
X                    (((volatile PDHR_SBCR_bit_view_st *)(0xC000042CU )) -> OSC10MSTBC=(u8Value));
N                }
N                break;
N            case CCR_OSC32K:
N                {
N                    vCCR_PDH_UNLOCK();
X                    ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                    vSetPDHR_SBCR_OSC32KSTBC(u8Value);
X                    (((volatile PDHR_SBCR_bit_view_st *)(0xC000042CU )) -> OSC32KSTBC=(u8Value));
N                }
N                break;
N            default:
N                {
N                    i32Res = C_FAILED;
X                    i32Res = (-1);
N                }
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nuint16_t u16CCR_GetBootOptions(void)
N{
N    return u16GetPDHR_BOOTOPT();
X    return (*((volatile u16PDHR_BOOTOPT_halfword_view *)(0xC0000430U )) );
N}
N
N
N/****************************************************************************/
Nuint32_t u32CCR_GetSystemIntStatusAll(void)
N{
N    return u32GetPDHR_INTSR();
X    return (*((volatile u32PDHR_INTSR_word_view *)(0xC0000434U )) );
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetSystemIntStatusSingle(ccr_system_interrupt_e eInt)
N{
N    ccr_enable_e eEn;
N
N    switch(eInt)
N    {
N        case CCR_OSC10M_CLOCK_MISSING_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_CSV10MINT();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> CSV10MINT);
N            }
N            break;
N        case CCR_OSC32K_CLOCK_MISSING_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_CSV32KINT();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> CSV32KINT);
N            }
N            break;
N        case CCR_EROR_INT_0:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_ERRINT0();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> ERRINT0);
N            }
N            break;
N        case CCR_EROR_INT_1:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_ERRINT1();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> ERRINT1);
N            }
N            break;
N        case CCR_EROR_INT_2:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_ERRINT2();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> ERRINT2);
N            }
N            break;
N        case CCR_BACKUP_ECC_RAM_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_BKPRAM_ECCNMI();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> BKPRAM_ECCNMI);
N            }
N            break;
N        case CCR_MAIN_MEMORY_ECC_RAM_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_MM_ECCNMI();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> MM_ECCNMI);
N            }
N            break;
N        case CCR_STPU_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_STPU_NMI();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> STPU_NMI);
N            }
N            break;
N        case CCR_WDT_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_WDT_NMI();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> WDT_NMI);
N            }
N            break;
N        case CCR_IO_INT:
N            {
N                eEn = (ccr_enable_e)biGetPDHR_INTSR_IO_NMI();
X                eEn = (ccr_enable_e)(((volatile PDHR_INTSR_bit_view_st *)(0xC0000434U )) -> IO_NMI);
N            }
N            break;
N        default:
N            {
N                eEn = CCR_DISABLE;
N            }
N            break;
N    }
N
N    return eEn;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_ClearSystemIntStatusSingle(ccr_system_interrupt_e eInt)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eInt)
N    {
N        case CCR_OSC10M_CLOCK_MISSING_INT:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_INTCR_CSV10MINTC(1U);
X                (((volatile PDHR_INTCR_bit_view_st *)(0xC0000438U )) -> CSV10MINTC=(1U));
N            }
N            break;
N        case CCR_OSC32K_CLOCK_MISSING_INT:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_INTCR_CSV32KINTC(1U);
X                (((volatile PDHR_INTCR_bit_view_st *)(0xC0000438U )) -> CSV32KINTC=(1U));
N            }
N            break;
N        case CCR_EROR_INT_0:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_INTCR_ERRINT0C(1U);
X                (((volatile PDHR_INTCR_bit_view_st *)(0xC0000438U )) -> ERRINT0C=(1U));
N            }
N            break;
N        case CCR_EROR_INT_1:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_INTCR_ERRINT1C(1U);
X                (((volatile PDHR_INTCR_bit_view_st *)(0xC0000438U )) -> ERRINT1C=(1U));
N            }
N            break;
N        case CCR_EROR_INT_2:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_INTCR_ERRINT2C(1U);
X                (((volatile PDHR_INTCR_bit_view_st *)(0xC0000438U )) -> ERRINT2C=(1U));
N            }
N            break;
N        case CCR_IO_INT:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_INTCR_IO_NMIC(1U);
X                (((volatile PDHR_INTCR_bit_view_st *)(0xC0000438U )) -> IO_NMIC=(1U));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_EnableECCInterrupt(ccr_ecc_e eEccType, ccr_ecc_interrupt_type_e eEccIntType)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eEccType)
N    {
N        case CCR_BACKUP_RAM_ECC:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_ECCEN_BKPRAM_ECCEN(eEccIntType);
X                (((volatile PDHR_ECCEN_bit_view_st *)(0xC000043CU )) -> BKPRAM_ECCEN=(eEccIntType));
N            }
N            break;
N        case CCR_MAIN_MEMORY_ECC:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_ECCEN_MM_ECCEN(eEccIntType);
X                (((volatile PDHR_ECCEN_bit_view_st *)(0xC000043CU )) -> MM_ECCEN=(eEccIntType));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nuint8_t u8CCR_GetDeviceModesAll(void)
N{
N    return u8GetPDHR_PRVSTATE();
X    return (*((volatile u8PDHR_PRVSTATE_byte_view *)(0xC0000440U )) );
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetDeviceModesSingle(ccr_modes_e eMode)
N{
N    ccr_enable_e eActive;
N
N    switch(eMode)
N    {
N        case CCR_STB_MODE:
N            {
N                eActive = (ccr_enable_e)biGetPDHR_PRVSTATE_STB_MODE();
X                eActive = (ccr_enable_e)(((volatile PDHR_PRVSTATE_bit_view_st *)(0xC0000440U )) -> STB_MODE);
N            }
N            break;
N        case CCR_SLPOSC10_MODE:
N            {
N                eActive = (ccr_enable_e)biGetPDHR_PRVSTATE_SLPOSC10_MODE();
X                eActive = (ccr_enable_e)(((volatile PDHR_PRVSTATE_bit_view_st *)(0xC0000440U )) -> SLPOSC10_MODE);
N            }
N            break;
N        case CCR_SLPRCOSC_MODE:
N            {
N                eActive = (ccr_enable_e)biGetPDHR_PRVSTATE_SLPRCOSC_MODE();
X                eActive = (ccr_enable_e)(((volatile PDHR_PRVSTATE_bit_view_st *)(0xC0000440U )) -> SLPRCOSC_MODE);
N            }
N            break;
N        case CCR_STOPR_MODE:
N            {
N                eActive = (ccr_enable_e)biGetPDHR_PRVSTATE_STOPR_MODE();
X                eActive = (ccr_enable_e)(((volatile PDHR_PRVSTATE_bit_view_st *)(0xC0000440U )) -> STOPR_MODE);
N            }
N            break;
N        case CCR_STOP_MODE:
N            {
N                eActive = (ccr_enable_e)biGetPDHR_PRVSTATE_STOP_MODE();
X                eActive = (ccr_enable_e)(((volatile PDHR_PRVSTATE_bit_view_st *)(0xC0000440U )) -> STOP_MODE);
N            }
N            break;
N        default:
N            {
N                eActive = CCR_DISABLE;
N            }
N            break;
N    }
N
N    return eActive;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_EnableWakeupSource(ccr_wakeup_source_e eSource, ccr_enable_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eSource)
N    {
N        case CCR_WAKEUP_SOURCE_0:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN0(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN0=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_1:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN1(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN1=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_2:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN2(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN2=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_3:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN3(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN3=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_4:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN4(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN4=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_5:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN5(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN5=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_6:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN6(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN6=(eEn));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_7:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAKINTEN7(eEn);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAKINTEN7=(eEn));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_SetWakeupAttribute(ccr_wakeup_source_e eSource, ccr_wakeup_attribute_e eAttribute)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eSource)
N    {
N        case CCR_WAKEUP_SOURCE_0:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL0(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL0=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_1:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL1(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL1=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_2:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL2(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL2=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_3:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL3(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL3=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_4:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL4(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL4=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_5:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL5(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL5=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_6:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL6(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL6=(eAttribute));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_7:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_IOWKP_CFG_WAK_SEL7(eAttribute);
X                (((volatile PDHR_IOWKP_CFG_bit_view_st *)(0xC0000444U )) -> WAK_SEL7=(eAttribute));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nuint16_t u16CCR_GetWakeupSourceInterruptAll(ccr_wakeup_source_e eSource)
N{
N    return u16GetPDHR_WAKINTS();
X    return (*((volatile u16PDHR_WAKINTS_halfword_view *)(0xC0000448U )) );
N}
N
N
N/****************************************************************************/
Nccr_enable_e eCCR_GetWakeupSourceInterruptSingle(ccr_wakeup_source_e eSource)
N{
N    ccr_enable_e eInterruptOccur;
N
N    switch(eSource)
N    {
N        case CCR_WAKEUP_SOURCE_0:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS0();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS0);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_1:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS1();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS1);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_2:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS2();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS2);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_3:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS3();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS3);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_4:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS4();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS4);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_5:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS5();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS5);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_6:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS6();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS6);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_7:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_WAKINTS7();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> WAKINTS7);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_NMI:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_NMI();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> NMI);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_ALARM:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_ALARM();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> ALARM);
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_RTC:
N            {
N                eInterruptOccur = (ccr_enable_e)biGetPDHR_WAKINTS_RTC();
X                eInterruptOccur = (ccr_enable_e)(((volatile PDHR_WAKINTS_bit_view_st *)(0xC0000448U )) -> RTC);
N            }
N            break;
N        default:
N            {
N                eInterruptOccur = CCR_DISABLE;
N            }
N            break;
N    }
N
N    return eInterruptOccur;
N}
N
N
N/****************************************************************************/
Nint32_t i32CCR_ClearWakeupInterruptSource(ccr_wakeup_source_e eSource)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch(eSource)
N    {
N        case CCR_WAKEUP_SOURCE_0:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC0(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC0=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_1:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC1(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC1=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_2:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC2(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC2=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_3:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC3(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC3=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_4:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC4(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC4=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_5:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC5(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC5=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_6:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC6(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC6=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_7:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_WAKINTC7(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> WAKINTC7=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_NMI:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_NMI_SC(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> NMI_SC=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_ALARM:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_ALARM_SC(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> ALARM_SC=(1U));
N            }
N            break;
N        case CCR_WAKEUP_SOURCE_RTC:
N            {
N                vCCR_PDH_UNLOCK();
X                ((((volatile PDHR_KEYR_bit_view_st *)(0xC0000400U )) -> KEYVAL=(0xA5C0F17BU)));
N                vSetPDHR_WAKINTC_RTC_SC(1U);
X                (((volatile PDHR_WAKINTC_bit_view_st *)(0xC000044CU )) -> RTC_SC=(1U));
N            }
N            break;
N        default:
N            {
N                i32Res = C_FAILED;
X                i32Res = (-1);
N            }
N            break;
N    }
N
N    return i32Res;
N}
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N/****************************************************************************/
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :   Deactivated:
N** |     Not requested Rules:
N** |         Rule 2.4  [A] : disable possible occurrence of 'commented out' code
N** |         Rule 5.7  [A] : disable No reuse of identifiers
N** |
N** |     Requested Rules:
N** |         Rule 1.1  [R] : ISO 9899:1990 C conformance w/o extensions
N** |                         Used for asm
N** |         Rule 8.1 [R] :  Restrict implicit conversions for integer type expressions:
N** |                         Used for asm
N** |         Rule 10.1 [R] : Restrict implicit conversions for integer type expressions:
N** |                         Used to have access to register bits of I/O header files
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************/
N/****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
