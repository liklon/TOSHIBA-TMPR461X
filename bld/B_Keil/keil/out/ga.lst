L 1 "..\..\..\..\lldd\src\ga.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.20 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/*======================================
N            Include Files
N=======================================*/
N#include "ga.h"
L 1 "..\..\..\..\lldd\inc\ga.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.19 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_H
N#define GA_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "ga_common.h"
L 1 "..\..\..\..\lldd\inc\ga_common.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/07/21 12:30:20 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_COMMON_H
N#define GA_COMMON_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\lldd\inc\ga_common.h" 2
N
N#define LLDD_GA_COMMON_H_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_COMMON_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*==========================================================================
N|                       GA Configuration Parameters                         |
N ==========================================================================*/
N/*---------------------------------------
N|        GA Sub-Module inclusion         |
N ---------------------------------------*/
N/* Blitting Engine */
N#define GA_USE_BLITTING
N
N/* Transformation Engine */
N#define GA_USE_TRANSFORM
N
N/* Rotation Engine */
N#define GA_USE_ROTATION
N
N/* Drawing Engine */
N#define GA_USE_DRAWING
N
N/*---------------------------------------
N|         GA List Configuration          |
N ---------------------------------------*/
N/* Maximal Number of commands in one list */
N#define GA_CMD_MAX    2048
N
N/*---------------------------------------
N|  Enable/Disable boundary check for     |
N|         GA Command List                |
N ---------------------------------------*/
N/* Enable/Disable boundary check in drivers for command buffer: */
N/* #define GA_CMDSLIST_BOUNDARY_CHECK */
N
N
N/* 1 double word more will be reserved by calculation of needed
N   buffers for GA-API's. This is necesary to add later an END-Command to 
N   finalize the command: 
N*/   
N#define RESERVED_FOR_END_CMD    1
N
N/*======================================
N                Defs
N=======================================*/
N
N/*--------------------------------------
N|     GA General Purpose Registers      |
N --------------------------------------*/
N#define GA_GPR0   0
N#define GA_GPR1   1
N#define GA_GPR2   2
N#define GA_GPR3   3
N#define GA_GPR4   4
N#define GA_GPR5   5
N#define GA_GPR6   6
N#define GA_GPR7   7
N#define GA_GPR8   8
N#define GA_GPR9   9
N#define GA_GPR10  10
N#define GA_GPR11  11
N#define GA_GPR12  12
N#define GA_GPR13  13
N#define GA_GPR14  14
N#define GA_GPR15  15
N#define GA_GPR16  16
N#define GA_GPR17  17
N#define GA_GPR18  18
N#define GA_GPR19  19
N#define GA_GPR20  20
N#define GA_GPR21  21
N#define GA_GPR22  22
N#define GA_GPR23  23
N#define GA_GPR24  24
N#define GA_GPR25  25
N#define GA_GPR26  26
N#define GA_GPR27  27
N#define GA_GPR28  28
N#define GA_GPR29  29
N#define GA_GPR30  30
N#define GA_GPR31  31
N
N
N/*--------------------------------------
N|         GA Command Parameters         |
N --------------------------------------*/
N/* Selection of module to wait on */
Ntypedef enum tag_ga_modul_e
N{
N    GA_GDC0        = 0x0u,
N    GA_FG0         = 0x1u,
N    GA_GDC1        = 0x2u
N} ga_modul_e;
N
N/* Enables/Disables option */
Ntypedef enum tag_ga_en_e
N{
N    GA_DIS         = 0x0u,     /* Disable/off */
N    GA_EN          = 0x1u      /* Enable/on */
N} ga_en_e;
N
N/* Blending Order */
Ntypedef enum tag_blendOrd_e
N{
N    GA_ONTO_DEST   = 0x0u,     /* Onto destination */
N    GA_BEHIND_DEST = 0x1u      /* Behind destination */
N} ga_blendOrd_e;
N
N/* Color format selection */
Ntypedef enum tag_ga_colFmt_e
N{
N    GA_RGB16       = 0x0u,      /* 16-bit RGB format */
N    GA_RGBA32      = 0x1u       /* 32-bit RGBA format */
N} ga_colFmt_e;
N
N/*--------------------------------------
N|        GA Command Construction        |
N --------------------------------------*/
N/* Command Field Masks */
N#define GA_MASK1           0x1u
N#define GA_MASK2           0x3u
N#define GA_MASK3           0x7u
N#define GA_MASK4           0xfu
N#define GA_MASK5           0x1fu
N#define GA_MASK6           0x3fu
N#define GA_MASK7           0x7fu
N#define GA_MASK8           0xffu
N#define GA_MASK9           0x1ffu
N#define GA_MASK10          0x3ffu
N#define GA_MASK12          0xfffu
N#define GA_MASK14          0x3fffu
N#define GA_MASK15          0x7fffu
N#define GA_MASK16          0xffffu
N#define GA_MASK22          0x3fffffu
N#define GA_MASK24          0xffffffu
N#define GA_MASK32          0xffffffffu
N#define GA_MASK36          0xfffffffffull
N#define GA_MASK48          0xffffffffffffull
N#define GA_MASK64          0xffffffffffffffffull
N
N/* GA Unit selection */
N#define GA_SCHED           0x0u
N#define GA_BLITING         0x1u
N#define GA_DRAWING         0x2u
N#define GA_ROTATION        0x3u
N#define GA_TRANSFORM       0x4u
N
N/*** Command Codes ***/
N#define GA_CMC_LGPR        0x1u
N#define GA_CMC_CSWVSYNC    0x2u
N#define GA_CMC_CSUIC	     0x3u
N#define GA_CMC_CSGDC0CC	   0x4u
N#define GA_CMC_CSGDC1CC	   0x5u
N#define GA_CMC_END         0xffu
N
N/* Blitting Engine Command Codes */
N
N#define GA_CMC_BLTO16      0x02u
N#define GA_CMC_BLTO32      0x04u
N#define GA_CMC_BLTORLEI16  0x0au
N#define GA_CMC_BLTORLEI24  0x06u
N#define GA_CMC_BLTORLEI24A 0x0Eu
N#define GA_CMC_BLTORLEI32  0x0cu
N#define GA_CMC_BLTOP16     0x12u
N#define GA_CMC_BLTOP32     0x14u
N#define GA_CMC_BLTB16      0x03u
N#define GA_CMC_BLTB32      0x07u
N#define GA_CMC_BLTBRLEI16  0x0bu
N#define GA_CMC_BLTBRLEI24  0x05u
N#define GA_CMC_BLTBRLEI24A 0x0fu
N#define GA_CMC_BLTBRLEI32  0x0du
N#define GA_CMC_BLTBP16     0x13u
N#define GA_CMC_BLTBP32     0x17u
N
N/* Transformation Engine Command Code */
N#define GA_CMC_TRANSF      0x01u
N#define GA_CMC_TRANSFB     0x00u
N
N/* Rotation Engine Command Code */
N#define GA_CMC_ROT         0x01u
N#define GA_CMC_ROTB        0x00u
N
N/* Drawing Engine Command Codes */
N#define GA_CMC_DE_DLRGBA32 0x03u
N#define GA_CMC_DE_DLRGB16  0x04u
N#define GA_CMC_DE_DTRGBA32 0x05u
N#define GA_CMC_DE_DTRGB16  0x06u
N
N/* Command Field Offsets */
N#define GA_ENG_OFF         60
N#define GA_LEN_OFF         56
N#define GA_CMC_OFF         48
N#define GA_SPC_OFF          0
N
N/* Command Field Masks */
N#define GA_ENG_MSK         (GA_MASK3)
N#define GA_LEN_MSK         (GA_MASK4)
N#define GA_CMC_MSK         (GA_MASK8)
N#define GA_SPC_MSK         (GA_MASK48)
N
N/* Macro for command field positioning */
N#define GA_FP(val, offset, mask) (((uint64_t)(val) & (mask)) << (offset))
N
N/* GA Command Fields (Engine, Length, Command code, Cmd Specific Params.)*/
N#define GA_ENG(Engine) (GA_FP((Engine), GA_ENG_OFF, GA_ENG_MSK))
N#define GA_LEN(Len)    (GA_FP((Len)   , GA_LEN_OFF, GA_LEN_MSK))
N#define GA_CMC(Code)   (GA_FP((Code)  , GA_CMC_OFF, GA_CMC_MSK))
N#define GA_SPC(spec)   (GA_FP((spec)  , GA_SPC_OFF, GA_SPC_MSK))
N
N/* GA Command Construction Macro */
N#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    | \
N                                                GA_ENG((Engine))   | \
N                                                GA_LEN((Len))      | \
N                                                GA_CMC((CmdCode))  | \
N                                                GA_SPC((CmdSpec)))
X#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    |                                                 GA_ENG((Engine))   |                                                 GA_LEN((Len))      |                                                 GA_CMC((CmdCode))  |                                                 GA_SPC((CmdSpec)))
N
N/*=========================================================================
N|                        SCHEDULER OPERATION COMMANDS                      |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load General-Purpose Register Command (LGPR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to configure
N|             one out of the 32 General-Purpose Registers. The command
N|             specific parameter for this command is the number of the
N|             register that should be loaded and the value itself.
N|
N|  Params:    regNr   - The number of the General-Purpose Register that
N|                       should be loaded
N|
N|             uiVal   - Value that should be stored within the selected
N|                       register. If the register does not encapsulate
N|                       32 bits the value within the command has to be right
N|                       aligned.
N|
N -------------------------------------------------------------------------*/
N#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,       \
N                               GA_FP ((regNr), 32, GA_MASK5)      |   \
N                               GA_FP ((uiVal),  0,  GA_MASK32)))
X#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,                                      GA_FP ((regNr), 32, GA_MASK5)      |                                  GA_FP ((uiVal),  0,  GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   END Command (CSEND)
N|
N|  Descr  :   The CSEND command must be placed at the end of every command
N|             list. It signals the Command Scheduler that all commands have
N|             been executed. When the Command Scheduler is detecting this
N|             mark, a flag in the status register signals that the command
N|             list was executed. Optionally an interrupt is generated.
N|
N|  Params:    none
N|
N -------------------------------------------------------------------------*/
N#define GA_END() (GA_CMN(GA_SCHED, 0x1u, GA_CMC_END,0x0u))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Wait VSYNC Command (CSWVSYNC)
N|
N|  Descr  :   The CSWVSYNC command can be used to synchronize parts of the
N|             command list with the vertical synchronization signal VSYNC
N|             from the GDC or the Frame Grabber.
N|
N|             When the Command Scheduler is reading the CSWVSYNC command
N|             it waits until the next vertical synchronization of the
N|             display/camera input takes place before executing the next
N|             command.
N|
N|  Params:    module   -  VSYNC select:
N|                         Use: GA_GDC0     - Wait on GDC0
N|                              GA_FG0      - Wait on FG0
N|                              GA_GDC1     - Wait on GDC1
N|                              GA_FG1      - Wait on FG1
N|
N|
N -------------------------------------------------------------------------*/
N#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,        \
N                         GA_FP ((module), 0, GA_MASK2)))
X#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,                                 GA_FP ((module), 0, GA_MASK2)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   User Interrupt Command (CSUIC)
N|
N|  Descr  :   The CSUIC command can be used to signal the MCU that a
N|             certain part of the Command List is already executed or
N|             will now start execution.
N|
N|  Params:    interrupt number:
N|                          Use: 0 - 23
N|                               values > 23 will be ignored
N|
N -------------------------------------------------------------------------*/
N#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,    \
N                                  GA_FP ((number), 0, GA_MASK6)))
X#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,                                      GA_FP ((number), 0, GA_MASK6)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC0 Configuration Command (CSGDC0CC)
N|
N|  Descr  :   The CSGDC0CC command can be used to change the content of GDC0 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC0 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC1 Configuration Command (CSGDC1CC)
N|
N|  Descr  :   The CSGDC1CC command can be used to change the content of GDC1 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC1 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N
N/*======================================
N              Structures
N=======================================*/
N/* Command List Structure */
Ntypedef struct tag_ga_list_st
N{
N    uint64_t  ullCommands[GA_CMD_MAX] ;
X    uint64_t  ullCommands[2048] ;
N    uint64_t* pu64Current;
N    uint32_t  u32UsedDoubleWords; /* used or needed double words for an  GA-API */
N    int32_t   i32FreeSpaceStat;   /* C_SUCCESS: OK no space free error,
N                                     C_FAILED:  No free space for GA-API */
N} ga_list_st ;
N
N/****************************************************************************/
N
N
N#endif /* GA_COMMON_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_common.h
N**  $Revision: 1.14 $
N**  $Date: 2015/07/21 12:30:20 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  : 
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 26 "..\..\..\..\lldd\inc\ga.h" 2
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_H_REVISION     "$Revision: 1.19 $"
N#define LLDD_GA_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/* Timeout */
N#define GA_TIMEOUT  10000
N
N/* Size of Draw Engine Filter RAM (in doublewords) */
N#define GA_DE_FILTER_SIZE 64
N
N/* GA Interrupt Masks */
N#define GA_IRQ_MASK_CENDIM  0x00000001U    /* GA Command End Interrupt Mask.                          */
N#define GA_IRQ_MASK_CSCEIM  0x00000004U    /* Command Scheduler Command Error Interrupt Mask          */
N#define GA_IRQ_MASK_CSLEIM  0x00000008U    /* Command Scheduler Command List Executed Interrupt Mask  */
N#define GA_IRQ_MASK_WBWIM   0x00000010U    /* GA Write Buffer Write Bus-Error Interrupt Mask          */
N#define GA_IRQ_MASK_WBRIM   0x00000020U    /* GA Write Buffer Read Bus-Error Interrupt Mask           */
N#define GA_IRQ_MASK_CBIM    0x00000040U    /* GA Cache Buffer Bus-Error Interrupt Mask                */
N#define GA_IRQ_MASK_RBIM    0x00000080U    /* GA Read Buffer Bus-Error Interrupt Mask                 */
N#define GA_IRQ_MASK_CSLUIM  0xFFFFFF00U    /* Command List User Interrupt Mask 0 – 23                 */
N
N/*======================================
N                Enums
N=======================================*/
N/****************************************
N*         GAIMR Param.Values
N****************************************/
N/* IRQ Mask */
Ntypedef enum tag_ga_irqen_e
N{
N    GA_IRQ_EN  = 0x1u,     /* Enable IRQ */
N    GA_IRQ_DIS = 0x0u      /* Disable IRQ */
N} ga_irqen_e;
N
N/* Bus type */
Ntypedef enum tag_ga_bus_type_e
N{
N    GA_READ_BUF_BUS        = 0x00U,
N    GA_CACHE_BUF_BUS       = 0x01U,
N    GA_WRITE_BUF_READ_BUS  = 0x02U,
N    GA_WRITE_BUF_WRITE_BUS = 0x03U,
N    GA_MAX_TYPE_BUS        = 0x04U
N} ga_bus_type_e;
N
N/* Read / Write Direction */
Ntypedef enum tag_ga_buserr_dir_e
N{
N    GA_BUSERR_READ_TRANSF   = 0x0U,
N    GA_BUSERR_WRITE_TRANSF  = 0x1U
N} ga_buserr_dir_e;
N
N/* Burs error Type */
Ntypedef enum tag_ga_buserr_bursttype
N{
N    GA_BUSERR_BURST_TYPE_FIXED   = 0x0U,
N    GA_BUSERR_BURST_TYPE_INCR    = 0x1U
N} ga_buserr_bursttype;
N
N/* Burst Size */
Ntypedef enum tag_ga_buserr_burstsize
N{
N    GA_BUSERR_BURST_1BYTE     = 0x0U,
N    GA_BUSERR_BURST_2BYTE     = 0x1U,
N    GA_BUSERR_BURST_4BYTE     = 0x2U,
N    GA_BUSERR_BURST_81BYTE    = 0x3U,
N    GA_BUSERR_BURST_16BYTE    = 0x4U,
N    GA_BUSERR_BURST_32BYTE    = 0x5U,
N    GA_BUSERR_BURST_64BYTE    = 0x6U,
N    GA_BUSERR_BURST_128BYTE   = 0x7U
N} ga_buserr_burstsize;
N
N
N/* Response Type */
Ntypedef enum tag_ga_buserr_resptype
N{
N    GA_BUSERR_RESP_OK        = 0x0U,
N    GA_BUSERR_RESP_EXOKAY    = 0x1U,
N    GA_BUSERR_RESP_SLVERR    = 0x2U,
N    GA_BUSERR_RESP_DECERR    = 0x3U
N} ga_buserr_resptype;
N
N/* Memory Protection Region */
Ntypedef enum tag_ga_memory_region_e
N{
N    GA_MEMORY_PROT_REGION_0   = 0x0U,
N    GA_MEMORY_PROT_REGION_1   = 0x1U,
N    GA_MEMORY_PROT_REGION_MAX = 0x2U
N} ga_memory_region_e;
N
N/*======================================
N              Structures
N=======================================*/
N/* GA bus Error Control Signal-Structure */
Ntypedef struct tag_ga_bus_err_ctrl_st
N{
N    ga_buserr_dir_e      eDirection;       /* Read / Write direction */
N    ga_buserr_bursttype  eBurstType;       /* Burst type */
N    ga_buserr_burstsize  eBurstSize;       /* Burst size */
N    ga_buserr_resptype   eRespType;        /* Response Type */
N    uint8_t              u8ByteEnables;    /* Byte-enables for the erroneous transfer. */
N    uint8_t              u8ID;             /* ID tag of the read/write transaction that triggered an error response. */
N    uint8_t              u8BurstLength;    /* Burst length of the read/write transaction that triggered an error response */
N} ga_bus_err_ctrl_st;
N
N/*======================================
N      Exported Function Prototypes
N=======================================*/
N
N/****************************************************************************
N *
N * Function:      vGA_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8CommonRevision - pointer to common header revision string
N *                pau8CommonTag      - pointer to common header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                    uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                    uint8_t** pau8CommonRevision, uint8_t** pau8CommonTag,
N                    uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetMaxUsedBuffSize
N *
N * Purpose:       Resets the counter for used buffer of command list
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ResetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      u32Ga_GetMaxUsedBuffSize
N *
N * Purpose:       To get max. used size of command buffer. This API can be
N *                used to optimize the need size of "GA_CMD_MAX" in ga_list_st
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: used size buffer in Double Words
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMaxUsedBuffSize(void);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_GetLastCmdBuffStatus
N *
N * Purpose:       returns the information if there was enough space free for
N *                command over API
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: space status for command list
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_GetLastCmdBuffStatus(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetLastCmdSize
N *
N * Purpose:       returns the uesed buffer size for last API call (in case it
N *                was enough memory in buffer) or it returns needed size of buffer
N *                for last API call (if there was not enough memory in command buffer)
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: sized of used buffer
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetLastCmdSize(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_CheckList
N *
N * Purpose:       To check whether there is enough space in command buffer
N *                to wrote some doble words 
N *
N * Inputs:        pstCmdList  - pointer to command list
N *                u32NeededDW - needed double words 
N *
N * Outputs:       none
N *
N * Return Values: C_FAILED  requested number of commands will not fit into list
N *                C_SUCCESS requested number of commands will fit into list   
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nint32_t i32GA_CheckList(ga_list_st* pstCmdList, uint32_t u32NeededDW);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ResetList
N *
N * Purpose:       Resets the Command List
N *
N * Inputs:        pstCmdList - Pointer to command list
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   The pointer to current list position will be reset, the
N *                content of the list will remain un-touched.
N *
N ***************************************************************************/
Nvoid vGA_ResetList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CloseList
N *
N * Purpose:       Closes the given list by inserting CSEND command
N *
N * Inputs:        pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CloseList(ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SyncList
N *
N * Purpose:       Inserts the VSYNC command in the command list in order to
N *                synchronize the execution of the list with vertical (VSYNC)
N *                signal from the GDC or Frame Grabber. When the command
N *                sceduler reaches this command it will stop the list
N *                execution until next VSYNC signal.
N *
N * Inputs:        eModul     - Modul selection to wait on (GDC/FG)
N *                pstCmdList - Pointer to Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SyncList(ga_modul_e eModule, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetUserInt
N *
N * Purpose:       defines Interrupt to CPU
N *
N * Inputs:        u8Number   - Interrupt number
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetUserInt(uint8_t u8Number, ga_list_st* pstCmdList);
N
N
N/****************************************************************************
N *
N * Function:      vGA_Enable
N *
N * Purpose:       Enables/Disables the Graphic Accelerator
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_Enable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ReadAheadEnable
N *
N * Purpose:       Enables/Disables ReadBuffer Read Ahead feature
N *
N * Inputs:        eEn - Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ReadAheadEnable(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      i32GA_Reset
N *
N * Purpose:       Resets the Graphic Accelerator
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS - Reset successful
N *                C_FAILED  - Reset timeout (Reset was not completted in
N *                            predefined time interval)
N *
N * Limitations:   The function will wait the reset to complete (it can take
N *                until recent bus cycle execution is finished)
N *
N ***************************************************************************/
Nint32_t i32GA_Reset(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetCmdListAddr
N *
N * Purpose:       Sets the physical address of the current command list
N *
N * Inputs:        u32Addr  - Physical address of the command list
N *                           (Must be 64-bit alligned -> uiAddr[2:0] = 0x0)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Make sure that when calling this function command scheduler
N *                is NOT executing a command list !!! Please note, that after
N *                the address is once written, the GA will automatically
N *                start the command list execution.
N *
N ***************************************************************************/
Nvoid vGA_SetCmdListAddr(uint32_t u32Addr);
N
N
N/****************************************************************************
N *
N * Function:      u8GA_GetStatus
N *
N * Purpose:       Reads the Graphic Accelerator Status register
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA Status Register (GASR) value
N *
N * Limitations:   The caller must parse returned status byte. For this
N *                purpose see the description of GASR Register.
N *
N ***************************************************************************/
Nuint8_t u8GA_GetStatus(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListFinished
N *
N * Purpose:       Indicates that the operation of a command list was finished or
N *                the GA was reset. This bit will be set to zero, when a new pointer
N *                is written.
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  command List Finished (ready to get new values)
N *                C_FALSE: command List is not Finished (not ready to get new values)
N *
N * Limitations: 
N *
N ***************************************************************************/
Nbool_t boGA_CmdListFinished(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_CmdListError
N *
N * Purpose:       This function shows if the Command Scheduler detects an invalid command
N *                or not. The Graphics Accelerator halts its operation and has to be reset
N *                if error is any detected. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  any Error detected by command list
N *                C_FALSE: no error detected
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdListError(void);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      boGA_CmdReg_IsBusy
N *
N * Purpose:       This function shows when any of the GA engines is currently operating.
N *                Then also the write access to many registers is prohibited.
N *                NOTE:
N *                  This function should be used from user by using direct comamnd 
N *                  registers instead of command list, before writing new commands. 
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE:  GA engine is busy.
N *                C_FALSE: GA engine is ready (not busy).
N *
N * Limitations:   
N *
N ***************************************************************************/
Nbool_t boGA_CmdReg_IsBusy(void);
N#endif
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetIrqCause
N *
N * Purpose:       Reads the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        void
N *
N * Outputs:       none
N *
N * Return Values: GA IRQ Cause value
N *
N * Limitations:   The calling function must parse returned IRQ cause byte.
N *                For this purpose see the GAICR register description.
N *                Please note that the funtion will automatically clear
N *                the interrupt source !!!
N *
N ***************************************************************************/
Nuint32_t u32GA_GetIrqCause(void);
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCause
N *
N * Purpose:       Clears the Graphic Accelerator Interrupt Cause
N *
N * Inputs:        u32CauseMask: Mask to clear the bits ("1" in the mask means clear Bit)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCause(uint32_t u32CauseMask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetIrqMask
N *
N * Purpose:       Sets all GA Interrupt masks in one shot
N *
N * Inputs:        u32Mask - Interrupt Mask. For this purpose you may use defines:
N *                         GA_IRQ_MASK_CENDIM, GA_IRQ_MASK_CSCEIM, GA_IRQ_MASK_CSLEIM,
N *                         GA_IRQ_MASK_WBWIM, GA_IRQ_MASK_WBRIM, GA_IRQ_MASK_CBIM,
N *                         GA_IRQ_MASK_RBIM, GA_IRQ_MASK_CSLUIM   
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetIrqMask(uint32_t u32Mask);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableUserIrq
N *
N * Purpose:       Enables/Disables interrupt to CPU
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *		  u8Number - interrupt line to be enabled/disabled
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableUserIrq(uint8_t u8Number, ga_en_e eEn);
N
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_EnableIrqCmdEnd
N *
N * Purpose:       Enables/Disables GA Command End Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_EnableIrqCmdEnd(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_CmdReg_ClearIrqCmdEnd
N *
N * Purpose:       Clears GA Command End Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_CmdReg_ClearIrqCmdEnd(void);
N
N
N#endif
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSLEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command List
N *                Executed Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSLEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSLEI
N *
N * Purpose:       Clears Command Scheduler Command List Executed Interrupt. 
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSLEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqCSCEI
N *
N * Purpose:       Enables/Disables Command Scheduler Command Error IRQ
N *                Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqCSCEI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqCSCEI
N *
N * Purpose:       Clears GA Command Scheduler Command Error IRQ
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqCSCEI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_SetGADelay
N *
N * Purpose:       Sets the minimum delay in System Clock cycles between two
N *                consecutive memory accesses performed by any Graphics 
N *                Accelerator engine
N *
N * Inputs:        u16Delay: Delay Value (0x0000 .. 0xFFFF)
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_SetGADelay(uint16_t u16Delay);
N
N
N/****************************************************************************/
N
N#ifndef _EXTENDED_GA_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBWI
N *
N * Purpose:       Enables/Disables GA Write Buffer Write Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBWI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBWI
N *
N * Purpose:       Clears GA Write Buffer Write Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBWI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGAWBRI
N *
N * Purpose:       Enables/Disables GA Write Buffer Read Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGAWBRI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGAWBRI
N *
N * Purpose:       Clears GA Write Buffer Read Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGAWBRI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGACBIM
N *
N * Purpose:       Enables/Disables GA Cache Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGACBI(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGACBI
N *
N * Purpose:       Clears GA Cache Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGACBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableIrqGARBI
N *
N * Purpose:       Enables/Disables GA Read Buffer Error Interrupt
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableIrqGARBI(ga_en_e eEn);
N
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearIrqGARBI
N *
N * Purpose:       Clears GA Read Buffer Error Interrupt
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearIrqGARBI(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearUserIrq
N *
N * Purpose:       Clears GA Command List User Interrupt 0 - 23
N *
N * Inputs:        u8CmdListIntr: No. of Interruot (0..23) to be cleared
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearUserIrq(uint8_t u8CmdListIntr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrAddr
N *
N * Purpose:       Returns the address after bus error on GA 
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       pu32BusErrAddr: Pointer to bus error address
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: NULL pointer
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrAddr(ga_bus_type_e eBusType, uint32_t* pu32BusErrAddr);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetBusErrCtrlStatus
N *
N * Purpose:       Returns the triggering access’s control status after bus error on GA
N *
N * Inputs:        eBusType  Related Bus
N *
N * Outputs:       control status structure
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_GetBusErrCtrlStatus(ga_bus_type_e eBusType, ga_bus_err_ctrl_st* pstCtrlStatus);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetMemoryProtRegionAddr
N *
N * Purpose:       Defines the lower and upper address of the memory region
N *                0 or 1 (primary, secondary) GA is allowed to perform write accesses.
N *                Write accesses outside the memory regions are discarded.
N *                NOTE:
N *                   The memory regions are defined with a granularity of 4Kbyte.
N *
N * Inputs:        eRegion  Related Region (0/1)
N *                u32LowAddress: Lower protected address
N *                u32HighAddress: Higher protected address
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong parameter
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGA_SetMemoryProtRegionAddr(ga_memory_region_e eRegion, uint32_t u32LowAddress, uint32_t u32HighAddress);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecConfigIrq
N *
N * Purpose:       Enables/Disables interrupt, set if a non-privileged access 
N *                tries to write to GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR,
N *                or GAMPIMR.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecConfigIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_EnableMemoryProtecAccessIrq
N *
N * Purpose:       Enables/Disables interrupt, set if GA tries to write to 
N *                memory outside the address range defined by GAMR0L-GAMR0H 
N *                and GAMR1L-GAMR1H.
N *
N * Inputs:        eEn - Interrupt Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_EnableMemoryProtecAccessIrq(ga_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecConfigIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to have a non-privileged access 
N *                tries to write to protection control registers
N *                (GAMR0L, GAMR0H, GAMR1L, GAMR1H, GAMPICR, or GAMPIMR)
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecConfigIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      vGA_ClearMemoryProtecAccessIrq
N *
N * Purpose:       Clears interrupt generated if GA tries to write to memory 
N *                outside the address range defined by GAMR0L-GAMR0H and GAMR1L-GAMR1H
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGA_ClearMemoryProtecAccessIrq(void);
N
N
N/****************************************************************************
N *
N * Function:      u32GA_GetMemoryProtecErr_CaptAddr
N *
N * Purpose:       Get the address of the first write access performed by the 
N *                Write Buffer’s write interface that caused a memory protection
N *                violation. The register is automatically set by the Graphics 
N *                Accelerator in case of a protection violation, it is reset to
N *                zero automatically if the corresponding interrupt bit GAMPI is
N *                cleared in the Graphics Accelerator Interrupt Cause Register (GAMPICR).
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: Address caused portection error
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nuint32_t u32GA_GetMemoryProtecErr_CaptAddr(void);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetGeneralPurposeRegister
N *
N * Purpose:       Set one of 32 Purpose Registers of GA, which are used to define  
N *                the required parameters for the triggered engine.
N *                Read access is possible all the time, write access is only allowed
N *                if no engine is currently operating (GASR.BUSY=0). Nevertheless, 
N *                it is recommended to configure these registers using Command Lists.
N *
N * Inputs:        u8RegNo      No. of Register (0..31)
N *                u32RegValue: Register value to be written
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo or GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t u32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_GetGeneralPurposeRegister
N *
N * Purpose:       Get content of one of 32 Purpose Registers of GA, which are used   
N *                to define the required parameters for the triggered engine.
N *
N * Inputs:        u8RegNo       No. of Register (0..31)
N *                pu32RegValue: Pointer to Register value to be read
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: Wrong RegNo NULL pointer 
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_GetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t* pu32RegValue);
N
N
N/****************************************************************************
N *
N * Function:      boGA_SetCommandRegisterLowHigh
N *
N * Purpose:       Set command register directly (as alternative to command List).
N *                For this mode, user should take care that GA should be ready 
N *                (not busy) before writng in registers. 
N *
N * Inputs:        u32LowValue:  Lower 32 bits of 64 bits command (0..31)
N *                u32HighValue: Higher 32 bits of 64 bits command (32..63)
N *                NOTE:
N *                  1) API should write first Lowe Part and then higher Part. 
N *                    By writing of higehr word thorugh API GA will be trigegred 
N *                    to execute command if it was not busy before.
N *                  2) Related general purpose registers for command should be
N *                     written before, 
N *
N * Outputs:       none
N *
N * Return Values: No Error?
N *                C_TRUE:  No Error
N *                C_FALSE: GA was busy and cannot accept new register values.
N *
N * Limitations:   Process one controller at a time. Api cannot be executed if GA is busy.
N *
N ***************************************************************************/
Nbool_t boGA_SetCommandRegisterLowHigh (uint32_t u32LowValue,  uint32_t u32HighValue);
N
N
N#endif /* _EXTENDED_GA_APIS_DISABLED_ */
N
N#endif /* GA_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\ga.c" 2
N#include "ga_io.h"
L 1 "..\..\..\..\lldd\hdr\ga_io.h" 1
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : GA 
N/  Date of creation (y-m-d:time): 2013-06-14+02:00  :  15:42:04.554+02:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.12 $ 
N/  Excel Sheet ver.             : vv1.0
N/  Excel Sheet date             : 2013-Apr-24
N/  Excel Sheet author           : BEL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION :
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : 
N*   LIBRARIES   :
N*****************************************************************************
N*   VERSION     : $Revision: 1.12 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef GAIO_H
N#define GAIO_H
N
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"                      /* Core specific primitive type definitions */ 
N/*********************************************/
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 230    /* Rule 6.4 [R] : 	nonstandard type for a bit field */
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
N#endif
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N#define LLDD_GA_IO_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_GA_IO_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/**********************************************
N*             extern defined varaibles
N**********************************************/
N#ifdef HW_EMULATION_GA
Sextern  volatile  uint32_t  GASCR_REG_EMUL;
Sextern  volatile  uint32_t  GACLAR_REG_EMUL;
Sextern  volatile  uint32_t  GASR_REG_EMUL;
Sextern  volatile  uint32_t  GAICR_REG_EMUL;
Sextern  volatile  uint32_t  GAIMR_REG_EMUL;
Sextern  volatile  uint32_t  GADR_REG_EMUL;
Sextern  volatile  uint32_t  GARBBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GARBBECR_REG_EMUL;
Sextern  volatile  uint32_t  GACBBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GACBBECR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBRBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBRBECR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBWBEAR_REG_EMUL;
Sextern  volatile  uint32_t  GAWBWBECR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR0LR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR0HR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR1LR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPR1HR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPICR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPIMR_REG_EMUL;
Sextern  volatile  uint32_t  GAMPACR_REG_EMUL;
Sextern  volatile  uint32_t  GAGPR_REG_EMUL[32];
Sextern  volatile  uint32_t  GACMDL_REG_EMUL;
Sextern  volatile  uint32_t  GACMDH_REG_EMUL;
Sextern  volatile  uint32_t  GADEFCR_REG_EMUL[64];
S
N#endif
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GASCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00000                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GASCR_REG__       0xC0C00000U
N#else
S#define GASCR_REG__       &GASCR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   GARESET	:1; 	 /* 0..0  bit(s) R/S */
N  uint16_t   GAEN	:1; 	 /* 1..1  bit(s) R/W */
N  uint16_t   	:6; 	 /* 2..7  bit(s) R */
N  uint16_t   DISRA	:1; 	 /* 8..8  bit(s) R/W */ 
N  uint16_t   	:7; 	 /* 9..31  bit(s) R */                    
N} GASCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GASCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GASCR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGASCR()     ((volatile GASCR_bit_view_st *)\
N(GASCR_REG__ ))
X#define pst_bitGASCR()     ((volatile GASCR_bit_view_st *)(GASCR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GASCR()     ((volatile GASCR_byte_view_st *)\
N(GASCR_REG__ ))
X#define pst_u8GASCR()     ((volatile GASCR_byte_view_st *)(GASCR_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16GASCR()     ((volatile u16GASCR_halfword_view *)\
N(GASCR_REG__ ))
X#define pu16GASCR()     ((volatile u16GASCR_halfword_view *)(GASCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGASCR_GARESET() (pst_bitGASCR() -> GARESET)
N#define vSetGASCR_GARESET() (pst_bitGASCR() -> GARESET=(1))
N#define biGetGASCR_GAEN() (pst_bitGASCR() -> GAEN)
N#define vSetGASCR_GAEN(ParValue)  (pst_bitGASCR() -> GAEN=(ParValue))
N#define biGetGASCR_DISRA() (pst_bitGASCR() -> DISRA)
N#define vSetGASCR_DISRA(ParValue)  (pst_bitGASCR() -> DISRA=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGASCRL(ParValue) (pst_u8GASCR() -> u8L = (ParValue))
N#define u8GetGASCRL() (pst_u8GASCR() -> u8L)
N/* H-struct byte access */
N#define vSetGASCRH(ParValue) (pst_u8GASCR() -> u8H = (ParValue))
N#define u8GetGASCRH() (pst_u8GASCR() -> u8H)
N            
N/* Half-word access */ 
N#define vSetGASCR(ParValue) (*pu16GASCR()  = (ParValue))
N#define u16GetGASCR() (*pu16GASCR() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACLAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00004                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACLAR_REG__       0xC0C00004U
N#else
S#define GACLAR_REG__       &GACLAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   CSLA	:29; 	 /* 3..31  bit(s) R/W */                    
N} GACLAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GACLAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GACLAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GACLAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGACLAR()     ((volatile GACLAR_bit_view_st *)\
N(GACLAR_REG__ ))
X#define pst_bitGACLAR()     ((volatile GACLAR_bit_view_st *)(GACLAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GACLAR()     ((volatile GACLAR_byte_view_st *)\
N(GACLAR_REG__ ))
X#define pst_u8GACLAR()     ((volatile GACLAR_byte_view_st *)(GACLAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GACLAR()     ((volatile GACLAR_halfword_view_st *)\
N(GACLAR_REG__ ))
X#define pst_u16GACLAR()     ((volatile GACLAR_halfword_view_st *)(GACLAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GACLAR()     ((volatile u32GACLAR_word_view *)\
N(GACLAR_REG__ ))
X#define pu32GACLAR()     ((volatile u32GACLAR_word_view *)(GACLAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGACLAR_CSLA() (pst_bitGACLAR() -> CSLA)
N#define vSetGACLAR_CSLA(ParValue)  (pst_bitGACLAR() -> CSLA=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGACLARLL(ParValue) (pst_u8GACLAR() -> u8LL = (ParValue))
N#define u8GetGACLARLL() (pst_u8GACLAR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGACLARLH(ParValue) (pst_u8GACLAR() -> u8LH = (ParValue))
N#define u8GetGACLARLH() (pst_u8GACLAR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGACLARHL(ParValue) (pst_u8GACLAR() -> u8HL = (ParValue))
N#define u8GetGACLARHL() (pst_u8GACLAR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGACLARHH(ParValue) (pst_u8GACLAR() -> u8HH = (ParValue))
N#define u8GetGACLARHH() (pst_u8GACLAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGACLARL(ParValue) (pst_u16GACLAR() -> u16L = (ParValue))
N#define u16GetGACLARL() (pst_u16GACLAR() -> u16L)
N#define vSetGACLARH(ParValue) (pst_u16GACLAR() -> u16H = (ParValue))
N#define u16GetGACLARH() (pst_u16GACLAR() -> u16H)
N            
N/* Word access */
N#define vSetGACLAR(ParValue)  (*pu32GACLAR() = (ParValue))
N#define u32GetGACLAR()  (*pu32GACLAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GASR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00008                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GASR_REG__       0xC0C00008U
N#else
S#define GASR_REG__       &GASR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   BUSY	:1; 	 /* 0..0  bit(s) R */
N  uint8_t   	:1; 	 /* 1..1  bit(s) R */
N  uint8_t   CSCEF	:1; 	 /* 2..2  bit(s) R */
N  uint8_t   CSLEF	:1; 	 /* 3..3  bit(s) R */ 
N  uint8_t   	:4; 	 /* 4..31  bit(s) R */                    
N} GASR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GASR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGASR()     ((volatile GASR_bit_view_st *)\
N(GASR_REG__ ))
X#define pst_bitGASR()     ((volatile GASR_bit_view_st *)(GASR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8GASR()     ((volatile u8GASR_byte_view *)\
N(GASR_REG__ ))
X#define pu8GASR()     ((volatile u8GASR_byte_view *)(GASR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGASR_BUSY() (pst_bitGASR() -> BUSY)            
N#define biGetGASR_CSCEF() (pst_bitGASR() -> CSCEF)            
N#define biGetGASR_CSLEF() (pst_bitGASR() -> CSLEF)
N            
N/* byte access */
N#define u8GetGASR() (*pu8GASR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAICR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0000C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAICR_REG__       0xC0C0000CU
N#else
S#define GAICR_REG__       &GAICR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GACENDI	:1; 	 /* 0..0  bit(s) R/W1C */
N  uint32_t   	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   CSCEI	:1; 	 /* 2..2  bit(s) R/W1C */
N  uint32_t   CSLEI	:1; 	 /* 3..3  bit(s) R/W1C */
N  uint32_t   GAWBWI	:1; 	 /* 4..4  bit(s) R/W1C */
N  uint32_t   GAWBRI	:1; 	 /* 5..5  bit(s) R/W1C */
N  uint32_t   GACBI	:1; 	 /* 6..6  bit(s) R/W1C */
N  uint32_t   GARBI	:1; 	 /* 7..7  bit(s) R/W1C */ 
N  uint32_t   CSLUI	:24; 	 /* 8..31  bit(s) R/W1C */                    
N} GAICR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAICR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAICR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAICR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAICR()     ((volatile GAICR_bit_view_st *)\
N(GAICR_REG__ ))
X#define pst_bitGAICR()     ((volatile GAICR_bit_view_st *)(GAICR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAICR()     ((volatile GAICR_byte_view_st *)\
N(GAICR_REG__ ))
X#define pst_u8GAICR()     ((volatile GAICR_byte_view_st *)(GAICR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAICR()     ((volatile GAICR_halfword_view_st *)\
N(GAICR_REG__ ))
X#define pst_u16GAICR()     ((volatile GAICR_halfword_view_st *)(GAICR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAICR()     ((volatile u32GAICR_word_view *)\
N(GAICR_REG__ ))
X#define pu32GAICR()     ((volatile u32GAICR_word_view *)(GAICR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAICR_GACENDI() (pst_bitGAICR() -> GACENDI)
N#define vClrGAICR_GACENDI() (pst_bitGAICR() -> GACENDI = (1))
N#define biGetGAICR_CSCEI() (pst_bitGAICR() -> CSCEI)
N#define vClrGAICR_CSCEI() (pst_bitGAICR() -> CSCEI = (1))
N#define biGetGAICR_CSLEI() (pst_bitGAICR() -> CSLEI)
N#define vClrGAICR_CSLEI() (pst_bitGAICR() -> CSLEI = (1))
N#define biGetGAICR_GAWBWI() (pst_bitGAICR() -> GAWBWI)
N#define vClrGAICR_GAWBWI() (pst_bitGAICR() -> GAWBWI = (1))
N#define biGetGAICR_GAWBRI() (pst_bitGAICR() -> GAWBRI)
N#define vClrGAICR_GAWBRI() (pst_bitGAICR() -> GAWBRI = (1))
N#define biGetGAICR_GACBI() (pst_bitGAICR() -> GACBI)
N#define vClrGAICR_GACBI() (pst_bitGAICR() -> GACBI = (1))
N#define biGetGAICR_GARBI() (pst_bitGAICR() -> GARBI)
N#define vClrGAICR_GARBI() (pst_bitGAICR() -> GARBI = (1))
N
N#define biGetGAICR_CSLUI() (pst_bitGAICR() -> CSLUI)
N/*---------------------------------------------------------------------------*/
N/* SRA: Clr funnction can be applied for each interrupt 0..23: */
N#define vClrGAICR_CSLUI(BitNo) (pst_bitGAICR() -> CSLUI = ( (0x000001 << (BitNo)) & 0xFFFFFFU) )
N/* SRA: Clr funnction for multiple bits can be applied for multiple interrupt 0..23: */
N#define vClrMultiGAICR_CSLUI(Mask) (pst_bitGAICR() -> CSLUI = ((Mask) & 0xFFFFFFU))
N/*---------------------------------------------------------------------------*/
N/* LL-struct byte access */
N#define vSetGAICRLL(ParValue) (pst_u8GAICR() -> u8LL = (ParValue))
N#define u8GetGAICRLL() (pst_u8GAICR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAICRLH(ParValue) (pst_u8GAICR() -> u8LH = (ParValue))
N#define u8GetGAICRLH() (pst_u8GAICR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAICRHL(ParValue) (pst_u8GAICR() -> u8HL = (ParValue))
N#define u8GetGAICRHL() (pst_u8GAICR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAICRHH(ParValue) (pst_u8GAICR() -> u8HH = (ParValue))
N#define u8GetGAICRHH() (pst_u8GAICR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAICRL(ParValue) (pst_u16GAICR() -> u16L = (ParValue))
N#define u16GetGAICRL() (pst_u16GAICR() -> u16L)
N#define vSetGAICRH(ParValue) (pst_u16GAICR() -> u16H = (ParValue))
N#define u16GetGAICRH() (pst_u16GAICR() -> u16H)
N            
N/* Word access */
N#define vSetGAICR(ParValue)  (*pu32GAICR() = (ParValue))
N#define u32GetGAICR()  (*pu32GAICR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAIMR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAIMR_REG__       0xC0C00010U
N#else
S#define GAIMR_REG__       &GAIMR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GACENDIM	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   CSCEIM	:1; 	 /* 2..2  bit(s) R/W */
N  uint32_t   CSLEIM	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   GAWBWIM	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   GAWBRIM	:1; 	 /* 5..5  bit(s) R/W */
N  uint32_t   GACBIM	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   GARBIM	:1; 	 /* 7..7  bit(s) R/W */ 
N  uint32_t   CSLUIM	:24; 	 /* 8..31  bit(s) R/W */                    
N} GAIMR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAIMR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAIMR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAIMR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAIMR()     ((volatile GAIMR_bit_view_st *)\
N(GAIMR_REG__ ))
X#define pst_bitGAIMR()     ((volatile GAIMR_bit_view_st *)(GAIMR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAIMR()     ((volatile GAIMR_byte_view_st *)\
N(GAIMR_REG__ ))
X#define pst_u8GAIMR()     ((volatile GAIMR_byte_view_st *)(GAIMR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAIMR()     ((volatile GAIMR_halfword_view_st *)\
N(GAIMR_REG__ ))
X#define pst_u16GAIMR()     ((volatile GAIMR_halfword_view_st *)(GAIMR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAIMR()     ((volatile u32GAIMR_word_view *)\
N(GAIMR_REG__ ))
X#define pu32GAIMR()     ((volatile u32GAIMR_word_view *)(GAIMR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAIMR_GACENDIM() (pst_bitGAIMR() -> GACENDIM)
N#define vSetGAIMR_GACENDIM(ParValue)  (pst_bitGAIMR() -> GACENDIM=(ParValue))
N#define biGetGAIMR_CSCEIM() (pst_bitGAIMR() -> CSCEIM)
N#define vSetGAIMR_CSCEIM(ParValue)  (pst_bitGAIMR() -> CSCEIM=(ParValue))
N#define biGetGAIMR_CSLEIM() (pst_bitGAIMR() -> CSLEIM)
N#define vSetGAIMR_CSLEIM(ParValue)  (pst_bitGAIMR() -> CSLEIM=(ParValue))
N#define biGetGAIMR_GAWBWIM() (pst_bitGAIMR() -> GAWBWIM)
N#define vSetGAIMR_GAWBWIM(ParValue)  (pst_bitGAIMR() -> GAWBWIM=(ParValue))
N#define biGetGAIMR_GAWBRIM() (pst_bitGAIMR() -> GAWBRIM)
N#define vSetGAIMR_GAWBRIM(ParValue)  (pst_bitGAIMR() -> GAWBRIM=(ParValue))
N#define biGetGAIMR_GACBIM() (pst_bitGAIMR() -> GACBIM)
N#define vSetGAIMR_GACBIM(ParValue)  (pst_bitGAIMR() -> GACBIM=(ParValue))
N#define biGetGAIMR_GARBIM() (pst_bitGAIMR() -> GARBIM)
N#define vSetGAIMR_GARBIM(ParValue)  (pst_bitGAIMR() -> GARBIM=(ParValue))
N#define biGetGAIMR_CSLUIM() (pst_bitGAIMR() -> CSLUIM)
N#define vSetGAIMR_CSLUIM(ParValue)  (pst_bitGAIMR() -> CSLUIM=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAIMRLL(ParValue) (pst_u8GAIMR() -> u8LL = (ParValue))
N#define u8GetGAIMRLL() (pst_u8GAIMR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAIMRLH(ParValue) (pst_u8GAIMR() -> u8LH = (ParValue))
N#define u8GetGAIMRLH() (pst_u8GAIMR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAIMRHL(ParValue) (pst_u8GAIMR() -> u8HL = (ParValue))
N#define u8GetGAIMRHL() (pst_u8GAIMR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAIMRHH(ParValue) (pst_u8GAIMR() -> u8HH = (ParValue))
N#define u8GetGAIMRHH() (pst_u8GAIMR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAIMRL(ParValue) (pst_u16GAIMR() -> u16L = (ParValue))
N#define u16GetGAIMRL() (pst_u16GAIMR() -> u16L)
N#define vSetGAIMRH(ParValue) (pst_u16GAIMR() -> u16H = (ParValue))
N#define u16GetGAIMRH() (pst_u16GAIMR() -> u16H)
N            
N/* Word access */
N#define vSetGAIMR(ParValue)  (*pu32GAIMR() = (ParValue))
N#define u32GetGAIMR()  (*pu32GAIMR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GADR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00014                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GADR_REG__       0xC0C00014U
N#else
S#define GADR_REG__       &GADR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   GAD	:16; 	 /* 0..15  bit(s) R/W */                    
N} GADR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GADR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GADR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGADR()     ((volatile GADR_bit_view_st *)\
N(GADR_REG__ ))
X#define pst_bitGADR()     ((volatile GADR_bit_view_st *)(GADR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GADR()     ((volatile GADR_byte_view_st *)\
N(GADR_REG__ ))
X#define pst_u8GADR()     ((volatile GADR_byte_view_st *)(GADR_REG__ ))
N            
N/* Pointer to HALFWORD */
N#define pu16GADR()     ((volatile u16GADR_halfword_view *)\
N(GADR_REG__ ))
X#define pu16GADR()     ((volatile u16GADR_halfword_view *)(GADR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGADR_GAD() (pst_bitGADR() -> GAD)
N#define vSetGADR_GAD(ParValue)  (pst_bitGADR() -> GAD=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGADRL(ParValue) (pst_u8GADR() -> u8L = (ParValue))
N#define u8GetGADRL() (pst_u8GADR() -> u8L)
N/* H-struct byte access */
N#define vSetGADRH(ParValue) (pst_u8GADR() -> u8H = (ParValue))
N#define u8GetGADRH() (pst_u8GADR() -> u8H)
N            
N/* Half-word access */ 
N#define vSetGADR(ParValue) (*pu16GADR()  = (ParValue))
N#define u16GetGADR() (*pu16GADR() )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GARBBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00020                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GARBBEAR_REG__       0xC0C00020U
N#else
S#define GARBBEAR_REG__       &GARBBEAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   RBA	:29; 	 /* 3..31  bit(s) R */                    
N} GARBBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GARBBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GARBBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GARBBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGARBBEAR()     ((volatile GARBBEAR_bit_view_st *)\
N(GARBBEAR_REG__ ))
X#define pst_bitGARBBEAR()     ((volatile GARBBEAR_bit_view_st *)(GARBBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GARBBEAR()     ((volatile GARBBEAR_byte_view_st *)\
N(GARBBEAR_REG__ ))
X#define pst_u8GARBBEAR()     ((volatile GARBBEAR_byte_view_st *)(GARBBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GARBBEAR()     ((volatile GARBBEAR_halfword_view_st *)\
N(GARBBEAR_REG__ ))
X#define pst_u16GARBBEAR()     ((volatile GARBBEAR_halfword_view_st *)(GARBBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GARBBEAR()     ((volatile u32GARBBEAR_word_view *)\
N(GARBBEAR_REG__ ))
X#define pu32GARBBEAR()     ((volatile u32GARBBEAR_word_view *)(GARBBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGARBBEAR_RBA() (pst_bitGARBBEAR() -> RBA)
N            
N/* LL-struct byte access */
N#define u8GetGARBBEARLL() (pst_u8GARBBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGARBBEARLH() (pst_u8GARBBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGARBBEARHL() (pst_u8GARBBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGARBBEARHH() (pst_u8GARBBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGARBBEARL() (pst_u16GARBBEAR() -> u16L)
N#define u16GetGARBBEARH() (pst_u16GARBBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGARBBEAR()  (*pu32GARBBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GARBBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00024                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GARBBECR_REG__       0xC0C00024U
N#else
S#define GARBBECR_REG__       &GARBBECR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GARBBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GARBBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GARBBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GARBBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGARBBECR()     ((volatile GARBBECR_bit_view_st *)\
N(GARBBECR_REG__ ))
X#define pst_bitGARBBECR()     ((volatile GARBBECR_bit_view_st *)(GARBBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GARBBECR()     ((volatile GARBBECR_byte_view_st *)\
N(GARBBECR_REG__ ))
X#define pst_u8GARBBECR()     ((volatile GARBBECR_byte_view_st *)(GARBBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GARBBECR()     ((volatile GARBBECR_halfword_view_st *)\
N(GARBBECR_REG__ ))
X#define pst_u16GARBBECR()     ((volatile GARBBECR_halfword_view_st *)(GARBBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GARBBECR()     ((volatile u32GARBBECR_word_view *)\
N(GARBBECR_REG__ ))
X#define pu32GARBBECR()     ((volatile u32GARBBECR_word_view *)(GARBBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGARBBECR_WR() (pst_bitGARBBECR() -> WR)            
N#define biGetGARBBECR_BTYPE() (pst_bitGARBBECR() -> BTYPE)            
N#define biGetGARBBECR_BSIZE() (pst_bitGARBBECR() -> BSIZE)            
N#define biGetGARBBECR_RTYPE() (pst_bitGARBBECR() -> RTYPE)            
N#define biGetGARBBECR_BEN() (pst_bitGARBBECR() -> BEN)            
N#define biGetGARBBECR_ID() (pst_bitGARBBECR() -> ID)            
N#define biGetGARBBECR_LEN() (pst_bitGARBBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGARBBECRLL() (pst_u8GARBBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGARBBECRLH() (pst_u8GARBBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGARBBECRHL() (pst_u8GARBBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGARBBECRHH() (pst_u8GARBBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGARBBECRL() (pst_u16GARBBECR() -> u16L)
N#define u16GetGARBBECRH() (pst_u16GARBBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGARBBECR()  (*pu32GARBBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACBBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00028                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACBBEAR_REG__       0xC0C00028U
N#else
S#define GACBBEAR_REG__       &GACBBEAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   CBA	:29; 	 /* 3..31  bit(s) R */                    
N} GACBBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GACBBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GACBBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GACBBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGACBBEAR()     ((volatile GACBBEAR_bit_view_st *)\
N(GACBBEAR_REG__ ))
X#define pst_bitGACBBEAR()     ((volatile GACBBEAR_bit_view_st *)(GACBBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GACBBEAR()     ((volatile GACBBEAR_byte_view_st *)\
N(GACBBEAR_REG__ ))
X#define pst_u8GACBBEAR()     ((volatile GACBBEAR_byte_view_st *)(GACBBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GACBBEAR()     ((volatile GACBBEAR_halfword_view_st *)\
N(GACBBEAR_REG__ ))
X#define pst_u16GACBBEAR()     ((volatile GACBBEAR_halfword_view_st *)(GACBBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GACBBEAR()     ((volatile u32GACBBEAR_word_view *)\
N(GACBBEAR_REG__ ))
X#define pu32GACBBEAR()     ((volatile u32GACBBEAR_word_view *)(GACBBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGACBBEAR_CBA() (pst_bitGACBBEAR() -> CBA)
N            
N/* LL-struct byte access */
N#define u8GetGACBBEARLL() (pst_u8GACBBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGACBBEARLH() (pst_u8GACBBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGACBBEARHL() (pst_u8GACBBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGACBBEARHH() (pst_u8GACBBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGACBBEARL() (pst_u16GACBBEAR() -> u16L)
N#define u16GetGACBBEARH() (pst_u16GACBBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGACBBEAR()  (*pu32GACBBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACBBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0002C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACBBECR_REG__       0xC0C0002CU
N#else
S#define GACBBECR_REG__       &GACBBECR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GACBBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GACBBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GACBBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GACBBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGACBBECR()     ((volatile GACBBECR_bit_view_st *)\
N(GACBBECR_REG__ ))
X#define pst_bitGACBBECR()     ((volatile GACBBECR_bit_view_st *)(GACBBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GACBBECR()     ((volatile GACBBECR_byte_view_st *)\
N(GACBBECR_REG__ ))
X#define pst_u8GACBBECR()     ((volatile GACBBECR_byte_view_st *)(GACBBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GACBBECR()     ((volatile GACBBECR_halfword_view_st *)\
N(GACBBECR_REG__ ))
X#define pst_u16GACBBECR()     ((volatile GACBBECR_halfword_view_st *)(GACBBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GACBBECR()     ((volatile u32GACBBECR_word_view *)\
N(GACBBECR_REG__ ))
X#define pu32GACBBECR()     ((volatile u32GACBBECR_word_view *)(GACBBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGACBBECR_WR() (pst_bitGACBBECR() -> WR)            
N#define biGetGACBBECR_BTYPE() (pst_bitGACBBECR() -> BTYPE)            
N#define biGetGACBBECR_BSIZE() (pst_bitGACBBECR() -> BSIZE)            
N#define biGetGACBBECR_RTYPE() (pst_bitGACBBECR() -> RTYPE)            
N#define biGetGACBBECR_BEN() (pst_bitGACBBECR() -> BEN)            
N#define biGetGACBBECR_ID() (pst_bitGACBBECR() -> ID)            
N#define biGetGACBBECR_LEN() (pst_bitGACBBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGACBBECRLL() (pst_u8GACBBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGACBBECRLH() (pst_u8GACBBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGACBBECRHL() (pst_u8GACBBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGACBBECRHH() (pst_u8GACBBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGACBBECRL() (pst_u16GACBBECR() -> u16L)
N#define u16GetGACBBECRH() (pst_u16GACBBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGACBBECR()  (*pu32GACBBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBRBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00030                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBRBEAR_REG__       0xC0C00030U
N#else
S#define GAWBRBEAR_REG__       &GAWBRBEAR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   WBRA	:29; 	 /* 3..31  bit(s) R */                    
N} GAWBRBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBRBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBRBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBRBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBRBEAR()     ((volatile GAWBRBEAR_bit_view_st *)\
N(GAWBRBEAR_REG__ ))
X#define pst_bitGAWBRBEAR()     ((volatile GAWBRBEAR_bit_view_st *)(GAWBRBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBRBEAR()     ((volatile GAWBRBEAR_byte_view_st *)\
N(GAWBRBEAR_REG__ ))
X#define pst_u8GAWBRBEAR()     ((volatile GAWBRBEAR_byte_view_st *)(GAWBRBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBRBEAR()     ((volatile GAWBRBEAR_halfword_view_st *)\
N(GAWBRBEAR_REG__ ))
X#define pst_u16GAWBRBEAR()     ((volatile GAWBRBEAR_halfword_view_st *)(GAWBRBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBRBEAR()     ((volatile u32GAWBRBEAR_word_view *)\
N(GAWBRBEAR_REG__ ))
X#define pu32GAWBRBEAR()     ((volatile u32GAWBRBEAR_word_view *)(GAWBRBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBRBEAR_WBRA() (pst_bitGAWBRBEAR() -> WBRA)
N            
N/* LL-struct byte access */
N#define u8GetGAWBRBEARLL() (pst_u8GAWBRBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBRBEARLH() (pst_u8GAWBRBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBRBEARHL() (pst_u8GAWBRBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBRBEARHH() (pst_u8GAWBRBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBRBEARL() (pst_u16GAWBRBEAR() -> u16L)
N#define u16GetGAWBRBEARH() (pst_u16GAWBRBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBRBEAR()  (*pu32GAWBRBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBRBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00034                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBRBECR_REG__       0xC0C00034U
N#else
S#define GAWBRBECR_REG__       &GAWBRBECR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GAWBRBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBRBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBRBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBRBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBRBECR()     ((volatile GAWBRBECR_bit_view_st *)\
N(GAWBRBECR_REG__ ))
X#define pst_bitGAWBRBECR()     ((volatile GAWBRBECR_bit_view_st *)(GAWBRBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBRBECR()     ((volatile GAWBRBECR_byte_view_st *)\
N(GAWBRBECR_REG__ ))
X#define pst_u8GAWBRBECR()     ((volatile GAWBRBECR_byte_view_st *)(GAWBRBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBRBECR()     ((volatile GAWBRBECR_halfword_view_st *)\
N(GAWBRBECR_REG__ ))
X#define pst_u16GAWBRBECR()     ((volatile GAWBRBECR_halfword_view_st *)(GAWBRBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBRBECR()     ((volatile u32GAWBRBECR_word_view *)\
N(GAWBRBECR_REG__ ))
X#define pu32GAWBRBECR()     ((volatile u32GAWBRBECR_word_view *)(GAWBRBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBRBECR_WR() (pst_bitGAWBRBECR() -> WR)            
N#define biGetGAWBRBECR_BTYPE() (pst_bitGAWBRBECR() -> BTYPE)            
N#define biGetGAWBRBECR_BSIZE() (pst_bitGAWBRBECR() -> BSIZE)            
N#define biGetGAWBRBECR_RTYPE() (pst_bitGAWBRBECR() -> RTYPE)            
N#define biGetGAWBRBECR_BEN() (pst_bitGAWBRBECR() -> BEN)            
N#define biGetGAWBRBECR_ID() (pst_bitGAWBRBECR() -> ID)            
N#define biGetGAWBRBECR_LEN() (pst_bitGAWBRBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGAWBRBECRLL() (pst_u8GAWBRBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBRBECRLH() (pst_u8GAWBRBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBRBECRHL() (pst_u8GAWBRBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBRBECRHH() (pst_u8GAWBRBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBRBECRL() (pst_u16GAWBRBECR() -> u16L)
N#define u16GetGAWBRBECRH() (pst_u16GAWBRBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBRBECR()  (*pu32GAWBRBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBWBEAR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00038                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBWBEAR_REG__       0xC0C00038U
N#else
S#define GAWBWBEAR_REG__       &GAWBWBEAR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   WBWA	:29; 	 /* 3..31  bit(s) R */                    
N} GAWBWBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBWBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBWBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBWBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBWBEAR()     ((volatile GAWBWBEAR_bit_view_st *)\
N(GAWBWBEAR_REG__ ))
X#define pst_bitGAWBWBEAR()     ((volatile GAWBWBEAR_bit_view_st *)(GAWBWBEAR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBWBEAR()     ((volatile GAWBWBEAR_byte_view_st *)\
N(GAWBWBEAR_REG__ ))
X#define pst_u8GAWBWBEAR()     ((volatile GAWBWBEAR_byte_view_st *)(GAWBWBEAR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBWBEAR()     ((volatile GAWBWBEAR_halfword_view_st *)\
N(GAWBWBEAR_REG__ ))
X#define pst_u16GAWBWBEAR()     ((volatile GAWBWBEAR_halfword_view_st *)(GAWBWBEAR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBWBEAR()     ((volatile u32GAWBWBEAR_word_view *)\
N(GAWBWBEAR_REG__ ))
X#define pu32GAWBWBEAR()     ((volatile u32GAWBWBEAR_word_view *)(GAWBWBEAR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBWBEAR_WBWA() (pst_bitGAWBWBEAR() -> WBWA)
N            
N/* LL-struct byte access */
N#define u8GetGAWBWBEARLL() (pst_u8GAWBWBEAR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBWBEARLH() (pst_u8GAWBWBEAR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBWBEARHL() (pst_u8GAWBWBEAR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBWBEARHH() (pst_u8GAWBWBEAR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBWBEARL() (pst_u16GAWBWBEAR() -> u16L)
N#define u16GetGAWBWBEARH() (pst_u16GAWBWBEAR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBWBEAR()  (*pu32GAWBWBEAR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAWBWBECR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0003C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAWBWBECR_REG__       0xC0C0003CU
N#else
S#define GAWBWBECR_REG__       &GAWBWBECR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..31  bit(s) R */                    
N} GAWBWBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAWBWBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAWBWBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAWBWBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAWBWBECR()     ((volatile GAWBWBECR_bit_view_st *)\
N(GAWBWBECR_REG__ ))
X#define pst_bitGAWBWBECR()     ((volatile GAWBWBECR_bit_view_st *)(GAWBWBECR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAWBWBECR()     ((volatile GAWBWBECR_byte_view_st *)\
N(GAWBWBECR_REG__ ))
X#define pst_u8GAWBWBECR()     ((volatile GAWBWBECR_byte_view_st *)(GAWBWBECR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAWBWBECR()     ((volatile GAWBWBECR_halfword_view_st *)\
N(GAWBWBECR_REG__ ))
X#define pst_u16GAWBWBECR()     ((volatile GAWBWBECR_halfword_view_st *)(GAWBWBECR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAWBWBECR()     ((volatile u32GAWBWBECR_word_view *)\
N(GAWBWBECR_REG__ ))
X#define pu32GAWBWBECR()     ((volatile u32GAWBWBECR_word_view *)(GAWBWBECR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAWBWBECR_WR() (pst_bitGAWBWBECR() -> WR)            
N#define biGetGAWBWBECR_BTYPE() (pst_bitGAWBWBECR() -> BTYPE)            
N#define biGetGAWBWBECR_BSIZE() (pst_bitGAWBWBECR() -> BSIZE)            
N#define biGetGAWBWBECR_RTYPE() (pst_bitGAWBWBECR() -> RTYPE)            
N#define biGetGAWBWBECR_BEN() (pst_bitGAWBWBECR() -> BEN)            
N#define biGetGAWBWBECR_ID() (pst_bitGAWBWBECR() -> ID)            
N#define biGetGAWBWBECR_LEN() (pst_bitGAWBWBECR() -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGAWBWBECRLL() (pst_u8GAWBWBECR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAWBWBECRLH() (pst_u8GAWBWBECR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAWBWBECRHL() (pst_u8GAWBWBECR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAWBWBECRHH() (pst_u8GAWBWBECR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAWBWBECRL() (pst_u16GAWBWBECR() -> u16L)
N#define u16GetGAWBWBECRH() (pst_u16GAWBWBECR() -> u16H)
N            
N/* Word access */
N#define u32GetGAWBWBECR()  (*pu32GAWBWBECR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR0LR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00040                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR0LR_REG__       0xC0C00040U
N#else
S#define GAMPR0LR_REG__       &GAMPR0LR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR0L	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR0LR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR0LR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR0LR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR0LR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR0LR()     ((volatile GAMPR0LR_bit_view_st *)\
N(GAMPR0LR_REG__ ))
X#define pst_bitGAMPR0LR()     ((volatile GAMPR0LR_bit_view_st *)(GAMPR0LR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR0LR()     ((volatile GAMPR0LR_byte_view_st *)\
N(GAMPR0LR_REG__ ))
X#define pst_u8GAMPR0LR()     ((volatile GAMPR0LR_byte_view_st *)(GAMPR0LR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR0LR()     ((volatile GAMPR0LR_halfword_view_st *)\
N(GAMPR0LR_REG__ ))
X#define pst_u16GAMPR0LR()     ((volatile GAMPR0LR_halfword_view_st *)(GAMPR0LR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR0LR()     ((volatile u32GAMPR0LR_word_view *)\
N(GAMPR0LR_REG__ ))
X#define pu32GAMPR0LR()     ((volatile u32GAMPR0LR_word_view *)(GAMPR0LR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR0LR_MPR0L() (pst_bitGAMPR0LR() -> MPR0L)
N#define vSetGAMPR0LR_MPR0L(ParValue)  (pst_bitGAMPR0LR() -> MPR0L=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR0LRLL(ParValue) (pst_u8GAMPR0LR() -> u8LL = (ParValue))
N#define u8GetGAMPR0LRLL() (pst_u8GAMPR0LR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR0LRLH(ParValue) (pst_u8GAMPR0LR() -> u8LH = (ParValue))
N#define u8GetGAMPR0LRLH() (pst_u8GAMPR0LR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR0LRHL(ParValue) (pst_u8GAMPR0LR() -> u8HL = (ParValue))
N#define u8GetGAMPR0LRHL() (pst_u8GAMPR0LR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR0LRHH(ParValue) (pst_u8GAMPR0LR() -> u8HH = (ParValue))
N#define u8GetGAMPR0LRHH() (pst_u8GAMPR0LR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR0LRL(ParValue) (pst_u16GAMPR0LR() -> u16L = (ParValue))
N#define u16GetGAMPR0LRL() (pst_u16GAMPR0LR() -> u16L)
N#define vSetGAMPR0LRH(ParValue) (pst_u16GAMPR0LR() -> u16H = (ParValue))
N#define u16GetGAMPR0LRH() (pst_u16GAMPR0LR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR0LR(ParValue)  (*pu32GAMPR0LR() = (ParValue))
N#define u32GetGAMPR0LR()  (*pu32GAMPR0LR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR0HR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00044                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR0HR_REG__       0xC0C00044U
N#else
S#define GAMPR0HR_REG__       &GAMPR0HR_REG_EMUL
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR0H	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR0HR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR0HR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR0HR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR0HR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR0HR()     ((volatile GAMPR0HR_bit_view_st *)\
N(GAMPR0HR_REG__ ))
X#define pst_bitGAMPR0HR()     ((volatile GAMPR0HR_bit_view_st *)(GAMPR0HR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR0HR()     ((volatile GAMPR0HR_byte_view_st *)\
N(GAMPR0HR_REG__ ))
X#define pst_u8GAMPR0HR()     ((volatile GAMPR0HR_byte_view_st *)(GAMPR0HR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR0HR()     ((volatile GAMPR0HR_halfword_view_st *)\
N(GAMPR0HR_REG__ ))
X#define pst_u16GAMPR0HR()     ((volatile GAMPR0HR_halfword_view_st *)(GAMPR0HR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR0HR()     ((volatile u32GAMPR0HR_word_view *)\
N(GAMPR0HR_REG__ ))
X#define pu32GAMPR0HR()     ((volatile u32GAMPR0HR_word_view *)(GAMPR0HR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR0HR_MPR0H() (pst_bitGAMPR0HR() -> MPR0H)
N#define vSetGAMPR0HR_MPR0H(ParValue)  (pst_bitGAMPR0HR() -> MPR0H=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR0HRLL(ParValue) (pst_u8GAMPR0HR() -> u8LL = (ParValue))
N#define u8GetGAMPR0HRLL() (pst_u8GAMPR0HR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR0HRLH(ParValue) (pst_u8GAMPR0HR() -> u8LH = (ParValue))
N#define u8GetGAMPR0HRLH() (pst_u8GAMPR0HR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR0HRHL(ParValue) (pst_u8GAMPR0HR() -> u8HL = (ParValue))
N#define u8GetGAMPR0HRHL() (pst_u8GAMPR0HR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR0HRHH(ParValue) (pst_u8GAMPR0HR() -> u8HH = (ParValue))
N#define u8GetGAMPR0HRHH() (pst_u8GAMPR0HR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR0HRL(ParValue) (pst_u16GAMPR0HR() -> u16L = (ParValue))
N#define u16GetGAMPR0HRL() (pst_u16GAMPR0HR() -> u16L)
N#define vSetGAMPR0HRH(ParValue) (pst_u16GAMPR0HR() -> u16H = (ParValue))
N#define u16GetGAMPR0HRH() (pst_u16GAMPR0HR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR0HR(ParValue)  (*pu32GAMPR0HR() = (ParValue))
N#define u32GetGAMPR0HR()  (*pu32GAMPR0HR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR1LR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00048                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR1LR_REG__       0xC0C00048U
N#else
S#define GAMPR1LR_REG__       &GAMPR1LR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR1L	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR1LR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR1LR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR1LR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR1LR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR1LR()     ((volatile GAMPR1LR_bit_view_st *)\
N(GAMPR1LR_REG__ ))
X#define pst_bitGAMPR1LR()     ((volatile GAMPR1LR_bit_view_st *)(GAMPR1LR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR1LR()     ((volatile GAMPR1LR_byte_view_st *)\
N(GAMPR1LR_REG__ ))
X#define pst_u8GAMPR1LR()     ((volatile GAMPR1LR_byte_view_st *)(GAMPR1LR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR1LR()     ((volatile GAMPR1LR_halfword_view_st *)\
N(GAMPR1LR_REG__ ))
X#define pst_u16GAMPR1LR()     ((volatile GAMPR1LR_halfword_view_st *)(GAMPR1LR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR1LR()     ((volatile u32GAMPR1LR_word_view *)\
N(GAMPR1LR_REG__ ))
X#define pu32GAMPR1LR()     ((volatile u32GAMPR1LR_word_view *)(GAMPR1LR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR1LR_MPR1L() (pst_bitGAMPR1LR() -> MPR1L)
N#define vSetGAMPR1LR_MPR1L(ParValue)  (pst_bitGAMPR1LR() -> MPR1L=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR1LRLL(ParValue) (pst_u8GAMPR1LR() -> u8LL = (ParValue))
N#define u8GetGAMPR1LRLL() (pst_u8GAMPR1LR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR1LRLH(ParValue) (pst_u8GAMPR1LR() -> u8LH = (ParValue))
N#define u8GetGAMPR1LRLH() (pst_u8GAMPR1LR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR1LRHL(ParValue) (pst_u8GAMPR1LR() -> u8HL = (ParValue))
N#define u8GetGAMPR1LRHL() (pst_u8GAMPR1LR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR1LRHH(ParValue) (pst_u8GAMPR1LR() -> u8HH = (ParValue))
N#define u8GetGAMPR1LRHH() (pst_u8GAMPR1LR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR1LRL(ParValue) (pst_u16GAMPR1LR() -> u16L = (ParValue))
N#define u16GetGAMPR1LRL() (pst_u16GAMPR1LR() -> u16L)
N#define vSetGAMPR1LRH(ParValue) (pst_u16GAMPR1LR() -> u16H = (ParValue))
N#define u16GetGAMPR1LRH() (pst_u16GAMPR1LR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR1LR(ParValue)  (*pu32GAMPR1LR() = (ParValue))
N#define u32GetGAMPR1LR()  (*pu32GAMPR1LR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPR1HR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C0004C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPR1HR_REG__       0xC0C0004CU
N#else
S#define GAMPR1HR_REG__       &GAMPR1HR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:12; 	 /* 0..11  bit(s) R */ 
N  uint32_t   MPR1H	:20; 	 /* 12..31  bit(s) R/W */                    
N} GAMPR1HR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPR1HR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPR1HR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPR1HR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPR1HR()     ((volatile GAMPR1HR_bit_view_st *)\
N(GAMPR1HR_REG__ ))
X#define pst_bitGAMPR1HR()     ((volatile GAMPR1HR_bit_view_st *)(GAMPR1HR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPR1HR()     ((volatile GAMPR1HR_byte_view_st *)\
N(GAMPR1HR_REG__ ))
X#define pst_u8GAMPR1HR()     ((volatile GAMPR1HR_byte_view_st *)(GAMPR1HR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPR1HR()     ((volatile GAMPR1HR_halfword_view_st *)\
N(GAMPR1HR_REG__ ))
X#define pst_u16GAMPR1HR()     ((volatile GAMPR1HR_halfword_view_st *)(GAMPR1HR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPR1HR()     ((volatile u32GAMPR1HR_word_view *)\
N(GAMPR1HR_REG__ ))
X#define pu32GAMPR1HR()     ((volatile u32GAMPR1HR_word_view *)(GAMPR1HR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPR1HR_MPR1H() (pst_bitGAMPR1HR() -> MPR1H)
N#define vSetGAMPR1HR_MPR1H(ParValue)  (pst_bitGAMPR1HR() -> MPR1H=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGAMPR1HRLL(ParValue) (pst_u8GAMPR1HR() -> u8LL = (ParValue))
N#define u8GetGAMPR1HRLL() (pst_u8GAMPR1HR() -> u8LL)
N/* LH-struct byte access */
N#define vSetGAMPR1HRLH(ParValue) (pst_u8GAMPR1HR() -> u8LH = (ParValue))
N#define u8GetGAMPR1HRLH() (pst_u8GAMPR1HR() -> u8LH)
N/* HL-struct byte access */
N#define vSetGAMPR1HRHL(ParValue) (pst_u8GAMPR1HR() -> u8HL = (ParValue))
N#define u8GetGAMPR1HRHL() (pst_u8GAMPR1HR() -> u8HL)
N/* HH-struct byte access */
N#define vSetGAMPR1HRHH(ParValue) (pst_u8GAMPR1HR() -> u8HH = (ParValue))
N#define u8GetGAMPR1HRHH() (pst_u8GAMPR1HR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGAMPR1HRL(ParValue) (pst_u16GAMPR1HR() -> u16L = (ParValue))
N#define u16GetGAMPR1HRL() (pst_u16GAMPR1HR() -> u16L)
N#define vSetGAMPR1HRH(ParValue) (pst_u16GAMPR1HR() -> u16H = (ParValue))
N#define u16GetGAMPR1HRH() (pst_u16GAMPR1HR() -> u16H)
N            
N/* Word access */
N#define vSetGAMPR1HR(ParValue)  (*pu32GAMPR1HR() = (ParValue))
N#define u32GetGAMPR1HR()  (*pu32GAMPR1HR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPICR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00050                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPICR_REG__       0xC0C00050U
N#else
S#define GAMPICR_REG__       &GAMPICR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   GAMPI	:1; 	 /* 0..0  bit(s) R/W1C */
N  uint8_t   GAMPCI	:1; 	 /* 1..1  bit(s) R/W1C */ 
N  uint8_t   	:6; 	 /* 2..31  bit(s) R */                    
N} GAMPICR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GAMPICR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPICR()     ((volatile GAMPICR_bit_view_st *)\
N(GAMPICR_REG__ ))
X#define pst_bitGAMPICR()     ((volatile GAMPICR_bit_view_st *)(GAMPICR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8GAMPICR()     ((volatile u8GAMPICR_byte_view *)\
N(GAMPICR_REG__ ))
X#define pu8GAMPICR()     ((volatile u8GAMPICR_byte_view *)(GAMPICR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPICR_GAMPI() (pst_bitGAMPICR() -> GAMPI)
N#define vClrGAMPICR_GAMPI() (pst_bitGAMPICR() -> GAMPI = (1))
N#define biGetGAMPICR_GAMPCI() (pst_bitGAMPICR() -> GAMPCI)
N#define vClrGAMPICR_GAMPCI() (pst_bitGAMPICR() -> GAMPCI = (1))
N            
N/* byte access */
N#define vSetGAMPICR(ParValue) (*pu8GAMPICR() = (ParValue))
N#define u8GetGAMPICR() (*pu8GAMPICR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPIMR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00054                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPIMR_REG__       0xC0C00054U
N#else
S#define GAMPIMR_REG__       &GAMPIMR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   GAMPIM	:1; 	 /* 0..0  bit(s) R/W */
N  uint8_t   GAMPCIM	:1; 	 /* 1..1  bit(s) R/W */ 
N  uint8_t   	:6; 	 /* 2..31  bit(s) R */                    
N} GAMPIMR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GAMPIMR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPIMR()     ((volatile GAMPIMR_bit_view_st *)\
N(GAMPIMR_REG__ ))
X#define pst_bitGAMPIMR()     ((volatile GAMPIMR_bit_view_st *)(GAMPIMR_REG__ ))
N        
N/* Pointer to BYTE  */
N#define pu8GAMPIMR()     ((volatile u8GAMPIMR_byte_view *)\
N(GAMPIMR_REG__ ))
X#define pu8GAMPIMR()     ((volatile u8GAMPIMR_byte_view *)(GAMPIMR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGAMPIMR_GAMPIM() (pst_bitGAMPIMR() -> GAMPIM)
N#define vSetGAMPIMR_GAMPIM(ParValue)  (pst_bitGAMPIMR() -> GAMPIM=(ParValue))
N#define biGetGAMPIMR_GAMPCIM() (pst_bitGAMPIMR() -> GAMPCIM)
N#define vSetGAMPIMR_GAMPCIM(ParValue)  (pst_bitGAMPIMR() -> GAMPCIM=(ParValue))
N            
N/* byte access */
N#define vSetGAMPIMR(ParValue) (*pu8GAMPIMR() = (ParValue))
N#define u8GetGAMPIMR() (*pu8GAMPIMR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAMPACR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00058                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAMPACR_REG__       0xC0C00058U
N#else
S#define GAMPACR_REG__       &GAMPACR_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */ 
N  uint32_t   MPVA	:29; 	 /* 3..31  bit(s) R */                    
N} GAMPACR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GAMPACR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GAMPACR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GAMPACR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGAMPACR()     ((volatile GAMPACR_bit_view_st *)\
N(GAMPACR_REG__ ))
X#define pst_bitGAMPACR()     ((volatile GAMPACR_bit_view_st *)(GAMPACR_REG__ ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GAMPACR()     ((volatile GAMPACR_byte_view_st *)\
N(GAMPACR_REG__ ))
X#define pst_u8GAMPACR()     ((volatile GAMPACR_byte_view_st *)(GAMPACR_REG__ ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GAMPACR()     ((volatile GAMPACR_halfword_view_st *)\
N(GAMPACR_REG__ ))
X#define pst_u16GAMPACR()     ((volatile GAMPACR_halfword_view_st *)(GAMPACR_REG__ ))
N            
N/* Pointer to WORD  */ 
N#define pu32GAMPACR()     ((volatile u32GAMPACR_word_view *)\
N(GAMPACR_REG__ ))
X#define pu32GAMPACR()     ((volatile u32GAMPACR_word_view *)(GAMPACR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGAMPACR_MPVA() (pst_bitGAMPACR() -> MPVA)
N            
N/* LL-struct byte access */
N#define u8GetGAMPACRLL() (pst_u8GAMPACR() -> u8LL)
N/* LH-struct byte access */
N#define u8GetGAMPACRLH() (pst_u8GAMPACR() -> u8LH)
N/* HL-struct byte access */
N#define u8GetGAMPACRHL() (pst_u8GAMPACR() -> u8HL)
N/* HH-struct byte access */
N#define u8GetGAMPACRHH() (pst_u8GAMPACR() -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGAMPACRL() (pst_u16GAMPACR() -> u16L)
N#define u16GetGAMPACRH() (pst_u16GAMPACR() -> u16H)
N            
N/* Word access */
N#define u32GetGAMPACR()  (*pu32GAMPACR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GAGPR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00080                             
N*       ACCESS  : 32,                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GAGPR_REG__       0xC0C00080U
N#else
S#define GAGPR_REG__       &GAGPR_REG_EMUL[0]
N#endif
N     
N/************************       STRUCTURES        ***************************/
N        
N/* WORD View */
Ntypedef uint32_t u32GAGPR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to WORD  */ 
N#define pu32GAGPR(ch)     ((volatile u32GAGPR_word_view *)\
N(GAGPR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pu32GAGPR(ch)     ((volatile u32GAGPR_word_view *)(GAGPR_REG__  + ((uint16_t)(ch) * 0x04U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N            
N/* Word access */
N#define vSetGAGPR(ch,ParValue)  (*pu32GAGPR(ch) = (ParValue))
N#define u32GetGAGPR(ch)  (*pu32GAGPR(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACMDL                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00100                             
N*       ACCESS  : 32,                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACMDL_REG__       0xC0C00100U
N#else
S#define GACMDL_REG__       &GACMDL_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N        
N/* WORD View */
Ntypedef uint32_t u32GACMDL_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to WORD  */ 
N#define pu32GACMDL()     ((volatile u32GACMDL_word_view *)\
N(GACMDL_REG__ ))
X#define pu32GACMDL()     ((volatile u32GACMDL_word_view *)(GACMDL_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N            
N/* Word access */
N#define vSetGACMDL(ParValue)  (*pu32GACMDL() = (ParValue))
N#define u32GetGACMDL()  (*pu32GACMDL() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GACMDH                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00104                             
N*       ACCESS  : 32,                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GACMDH_REG__       0xC0C00104U
N#else
S#define GACMDH_REG__       &GACMDH_REG_EMUL
N#endif
N     
N/************************       STRUCTURES        ***************************/
N        
N/* WORD View */
Ntypedef uint32_t u32GACMDH_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to WORD  */ 
N#define pu32GACMDH()     ((volatile u32GACMDH_word_view *)\
N(GACMDH_REG__ ))
X#define pu32GACMDH()     ((volatile u32GACMDH_word_view *)(GACMDH_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N            
N/* Word access */
N#define vSetGACMDH(ParValue)  (*pu32GACMDH() = (ParValue))
N#define u32GetGACMDH()  (*pu32GACMDH() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GADEFCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC0C00200                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GA 
N#define GADEFCR_REG__       0xC0C00200U
N#else
S#define GADEFCR_REG__       &GADEFCR_REG_EMUL[0]
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   FC3	:8; 	 /* 0..7  bit(s) R/W */
N  uint32_t   FC2	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   FC1	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   FC0	:8; 	 /* 24..31  bit(s) R/W */                    
N} GADEFCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GADEFCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GADEFCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GADEFCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitGADEFCR(ch)     ((volatile GADEFCR_bit_view_st *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pst_bitGADEFCR(ch)     ((volatile GADEFCR_bit_view_st *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GADEFCR(ch)     ((volatile GADEFCR_byte_view_st *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pst_u8GADEFCR(ch)     ((volatile GADEFCR_byte_view_st *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GADEFCR(ch)     ((volatile GADEFCR_halfword_view_st *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pst_u16GADEFCR(ch)     ((volatile GADEFCR_halfword_view_st *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N            
N/* Pointer to WORD  */ 
N#define pu32GADEFCR(ch)     ((volatile u32GADEFCR_word_view *)\
N(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
X#define pu32GADEFCR(ch)     ((volatile u32GADEFCR_word_view *)(GADEFCR_REG__  + ((uint16_t)(ch) * 0x04U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGADEFCR_FC3(ch) (pst_bitGADEFCR(ch) -> FC3)
N#define vSetGADEFCR_FC3(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC3=(ParValue))
N#define biGetGADEFCR_FC2(ch) (pst_bitGADEFCR(ch) -> FC2)
N#define vSetGADEFCR_FC2(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC2=(ParValue))
N#define biGetGADEFCR_FC1(ch) (pst_bitGADEFCR(ch) -> FC1)
N#define vSetGADEFCR_FC1(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC1=(ParValue))
N#define biGetGADEFCR_FC0(ch) (pst_bitGADEFCR(ch) -> FC0)
N#define vSetGADEFCR_FC0(ch,ParValue)  (pst_bitGADEFCR(ch) -> FC0=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGADEFCRLL(ch,ParValue) (pst_u8GADEFCR(ch) -> u8LL = (ParValue))
N#define u8GetGADEFCRLL(ch) (pst_u8GADEFCR(ch) -> u8LL)
N/* LH-struct byte access */
N#define vSetGADEFCRLH(ch,ParValue) (pst_u8GADEFCR(ch) -> u8LH = (ParValue))
N#define u8GetGADEFCRLH(ch) (pst_u8GADEFCR(ch) -> u8LH)
N/* HL-struct byte access */
N#define vSetGADEFCRHL(ch,ParValue) (pst_u8GADEFCR(ch) -> u8HL = (ParValue))
N#define u8GetGADEFCRHL(ch) (pst_u8GADEFCR(ch) -> u8HL)
N/* HH-struct byte access */
N#define vSetGADEFCRHH(ch,ParValue) (pst_u8GADEFCR(ch) -> u8HH = (ParValue))
N#define u8GetGADEFCRHH(ch) (pst_u8GADEFCR(ch) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGADEFCRL(ch,ParValue) (pst_u16GADEFCR(ch) -> u16L = (ParValue))
N#define u16GetGADEFCRL(ch) (pst_u16GADEFCR(ch) -> u16L)
N#define vSetGADEFCRH(ch,ParValue) (pst_u16GADEFCR(ch) -> u16H = (ParValue))
N#define u16GetGADEFCRH(ch) (pst_u16GADEFCR(ch) -> u16H)
N            
N/* Word access */
N#define vSetGADEFCR(ch,ParValue)  (*pu32GADEFCR(ch) = (ParValue))
N#define u32GetGADEFCR(ch)  (*pu32GADEFCR(ch) )
N
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#endif /* GAIO_H */  
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_io.c
N**  $Revision: 1.12 $
N**  $Date: 2015/05/04 09:07:16 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 230 / 6.4 - bitwise operation may not be performed on signed integer types
N** | CONS.  : allow
N** | REASON : to use macros generated by converter tool 
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 25 "..\..\..\..\lldd\src\ga.c" 2
N#include "stdlib.h"
L 1 "C:\Keil_v5\ARM\ARMCC_505u2\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5050157
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 26 "..\..\..\..\lldd\src\ga.c" 2
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1730  /* Rule 12.7 [R] : bitwise operation may not be performed on signed integer types */
S  #pragma ghs nowarning 1752  /* Rule 17.4 [R] : pointer arithmetic not allowed */
S  #pragma ghs nowarning 1847  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to non-integer type "type" not allowed */
S  #pragma ghs nowarning 1858  /* Rule 17.4 [R] : subscript operator may only be applied to objects declared as an array type */
S  #pragma ghs nowarning 1864  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to narrower underlying type, "type", not allowed */
S  #pragma ghs nowarning 1865  /* Rule 10.1 [R] : conversion from underlying type, "int", to same width underlying type, "uint32_t", not allowed */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to underlying type, "type", changes signedness */
S  #pragma ghs nowarning 1867  /* Rule 10.1 [R] : disable type conversion not allowed for usage of enums for io header files */
S  #pragma ghs nowarning 1879  /* Rule 10.3 [R] :  cast of complex integer expression with underlying type "type" to same width type "type" not allowed */
S
S  #pragma ghs nowarning 1737  /* Rule 12.1 [A] : expression may not depend on operator precedence rules */
S  #pragma ghs nowarning 1834  /* Rule 11.3 [A] : disable casting error */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S  #pragma ghs nowarning 1855  /* Rule 13.2 [A] : Explicit test of a value against zero unless the expression is Boolean */
S
N#endif
N
N
N/*======================================
N    Stat. Var and Func. Prototypes
N=======================================*/
N
N/*======================================
N    Glob. Var and Func. Prototypes
N=======================================*/
N
N/*======================================
N                Macros
N=======================================*/
N
N#define LLDD_GA_C_REVISION     "$Revision: 1.20 $"
N#define LLDD_GA_C_TAG          "$Name: LLDD_1_7_GFX $"
N
N
N#define GA_PROT_REGION_MASK  0xFFF
N#define GA_IRQ_CLR_ALL       0xFFFFFFFDU
N/*======================================
N Static variables and forward declarations
N=======================================*/
N
Nstatic uint8_t au8LLDD_GA_C_REVISION[]          = LLDD_GA_C_REVISION;
Xstatic uint8_t au8LLDD_GA_C_REVISION[]          = "$Revision: 1.20 $";
Nstatic uint8_t au8LLDD_GA_C_TAG[]               = LLDD_GA_C_TAG;
Xstatic uint8_t au8LLDD_GA_C_TAG[]               = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GA_H_REVISION[]          = LLDD_GA_H_REVISION;
Xstatic uint8_t au8LLDD_GA_H_REVISION[]          = "$Revision: 1.19 $";
Nstatic uint8_t au8LLDD_GA_H_TAG[]               = LLDD_GA_H_TAG;
Xstatic uint8_t au8LLDD_GA_H_TAG[]               = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GA_COMMON_H_REVISION[]   = LLDD_GA_COMMON_H_REVISION;
Xstatic uint8_t au8LLDD_GA_COMMON_H_REVISION[]   = "$Revision: 1.14 $";
Nstatic uint8_t au8LLDD_GA_COMMON_H_TAG[]        = LLDD_GA_COMMON_H_TAG;
Xstatic uint8_t au8LLDD_GA_COMMON_H_TAG[]        = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GA_IO_H_REVISION[]       = LLDD_GA_IO_H_REVISION;
Xstatic uint8_t au8LLDD_GA_IO_H_REVISION[]       = "$Revision: 1.12 $";
Nstatic uint8_t au8LLDD_GA_IO_H_TAG[]            = LLDD_GA_IO_H_TAG;
Xstatic uint8_t au8LLDD_GA_IO_H_TAG[]            = "$Name: LLDD_1_7_GFX $";
N
Nstatic uint32_t u32MaxUsedBuffSize = 0U;
N
N/*======================================
N          Function definitions
N=======================================*/
N
Nvoid vGA_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                    uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                    uint8_t** pau8CommonRevision, uint8_t** pau8CommonTag,
N                    uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N     *pau8ModuleRevision = &au8LLDD_GA_C_REVISION[0];
N     *pau8ModuleTag      = &au8LLDD_GA_C_TAG[0];
N     *pau8HeaderRevision = &au8LLDD_GA_H_REVISION[0];
N     *pau8HeaderTag      = &au8LLDD_GA_H_TAG[0];
N     *pau8CommonRevision = &au8LLDD_GA_COMMON_H_REVISION[0];
N     *pau8CommonTag      = &au8LLDD_GA_COMMON_H_TAG[0];
N     *pau8IORevision     = &au8LLDD_GA_IO_H_REVISION[0];
N     *pau8IOTag          = &au8LLDD_GA_IO_H_TAG[0];
N}
N
N/* ....................................................................... */
Nvoid vGA_ResetMaxUsedBuffSize(void)
N{
N     u32MaxUsedBuffSize = 0U;
N}
N/* ....................................................................... */
Nuint32_t u32GA_GetMaxUsedBuffSize(void)
N{
N     return u32MaxUsedBuffSize;
N}
N/* ....................................................................... */
Nint32_t i32GA_GetLastCmdBuffStatus(ga_list_st* pstCmdList)
N{
N     return pstCmdList->i32FreeSpaceStat;
N}
N/* ....................................................................... */
Nuint32_t u32GA_GetLastCmdSize(ga_list_st* pstCmdList)
N{
N     return pstCmdList->u32UsedDoubleWords;
N}
N/* ....................................................................... */
Nint32_t i32GA_CheckList(ga_list_st* pstCmdList, uint32_t u32NeededDW)
N{
N    int32_t i32Result;
N   /* check if there are enough double words free */
N   if ((pstCmdList->pu64Current + u32NeededDW-1) < &pstCmdList->ullCommands[GA_CMD_MAX])
X   if ((pstCmdList->pu64Current + u32NeededDW-1) < &pstCmdList->ullCommands[2048])
N   {
N       i32Result = C_SUCCESS;
X       i32Result = (0);
N   }
N   else
N   {
N       i32Result = C_FAILED;
X       i32Result = (-1);
N   }
N   return (i32Result);
N}
N/* ....................................................................... */
Nvoid vGA_ResetList(ga_list_st* pstCmdList)
N{
N
N    pstCmdList->pu64Current = &(pstCmdList->ullCommands[0]);
N    pstCmdList->i32FreeSpaceStat   = C_SUCCESS;
X    pstCmdList->i32FreeSpaceStat   = (0);
N    pstCmdList->u32UsedDoubleWords = 0U;
N
N}
N
N/* ....................................................................... */
Nvoid vGA_Enable(ga_en_e eEn)
N{
N    vSetGASCR_GAEN((uint8_t)eEn);
X    (((volatile GASCR_bit_view_st *)(0xC0C00000U )) -> GAEN=((uint8_t)eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ReadAheadEnable(ga_en_e eEn)
N{
N    /* NOTE:
N     * Disable ReadBuffer Read Ahead feature
N     *   0: Read Ahead feature is enabled
N     *   1: Read Ahead feature is disabled */
N    if (GA_EN == eEn)
N    {
N        vSetGASCR_DISRA((uint8_t)GA_DIS);
X        (((volatile GASCR_bit_view_st *)(0xC0C00000U )) -> DISRA=((uint8_t)GA_DIS));
N    }
N    else
N    {
N        vSetGASCR_DISRA((uint8_t)GA_EN);
X        (((volatile GASCR_bit_view_st *)(0xC0C00000U )) -> DISRA=((uint8_t)GA_EN));
N    }
N}
N
N/* ....................................................................... */
Nvoid vGA_CloseList(ga_list_st* pstCmdList)
N{
N    uint32_t u32UsedBuffSize;
N    uint64_t* pullCurr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW = 1;
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N
N    pullCurr[0] = GA_END();
X    pullCurr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((0x1u))) & ((0xfu))) << (56))) | ((((uint64_t)(((0xffu))) & ((0xffu))) << (48))) | ((((uint64_t)(((0x0u))) & ((0xffffffffffffull))) << (0)))));
N
N    pstCmdList->pu64Current = &pullCurr[1];
N
N    
N    u32UsedBuffSize = pstCmdList->pu64Current - pstCmdList->ullCommands;
N    if (u32UsedBuffSize > u32MaxUsedBuffSize) 
N    {
N      u32MaxUsedBuffSize = u32UsedBuffSize; 
N    }
N    pstCmdList->u32UsedDoubleWords = 1;
N}
N
N/* ....................................................................... */
Nvoid vGA_SyncList(ga_modul_e eModule, ga_list_st* pstCmdList)
N{
N    uint64_t* pullCurr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pullCurr[0] = GA_WAIT(eModule);
X    pullCurr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((0x1u))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x2u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((eModule)) & (0x3u)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N
N    pstCmdList->pu64Current = &pullCurr[1];
N    pstCmdList->u32UsedDoubleWords = 1;
N}
N
N/* ....................................................................... */
Nvoid vGA_SetUserInt(uint8_t u8Number, ga_list_st* pstCmdList)
N{
N    uint64_t* pullCurr = (uint64_t*) pstCmdList->pu64Current;
N
N#ifdef  GA_CMDSLIST_BOUNDARY_CHECK
S
S    uint32_t u32NeededDW = 1;
S   
S    u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
S
S    /* check if there is enough space in command list: */
S    if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
S    {
S      pstCmdList->i32FreeSpaceStat = C_FAILED;
S      pstCmdList->u32UsedDoubleWords = u32NeededDW;
S      return;
S    }
S    else 
S    {
S      pstCmdList->i32FreeSpaceStat = C_SUCCESS;
S    }
N#endif
N
N    pullCurr[0] = GA_USERINTERRUPT(u8Number);
X    pullCurr[0] = (((uint64_t)0x0ull | ((((uint64_t)(((0x0u))) & ((0x7u))) << (60))) | ((((uint64_t)(((0x1u))) & ((0xfu))) << (56))) | ((((uint64_t)(((0x3u))) & ((0xffu))) << (48))) | ((((uint64_t)((((((uint64_t)((u8Number)) & (0x3fu)) << (0))))) & ((0xffffffffffffull))) << (0)))));
N
N    pstCmdList->pu64Current = &pullCurr[1];
N    pstCmdList->u32UsedDoubleWords = 1;
N}
N/* ....................................................................... */
Nint32_t i32GA_Reset(void)
N{
N    int32_t  i32Ret = C_FAILED;
X    int32_t  i32Ret = (-1);
N    int32_t  i32TimeOut = GA_TIMEOUT;
X    int32_t  i32TimeOut = 10000;
N    uint32_t u32Res;
N
N    vSetGASCR_GARESET();
X    (((volatile GASCR_bit_view_st *)(0xC0C00000U )) -> GARESET=(1));
N    u32Res =  (uint32_t)biGetGASCR_GARESET();
X    u32Res =  (uint32_t)(((volatile GASCR_bit_view_st *)(0xC0C00000U )) -> GARESET);
N
N    while((i32TimeOut > 0) && (u32Res == 1))
N    {
N        i32TimeOut--;
N    }
N
N    if(i32TimeOut > 0)
N    {
N        i32Ret = C_SUCCESS;
X        i32Ret = (0);
N    }
N
N    return i32Ret;
N}
N
N/* ....................................................................... */
Nvoid vGA_SetCmdListAddr(uint32_t u32Addr)
N{
N    vSetGACLAR(u32Addr);
X    (*((volatile u32GACLAR_word_view *)(0xC0C00004U )) = (u32Addr));
N}
N
N/* ....................................................................... */
Nuint8_t u8GA_GetStatus(void)
N{
N    return ((uint8_t) u8GetGASR());
X    return ((uint8_t) (*((volatile u8GASR_byte_view *)(0xC0C00008U )) ));
N}
N
N/* ....................................................................... */
Nbool_t boGA_CmdListFinished(void)
N{
N    bool_t boRes;
N    boRes = ( 0x01 == biGetGASR_CSLEF() )? C_TRUE : C_FALSE;
X    boRes = ( 0x01 == (((volatile GASR_bit_view_st *)(0xC0C00008U )) -> CSLEF) )? (1) : (0);
N    return (boRes);
N}
N
N/* ....................................................................... */
Nbool_t boGA_CmdListError(void)
N{
N    bool_t boRes;
N    boRes = ( 0x01 == biGetGASR_CSCEF() )? C_TRUE : C_FALSE;
X    boRes = ( 0x01 == (((volatile GASR_bit_view_st *)(0xC0C00008U )) -> CSCEF) )? (1) : (0);
N    return (boRes);
N}
N
N/* ....................................................................... */
Nbool_t boGA_CmdReg_IsBusy(void)
N{
N    bool_t boRes;
N    boRes = ( 0x01 == biGetGASR_BUSY() )? C_TRUE : C_FALSE;
X    boRes = ( 0x01 == (((volatile GASR_bit_view_st *)(0xC0C00008U )) -> BUSY) )? (1) : (0);
N    return (boRes);
N}
N
N/* ....................................................................... */
Nuint32_t u32GA_GetIrqCause(void)
N{
N    uint32_t u32Result;
N    
N    u32Result = u32GetGAICR();
X    u32Result = (*((volatile u32GAICR_word_view *)(0xC0C0000CU )) );
N    
N    return u32Result;
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearIrqCause(uint32_t u32CauseMask)
N{
N    /* set bit 1 to o, since these bit is Read Only: */
N    vSetGAICR(u32CauseMask & GA_IRQ_CLR_ALL);
X    (*((volatile u32GAICR_word_view *)(0xC0C0000CU )) = (u32CauseMask & 0xFFFFFFFDU));
N}
N
N/* ....................................................................... */
Nvoid vGA_SetIrqMask(uint32_t u32Mask)
N{
N  /* set bit 1 to o, since these bit is Read Only: */
N    vSetGAIMR(u32Mask & GA_IRQ_CLR_ALL);
X    (*((volatile u32GAIMR_word_view *)(0xC0C00010U )) = (u32Mask & 0xFFFFFFFDU));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableUserIrq(uint8_t u8Number, ga_en_e eEn)
N{
N    uint32_t  u32GAIMR_CSLUIM;
N    uint32_t  u32NewVal; 
N
N    /* invalid parameter: */
N    if (u8Number <= 23) 
N    {
N        u32GAIMR_CSLUIM = biGetGAIMR_CSLUIM();  
X        u32GAIMR_CSLUIM = (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> CSLUIM);  
N
N        u32NewVal = (eEn== GA_EN)? 1<<u8Number : 0;
N    
N        /* clear bit: */
N        u32GAIMR_CSLUIM &= ~(1<<u8Number);
N    
N        /* modify bit: */
N        u32GAIMR_CSLUIM |= u32NewVal;
N    
N        vSetGAIMR_CSLUIM(u32GAIMR_CSLUIM);
X        (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> CSLUIM=(u32GAIMR_CSLUIM));
N    }
N    
N    return;
N}
N
N/* ....................................................................... */
Nvoid vGA_CmdReg_EnableIrqCmdEnd(ga_en_e eEn)
N{
N    vSetGAIMR_GACENDIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> GACENDIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_CmdReg_ClearIrqCmdEnd(void)
N{
N    vClrGAICR_GACENDI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> GACENDI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableIrqCSCEI(ga_en_e eEn)
N{
N    vSetGAIMR_CSCEIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> CSCEIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearIrqCSCEI(void)
N{
N    vClrGAICR_CSCEI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> CSCEI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableIrqCSLEI(ga_en_e eEn)
N{
N    vSetGAIMR_CSLEIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> CSLEIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearIrqCSLEI(void)
N{
N    vClrGAICR_CSLEI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> CSLEI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_SetGADelay(uint16_t u16Delay)
N{
N    vSetGADR((uint32_t) u16Delay);
X    (*((volatile u16GADR_halfword_view *)(0xC0C00014U )) = ((uint32_t) u16Delay));
N}
N
N
N/*+-----------------------------------------------------------------------+*
N *|     START-Extended new APIs                                           |*
N *+-----------------------------------------------------------------------+*/
N
N/* ....................................................................... */
Nvoid vGA_EnableIrqGAWBWI(ga_en_e eEn)
N{
N    vSetGAIMR_GAWBWIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> GAWBWIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearIrqGAWBWI(void)
N{
N    vClrGAICR_GAWBWI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> GAWBWI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableIrqGAWBRI(ga_en_e eEn)
N{
N    vSetGAIMR_GAWBRIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> GAWBRIM=((uint8_t) eEn));
N}
N/* ....................................................................... */
Nvoid vGA_ClearIrqGAWBRI(void)
N{
N    vClrGAICR_GAWBRI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> GAWBRI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableIrqGACBI(ga_en_e eEn)
N{
N    vSetGAIMR_GACBIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> GACBIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearIrqGACBI(void)
N{
N    vClrGAICR_GACBI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> GACBI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableIrqGARBI(ga_en_e eEn)
N{
N    vSetGAIMR_GARBIM((uint8_t) eEn);
X    (((volatile GAIMR_bit_view_st *)(0xC0C00010U )) -> GARBIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearIrqGARBI(void)
N{
N    vClrGAICR_GARBI();
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> GARBI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearUserIrq(uint8_t u8CmdListIntr)
N
N{
N    vClrGAICR_CSLUI(u8CmdListIntr);
X    (((volatile GAICR_bit_view_st *)(0xC0C0000CU )) -> CSLUI = ( (0x000001 << (u8CmdListIntr)) & 0xFFFFFFU) );
N}
N
N/* ....................................................................... */
Nbool_t boGA_GetBusErrAddr(ga_bus_type_e eBusType, uint32_t* pu32BusErrAddr)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    uint32_t u32BusErrAddr;
N    
N    if(0x00 != pu32BusErrAddr)
N    {
N        switch( eBusType )
N        {
N            case GA_READ_BUF_BUS:
N                /* GA Read Buffer Bus: */
N                u32BusErrAddr = (uint32_t) u32GetGARBBEAR();
X                u32BusErrAddr = (uint32_t) (*((volatile u32GARBBEAR_word_view *)(0xC0C00020U )) );
N                *pu32BusErrAddr = u32BusErrAddr;
N                break;
N             
N            case GA_CACHE_BUF_BUS:
N                /* GA Cache Buffer Bus: */
N                u32BusErrAddr = (uint32_t) u32GetGACBBEAR();
X                u32BusErrAddr = (uint32_t) (*((volatile u32GACBBEAR_word_view *)(0xC0C00028U )) );
N                *pu32BusErrAddr = u32BusErrAddr;
N                break;
N
N            case GA_WRITE_BUF_READ_BUS:
N                /* GA Write Buffer Read Bus: */
N                u32BusErrAddr = (uint32_t) u32GetGAWBRBEAR();
X                u32BusErrAddr = (uint32_t) (*((volatile u32GAWBRBEAR_word_view *)(0xC0C00030U )) );
N                *pu32BusErrAddr = u32BusErrAddr;
N                break;
N
N            case GA_WRITE_BUF_WRITE_BUS:
N                /* GA Write Buffer Write Bus: */
N                u32BusErrAddr = (uint32_t) u32GetGAWBWBEAR();
X                u32BusErrAddr = (uint32_t) (*((volatile u32GAWBWBEAR_word_view *)(0xC0C00038U )) );
N                *pu32BusErrAddr = u32BusErrAddr;
N                break;
N
N            default:
N                /* Invalid Bus Type */
N                boRes = C_FALSE;
X                boRes = (0);
N                break;
N        }      
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    return  boRes;
N}
N
N/* ....................................................................... */
Nbool_t boGA_GetBusErrCtrlStatus(ga_bus_type_e eBusType, ga_bus_err_ctrl_st* pstCtrlStatus)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    
N    if(0x00 != pstCtrlStatus)
N    {
N        switch( eBusType )
N        {
N            case GA_READ_BUF_BUS:
N                /* GA Read Buffer Bus: */
N                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGARBBECR_WR();
X                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> WR);
N                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGARBBECR_BTYPE();
X                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> BTYPE);
N                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGARBBECR_BSIZE();
X                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> BSIZE);
N                pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGARBBECR_RTYPE();
X                pstCtrlStatus->eRespType     = (ga_buserr_resptype) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> RTYPE);
N                pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGARBBECR_BEN();
X                pstCtrlStatus->u8ByteEnables = (uint8_t) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> BEN);
N                pstCtrlStatus->u8ID          = (uint8_t) biGetGARBBECR_ID();
X                pstCtrlStatus->u8ID          = (uint8_t) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> ID);
N                pstCtrlStatus->u8BurstLength = (uint8_t) biGetGARBBECR_LEN();
X                pstCtrlStatus->u8BurstLength = (uint8_t) (((volatile GARBBECR_bit_view_st *)(0xC0C00024U )) -> LEN);
N                break;
N
N            case GA_CACHE_BUF_BUS:
N                /* GA Cache Buffer Bus: */
N                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGACBBECR_WR();
X                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> WR);
N                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGACBBECR_BTYPE();
X                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> BTYPE);
N                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGACBBECR_BSIZE();
X                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> BSIZE);
N                pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGACBBECR_RTYPE();
X                pstCtrlStatus->eRespType     = (ga_buserr_resptype) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> RTYPE);
N                pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGACBBECR_BEN();
X                pstCtrlStatus->u8ByteEnables = (uint8_t) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> BEN);
N                pstCtrlStatus->u8ID          = (uint8_t) biGetGACBBECR_ID();
X                pstCtrlStatus->u8ID          = (uint8_t) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> ID);
N                pstCtrlStatus->u8BurstLength = (uint8_t) biGetGACBBECR_LEN();
X                pstCtrlStatus->u8BurstLength = (uint8_t) (((volatile GACBBECR_bit_view_st *)(0xC0C0002CU )) -> LEN);
N                break;
N
N            case GA_WRITE_BUF_READ_BUS:
N                /* GA Write Buffer Read Bus: */
N                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGAWBRBECR_WR();
X                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> WR);
N                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGAWBRBECR_BTYPE();
X                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> BTYPE);
N                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGAWBRBECR_BSIZE();
X                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> BSIZE);
N                pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGAWBRBECR_RTYPE();
X                pstCtrlStatus->eRespType     = (ga_buserr_resptype) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> RTYPE);
N                pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGAWBRBECR_BEN();
X                pstCtrlStatus->u8ByteEnables = (uint8_t) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> BEN);
N                pstCtrlStatus->u8ID          = (uint8_t) biGetGAWBRBECR_ID();
X                pstCtrlStatus->u8ID          = (uint8_t) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> ID);
N                pstCtrlStatus->u8BurstLength = (uint8_t) biGetGAWBRBECR_LEN();
X                pstCtrlStatus->u8BurstLength = (uint8_t) (((volatile GAWBRBECR_bit_view_st *)(0xC0C00034U )) -> LEN);
N                break;
N
N            case GA_WRITE_BUF_WRITE_BUS:
N                /* GA Write Buffer Write Bus: */
N                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGAWBWBECR_WR();
X                pstCtrlStatus->eDirection    = (ga_buserr_dir_e) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> WR);
N                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGAWBWBECR_BTYPE();
X                pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> BTYPE);
N                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGAWBWBECR_BSIZE();
X                pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> BSIZE);
N                pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGAWBWBECR_RTYPE();
X                pstCtrlStatus->eRespType     = (ga_buserr_resptype) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> RTYPE);
N                pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGAWBWBECR_BEN();
X                pstCtrlStatus->u8ByteEnables = (uint8_t) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> BEN);
N                pstCtrlStatus->u8ID          = (uint8_t) biGetGAWBWBECR_ID();
X                pstCtrlStatus->u8ID          = (uint8_t) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> ID);
N                pstCtrlStatus->u8BurstLength = (uint8_t) biGetGAWBWBECR_LEN();
X                pstCtrlStatus->u8BurstLength = (uint8_t) (((volatile GAWBWBECR_bit_view_st *)(0xC0C0003CU )) -> LEN);
N                break;
N
N            default:
N                /* Invalid Bus Type */
N                boRes = C_FALSE;
X                boRes = (0);
N                break;
N        }      
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    return  boRes;
N}
N
N/* ....................................................................... */
Nbool_t boGA_SetMemoryProtRegionAddr(ga_memory_region_e eRegion, uint32_t u32LowAddress, uint32_t u32HighAddress)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    
N     /* Th memory regions are defined with a granularity of 4KB:
N        check addresses: */    
N    if ( (0x00 ==(u32LowAddress & GA_PROT_REGION_MASK)) && (0xFFF ==(u32HighAddress & GA_PROT_REGION_MASK)) )
X    if ( (0x00 ==(u32LowAddress & 0xFFF)) && (0xFFF ==(u32HighAddress & 0xFFF)) )
N    {
N        switch( eRegion )
N        {
N            case GA_MEMORY_PROT_REGION_0:
N                /* GA Read Buffer Bus: */
N                vSetGAMPR0LR(u32LowAddress);
X                (*((volatile u32GAMPR0LR_word_view *)(0xC0C00040U )) = (u32LowAddress));
N                vSetGAMPR0HR(u32HighAddress);
X                (*((volatile u32GAMPR0HR_word_view *)(0xC0C00044U )) = (u32HighAddress));
N                break;
N             
N            case GA_MEMORY_PROT_REGION_1:
N                /* GA Read Buffer Bus: */
N                vSetGAMPR1LR(u32LowAddress);
X                (*((volatile u32GAMPR1LR_word_view *)(0xC0C00048U )) = (u32LowAddress));
N                vSetGAMPR1HR(u32HighAddress);
X                (*((volatile u32GAMPR1HR_word_view *)(0xC0C0004CU )) = (u32HighAddress));
N                break;
N
N            default:
N                /* Invalid Bus Type */
N                boRes = C_FALSE;
X                boRes = (0);
N                break;
N        }
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    return  boRes;
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableMemoryProtecConfigIrq(ga_en_e eEn)
N{
N    vSetGAMPIMR_GAMPCIM((uint8_t) eEn);
X    (((volatile GAMPIMR_bit_view_st *)(0xC0C00054U )) -> GAMPCIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_EnableMemoryProtecAccessIrq(ga_en_e eEn)
N{
N    vSetGAMPIMR_GAMPIM((uint8_t) eEn);
X    (((volatile GAMPIMR_bit_view_st *)(0xC0C00054U )) -> GAMPIM=((uint8_t) eEn));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearMemoryProtecConfigIrq(void)
N{
N    vClrGAMPICR_GAMPCI();
X    (((volatile GAMPICR_bit_view_st *)(0xC0C00050U )) -> GAMPCI = (1));
N}
N
N/* ....................................................................... */
Nvoid vGA_ClearMemoryProtecAccessIrq(void)
N{
N    vClrGAMPICR_GAMPI();
X    (((volatile GAMPICR_bit_view_st *)(0xC0C00050U )) -> GAMPI = (1));
N}
N
N
N/* ....................................................................... */
Nuint32_t u32GA_GetMemoryProtecErr_CaptAddr(void)
N{
N    uint32_t u32Addr;
N    
N    u32Addr = u32GetGAMPACR();
X    u32Addr = (*((volatile u32GAMPACR_word_view *)(0xC0C00058U )) );
N    
N    return (u32Addr);
N}
N
N
N/* ....................................................................... */
Nbool_t boGA_SetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t u32RegValue)
N{
N    bool_t   boRes = C_TRUE;
X    bool_t   boRes = (1);
N    uint32_t u32Res;
N    
N    u32Res = (uint32_t)biGetGASR_BUSY();
X    u32Res = (uint32_t)(((volatile GASR_bit_view_st *)(0xC0C00008U )) -> BUSY);
N    /* check parameters and if GA is not busy: */
N    if ( (u8RegNo > 31) || (0x00U != u32Res ) )
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    else
N    {
N        vSetGAGPR(u8RegNo, u32RegValue);
X        (*((volatile u32GAGPR_word_view *)(0xC0C00080U + ((uint16_t)(u8RegNo) * 0x04U))) = (u32RegValue));
N    }
N    return (boRes);
N}
N
N
N/* ....................................................................... */
Nbool_t boGA_GetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t* pu32RegValue)
N{
N    bool_t    boRes = C_TRUE;
X    bool_t    boRes = (1);
N    uint32_t  u32Value;
N    
N    /* check parameters: */
N    if ( (u8RegNo > 31) || (0x00U == pu32RegValue) )
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    else
N    {
N        u32Value = u32GetGAGPR(u8RegNo);
X        u32Value = (*((volatile u32GAGPR_word_view *)(0xC0C00080U + ((uint16_t)(u8RegNo) * 0x04U))) );
N        *pu32RegValue = u32Value;
N    }
N    return (boRes);
N}
N
N
N/* ....................................................................... */
Nbool_t boGA_SetCommandRegisterLowHigh (uint32_t u32LowValue,  uint32_t u32HighValue)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    
N    /* check if GA is not busy: */
N    if (0x00U != biGetGASR_BUSY() )
X    if (0x00U != (((volatile GASR_bit_view_st *)(0xC0C00008U )) -> BUSY) )
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    else
N    {
N        /* it is important to write first the low register!: */
N        vSetGACMDL(u32LowValue);
X        (*((volatile u32GACMDL_word_view *)(0xC0C00100U )) = (u32LowValue));
N        
N        /* then write high register!: */
N        vSetGACMDH(u32HighValue);
X        (*((volatile u32GACMDH_word_view *)(0xC0C00104U )) = (u32HighValue));
N
N    }
N    return (boRes);
N}
N
N/* ....................................................................... */
N/*+-----------------------------------------------------------------------+*
N *|     END-Extended new APIs                                             |*
N *+-----------------------------------------------------------------------+*/
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga.c
N**  $Revision: 1.20 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1730 / 12.7 - bitwise operation may not be performed on signed integer types
N** | CONS.  : allow
N** | REASON : to generate masks in run time using shift oeprations 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1752 / 17.4 - pointer arithmetic not allowed
N** | CONS.  : allow
N** | REASON : to increment command list pointer 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1847 / 10.3 - cast of complex integer expression with underlying type
N** |                        "type" to non-integer type "type" not allowed 
N** | CONS.  : disable
N** | REASON : to use macros from i/o header files, unavoidable when addressing 
N** |          memory mapped registers 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1858 /17.4  - subscript operator may only be applied to objects 
N** |                        declared as an array type
N** | CONS.  : allow
N** | REASON : to handle array of data by usage of pointer 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1864 /10.1  - implicit conversion from underlying type, "type", 
N** |                        to narrower underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : to use macros from i/o header files 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1865 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to same width underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1866 /10.1  -  implicit conversion from underlying type, "type",  
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1867 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1879 /10.3  -   cast of complex integer expression with underlying
N** |                          type "type" to same width type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as macros in io header file
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N/****************************************************************************/
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
