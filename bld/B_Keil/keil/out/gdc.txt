; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\gdc.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\gdc.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\gdc.crf ..\..\..\..\lldd\src\gdc.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vUpdateDCR_HighWord_Special PROC
;;;231    **********************************************/
;;;232    static void vUpdateDCR_HighWord_Special(gdc_ch_e eGDC)
000000  e92d4010          PUSH     {r4,lr}
;;;233    {
;;;234        /* Since UPDREG may be changed by HW (From 2 to 0) and 
;;;235         * it belongs to higher 32 bit or register, all modifications of
;;;236         * higher 32 bits (bits 32..63) from DCR register should be handled
;;;237         * special, to synchronize UPDREG in HW and local storage of register: */
;;;238        
;;;239        gdc_reg_update_mode_e  eUpdModeHW;
;;;240    
;;;241        /* synchronisation of update mode in HW and local storage of register: */
;;;242        /* get the update mode from HW: */
;;;243        eUpdModeHW = (gdc_reg_update_mode_e) biGetGDCDCR_UPDREG_Direct(eGDC);
000004  e59f3a24          LDR      r3,|L1.2608|
000008  e0832600          ADD      r2,r3,r0,LSL #12
00000c  e1c220d0          LDRD     r2,r3,[r2,#0]
000010  e7e12b53          UBFX     r2,r3,#22,#2
000014  e20210ff          AND      r1,r2,#0xff
;;;244        
;;;245        /* to be synchronized with HW, update local variable: */
;;;246        vSetGDCDCR_UPDREG(eGDC, eUpdModeHW);
000018  e59f2a14          LDR      r2,|L1.2612|
00001c  e0822180          ADD      r2,r2,r0,LSL #3
000020  e1c220d0          LDRD     r2,r3,[r2,#0]
000024  e7d73b11          BFI      r3,r1,#22,#2
000028  e59f4a04          LDR      r4,|L1.2612|
00002c  e0844180          ADD      r4,r4,r0,LSL #3
000030  e1c420f0          STRD     r2,r3,[r4,#0]
;;;247        
;;;248        /* write now high word of DCR register in HW: */
;;;249        UPDATE_REGISTER_HIGH_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000034  e59f29f8          LDR      r2,|L1.2612|
000038  e0822180          ADD      r2,r2,r0,LSL #3
00003c  e1c220d0          LDRD     r2,r3,[r2,#0]
000040  e1a02003          MOV      r2,r3
000044  e59f39e4          LDR      r3,|L1.2608|
000048  e0833600          ADD      r3,r3,r0,LSL #12
00004c  e5832004          STR      r2,[r3,#4]
;;;250    }
000050  e8bd8010          POP      {r4,pc}
;;;251    /****************************************************************************/
                          ENDP

                  vGDC_SetShadowRegUpdateMode PROC
;;;416    /****************************************************************************/
;;;417    void vGDC_SetShadowRegUpdateMode(gdc_ch_e eGDC, gdc_reg_update_mode_e eCtrl)
000054  e92d4010          PUSH     {r4,lr}
;;;418    {
;;;419        /* Note:
;;;420         * in this fucntion UPDREG bits of DCR register should be modified.
;;;421         * These bits are in higher wordt of shadow register, so we modicy only the higher part. 
;;;422         */
;;;423        
;;;424        /* Set UPDREG bits in backup variables: */
;;;425        vSetGDCDCR_UPDREG(eGDC, eCtrl);
000058  e59f29d4          LDR      r2,|L1.2612|
00005c  e0822180          ADD      r2,r2,r0,LSL #3
000060  e1c220d0          LDRD     r2,r3,[r2,#0]
000064  e7d73b11          BFI      r3,r1,#22,#2
000068  e59f49c4          LDR      r4,|L1.2612|
00006c  e0844180          ADD      r4,r4,r0,LSL #3
000070  e1c420f0          STRD     r2,r3,[r4,#0]
;;;426        /* UPDREG: belongs to high word of register: */
;;;427        UPDATE_REGISTER_HIGH_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000074  e59f29b8          LDR      r2,|L1.2612|
000078  e0822180          ADD      r2,r2,r0,LSL #3
00007c  e1c220d0          LDRD     r2,r3,[r2,#0]
000080  e1a02003          MOV      r2,r3
000084  e59f39a4          LDR      r3,|L1.2608|
000088  e0833600          ADD      r3,r3,r0,LSL #12
00008c  e5832004          STR      r2,[r3,#4]
;;;428    }
000090  e8bd8010          POP      {r4,pc}
;;;429    
                          ENDP

                  vUpdateDCR_Special PROC
;;;251    /****************************************************************************/
;;;252    static void vUpdateDCR_Special(gdc_ch_e eGDC)
000094  e92d4030          PUSH     {r4,r5,lr}
;;;253    {
000098  e1a04000          MOV      r4,r0
;;;254        /* this function will be used, where Low and high word of DCR register
;;;255         * has been changed. In this case Shadow register update should be disabled first: */
;;;256        gdc_reg_update_mode_e  eUpdModeHW;
;;;257    
;;;258        /* Get update mode from HW for later restore: */
;;;259        eUpdModeHW = (gdc_reg_update_mode_e) biGetGDCDCR_UPDREG_Direct(eGDC);
00009c  e59f198c          LDR      r1,|L1.2608|
0000a0  e0810604          ADD      r0,r1,r4,LSL #12
0000a4  e1c000d0          LDRD     r0,r1,[r0,#0]
0000a8  e7e10b51          UBFX     r0,r1,#22,#2
0000ac  e20050ff          AND      r5,r0,#0xff
;;;260    
;;;261    #ifdef HW_UPDATE_BUG_FIXED
;;;262        /* Disable Update Mode, if it was not disabled: */
;;;263        if (GDC_NO_UPDATE_BY_VSYNC != eUpdModeHW)
;;;264        {
;;;265            vGDC_SetShadowRegUpdateMode(eGDC, GDC_NO_UPDATE_BY_VSYNC);
;;;266        }
;;;267    #endif
;;;268        /* Write Low Word first: */
;;;269        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
0000b0  e59f097c          LDR      r0,|L1.2612|
0000b4  e0800184          ADD      r0,r0,r4,LSL #3
0000b8  e1c000d0          LDRD     r0,r1,[r0,#0]
0000bc  e59f296c          LDR      r2,|L1.2608|
0000c0  e7820604          STR      r0,[r2,r4,LSL #12]
;;;270    
;;;271        /* restore update mode and write high word to HW: */
;;;272        vGDC_SetShadowRegUpdateMode(eGDC, eUpdModeHW);
0000c4  e1a01005          MOV      r1,r5
0000c8  e1a00004          MOV      r0,r4
0000cc  ebfffffe          BL       vGDC_SetShadowRegUpdateMode
;;;273    }
0000d0  e8bd8030          POP      {r4,r5,pc}
;;;274    /**********************************************
                          ENDP

                  vGDC_GetVersion PROC
;;;276    **********************************************/
;;;277    void vGDC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
0000d4  e92d4070          PUSH     {r4-r6,lr}
;;;278                        uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
;;;279                        uint8_t** pau8IORevision, uint8_t** pau8IOTag)
;;;280    {
0000d8  e1cd41d0          LDRD     r4,r5,[sp,#0x10]
;;;281         *pau8ModuleRevision = &au8LLDD_GDC_C_REVISION[0];
0000dc  e59f6954          LDR      r6,|L1.2616|
0000e0  e5806000          STR      r6,[r0,#0]
;;;282         *pau8ModuleTag      = &au8LLDD_GDC_C_TAG[0];
0000e4  e59f6950          LDR      r6,|L1.2620|
0000e8  e5816000          STR      r6,[r1,#0]
;;;283         *pau8HeaderRevision = &au8LLDD_GDC_H_REVISION[0];
0000ec  e59f694c          LDR      r6,|L1.2624|
0000f0  e5826000          STR      r6,[r2,#0]
;;;284         *pau8HeaderTag      = &au8LLDD_GDC_H_TAG[0];
0000f4  e59f6948          LDR      r6,|L1.2628|
0000f8  e5836000          STR      r6,[r3,#0]
;;;285         *pau8IORevision     = &au8LLDD_GDC_IO_H_REVISION[0];
0000fc  e59f6944          LDR      r6,|L1.2632|
000100  e5846000          STR      r6,[r4,#0]
;;;286         *pau8IOTag          = &au8LLDD_GDC_IO_H_TAG[0];
000104  e59f6940          LDR      r6,|L1.2636|
000108  e5856000          STR      r6,[r5,#0]
;;;287    }
00010c  e8bd8070          POP      {r4-r6,pc}
;;;288    
                          ENDP

                  vGDC_Init PROC
;;;290    /****************************************************************************/
;;;291    void vGDC_Init(gdc_ch_e eGDC)
000110  e92d4030          PUSH     {r4,r5,lr}
;;;292    {
000114  e1a01000          MOV      r1,r0
;;;293        /* this function initializes local values for registers at beginning.
;;;294             * It is important, that Clear Bit will be set to "0" in local values,
;;;295             * Other wise by write back to shadow register they will be reset!
;;;296             * */
;;;297        uint32_t u32Chn;
;;;298        
;;;299        u32Chn = (GDC0 == eGDC)? 0x00U : 0x01U;
000118  e3510000          CMP      r1,#0
00011c  0a000001          BEQ      |L1.296|
000120  e3a02001          MOV      r2,#1
000124  ea000000          B        |L1.300|
                  |L1.296|
000128  e3a02000          MOV      r2,#0
                  |L1.300|
00012c  e1a00002          MOV      r0,r2
;;;300        
;;;301        u64GDCDCR_REG__Var[u32Chn]    = READ_REGISTER_64BITS(GDCDCR_REG__ , u32Chn);
000130  e1a02c00          LSL      r2,r0,#24
000134  e59f38f4          LDR      r3,|L1.2608|
000138  e0832622          ADD      r2,r3,r2,LSR #12
00013c  e1c220d0          LDRD     r2,r3,[r2,#0]
000140  e59f48ec          LDR      r4,|L1.2612|
000144  e0844180          ADD      r4,r4,r0,LSL #3
000148  e1c420f0          STRD     r2,r3,[r4,#0]
;;;302        /* Important NOTE:
;;;303         * Clear Bits should not be set in local variables, other wise the clear bit will be reset by
;;;304         * next shadow register update and application will not know about it. 
;;;305         * Mask  Clr bits (GAPCOL/bit 57 and GBER/Bit 19 ) */
;;;306        u64GDCDCR_REG__Var[u32Chn]   &= (~GDC_DCR_ERR_GBER_AND_GAPCOL_MASK);
00014c  e59f28e0          LDR      r2,|L1.2612|
000150  e0822180          ADD      r2,r2,r0,LSL #3
000154  e1c220d0          LDRD     r2,r3,[r2,#0]
000158  e3c22702          BIC      r2,r2,#0x80000
00015c  e3c33402          BIC      r3,r3,#0x2000000
000160  e59f48cc          LDR      r4,|L1.2612|
000164  e0844180          ADD      r4,r4,r0,LSL #3
000168  e1c420f0          STRD     r2,r3,[r4,#0]
;;;307        
;;;308        u64GDCCAVRA_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCCAVRA_REG__ , u32Chn);
00016c  e1a02c00          LSL      r2,r0,#24
000170  e59f38d8          LDR      r3,|L1.2640|
000174  e0832622          ADD      r2,r3,r2,LSR #12
000178  e1c220d0          LDRD     r2,r3,[r2,#0]
00017c  e59f48d0          LDR      r4,|L1.2644|
000180  e0844180          ADD      r4,r4,r0,LSL #3
000184  e1c420f0          STRD     r2,r3,[r4,#0]
;;;309        u64GDCSCVRA_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRA_REG__ , u32Chn);
000188  e1a02c00          LSL      r2,r0,#24
00018c  e59f38c4          LDR      r3,|L1.2648|
000190  e0832622          ADD      r2,r3,r2,LSR #12
000194  e1c220d0          LDRD     r2,r3,[r2,#0]
000198  e59f48bc          LDR      r4,|L1.2652|
00019c  e0844180          ADD      r4,r4,r0,LSL #3
0001a0  e1c420f0          STRD     r2,r3,[r4,#0]
;;;310        u64GDCSCVRB_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRB_REG__ , u32Chn);
0001a4  e1a02c00          LSL      r2,r0,#24
0001a8  e59f38b0          LDR      r3,|L1.2656|
0001ac  e0832622          ADD      r2,r3,r2,LSR #12
0001b0  e1c220d0          LDRD     r2,r3,[r2,#0]
0001b4  e59f48a8          LDR      r4,|L1.2660|
0001b8  e0844180          ADD      r4,r4,r0,LSL #3
0001bc  e1c420f0          STRD     r2,r3,[r4,#0]
;;;311        u64GDCSCVRC_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRC_REG__ , u32Chn);
0001c0  e1a02c00          LSL      r2,r0,#24
0001c4  e59f389c          LDR      r3,|L1.2664|
0001c8  e0832622          ADD      r2,r3,r2,LSR #12
0001cc  e1c220d0          LDRD     r2,r3,[r2,#0]
0001d0  e59f4894          LDR      r4,|L1.2668|
0001d4  e0844180          ADD      r4,r4,r0,LSL #3
0001d8  e1c420f0          STRD     r2,r3,[r4,#0]
;;;312        u64GDCSCVRD_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRD_REG__ , u32Chn);
0001dc  e1a02c00          LSL      r2,r0,#24
0001e0  e59f3888          LDR      r3,|L1.2672|
0001e4  e0832622          ADD      r2,r3,r2,LSR #12
0001e8  e1c220d0          LDRD     r2,r3,[r2,#0]
0001ec  e59f4880          LDR      r4,|L1.2676|
0001f0  e0844180          ADD      r4,r4,r0,LSL #3
0001f4  e1c420f0          STRD     r2,r3,[r4,#0]
;;;313        u64APCCR_REG__Var[u32Chn]     = READ_REGISTER_64BITS(APCCR_REG__ , u32Chn);
0001f8  e1a02c00          LSL      r2,r0,#24
0001fc  e59f3874          LDR      r3,|L1.2680|
000200  e0832622          ADD      r2,r3,r2,LSR #12
000204  e1c220d0          LDRD     r2,r3,[r2,#0]
000208  e59f486c          LDR      r4,|L1.2684|
00020c  e0844180          ADD      r4,r4,r0,LSL #3
000210  e1c420f0          STRD     r2,r3,[r4,#0]
;;;314        u64APCCWR_REG__Var[u32Chn]    = READ_REGISTER_64BITS(APCCWR_REG__ , u32Chn);
000214  e1a02c00          LSL      r2,r0,#24
000218  e59f3860          LDR      r3,|L1.2688|
00021c  e0832622          ADD      r2,r3,r2,LSR #12
000220  e1c220d0          LDRD     r2,r3,[r2,#0]
000224  e59f4858          LDR      r4,|L1.2692|
000228  e0844180          ADD      r4,r4,r0,LSL #3
00022c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;315        
;;;316        /* Note: CURCHKSUM is a R/C Bit, it means after read CURCHKSUM will be reset!: */
;;;317        u64APCCSR_REG__Var[u32Chn]    = READ_REGISTER_64BITS(APCCSR_REG__ , u32Chn);
000230  e1a02c00          LSL      r2,r0,#24
000234  e59f384c          LDR      r3,|L1.2696|
000238  e0832622          ADD      r2,r3,r2,LSR #12
00023c  e1c220d0          LDRD     r2,r3,[r2,#0]
000240  e59f4844          LDR      r4,|L1.2700|
000244  e0844180          ADD      r4,r4,r0,LSL #3
000248  e1c420f0          STRD     r2,r3,[r4,#0]
;;;318        
;;;319        u32GDCLARA0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARA0_REG__ , u32Chn);
00024c  e1a02c00          LSL      r2,r0,#24
000250  e59f37d8          LDR      r3,|L1.2608|
000254  e0832622          ADD      r2,r3,r2,LSR #12
000258  e5922010          LDR      r2,[r2,#0x10]
00025c  e59f382c          LDR      r3,|L1.2704|
000260  e7832100          STR      r2,[r3,r0,LSL #2]
;;;320        u32GDCLARA1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARA1_REG__ , u32Chn);
000264  e1a02c00          LSL      r2,r0,#24
000268  e59f37c0          LDR      r3,|L1.2608|
00026c  e0832622          ADD      r2,r3,r2,LSR #12
000270  e5922018          LDR      r2,[r2,#0x18]
000274  e59f3818          LDR      r3,|L1.2708|
000278  e7832100          STR      r2,[r3,r0,LSL #2]
;;;321        u32GDCWARA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARA_REG__ , u32Chn);
00027c  e1a02c00          LSL      r2,r0,#24
000280  e59f37a8          LDR      r3,|L1.2608|
000284  e0832622          ADD      r2,r3,r2,LSR #12
000288  e5922020          LDR      r2,[r2,#0x20]
00028c  e59f3804          LDR      r3,|L1.2712|
000290  e7832100          STR      r2,[r3,r0,LSL #2]
;;;322        u32GDCBGCR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCBGCR_REG__ , u32Chn);
000294  e1a02c00          LSL      r2,r0,#24
000298  e59f3790          LDR      r3,|L1.2608|
00029c  e0832622          ADD      r2,r3,r2,LSR #12
0002a0  e5922028          LDR      r2,[r2,#0x28]
0002a4  e59f37f0          LDR      r3,|L1.2716|
0002a8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;323        u32GDCLARB0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARB0_REG__ , u32Chn);
0002ac  e1a02c00          LSL      r2,r0,#24
0002b0  e59f3778          LDR      r3,|L1.2608|
0002b4  e0832622          ADD      r2,r3,r2,LSR #12
0002b8  e5922030          LDR      r2,[r2,#0x30]
0002bc  e59f37dc          LDR      r3,|L1.2720|
0002c0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;324        u32GDCLARB1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARB1_REG__ , u32Chn);
0002c4  e1a02c00          LSL      r2,r0,#24
0002c8  e59f3760          LDR      r3,|L1.2608|
0002cc  e0832622          ADD      r2,r3,r2,LSR #12
0002d0  e5922038          LDR      r2,[r2,#0x38]
0002d4  e59f37c8          LDR      r3,|L1.2724|
0002d8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;325        u32GDCWARB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARB_REG__ , u32Chn);
0002dc  e1a02c00          LSL      r2,r0,#24
0002e0  e59f3748          LDR      r3,|L1.2608|
0002e4  e0832622          ADD      r2,r3,r2,LSR #12
0002e8  e5922040          LDR      r2,[r2,#0x40]
0002ec  e59f37b4          LDR      r3,|L1.2728|
0002f0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;326        u32GDCLARC0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARC0_REG__ , u32Chn);
0002f4  e1a02c00          LSL      r2,r0,#24
0002f8  e59f3730          LDR      r3,|L1.2608|
0002fc  e0832622          ADD      r2,r3,r2,LSR #12
000300  e5922048          LDR      r2,[r2,#0x48]
000304  e59f37a0          LDR      r3,|L1.2732|
000308  e7832100          STR      r2,[r3,r0,LSL #2]
;;;327        u32GDCLARC1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARC1_REG__ , u32Chn);
00030c  e1a02c00          LSL      r2,r0,#24
000310  e59f3718          LDR      r3,|L1.2608|
000314  e0832622          ADD      r2,r3,r2,LSR #12
000318  e5922050          LDR      r2,[r2,#0x50]
00031c  e59f378c          LDR      r3,|L1.2736|
000320  e7832100          STR      r2,[r3,r0,LSL #2]
;;;328        u32GDCLARD0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARD0_REG__ , u32Chn);
000324  e1a02c00          LSL      r2,r0,#24
000328  e59f3700          LDR      r3,|L1.2608|
00032c  e0832622          ADD      r2,r3,r2,LSR #12
000330  e5922058          LDR      r2,[r2,#0x58]
000334  e59f3778          LDR      r3,|L1.2740|
000338  e7832100          STR      r2,[r3,r0,LSL #2]
;;;329        u32GDCLARD1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARD1_REG__ , u32Chn);
00033c  e1a02c00          LSL      r2,r0,#24
000340  e59f36e8          LDR      r3,|L1.2608|
000344  e0832622          ADD      r2,r3,r2,LSR #12
000348  e5922060          LDR      r2,[r2,#0x60]
00034c  e59f3764          LDR      r3,|L1.2744|
000350  e7832100          STR      r2,[r3,r0,LSL #2]
;;;330        u32GDCMWRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRA_REG__ , u32Chn);
000354  e1a02c00          LSL      r2,r0,#24
000358  e59f36d0          LDR      r3,|L1.2608|
00035c  e0832622          ADD      r2,r3,r2,LSR #12
000360  e5922068          LDR      r2,[r2,#0x68]
000364  e59f3750          LDR      r3,|L1.2748|
000368  e7832100          STR      r2,[r3,r0,LSL #2]
;;;331        u32GDCMWRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRB_REG__ , u32Chn);
00036c  e1a02c00          LSL      r2,r0,#24
000370  e59f36b8          LDR      r3,|L1.2608|
000374  e0832622          ADD      r2,r3,r2,LSR #12
000378  e5922070          LDR      r2,[r2,#0x70]
00037c  e59f373c          LDR      r3,|L1.2752|
000380  e7832100          STR      r2,[r3,r0,LSL #2]
;;;332        u32GDCMWRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRC_REG__ , u32Chn);
000384  e1a02c00          LSL      r2,r0,#24
000388  e59f36a0          LDR      r3,|L1.2608|
00038c  e0832622          ADD      r2,r3,r2,LSR #12
000390  e5922078          LDR      r2,[r2,#0x78]
000394  e59f3728          LDR      r3,|L1.2756|
000398  e7832100          STR      r2,[r3,r0,LSL #2]
;;;333        u32GDCMWRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRD_REG__ , u32Chn);
00039c  e1a02c00          LSL      r2,r0,#24
0003a0  e59f3688          LDR      r3,|L1.2608|
0003a4  e0832622          ADD      r2,r3,r2,LSR #12
0003a8  e5922080          LDR      r2,[r2,#0x80]
0003ac  e59f3714          LDR      r3,|L1.2760|
0003b0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;334        u32GDCMWRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRE_REG__ , u32Chn);
0003b4  e1a02c00          LSL      r2,r0,#24
0003b8  e59f3670          LDR      r3,|L1.2608|
0003bc  e0832622          ADD      r2,r3,r2,LSR #12
0003c0  e5922088          LDR      r2,[r2,#0x88]
0003c4  e59f3700          LDR      r3,|L1.2764|
0003c8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;335        u32GDCLSRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRA_REG__ , u32Chn);
0003cc  e1a02c00          LSL      r2,r0,#24
0003d0  e59f3658          LDR      r3,|L1.2608|
0003d4  e0832622          ADD      r2,r3,r2,LSR #12
0003d8  e5922090          LDR      r2,[r2,#0x90]
0003dc  e59f36ec          LDR      r3,|L1.2768|
0003e0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;336        u32GDCLSRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRB_REG__ , u32Chn);
0003e4  e1a02c00          LSL      r2,r0,#24
0003e8  e59f3640          LDR      r3,|L1.2608|
0003ec  e0832622          ADD      r2,r3,r2,LSR #12
0003f0  e5922098          LDR      r2,[r2,#0x98]
0003f4  e59f36d8          LDR      r3,|L1.2772|
0003f8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;337        u32GDCLSRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRC_REG__ , u32Chn);
0003fc  e1a02c00          LSL      r2,r0,#24
000400  e59f3628          LDR      r3,|L1.2608|
000404  e0832622          ADD      r2,r3,r2,LSR #12
000408  e59220a0          LDR      r2,[r2,#0xa0]
00040c  e59f36c4          LDR      r3,|L1.2776|
000410  e7832100          STR      r2,[r3,r0,LSL #2]
;;;338        u32GDCLSRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRD_REG__ , u32Chn);
000414  e1a02c00          LSL      r2,r0,#24
000418  e59f3610          LDR      r3,|L1.2608|
00041c  e0832622          ADD      r2,r3,r2,LSR #12
000420  e59220a8          LDR      r2,[r2,#0xa8]
000424  e59f36b0          LDR      r3,|L1.2780|
000428  e7832100          STR      r2,[r3,r0,LSL #2]
;;;339        u32GDCLSRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRE_REG__ , u32Chn);
00042c  e1a02c00          LSL      r2,r0,#24
000430  e59f35f8          LDR      r3,|L1.2608|
000434  e0832622          ADD      r2,r3,r2,LSR #12
000438  e59220b0          LDR      r2,[r2,#0xb0]
00043c  e59f369c          LDR      r3,|L1.2784|
000440  e7832100          STR      r2,[r3,r0,LSL #2]
;;;340        u32GDCLDRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRA_REG__ , u32Chn);
000444  e1a02c00          LSL      r2,r0,#24
000448  e59f35e0          LDR      r3,|L1.2608|
00044c  e0832622          ADD      r2,r3,r2,LSR #12
000450  e59220b8          LDR      r2,[r2,#0xb8]
000454  e59f3688          LDR      r3,|L1.2788|
000458  e7832100          STR      r2,[r3,r0,LSL #2]
;;;341        u32GDCLDRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRB_REG__ , u32Chn);
00045c  e1a02c00          LSL      r2,r0,#24
000460  e59f35c8          LDR      r3,|L1.2608|
000464  e0832622          ADD      r2,r3,r2,LSR #12
000468  e59220c0          LDR      r2,[r2,#0xc0]
00046c  e59f3674          LDR      r3,|L1.2792|
000470  e7832100          STR      r2,[r3,r0,LSL #2]
;;;342        u32GDCLDRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRC_REG__ , u32Chn);
000474  e1a02c00          LSL      r2,r0,#24
000478  e59f35b0          LDR      r3,|L1.2608|
00047c  e0832622          ADD      r2,r3,r2,LSR #12
000480  e59220c8          LDR      r2,[r2,#0xc8]
000484  e59f3660          LDR      r3,|L1.2796|
000488  e7832100          STR      r2,[r3,r0,LSL #2]
;;;343        u32GDCLDRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRD_REG__ , u32Chn);
00048c  e1a02c00          LSL      r2,r0,#24
000490  e59f3598          LDR      r3,|L1.2608|
000494  e0832622          ADD      r2,r3,r2,LSR #12
000498  e59220d0          LDR      r2,[r2,#0xd0]
00049c  e59f364c          LDR      r3,|L1.2800|
0004a0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;344        u32GDCLDRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRE_REG__ , u32Chn);
0004a4  e1a02c00          LSL      r2,r0,#24
0004a8  e59f3580          LDR      r3,|L1.2608|
0004ac  e0832622          ADD      r2,r3,r2,LSR #12
0004b0  e59220d8          LDR      r2,[r2,#0xd8]
0004b4  e59f3638          LDR      r3,|L1.2804|
0004b8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;345        u32GDCWSRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRA_REG__ , u32Chn);
0004bc  e1a02c00          LSL      r2,r0,#24
0004c0  e59f3568          LDR      r3,|L1.2608|
0004c4  e0832622          ADD      r2,r3,r2,LSR #12
0004c8  e59220e0          LDR      r2,[r2,#0xe0]
0004cc  e59f3624          LDR      r3,|L1.2808|
0004d0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;346        u32GDCWSRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRB_REG__ , u32Chn);
0004d4  e1a02c00          LSL      r2,r0,#24
0004d8  e59f3550          LDR      r3,|L1.2608|
0004dc  e0832622          ADD      r2,r3,r2,LSR #12
0004e0  e59220e8          LDR      r2,[r2,#0xe8]
0004e4  e59f3610          LDR      r3,|L1.2812|
0004e8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;347        u32GDCWIMRA_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRA_REG__ , u32Chn);
0004ec  e1a02c00          LSL      r2,r0,#24
0004f0  e59f3538          LDR      r3,|L1.2608|
0004f4  e0832622          ADD      r2,r3,r2,LSR #12
0004f8  e59220f0          LDR      r2,[r2,#0xf0]
0004fc  e59f35fc          LDR      r3,|L1.2816|
000500  e7832100          STR      r2,[r3,r0,LSL #2]
;;;348        u32GDCWIMRB_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRB_REG__ , u32Chn);
000504  e1a02c00          LSL      r2,r0,#24
000508  e59f3520          LDR      r3,|L1.2608|
00050c  e0832622          ADD      r2,r3,r2,LSR #12
000510  e59220f8          LDR      r2,[r2,#0xf8]
000514  e59f35e8          LDR      r3,|L1.2820|
000518  e7832100          STR      r2,[r3,r0,LSL #2]
;;;349        u32GDCCAVRB_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCAVRB_REG__ , u32Chn);
00051c  e1a02c00          LSL      r2,r0,#24
000520  e59f3508          LDR      r3,|L1.2608|
000524  e0832622          ADD      r2,r3,r2,LSR #12
000528  e5922108          LDR      r2,[r2,#0x108]
00052c  e59f35d4          LDR      r3,|L1.2824|
000530  e7832100          STR      r2,[r3,r0,LSL #2]
;;;350        u32GDCHSR_REG__Var[u32Chn]    = READ_REGISTER_LOW_WORD(GDCHSR_REG__ , u32Chn);
000534  e1a02c00          LSL      r2,r0,#24
000538  e59f34f0          LDR      r3,|L1.2608|
00053c  e0832622          ADD      r2,r3,r2,LSR #12
000540  e5922110          LDR      r2,[r2,#0x110]
000544  e59f35c0          LDR      r3,|L1.2828|
000548  e7832100          STR      r2,[r3,r0,LSL #2]
;;;351        u32GDCVSR_REG__Var[u32Chn]    = READ_REGISTER_LOW_WORD(GDCVSR_REG__ , u32Chn);
00054c  e1a02c00          LSL      r2,r0,#24
000550  e59f34d8          LDR      r3,|L1.2608|
000554  e0832622          ADD      r2,r3,r2,LSR #12
000558  e5922118          LDR      r2,[r2,#0x118]
00055c  e59f35ac          LDR      r3,|L1.2832|
000560  e7832100          STR      r2,[r3,r0,LSL #2]
;;;352        
;;;353        u32GDCCBAR0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCBAR0_REG__ , u32Chn);
000564  e1a02c00          LSL      r2,r0,#24
000568  e59f34c0          LDR      r3,|L1.2608|
00056c  e0832622          ADD      r2,r3,r2,LSR #12
000570  e5922128          LDR      r2,[r2,#0x128]
000574  e59f3598          LDR      r3,|L1.2836|
000578  e7832100          STR      r2,[r3,r0,LSL #2]
;;;354        u32GDCCBAR1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCBAR1_REG__ , u32Chn);
00057c  e1a02c00          LSL      r2,r0,#24
000580  e59f34a8          LDR      r3,|L1.2608|
000584  e0832622          ADD      r2,r3,r2,LSR #12
000588  e5922130          LDR      r2,[r2,#0x130]
00058c  e59f3584          LDR      r3,|L1.2840|
000590  e7832100          STR      r2,[r3,r0,LSL #2]
;;;355        u32GDCCBAR2_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCBAR2_REG__ , u32Chn);
000594  e1a02c00          LSL      r2,r0,#24
000598  e59f3490          LDR      r3,|L1.2608|
00059c  e0832622          ADD      r2,r3,r2,LSR #12
0005a0  e5922138          LDR      r2,[r2,#0x138]
0005a4  e59f3570          LDR      r3,|L1.2844|
0005a8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;356        u32GDCPTCR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCPTCR_REG__ , u32Chn);
0005ac  e1a02c00          LSL      r2,r0,#24
0005b0  e59f3478          LDR      r3,|L1.2608|
0005b4  e0832622          ADD      r2,r3,r2,LSR #12
0005b8  e5922148          LDR      r2,[r2,#0x148]
0005bc  e59f355c          LDR      r3,|L1.2848|
0005c0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;357        u32GDCGPCRA_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCGPCRA_REG__ , u32Chn);
0005c4  e1a02c00          LSL      r2,r0,#24
0005c8  e59f3460          LDR      r3,|L1.2608|
0005cc  e0832622          ADD      r2,r3,r2,LSR #12
0005d0  e5922150          LDR      r2,[r2,#0x150]
0005d4  e59f3548          LDR      r3,|L1.2852|
0005d8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;358        u32GDCGPCRB_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCGPCRB_REG__ , u32Chn);
0005dc  e1a02c00          LSL      r2,r0,#24
0005e0  e59f3448          LDR      r3,|L1.2608|
0005e4  e0832622          ADD      r2,r3,r2,LSR #12
0005e8  e5922158          LDR      r2,[r2,#0x158]
0005ec  e59f3534          LDR      r3,|L1.2856|
0005f0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;359        u32GDCGPCRC_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCGPCRC_REG__ , u32Chn);
0005f4  e1a02c00          LSL      r2,r0,#24
0005f8  e59f3430          LDR      r3,|L1.2608|
0005fc  e0832622          ADD      r2,r3,r2,LSR #12
000600  e5922160          LDR      r2,[r2,#0x160]
000604  e59f3520          LDR      r3,|L1.2860|
000608  e7832100          STR      r2,[r3,r0,LSL #2]
;;;360        u32GDCPSMR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCPSMR_REG__ , u32Chn);
00060c  e1a02c00          LSL      r2,r0,#24
000610  e59f3418          LDR      r3,|L1.2608|
000614  e0832622          ADD      r2,r3,r2,LSR #12
000618  e5922228          LDR      r2,[r2,#0x228]
00061c  e59f350c          LDR      r3,|L1.2864|
000620  e7832100          STR      r2,[r3,r0,LSL #2]
;;;361        u32GDCLARE0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARE0_REG__ , u32Chn);
000624  e1a02c00          LSL      r2,r0,#24
000628  e59f3400          LDR      r3,|L1.2608|
00062c  e0832622          ADD      r2,r3,r2,LSR #12
000630  e5922230          LDR      r2,[r2,#0x230]
000634  e59f34f8          LDR      r3,|L1.2868|
000638  e7832100          STR      r2,[r3,r0,LSL #2]
;;;362        u32GDCLARE1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARE1_REG__ , u32Chn);
00063c  e1a02c00          LSL      r2,r0,#24
000640  e59f33e8          LDR      r3,|L1.2608|
000644  e0832622          ADD      r2,r3,r2,LSR #12
000648  e5922238          LDR      r2,[r2,#0x238]
00064c  e59f34e4          LDR      r3,|L1.2872|
000650  e7832100          STR      r2,[r3,r0,LSL #2]
;;;363        u32GDCWARC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARC_REG__ , u32Chn);
000654  e1a02c00          LSL      r2,r0,#24
000658  e59f33d0          LDR      r3,|L1.2608|
00065c  e0832622          ADD      r2,r3,r2,LSR #12
000660  e5922240          LDR      r2,[r2,#0x240]
000664  e59f34d0          LDR      r3,|L1.2876|
000668  e7832100          STR      r2,[r3,r0,LSL #2]
;;;364        u32GDCWARD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARD_REG__ , u32Chn);
00066c  e1a02c00          LSL      r2,r0,#24
000670  e59f33b8          LDR      r3,|L1.2608|
000674  e0832622          ADD      r2,r3,r2,LSR #12
000678  e5922248          LDR      r2,[r2,#0x248]
00067c  e59f34bc          LDR      r3,|L1.2880|
000680  e7832100          STR      r2,[r3,r0,LSL #2]
;;;365        u32GDCWARE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARE_REG__ , u32Chn);
000684  e1a02c00          LSL      r2,r0,#24
000688  e59f33a0          LDR      r3,|L1.2608|
00068c  e0832622          ADD      r2,r3,r2,LSR #12
000690  e5922250          LDR      r2,[r2,#0x250]
000694  e59f34a8          LDR      r3,|L1.2884|
000698  e7832100          STR      r2,[r3,r0,LSL #2]
;;;366        u32GDCWSRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRC_REG__ , u32Chn);
00069c  e1a02c00          LSL      r2,r0,#24
0006a0  e59f3388          LDR      r3,|L1.2608|
0006a4  e0832622          ADD      r2,r3,r2,LSR #12
0006a8  e5922258          LDR      r2,[r2,#0x258]
0006ac  e59f3494          LDR      r3,|L1.2888|
0006b0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;367        u32GDCWSRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRD_REG__ , u32Chn);
0006b4  e1a02c00          LSL      r2,r0,#24
0006b8  e59f3370          LDR      r3,|L1.2608|
0006bc  e0832622          ADD      r2,r3,r2,LSR #12
0006c0  e5922260          LDR      r2,[r2,#0x260]
0006c4  e59f3480          LDR      r3,|L1.2892|
0006c8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;368        u32GDCWSRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRE_REG__ , u32Chn);
0006cc  e1a02c00          LSL      r2,r0,#24
0006d0  e59f3358          LDR      r3,|L1.2608|
0006d4  e0832622          ADD      r2,r3,r2,LSR #12
0006d8  e5922268          LDR      r2,[r2,#0x268]
0006dc  e59f346c          LDR      r3,|L1.2896|
0006e0  e7832100          STR      r2,[r3,r0,LSL #2]
;;;369        u32GDCWIMRC_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRC_REG__ , u32Chn);
0006e4  e1a02c00          LSL      r2,r0,#24
0006e8  e59f3340          LDR      r3,|L1.2608|
0006ec  e0832622          ADD      r2,r3,r2,LSR #12
0006f0  e5922270          LDR      r2,[r2,#0x270]
0006f4  e59f3458          LDR      r3,|L1.2900|
0006f8  e7832100          STR      r2,[r3,r0,LSL #2]
;;;370        u32GDCWIMRD_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRD_REG__ , u32Chn);
0006fc  e1a02c00          LSL      r2,r0,#24
000700  e59f3328          LDR      r3,|L1.2608|
000704  e0832622          ADD      r2,r3,r2,LSR #12
000708  e5922278          LDR      r2,[r2,#0x278]
00070c  e59f3444          LDR      r3,|L1.2904|
000710  e7832100          STR      r2,[r3,r0,LSL #2]
;;;371        u32GDCWIMRE_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRE_REG__ , u32Chn);
000714  e1a02c00          LSL      r2,r0,#24
000718  e59f3310          LDR      r3,|L1.2608|
00071c  e0832622          ADD      r2,r3,r2,LSR #12
000720  e5922280          LDR      r2,[r2,#0x280]
000724  e59f3430          LDR      r3,|L1.2908|
000728  e7832100          STR      r2,[r3,r0,LSL #2]
;;;372        u32GDCDSR_REG__Var[u32Chn]    = READ_REGISTER_LOW_WORD(GDCDSR_REG__ , u32Chn);
00072c  e1a02c00          LSL      r2,r0,#24
000730  e59f32f8          LDR      r3,|L1.2608|
000734  e0832622          ADD      r2,r3,r2,LSR #12
000738  e59222b0          LDR      r2,[r2,#0x2b0]
00073c  e59f341c          LDR      r3,|L1.2912|
000740  e7832100          STR      r2,[r3,r0,LSL #2]
;;;373        u32GDCDIMR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCDIMR_REG__ , u32Chn);
000744  e1a02c00          LSL      r2,r0,#24
000748  e59f32e0          LDR      r3,|L1.2608|
00074c  e0832622          ADD      r2,r3,r2,LSR #12
000750  e59222b8          LDR      r2,[r2,#0x2b8]
000754  e59f3408          LDR      r3,|L1.2916|
000758  e7832100          STR      r2,[r3,r0,LSL #2]
;;;374        u32GDCPROTR_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCPROTR_REG__ , u32Chn);
00075c  e1a02c00          LSL      r2,r0,#24
000760  e59f32c8          LDR      r3,|L1.2608|
000764  e0832622          ADD      r2,r3,r2,LSR #12
000768  e59222c0          LDR      r2,[r2,#0x2c0]
00076c  e59f33f4          LDR      r3,|L1.2920|
000770  e7832100          STR      r2,[r3,r0,LSL #2]
;;;375        u32APCPROTR_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(APCPROTR_REG__ , u32Chn);
000774  e1a02c00          LSL      r2,r0,#24
000778  e59f32b0          LDR      r3,|L1.2608|
00077c  e0832622          ADD      r2,r3,r2,LSR #12
000780  e5922320          LDR      r2,[r2,#0x320]
000784  e59f33e0          LDR      r3,|L1.2924|
000788  e7832100          STR      r2,[r3,r0,LSL #2]
;;;376    
;;;377        u32GDCPxGAR_REG__Var[u32Chn][0]  = READ_REGISTER_LOW_WORD(GDCP0GAR_REG__ , u32Chn);
00078c  e1a02c00          LSL      r2,r0,#24
000790  e59f3298          LDR      r3,|L1.2608|
000794  e0832622          ADD      r2,r3,r2,LSR #12
000798  e5922168          LDR      r2,[r2,#0x168]
00079c  e0803080          ADD      r3,r0,r0,LSL #1
0007a0  e59f43c8          LDR      r4,|L1.2928|
0007a4  e7842203          STR      r2,[r4,r3,LSL #4]
;;;378        u32GDCPxGAR_REG__Var[u32Chn][1]  = READ_REGISTER_LOW_WORD(GDCP1GAR_REG__ , u32Chn);
0007a8  e1a02c00          LSL      r2,r0,#24
0007ac  e59f327c          LDR      r3,|L1.2608|
0007b0  e0832622          ADD      r2,r3,r2,LSR #12
0007b4  e5922170          LDR      r2,[r2,#0x170]
0007b8  e0803080          ADD      r3,r0,r0,LSL #1
0007bc  e0843203          ADD      r3,r4,r3,LSL #4
0007c0  e5832004          STR      r2,[r3,#4]
;;;379        u32GDCPxGAR_REG__Var[u32Chn][2]  = READ_REGISTER_LOW_WORD(GDCP2GAR_REG__ , u32Chn);
0007c4  e1a02c00          LSL      r2,r0,#24
0007c8  e59f3260          LDR      r3,|L1.2608|
0007cc  e0832622          ADD      r2,r3,r2,LSR #12
0007d0  e5922178          LDR      r2,[r2,#0x178]
0007d4  e0803080          ADD      r3,r0,r0,LSL #1
0007d8  e0843203          ADD      r3,r4,r3,LSL #4
0007dc  e5832008          STR      r2,[r3,#8]
;;;380        u32GDCPxGAR_REG__Var[u32Chn][3]  = READ_REGISTER_LOW_WORD(GDCP3GAR_REG__ , u32Chn);
0007e0  e1a02c00          LSL      r2,r0,#24
0007e4  e59f3244          LDR      r3,|L1.2608|
0007e8  e0832622          ADD      r2,r3,r2,LSR #12
0007ec  e5922180          LDR      r2,[r2,#0x180]
0007f0  e0803080          ADD      r3,r0,r0,LSL #1
0007f4  e0843203          ADD      r3,r4,r3,LSL #4
0007f8  e583200c          STR      r2,[r3,#0xc]
;;;381        u32GDCPxGAR_REG__Var[u32Chn][4]  = READ_REGISTER_LOW_WORD(GDCP4GAR_REG__ , u32Chn);
0007fc  e1a02c00          LSL      r2,r0,#24
000800  e59f3228          LDR      r3,|L1.2608|
000804  e0832622          ADD      r2,r3,r2,LSR #12
000808  e5922188          LDR      r2,[r2,#0x188]
00080c  e0803080          ADD      r3,r0,r0,LSL #1
000810  e0843203          ADD      r3,r4,r3,LSL #4
000814  e5832010          STR      r2,[r3,#0x10]
;;;382        u32GDCPxGAR_REG__Var[u32Chn][5]  = READ_REGISTER_LOW_WORD(GDCP5GAR_REG__ , u32Chn);
000818  e1a02c00          LSL      r2,r0,#24
00081c  e59f320c          LDR      r3,|L1.2608|
000820  e0832622          ADD      r2,r3,r2,LSR #12
000824  e5922190          LDR      r2,[r2,#0x190]
000828  e0803080          ADD      r3,r0,r0,LSL #1
00082c  e0843203          ADD      r3,r4,r3,LSL #4
000830  e5832014          STR      r2,[r3,#0x14]
;;;383        u32GDCPxGAR_REG__Var[u32Chn][6]  = READ_REGISTER_LOW_WORD(GDCP6GAR_REG__ , u32Chn);
000834  e1a02c00          LSL      r2,r0,#24
000838  e59f31f0          LDR      r3,|L1.2608|
00083c  e0832622          ADD      r2,r3,r2,LSR #12
000840  e5922198          LDR      r2,[r2,#0x198]
000844  e0803080          ADD      r3,r0,r0,LSL #1
000848  e0843203          ADD      r3,r4,r3,LSL #4
00084c  e5832018          STR      r2,[r3,#0x18]
;;;384        u32GDCPxGAR_REG__Var[u32Chn][7]  = READ_REGISTER_LOW_WORD(GDCP7GAR_REG__ , u32Chn);
000850  e1a02c00          LSL      r2,r0,#24
000854  e59f31d4          LDR      r3,|L1.2608|
000858  e0832622          ADD      r2,r3,r2,LSR #12
00085c  e59221a0          LDR      r2,[r2,#0x1a0]
000860  e0803080          ADD      r3,r0,r0,LSL #1
000864  e0843203          ADD      r3,r4,r3,LSL #4
000868  e583201c          STR      r2,[r3,#0x1c]
;;;385        u32GDCPxGAR_REG__Var[u32Chn][8]  = READ_REGISTER_LOW_WORD(GDCP8GAR_REG__ , u32Chn);
00086c  e1a02c00          LSL      r2,r0,#24
000870  e59f31b8          LDR      r3,|L1.2608|
000874  e0832622          ADD      r2,r3,r2,LSR #12
000878  e59221a8          LDR      r2,[r2,#0x1a8]
00087c  e0803080          ADD      r3,r0,r0,LSL #1
000880  e0843203          ADD      r3,r4,r3,LSL #4
000884  e5832020          STR      r2,[r3,#0x20]
;;;386        u32GDCPxGAR_REG__Var[u32Chn][9]  = READ_REGISTER_LOW_WORD(GDCP9GAR_REG__ , u32Chn);
000888  e1a02c00          LSL      r2,r0,#24
00088c  e59f319c          LDR      r3,|L1.2608|
000890  e0832622          ADD      r2,r3,r2,LSR #12
000894  e59221b0          LDR      r2,[r2,#0x1b0]
000898  e0803080          ADD      r3,r0,r0,LSL #1
00089c  e0843203          ADD      r3,r4,r3,LSL #4
0008a0  e5832024          STR      r2,[r3,#0x24]
;;;387        u32GDCPxGAR_REG__Var[u32Chn][10] = READ_REGISTER_LOW_WORD(GDCP10GAR_REG__ , u32Chn);
0008a4  e1a02c00          LSL      r2,r0,#24
0008a8  e59f3180          LDR      r3,|L1.2608|
0008ac  e0832622          ADD      r2,r3,r2,LSR #12
0008b0  e59221b8          LDR      r2,[r2,#0x1b8]
0008b4  e0803080          ADD      r3,r0,r0,LSL #1
0008b8  e0843203          ADD      r3,r4,r3,LSL #4
0008bc  e5832028          STR      r2,[r3,#0x28]
;;;388        u32GDCPxGAR_REG__Var[u32Chn][11] = READ_REGISTER_LOW_WORD(GDCP11GAR_REG__ , u32Chn);
0008c0  e1a02c00          LSL      r2,r0,#24
0008c4  e59f3164          LDR      r3,|L1.2608|
0008c8  e0832622          ADD      r2,r3,r2,LSR #12
0008cc  e59221c0          LDR      r2,[r2,#0x1c0]
0008d0  e0803080          ADD      r3,r0,r0,LSL #1
0008d4  e0843203          ADD      r3,r4,r3,LSL #4
0008d8  e583202c          STR      r2,[r3,#0x2c]
;;;389        
;;;390        u32GDCPxGBR_REG__Var[u32Chn][0]  = READ_REGISTER_LOW_WORD(GDCP0GBR_REG__ , u32Chn);
0008dc  e1a02c00          LSL      r2,r0,#24
0008e0  e59f3148          LDR      r3,|L1.2608|
0008e4  e0832622          ADD      r2,r3,r2,LSR #12
0008e8  e59221c8          LDR      r2,[r2,#0x1c8]
0008ec  e0803080          ADD      r3,r0,r0,LSL #1
0008f0  e59f427c          LDR      r4,|L1.2932|
0008f4  e7842203          STR      r2,[r4,r3,LSL #4]
;;;391        u32GDCPxGBR_REG__Var[u32Chn][1]  = READ_REGISTER_LOW_WORD(GDCP1GBR_REG__ , u32Chn);
0008f8  e1a02c00          LSL      r2,r0,#24
0008fc  e59f312c          LDR      r3,|L1.2608|
000900  e0832622          ADD      r2,r3,r2,LSR #12
000904  e59221d0          LDR      r2,[r2,#0x1d0]
000908  e0803080          ADD      r3,r0,r0,LSL #1
00090c  e0843203          ADD      r3,r4,r3,LSL #4
000910  e5832004          STR      r2,[r3,#4]
;;;392        u32GDCPxGBR_REG__Var[u32Chn][2]  = READ_REGISTER_LOW_WORD(GDCP2GBR_REG__ , u32Chn);
000914  e1a02c00          LSL      r2,r0,#24
000918  e59f3110          LDR      r3,|L1.2608|
00091c  e0832622          ADD      r2,r3,r2,LSR #12
000920  e59221d8          LDR      r2,[r2,#0x1d8]
000924  e0803080          ADD      r3,r0,r0,LSL #1
000928  e0843203          ADD      r3,r4,r3,LSL #4
00092c  e5832008          STR      r2,[r3,#8]
;;;393        u32GDCPxGBR_REG__Var[u32Chn][3]  = READ_REGISTER_LOW_WORD(GDCP3GBR_REG__ , u32Chn);
000930  e1a02c00          LSL      r2,r0,#24
000934  e59f30f4          LDR      r3,|L1.2608|
000938  e0832622          ADD      r2,r3,r2,LSR #12
00093c  e59221e0          LDR      r2,[r2,#0x1e0]
000940  e0803080          ADD      r3,r0,r0,LSL #1
000944  e0843203          ADD      r3,r4,r3,LSL #4
000948  e583200c          STR      r2,[r3,#0xc]
;;;394        u32GDCPxGBR_REG__Var[u32Chn][4]  = READ_REGISTER_LOW_WORD(GDCP4GBR_REG__ , u32Chn);
00094c  e1a02c00          LSL      r2,r0,#24
000950  e59f30d8          LDR      r3,|L1.2608|
000954  e0832622          ADD      r2,r3,r2,LSR #12
000958  e59221e8          LDR      r2,[r2,#0x1e8]
00095c  e0803080          ADD      r3,r0,r0,LSL #1
000960  e0843203          ADD      r3,r4,r3,LSL #4
000964  e5832010          STR      r2,[r3,#0x10]
;;;395        u32GDCPxGBR_REG__Var[u32Chn][5]  = READ_REGISTER_LOW_WORD(GDCP5GBR_REG__ , u32Chn);
000968  e1a02c00          LSL      r2,r0,#24
00096c  e59f30bc          LDR      r3,|L1.2608|
000970  e0832622          ADD      r2,r3,r2,LSR #12
000974  e59221f0          LDR      r2,[r2,#0x1f0]
000978  e0803080          ADD      r3,r0,r0,LSL #1
00097c  e0843203          ADD      r3,r4,r3,LSL #4
000980  e5832014          STR      r2,[r3,#0x14]
;;;396        u32GDCPxGBR_REG__Var[u32Chn][6]  = READ_REGISTER_LOW_WORD(GDCP6GBR_REG__ , u32Chn);
000984  e1a02c00          LSL      r2,r0,#24
000988  e59f30a0          LDR      r3,|L1.2608|
00098c  e0832622          ADD      r2,r3,r2,LSR #12
000990  e59221f8          LDR      r2,[r2,#0x1f8]
000994  e0803080          ADD      r3,r0,r0,LSL #1
000998  e0843203          ADD      r3,r4,r3,LSL #4
00099c  e5832018          STR      r2,[r3,#0x18]
;;;397        u32GDCPxGBR_REG__Var[u32Chn][7]  = READ_REGISTER_LOW_WORD(GDCP7GBR_REG__ , u32Chn);
0009a0  e1a02c00          LSL      r2,r0,#24
0009a4  e59f3084          LDR      r3,|L1.2608|
0009a8  e0832622          ADD      r2,r3,r2,LSR #12
0009ac  e5922200          LDR      r2,[r2,#0x200]
0009b0  e0803080          ADD      r3,r0,r0,LSL #1
0009b4  e0843203          ADD      r3,r4,r3,LSL #4
0009b8  e583201c          STR      r2,[r3,#0x1c]
;;;398        u32GDCPxGBR_REG__Var[u32Chn][8]  = READ_REGISTER_LOW_WORD(GDCP8GBR_REG__ , u32Chn);
0009bc  e1a02c00          LSL      r2,r0,#24
0009c0  e59f3068          LDR      r3,|L1.2608|
0009c4  e0832622          ADD      r2,r3,r2,LSR #12
0009c8  e5922208          LDR      r2,[r2,#0x208]
0009cc  e0803080          ADD      r3,r0,r0,LSL #1
0009d0  e0843203          ADD      r3,r4,r3,LSL #4
0009d4  e5832020          STR      r2,[r3,#0x20]
;;;399        u32GDCPxGBR_REG__Var[u32Chn][9]  = READ_REGISTER_LOW_WORD(GDCP9GBR_REG__ , u32Chn);
0009d8  e1a02c00          LSL      r2,r0,#24
0009dc  e59f304c          LDR      r3,|L1.2608|
0009e0  e0832622          ADD      r2,r3,r2,LSR #12
0009e4  e5922210          LDR      r2,[r2,#0x210]
0009e8  e0803080          ADD      r3,r0,r0,LSL #1
0009ec  e0843203          ADD      r3,r4,r3,LSL #4
0009f0  e5832024          STR      r2,[r3,#0x24]
;;;400        u32GDCPxGBR_REG__Var[u32Chn][10] = READ_REGISTER_LOW_WORD(GDCP10GBR_REG__ , u32Chn);
0009f4  e1a02c00          LSL      r2,r0,#24
0009f8  e59f3030          LDR      r3,|L1.2608|
0009fc  e0832622          ADD      r2,r3,r2,LSR #12
000a00  e5922218          LDR      r2,[r2,#0x218]
000a04  e0803080          ADD      r3,r0,r0,LSL #1
000a08  e0843203          ADD      r3,r4,r3,LSL #4
000a0c  e5832028          STR      r2,[r3,#0x28]
;;;401        u32GDCPxGBR_REG__Var[u32Chn][11] = READ_REGISTER_LOW_WORD(GDCP11GBR_REG__ , u32Chn);
000a10  e1a02c00          LSL      r2,r0,#24
000a14  e59f3014          LDR      r3,|L1.2608|
000a18  e0832622          ADD      r2,r3,r2,LSR #12
000a1c  e5922220          LDR      r2,[r2,#0x220]
000a20  e0803080          ADD      r3,r0,r0,LSL #1
000a24  e0843203          ADD      r3,r4,r3,LSL #4
000a28  e583202c          STR      r2,[r3,#0x2c]
;;;402        
;;;403    }
000a2c  e8bd8030          POP      {r4,r5,pc}
                  |L1.2608|
                          DCD      0xc0c02000
                  |L1.2612|
                          DCD      u64GDCDCR_REG__Var
                  |L1.2616|
                          DCD      au8LLDD_GDC_C_REVISION
                  |L1.2620|
                          DCD      au8LLDD_GDC_C_TAG
                  |L1.2624|
                          DCD      au8LLDD_GDC_H_REVISION
                  |L1.2628|
                          DCD      au8LLDD_GDC_H_TAG
                  |L1.2632|
                          DCD      au8LLDD_GDC_IO_H_REVISION
                  |L1.2636|
                          DCD      au8LLDD_GDC_IO_H_TAG
                  |L1.2640|
                          DCD      0xc0c02100
                  |L1.2644|
                          DCD      u64GDCCAVRA_REG__Var
                  |L1.2648|
                          DCD      0xc0c02288
                  |L1.2652|
                          DCD      u64GDCSCVRA_REG__Var
                  |L1.2656|
                          DCD      0xc0c02290
                  |L1.2660|
                          DCD      u64GDCSCVRB_REG__Var
                  |L1.2664|
                          DCD      0xc0c02298
                  |L1.2668|
                          DCD      u64GDCSCVRC_REG__Var
                  |L1.2672|
                          DCD      0xc0c022a0
                  |L1.2676|
                          DCD      u64GDCSCVRD_REG__Var
                  |L1.2680|
                          DCD      0xc0c02300
                  |L1.2684|
                          DCD      u64APCCR_REG__Var
                  |L1.2688|
                          DCD      0xc0c02308
                  |L1.2692|
                          DCD      u64APCCWR_REG__Var
                  |L1.2696|
                          DCD      0xc0c02310
                  |L1.2700|
                          DCD      u64APCCSR_REG__Var
                  |L1.2704|
                          DCD      u32GDCLARA0_REG__Var
                  |L1.2708|
                          DCD      u32GDCLARA1_REG__Var
                  |L1.2712|
                          DCD      u32GDCWARA_REG__Var
                  |L1.2716|
                          DCD      u32GDCBGCR_REG__Var
                  |L1.2720|
                          DCD      u32GDCLARB0_REG__Var
                  |L1.2724|
                          DCD      u32GDCLARB1_REG__Var
                  |L1.2728|
                          DCD      u32GDCWARB_REG__Var
                  |L1.2732|
                          DCD      u32GDCLARC0_REG__Var
                  |L1.2736|
                          DCD      u32GDCLARC1_REG__Var
                  |L1.2740|
                          DCD      u32GDCLARD0_REG__Var
                  |L1.2744|
                          DCD      u32GDCLARD1_REG__Var
                  |L1.2748|
                          DCD      u32GDCMWRA_REG__Var
                  |L1.2752|
                          DCD      u32GDCMWRB_REG__Var
                  |L1.2756|
                          DCD      u32GDCMWRC_REG__Var
                  |L1.2760|
                          DCD      u32GDCMWRD_REG__Var
                  |L1.2764|
                          DCD      u32GDCMWRE_REG__Var
                  |L1.2768|
                          DCD      u32GDCLSRA_REG__Var
                  |L1.2772|
                          DCD      u32GDCLSRB_REG__Var
                  |L1.2776|
                          DCD      u32GDCLSRC_REG__Var
                  |L1.2780|
                          DCD      u32GDCLSRD_REG__Var
                  |L1.2784|
                          DCD      u32GDCLSRE_REG__Var
                  |L1.2788|
                          DCD      u32GDCLDRA_REG__Var
                  |L1.2792|
                          DCD      u32GDCLDRB_REG__Var
                  |L1.2796|
                          DCD      u32GDCLDRC_REG__Var
                  |L1.2800|
                          DCD      u32GDCLDRD_REG__Var
                  |L1.2804|
                          DCD      u32GDCLDRE_REG__Var
                  |L1.2808|
                          DCD      u32GDCWSRA_REG__Var
                  |L1.2812|
                          DCD      u32GDCWSRB_REG__Var
                  |L1.2816|
                          DCD      u32GDCWIMRA_REG__Var
                  |L1.2820|
                          DCD      u32GDCWIMRB_REG__Var
                  |L1.2824|
                          DCD      u32GDCCAVRB_REG__Var
                  |L1.2828|
                          DCD      u32GDCHSR_REG__Var
                  |L1.2832|
                          DCD      u32GDCVSR_REG__Var
                  |L1.2836|
                          DCD      u32GDCCBAR0_REG__Var
                  |L1.2840|
                          DCD      u32GDCCBAR1_REG__Var
                  |L1.2844|
                          DCD      u32GDCCBAR2_REG__Var
                  |L1.2848|
                          DCD      u32GDCPTCR_REG__Var
                  |L1.2852|
                          DCD      u32GDCGPCRA_REG__Var
                  |L1.2856|
                          DCD      u32GDCGPCRB_REG__Var
                  |L1.2860|
                          DCD      u32GDCGPCRC_REG__Var
                  |L1.2864|
                          DCD      u32GDCPSMR_REG__Var
                  |L1.2868|
                          DCD      u32GDCLARE0_REG__Var
                  |L1.2872|
                          DCD      u32GDCLARE1_REG__Var
                  |L1.2876|
                          DCD      u32GDCWARC_REG__Var
                  |L1.2880|
                          DCD      u32GDCWARD_REG__Var
                  |L1.2884|
                          DCD      u32GDCWARE_REG__Var
                  |L1.2888|
                          DCD      u32GDCWSRC_REG__Var
                  |L1.2892|
                          DCD      u32GDCWSRD_REG__Var
                  |L1.2896|
                          DCD      u32GDCWSRE_REG__Var
                  |L1.2900|
                          DCD      u32GDCWIMRC_REG__Var
                  |L1.2904|
                          DCD      u32GDCWIMRD_REG__Var
                  |L1.2908|
                          DCD      u32GDCWIMRE_REG__Var
                  |L1.2912|
                          DCD      u32GDCDSR_REG__Var
                  |L1.2916|
                          DCD      u32GDCDIMR_REG__Var
                  |L1.2920|
                          DCD      u32GDCPROTR_REG__Var
                  |L1.2924|
                          DCD      u32APCPROTR_REG__Var
                  |L1.2928|
                          DCD      u32GDCPxGAR_REG__Var
                  |L1.2932|
                          DCD      u32GDCPxGBR_REG__Var
                          ENDP

                  vGDC_Switch PROC
;;;406    /****************************************************************************/
;;;407    void vGDC_Switch(gdc_ch_e eGDC, gdc_on_e eSwitch)
000b78  e92d4070          PUSH     {r4-r6,lr}
;;;408    {
000b7c  e1a05000          MOV      r5,r0
000b80  e1a04001          MOV      r4,r1
;;;409        vSetGDCDCR_GDCON(eGDC, eSwitch);
000b84  e51f0158          LDR      r0,|L1.2612|
000b88  e0800185          ADD      r0,r0,r5,LSL #3
000b8c  e1c000d0          LDRD     r0,r1,[r0,#0]
000b90  e7df1f94          BFI      r1,r4,#31,#1
000b94  e51f2168          LDR      r2,|L1.2612|
000b98  e0822185          ADD      r2,r2,r5,LSL #3
000b9c  e1c200f0          STRD     r0,r1,[r2,#0]
;;;410        /* GDCON: belongs to high word of register: */
;;;411        /* GDCDCR register should be updated special: */  
;;;412        vUpdateDCR_HighWord_Special(eGDC);
000ba0  e1a00005          MOV      r0,r5
000ba4  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;413    }
000ba8  e8bd8070          POP      {r4-r6,pc}
;;;414    
                          ENDP

                  eGetShadowRegUpdateStatus PROC
;;;431    /****************************************************************************/
;;;432    gdc_reg_update_status_e eGetShadowRegUpdateStatus(gdc_ch_e eGDC)
000bac  e92d4010          PUSH     {r4,lr}
;;;433    {
000bb0  e1a01000          MOV      r1,r0
;;;434        gdc_reg_update_status_e eUpdMode;
;;;435        
;;;436        /* get the update mode from HW: */
;;;437        eUpdMode = (gdc_reg_update_status_e) biGetGDCDCR_UPDREG_Direct(eGDC);
000bb4  e51f318c          LDR      r3,|L1.2608|
000bb8  e0832601          ADD      r2,r3,r1,LSL #12
000bbc  e1c220d0          LDRD     r2,r3,[r2,#0]
000bc0  e7e12b53          UBFX     r2,r3,#22,#2
000bc4  e20200ff          AND      r0,r2,#0xff
;;;438        
;;;439        /* to be synchronized with HW, update local variable: */
;;;440        vSetGDCDCR_UPDREG(eGDC, eUpdMode);
000bc8  e51f219c          LDR      r2,|L1.2612|
000bcc  e0822181          ADD      r2,r2,r1,LSL #3
000bd0  e1c220d0          LDRD     r2,r3,[r2,#0]
000bd4  e7d73b10          BFI      r3,r0,#22,#2
000bd8  e51f41ac          LDR      r4,|L1.2612|
000bdc  e0844181          ADD      r4,r4,r1,LSL #3
000be0  e1c420f0          STRD     r2,r3,[r4,#0]
;;;441    
;;;442        return eUpdMode;
;;;443    }
000be4  e8bd8010          POP      {r4,pc}
;;;444    
                          ENDP

                  vGDC_SetDispConfigType PROC
;;;446    /****************************************************************************/
;;;447    void vGDC_SetDispConfigType(gdc_ch_e eGDC, gdc_disp_config_type_e eDispConfigType)
000be8  e92d4070          PUSH     {r4-r6,lr}
;;;448    {
000bec  e1a05000          MOV      r5,r0
000bf0  e1a04001          MOV      r4,r1
;;;449        vSetGDCDCR_LAD(eGDC, eDispConfigType);
000bf4  e51f01c8          LDR      r0,|L1.2612|
000bf8  e0800185          ADD      r0,r0,r5,LSL #3
000bfc  e1c000d0          LDRD     r0,r1,[r0,#0]
000c00  e7d51a94          BFI      r1,r4,#21,#1
000c04  e51f21d8          LDR      r2,|L1.2612|
000c08  e0822185          ADD      r2,r2,r5,LSL #3
000c0c  e1c200f0          STRD     r0,r1,[r2,#0]
;;;450        /* LAD: belongs to high word of register: */
;;;451        /* GDCDCR register should be updated special: */  
;;;452        vUpdateDCR_HighWord_Special(eGDC);
000c10  e1a00005          MOV      r0,r5
000c14  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;453    }
000c18  e8bd8070          POP      {r4-r6,pc}
;;;454    
                          ENDP

                  vGDC_ADBSEnable PROC
;;;456    /****************************************************************************/
;;;457    void vGDC_ADBSEnable(gdc_ch_e eGDC, gdc_en_e eEn)
000c1c  e92d4010          PUSH     {r4,lr}
;;;458    {
;;;459        vSetGDCDCR_ADBS(eGDC, eEn);
000c20  e51f21f4          LDR      r2,|L1.2612|
000c24  e0822180          ADD      r2,r2,r0,LSL #3
000c28  e1c220d0          LDRD     r2,r3,[r2,#0]
000c2c  e7ce2711          BFI      r2,r1,#14,#1
000c30  e51f4204          LDR      r4,|L1.2612|
000c34  e0844180          ADD      r4,r4,r0,LSL #3
000c38  e1c420f0          STRD     r2,r3,[r4,#0]
;;;460        /* ADBS: belongs to low word of register: */
;;;461        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000c3c  e51f2210          LDR      r2,|L1.2612|
000c40  e0822180          ADD      r2,r2,r0,LSL #3
000c44  e1c220d0          LDRD     r2,r3,[r2,#0]
000c48  e51f4220          LDR      r4,|L1.2608|
000c4c  e7842600          STR      r2,[r4,r0,LSL #12]
;;;462    }
000c50  e8bd8010          POP      {r4,pc}
;;;463    
                          ENDP

                  vGDC_ColorCorrectEnable PROC
;;;465    /****************************************************************************/
;;;466    void vGDC_ColorCorrectEnable(gdc_ch_e eGDC, gdc_en_e eEn)
000c54  e92d4070          PUSH     {r4-r6,lr}
;;;467    {
000c58  e1a05000          MOV      r5,r0
000c5c  e1a04001          MOV      r4,r1
;;;468        vSetGDCDCR_CCEN(eGDC, eEn);
000c60  e51f0234          LDR      r0,|L1.2612|
000c64  e0800185          ADD      r0,r0,r5,LSL #3
000c68  e1c000d0          LDRD     r0,r1,[r0,#0]
000c6c  e7c81414          BFI      r1,r4,#8,#1
000c70  e51f2244          LDR      r2,|L1.2612|
000c74  e0822185          ADD      r2,r2,r5,LSL #3
000c78  e1c200f0          STRD     r0,r1,[r2,#0]
;;;469        /* CCEN: belongs to high word of register: */
;;;470        /* GDCDCR register should be updated special: */  
;;;471        vUpdateDCR_HighWord_Special(eGDC);
000c7c  e1a00005          MOV      r0,r5
000c80  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;472    }
000c84  e8bd8070          POP      {r4-r6,pc}
;;;473    
                          ENDP

                  vGDC_SetArthMode PROC
;;;475    /****************************************************************************/
;;;476    void vGDC_SetArthMode(gdc_ch_e eGDC, gdc_arth_e eMode, gdc_arthcd_e eLoc)
000c88  e92d4030          PUSH     {r4,r5,lr}
;;;477    {
000c8c  e1a04002          MOV      r4,r2
;;;478        vSetGDCDCR_ARTHCD(eGDC, eLoc);
000c90  e51f2264          LDR      r2,|L1.2612|
000c94  e0822180          ADD      r2,r2,r0,LSL #3
000c98  e1c220d0          LDRD     r2,r3,[r2,#0]
000c9c  e7ca2514          BFI      r2,r4,#10,#1
000ca0  e51f5274          LDR      r5,|L1.2612|
000ca4  e0855180          ADD      r5,r5,r0,LSL #3
000ca8  e1c520f0          STRD     r2,r3,[r5,#0]
;;;479        vSetGDCDCR_ARTH(eGDC, eMode);
000cac  e51f2280          LDR      r2,|L1.2612|
000cb0  e0822180          ADD      r2,r2,r0,LSL #3
000cb4  e1c220d0          LDRD     r2,r3,[r2,#0]
000cb8  e7c92411          BFI      r2,r1,#8,#2
000cbc  e51f5290          LDR      r5,|L1.2612|
000cc0  e0855180          ADD      r5,r5,r0,LSL #3
000cc4  e1c520f0          STRD     r2,r3,[r5,#0]
;;;480        /* ARTH & vSetGDCDCR_ARTHCD: belong to low word of register: */
;;;481        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000cc8  e51f229c          LDR      r2,|L1.2612|
000ccc  e0822180          ADD      r2,r2,r0,LSL #3
000cd0  e1c220d0          LDRD     r2,r3,[r2,#0]
000cd4  e51f52ac          LDR      r5,|L1.2608|
000cd8  e7852600          STR      r2,[r5,r0,LSL #12]
;;;482    }
000cdc  e8bd8030          POP      {r4,r5,pc}
;;;483    
                          ENDP

                  vGDC_SetDitheringMode PROC
;;;485    /****************************************************************************/
;;;486    void vGDC_SetDitheringMode(gdc_ch_e eGDC, gdc_dithering_e eDith)
000ce0  e92d4070          PUSH     {r4-r6,lr}
;;;487    {
000ce4  e1a05000          MOV      r5,r0
000ce8  e1a04001          MOV      r4,r1
;;;488        vSetGDCDCR_DITHEN(eGDC, eDith);
000cec  e51f02c0          LDR      r0,|L1.2612|
000cf0  e0800185          ADD      r0,r0,r5,LSL #3
000cf4  e1c000d0          LDRD     r0,r1,[r0,#0]
000cf8  e7cd1614          BFI      r1,r4,#12,#2
000cfc  e51f22d0          LDR      r2,|L1.2612|
000d00  e0822185          ADD      r2,r2,r5,LSL #3
000d04  e1c200f0          STRD     r0,r1,[r2,#0]
;;;489        /* DITHEN: belongs to high word of register: */
;;;490        /* GDCDCR register should be updated special: */  
;;;491        vUpdateDCR_HighWord_Special(eGDC);
000d08  e1a00005          MOV      r0,r5
000d0c  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;492    }
000d10  e8bd8070          POP      {r4-r6,pc}
;;;493    
                          ENDP

                  vGDC_SetBgrColor PROC
;;;494    /****************************************************************************/
;;;495    void vGDC_SetBgrColor(gdc_ch_e eGDC, uint32_t u32Color)
000d14  e92d4010          PUSH     {r4,lr}
;;;496    {
;;;497        /* Shift to adjust the bits according to the register layout */
;;;498        vSetGDCBGCR(eGDC, (u32Color << 8) );
000d18  e1a02401          LSL      r2,r1,#8
000d1c  e51f3288          LDR      r3,|L1.2716|
000d20  e7832100          STR      r2,[r3,r0,LSL #2]
;;;499        
;;;500        /* Low Word of GDCBGCR register should be updated  */
;;;501        UPDATE_REGISTER_LOW_WORD(eGDC, GDCBGCR_REG__, u32GDCBGCR_REG__Var[eGDC]);
000d24  e2832000          ADD      r2,r3,#0
000d28  e7922100          LDR      r2,[r2,r0,LSL #2]
000d2c  e51f4304          LDR      r4,|L1.2608|
000d30  e0843600          ADD      r3,r4,r0,LSL #12
000d34  e5832028          STR      r2,[r3,#0x28]
;;;502    }
000d38  e8bd8010          POP      {r4,pc}
;;;503    
                          ENDP

                  eGDC_GetDispStat PROC
;;;505    /****************************************************************************/
;;;506    gdc_en_e eGDC_GetDispStat(gdc_ch_e eGDC)
000d3c  e1a01000          MOV      r1,r0
;;;507    {
;;;508        return (gdc_en_e) biGetGDCDCR_DISPIFON(eGDC);
000d40  e51f2318          LDR      r2,|L1.2608|
000d44  e0820601          ADD      r0,r2,r1,LSL #12
000d48  e1c020d0          LDRD     r2,r3,[r0,#0]
000d4c  e7e00f53          UBFX     r0,r3,#30,#1
000d50  e20000ff          AND      r0,r0,#0xff
;;;509    }
000d54  e12fff1e          BX       lr
;;;510    
                          ENDP

                  eGDC_GetPanelStat PROC
;;;512    /****************************************************************************/
;;;513    gdc_en_e eGDC_GetPanelStat(gdc_ch_e eGDC)
000d58  e1a01000          MOV      r1,r0
;;;514    {
;;;515        return (gdc_en_e) biGetGDCDCR_PNLIFON(eGDC);
000d5c  e51f2334          LDR      r2,|L1.2608|
000d60  e0820601          ADD      r0,r2,r1,LSL #12
000d64  e1c020d0          LDRD     r2,r3,[r0,#0]
000d68  e7e00ed3          UBFX     r0,r3,#29,#1
000d6c  e20000ff          AND      r0,r0,#0xff
;;;516    }
000d70  e12fff1e          BX       lr
;;;517    
                          ENDP

                  u32GDC_GetStatVSync PROC
;;;518    /****************************************************************************/
;;;519    uint32_t u32GDC_GetStatVSync(gdc_ch_e eGDC)
000d74  e1a01000          MOV      r1,r0
;;;520    {
;;;521        return (uint32_t) biGetGDCDCR_VSYNC(eGDC);
000d78  e51f2350          LDR      r2,|L1.2608|
000d7c  e0820601          ADD      r0,r2,r1,LSL #12
000d80  e1c020d0          LDRD     r2,r3,[r0,#0]
000d84  e7e00952          UBFX     r0,r2,#18,#1
;;;522    }
000d88  e12fff1e          BX       lr
;;;523    
                          ENDP

                  u32GDC_GetPolVSync PROC
;;;525    /****************************************************************************/
;;;526    uint32_t u32GDC_GetPolVSync(gdc_ch_e eGDC)
000d8c  e1a01000          MOV      r1,r0
;;;527    {
;;;528        return (uint32_t) biGetGDCDCR_PVSYNC(eGDC);
000d90  e51f0364          LDR      r0,|L1.2612|
000d94  e0800181          ADD      r0,r0,r1,LSL #3
000d98  e1c020d0          LDRD     r2,r3,[r0,#0]
000d9c  e7e00152          UBFX     r0,r2,#2,#1
;;;529    }
000da0  e12fff1e          BX       lr
;;;530    
                          ENDP

                  u32GDC_GetStatHSync PROC
;;;532    /****************************************************************************/
;;;533    uint32_t u32GDC_GetStatHSync(gdc_ch_e eGDC)
000da4  e1a01000          MOV      r1,r0
;;;534    {
;;;535        return (uint32_t) biGetGDCDCR_HSYNC(eGDC);
000da8  e51f2380          LDR      r2,|L1.2608|
000dac  e0820601          ADD      r0,r2,r1,LSL #12
000db0  e1c020d0          LDRD     r2,r3,[r0,#0]
000db4  e7e008d2          UBFX     r0,r2,#17,#1
;;;536    }
000db8  e12fff1e          BX       lr
;;;537    
                          ENDP

                  u32GDC_GetStatHDisp PROC
;;;539    /****************************************************************************/
;;;540    uint32_t u32GDC_GetStatHDisp(gdc_ch_e eGDC)
000dbc  e1a01000          MOV      r1,r0
;;;541    {
;;;542        return (uint32_t) biGetGDCDCR_HDISP(eGDC);
000dc0  e51f2398          LDR      r2,|L1.2608|
000dc4  e0820601          ADD      r0,r2,r1,LSL #12
000dc8  e1c020d0          LDRD     r2,r3,[r0,#0]
000dcc  e7e00852          UBFX     r0,r2,#16,#1
;;;543    }
000dd0  e12fff1e          BX       lr
;;;544    
                          ENDP

                  vGDC_SelDotClkSrc PROC
;;;546    /****************************************************************************/
;;;547    void vGDC_SelDotClkSrc(gdc_ch_e eGDC, gdc_idc_e eSel)
000dd4  e92d4010          PUSH     {r4,lr}
;;;548    {
;;;549        vSetGDCDCR_IDC(eGDC, eSel);
000dd8  e51f23ac          LDR      r2,|L1.2612|
000ddc  e0822180          ADD      r2,r2,r0,LSL #3
000de0  e1c220d0          LDRD     r2,r3,[r2,#0]
000de4  e7cd2691          BFI      r2,r1,#13,#1
000de8  e51f43bc          LDR      r4,|L1.2612|
000dec  e0844180          ADD      r4,r4,r0,LSL #3
000df0  e1c420f0          STRD     r2,r3,[r4,#0]
;;;550        /* IDC: belongs to low word of register: */
;;;551        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000df4  e51f23c8          LDR      r2,|L1.2612|
000df8  e0822180          ADD      r2,r2,r0,LSL #3
000dfc  e1c220d0          LDRD     r2,r3,[r2,#0]
000e00  e51f43d8          LDR      r4,|L1.2608|
000e04  e7842600          STR      r2,[r4,r0,LSL #12]
;;;552    }
000e08  e8bd8010          POP      {r4,pc}
;;;553    
                          ENDP

                  vGDC_SetDotClkPol PROC
;;;555    /****************************************************************************/
;;;556    void vGDC_SetDotClkPol(gdc_ch_e eGDC, gdc_pol_e ePol)
000e0c  e92d4010          PUSH     {r4,lr}
;;;557    {
;;;558        vSetGDCDCR_PDC(eGDC, ePol);
000e10  e51f23e4          LDR      r2,|L1.2612|
000e14  e0822180          ADD      r2,r2,r0,LSL #3
000e18  e1c220d0          LDRD     r2,r3,[r2,#0]
000e1c  e7cc2611          BFI      r2,r1,#12,#1
000e20  e51f43f4          LDR      r4,|L1.2612|
000e24  e0844180          ADD      r4,r4,r0,LSL #3
000e28  e1c420f0          STRD     r2,r3,[r4,#0]
;;;559        /* PDC: belongs to low word of register: */
;;;560        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000e2c  e51f2400          LDR      r2,|L1.2612|
000e30  e0822180          ADD      r2,r2,r0,LSL #3
000e34  e1c220d0          LDRD     r2,r3,[r2,#0]
000e38  e51f4410          LDR      r4,|L1.2608|
000e3c  e7842600          STR      r2,[r4,r0,LSL #12]
;;;561    }
000e40  e8bd8010          POP      {r4,pc}
;;;562    
                          ENDP

                  i32GDC_LayerEnable PROC
;;;564    /****************************************************************************/
;;;565    int32_t i32GDC_LayerEnable(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_en_e eEn)
000e44  e92d41f0          PUSH     {r4-r8,lr}
;;;566    {
000e48  e1a04000          MOV      r4,r0
000e4c  e1a06001          MOV      r6,r1
000e50  e1a05002          MOV      r5,r2
;;;567        int32_t i32Res = C_SUCCESS;
000e54  e3a07000          MOV      r7,#0
;;;568    
;;;569        switch( eLayer )
000e58  e3560005          CMP      r6,#5
000e5c  308ff106          ADDCC    pc,pc,r6,LSL #2
000e60  ea000047          B        |L1.3972|
000e64  ea000003          B        |L1.3704|
000e68  ea000010          B        |L1.3760|
000e6c  ea00001d          B        |L1.3816|
000e70  ea00002a          B        |L1.3872|
000e74  ea000037          B        |L1.3928|
                  |L1.3704|
;;;570        {
;;;571            case GDC_LAYER_A:
000e78  e320f000          NOP      
;;;572                vSetGDCDCR_AEN(eGDC, eEn);
000e7c  e51f0450          LDR      r0,|L1.2612|
000e80  e0800184          ADD      r0,r0,r4,LSL #3
000e84  e1c000d0          LDRD     r0,r1,[r0,#0]
000e88  e7d80c15          BFI      r0,r5,#24,#1
000e8c  e51f2460          LDR      r2,|L1.2612|
000e90  e0822184          ADD      r2,r2,r4,LSL #3
000e94  e1c200f0          STRD     r0,r1,[r2,#0]
;;;573                /* AEN: belongs to low word of register: */
;;;574                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000e98  e51f046c          LDR      r0,|L1.2612|
000e9c  e0800184          ADD      r0,r0,r4,LSL #3
000ea0  e1c000d0          LDRD     r0,r1,[r0,#0]
000ea4  e51f247c          LDR      r2,|L1.2608|
000ea8  e7820604          STR      r0,[r2,r4,LSL #12]
;;;575                break;
000eac  ea000037          B        |L1.3984|
                  |L1.3760|
;;;576    
;;;577            case GDC_LAYER_B:
000eb0  e320f000          NOP      
;;;578                vSetGDCDCR_BEN(eGDC, eEn);
000eb4  e51f0488          LDR      r0,|L1.2612|
000eb8  e0800184          ADD      r0,r0,r4,LSL #3
000ebc  e1c000d0          LDRD     r0,r1,[r0,#0]
000ec0  e7da0d15          BFI      r0,r5,#26,#1
000ec4  e51f2498          LDR      r2,|L1.2612|
000ec8  e0822184          ADD      r2,r2,r4,LSL #3
000ecc  e1c200f0          STRD     r0,r1,[r2,#0]
;;;579                /* BEN: belongs to low word of register: */
;;;580                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000ed0  e51f04a4          LDR      r0,|L1.2612|
000ed4  e0800184          ADD      r0,r0,r4,LSL #3
000ed8  e1c000d0          LDRD     r0,r1,[r0,#0]
000edc  e51f24b4          LDR      r2,|L1.2608|
000ee0  e7820604          STR      r0,[r2,r4,LSL #12]
;;;581                break;
000ee4  ea000029          B        |L1.3984|
                  |L1.3816|
;;;582    
;;;583            case GDC_LAYER_C:
000ee8  e320f000          NOP      
;;;584                vSetGDCDCR_CEN(eGDC, eEn);
000eec  e51f04c0          LDR      r0,|L1.2612|
000ef0  e0800184          ADD      r0,r0,r4,LSL #3
000ef4  e1c000d0          LDRD     r0,r1,[r0,#0]
000ef8  e7dc0e15          BFI      r0,r5,#28,#1
000efc  e51f24d0          LDR      r2,|L1.2612|
000f00  e0822184          ADD      r2,r2,r4,LSL #3
000f04  e1c200f0          STRD     r0,r1,[r2,#0]
;;;585                /* CEN: belongs to low word of register: */
;;;586                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000f08  e51f04dc          LDR      r0,|L1.2612|
000f0c  e0800184          ADD      r0,r0,r4,LSL #3
000f10  e1c000d0          LDRD     r0,r1,[r0,#0]
000f14  e51f24ec          LDR      r2,|L1.2608|
000f18  e7820604          STR      r0,[r2,r4,LSL #12]
;;;587                break;
000f1c  ea00001b          B        |L1.3984|
                  |L1.3872|
;;;588    
;;;589            case GDC_LAYER_D:
000f20  e320f000          NOP      
;;;590                vSetGDCDCR_DEN(eGDC, eEn);
000f24  e51f04f8          LDR      r0,|L1.2612|
000f28  e0800184          ADD      r0,r0,r4,LSL #3
000f2c  e1c000d0          LDRD     r0,r1,[r0,#0]
000f30  e7de0f15          BFI      r0,r5,#30,#1
000f34  e51f2508          LDR      r2,|L1.2612|
000f38  e0822184          ADD      r2,r2,r4,LSL #3
000f3c  e1c200f0          STRD     r0,r1,[r2,#0]
;;;591                /* DEN: belongs to low word of register: */
;;;592                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
000f40  e51f0514          LDR      r0,|L1.2612|
000f44  e0800184          ADD      r0,r0,r4,LSL #3
000f48  e1c000d0          LDRD     r0,r1,[r0,#0]
000f4c  e51f2524          LDR      r2,|L1.2608|
000f50  e7820604          STR      r0,[r2,r4,LSL #12]
;;;593                break;
000f54  ea00000d          B        |L1.3984|
                  |L1.3928|
;;;594    
;;;595            case GDC_LAYER_E:
000f58  e320f000          NOP      
;;;596                vSetGDCDCR_EEN(eGDC, eEn);
000f5c  e51f0530          LDR      r0,|L1.2612|
000f60  e0800184          ADD      r0,r0,r4,LSL #3
000f64  e1c000d0          LDRD     r0,r1,[r0,#0]
000f68  e7c01015          BFI      r1,r5,#0,#1
000f6c  e51f2540          LDR      r2,|L1.2612|
000f70  e0822184          ADD      r2,r2,r4,LSL #3
000f74  e1c200f0          STRD     r0,r1,[r2,#0]
;;;597                /* EEN: belongs to high word of register: */
;;;598                /* GDCDCR register should be updated special: */  
;;;599                vUpdateDCR_HighWord_Special(eGDC);
000f78  e1a00004          MOV      r0,r4
000f7c  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;600                break;
000f80  ea000002          B        |L1.3984|
                  |L1.3972|
;;;601    
;;;602            default:
000f84  e320f000          NOP      
;;;603                /* Unsupported layer */
;;;604                i32Res = C_FAILED;
000f88  e3e07000          MVN      r7,#0
;;;605                break;
000f8c  e320f000          NOP      
                  |L1.3984|
000f90  e320f000          NOP                            ;575
;;;606        }
;;;607        return i32Res;
000f94  e1a00007          MOV      r0,r7
;;;608    }
000f98  e8bd81f0          POP      {r4-r8,pc}
;;;609    
                          ENDP

                  i32GDC_SetDataFormat PROC
;;;611    /****************************************************************************/
;;;612    int32_t i32GDC_SetDataFormat(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_dfmt_e eFmt)
000f9c  e92d41f0          PUSH     {r4-r8,lr}
;;;613    {
000fa0  e1a05000          MOV      r5,r0
000fa4  e1a07001          MOV      r7,r1
000fa8  e1a06002          MOV      r6,r2
;;;614        int32_t i32Res = C_SUCCESS;
000fac  e3a08000          MOV      r8,#0
;;;615        uint8_t u8Fmt;
;;;616    
;;;617        /* check pixel format for validity (clut not supported) */
;;;618        switch( eFmt )
000fb0  e3560000          CMP      r6,#0
000fb4  0a000004          BEQ      |L1.4044|
000fb8  e3560001          CMP      r6,#1
000fbc  0a000006          BEQ      |L1.4060|
000fc0  e3560002          CMP      r6,#2
000fc4  1a000007          BNE      |L1.4072|
000fc8  ea000001          B        |L1.4052|
                  |L1.4044|
;;;619        {
;;;620            case GDC_RGBA32:
000fcc  e320f000          NOP      
;;;621            case GDC_ARGB32:
000fd0  e320f000          NOP      
                  |L1.4052|
;;;622                u8Fmt = (uint8_t)LAYER_FMT_32bpp;
000fd4  e3a04000          MOV      r4,#0
;;;623                break;
000fd8  ea000005          B        |L1.4084|
                  |L1.4060|
;;;624    
;;;625            case GDC_RGB16:
000fdc  e320f000          NOP      
;;;626                u8Fmt = (uint8_t)LAYER_FMT_16bpp;
000fe0  e3a04001          MOV      r4,#1
;;;627                break;
000fe4  ea000002          B        |L1.4084|
                  |L1.4072|
;;;628    
;;;629            default:
000fe8  e320f000          NOP      
;;;630                i32Res = C_FAILED;
000fec  e3e08000          MVN      r8,#0
;;;631                break;
000ff0  e320f000          NOP      
                  |L1.4084|
000ff4  e320f000          NOP                            ;623
;;;632         }
;;;633       if (i32Res == C_SUCCESS)
000ff8  e3580000          CMP      r8,#0
000ffc  1a000051          BNE      |L1.4424|
;;;634       {
;;;635           /* 32 vs. 16-bit mode */
;;;636           switch( eLayer )
001000  e3570005          CMP      r7,#5
001004  308ff107          ADDCC    pc,pc,r7,LSL #2
001008  ea000031          B        |L1.4308|
00100c  ea000003          B        |L1.4128|
001010  ea00000b          B        |L1.4164|
001014  ea000013          B        |L1.4200|
001018  ea00001b          B        |L1.4236|
00101c  ea000023          B        |L1.4272|
                  |L1.4128|
;;;637           {
;;;638               case GDC_LAYER_A:
001020  e320f000          NOP      
;;;639                   vSetGDCDCR_A16(eGDC, u8Fmt);
001024  e51f05f8          LDR      r0,|L1.2612|
001028  e0800185          ADD      r0,r0,r5,LSL #3
00102c  e1c000d0          LDRD     r0,r1,[r0,#0]
001030  e7d40a14          BFI      r0,r4,#20,#1
001034  e51f2608          LDR      r2,|L1.2612|
001038  e0822185          ADD      r2,r2,r5,LSL #3
00103c  e1c200f0          STRD     r0,r1,[r2,#0]
;;;640                   break;
001040  ea000026          B        |L1.4320|
                  |L1.4164|
;;;641    
;;;642               case GDC_LAYER_B:
001044  e320f000          NOP      
;;;643                   vSetGDCDCR_B16(eGDC, u8Fmt);
001048  e51f061c          LDR      r0,|L1.2612|
00104c  e0800185          ADD      r0,r0,r5,LSL #3
001050  e1c000d0          LDRD     r0,r1,[r0,#0]
001054  e7d50a94          BFI      r0,r4,#21,#1
001058  e51f262c          LDR      r2,|L1.2612|
00105c  e0822185          ADD      r2,r2,r5,LSL #3
001060  e1c200f0          STRD     r0,r1,[r2,#0]
;;;644                   break;
001064  ea00001d          B        |L1.4320|
                  |L1.4200|
;;;645    
;;;646               case GDC_LAYER_C:
001068  e320f000          NOP      
;;;647                   vSetGDCDCR_C16(eGDC, u8Fmt);
00106c  e51f0640          LDR      r0,|L1.2612|
001070  e0800185          ADD      r0,r0,r5,LSL #3
001074  e1c000d0          LDRD     r0,r1,[r0,#0]
001078  e7d60b14          BFI      r0,r4,#22,#1
00107c  e51f2650          LDR      r2,|L1.2612|
001080  e0822185          ADD      r2,r2,r5,LSL #3
001084  e1c200f0          STRD     r0,r1,[r2,#0]
;;;648                   break;
001088  ea000014          B        |L1.4320|
                  |L1.4236|
;;;649    
;;;650               case GDC_LAYER_D:
00108c  e320f000          NOP      
;;;651                   vSetGDCDCR_D16(eGDC, u8Fmt);
001090  e51f0664          LDR      r0,|L1.2612|
001094  e0800185          ADD      r0,r0,r5,LSL #3
001098  e1c000d0          LDRD     r0,r1,[r0,#0]
00109c  e7d70b94          BFI      r0,r4,#23,#1
0010a0  e51f2674          LDR      r2,|L1.2612|
0010a4  e0822185          ADD      r2,r2,r5,LSL #3
0010a8  e1c200f0          STRD     r0,r1,[r2,#0]
;;;652                   break;
0010ac  ea00000b          B        |L1.4320|
                  |L1.4272|
;;;653    
;;;654               case GDC_LAYER_E:
0010b0  e320f000          NOP      
;;;655                   vSetGDCDCR_E16(eGDC, u8Fmt);
0010b4  e51f0688          LDR      r0,|L1.2612|
0010b8  e0800185          ADD      r0,r0,r5,LSL #3
0010bc  e1c000d0          LDRD     r0,r1,[r0,#0]
0010c0  e7c41214          BFI      r1,r4,#4,#1
0010c4  e51f2698          LDR      r2,|L1.2612|
0010c8  e0822185          ADD      r2,r2,r5,LSL #3
0010cc  e1c200f0          STRD     r0,r1,[r2,#0]
;;;656                   break;
0010d0  ea000002          B        |L1.4320|
                  |L1.4308|
;;;657    
;;;658               /* Unsupported Layer */
;;;659               default:
0010d4  e320f000          NOP      
;;;660                   i32Res = C_FAILED;
0010d8  e3e08000          MVN      r8,#0
;;;661                   break;
0010dc  e320f000          NOP      
                  |L1.4320|
0010e0  e320f000          NOP                            ;640
;;;662           }
;;;663           if ( C_FAILED != i32Res)
0010e4  e3780001          CMN      r8,#1
0010e8  0a000016          BEQ      |L1.4424|
;;;664           {
;;;665               /* set the flag to indicates ARGB or RGBA format*/
;;;666               if ( eFmt == GDC_ARGB32)
0010ec  e3560002          CMP      r6,#2
0010f0  1a000008          BNE      |L1.4376|
0010f4  e3a02001          MOV      r2,#1
;;;667               {
;;;668                 /* ARGB supported: This will affect all Layers!*/
;;;669                 vSetGDCDCR_ARGBEN(eGDC, 1);
0010f8  e51f06cc          LDR      r0,|L1.2612|
0010fc  e0800185          ADD      r0,r0,r5,LSL #3
001100  e1c000d0          LDRD     r0,r1,[r0,#0]
001104  e7d41a12          BFI      r1,r2,#20,#1
001108  e51f26dc          LDR      r2,|L1.2612|
00110c  e0822185          ADD      r2,r2,r5,LSL #3
001110  e1c200f0          STRD     r0,r1,[r2,#0]
001114  ea000009          B        |L1.4416|
                  |L1.4376|
;;;670               }
;;;671               else
;;;672               {
;;;673                   if ( eFmt == GDC_RGBA32)
001118  e3560000          CMP      r6,#0
00111c  1a000007          BNE      |L1.4416|
001120  e3a02000          MOV      r2,#0
;;;674                   {
;;;675                     /* RGBA supported: This will effect all Layers!*/
;;;676                     vSetGDCDCR_ARGBEN(eGDC, 0);
001124  e51f06f8          LDR      r0,|L1.2612|
001128  e0800185          ADD      r0,r0,r5,LSL #3
00112c  e1c000d0          LDRD     r0,r1,[r0,#0]
001130  e7d41a12          BFI      r1,r2,#20,#1
001134  e51f2708          LDR      r2,|L1.2612|
001138  e0822185          ADD      r2,r2,r5,LSL #3
00113c  e1c200f0          STRD     r0,r1,[r2,#0]
                  |L1.4416|
;;;677                   }
;;;678               }
;;;679               /* GDCDCR register should be updated special: */  
;;;680               vUpdateDCR_Special(eGDC);
001140  e1a00005          MOV      r0,r5
001144  ebfffffe          BL       vUpdateDCR_Special
                  |L1.4424|
;;;681           }
;;;682        }
;;;683    
;;;684        return i32Res;
001148  e1a00008          MOV      r0,r8
;;;685    }
00114c  e8bd81f0          POP      {r4-r8,pc}
;;;686    
                          ENDP

                  vGDC_SetLayerStart PROC
;;;688    /****************************************************************************/
;;;689    void vGDC_SetLayerStart(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16HStart, uint16_t u16VStart)
001150  e92d40f0          PUSH     {r4-r7,lr}
;;;690    {
001154  e1a04001          MOV      r4,r1
001158  e1a05003          MOV      r5,r3
;;;691        uint32_t u32Val;
;;;692    
;;;693        /* Compose the entire register value */
;;;694        u32Val = (((uint32_t) (u16HStart & GDC_11_BIT_MASK)) << 16) | (u16VStart & GDC_10_BIT_MASK);
00115c  e7df551f          BFC      r5,#10,#22
001160  e1a06002          MOV      r6,r2
001164  e7df659f          BFC      r6,#11,#21
001168  e1851806          ORR      r1,r5,r6,LSL #16
;;;695    
;;;696        /* Set */
;;;697        switch( eLayer )
00116c  e3540005          CMP      r4,#5
001170  308ff104          ADDCC    pc,pc,r4,LSL #2
001174  ea00002c          B        |L1.4652|
001178  ea000003          B        |L1.4492|
00117c  ea00000a          B        |L1.4524|
001180  ea000011          B        |L1.4556|
001184  ea000018          B        |L1.4588|
001188  ea00001f          B        |L1.4620|
                  |L1.4492|
;;;698        {
;;;699            case GDC_LAYER_A:
00118c  e320f000          NOP      
;;;700                vSetGDCLSRA(eGDC, u32Val);
001190  e51f56c8          LDR      r5,|L1.2768|
001194  e7851100          STR      r1,[r5,r0,LSL #2]
;;;701                /* LVS & LHS: belong to low word of register: */
;;;702                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRA_REG__, u32GDCLSRA_REG__Var[eGDC]);
001198  e7955100          LDR      r5,[r5,r0,LSL #2]
00119c  e51f7774          LDR      r7,|L1.2608|
0011a0  e0876600          ADD      r6,r7,r0,LSL #12
0011a4  e5865090          STR      r5,[r6,#0x90]
;;;703                break;
0011a8  ea000021          B        |L1.4660|
                  |L1.4524|
;;;704    
;;;705            case GDC_LAYER_B:
0011ac  e320f000          NOP      
;;;706                vSetGDCLSRB(eGDC, u32Val);
0011b0  e51f56e4          LDR      r5,|L1.2772|
0011b4  e7851100          STR      r1,[r5,r0,LSL #2]
;;;707                /* LVS & LHS: belong to low word of register: */
;;;708                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRB_REG__, u32GDCLSRB_REG__Var[eGDC]);
0011b8  e7955100          LDR      r5,[r5,r0,LSL #2]
0011bc  e51f7794          LDR      r7,|L1.2608|
0011c0  e0876600          ADD      r6,r7,r0,LSL #12
0011c4  e5865098          STR      r5,[r6,#0x98]
;;;709                break;
0011c8  ea000019          B        |L1.4660|
                  |L1.4556|
;;;710    
;;;711            case GDC_LAYER_C:
0011cc  e320f000          NOP      
;;;712                vSetGDCLSRC(eGDC, u32Val);
0011d0  e51f5700          LDR      r5,|L1.2776|
0011d4  e7851100          STR      r1,[r5,r0,LSL #2]
;;;713                /* LVS & LHS: belong to low word of register: */
;;;714                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRC_REG__, u32GDCLSRC_REG__Var[eGDC]);
0011d8  e7955100          LDR      r5,[r5,r0,LSL #2]
0011dc  e51f77b4          LDR      r7,|L1.2608|
0011e0  e0876600          ADD      r6,r7,r0,LSL #12
0011e4  e58650a0          STR      r5,[r6,#0xa0]
;;;715                break;
0011e8  ea000011          B        |L1.4660|
                  |L1.4588|
;;;716    
;;;717            case GDC_LAYER_D:
0011ec  e320f000          NOP      
;;;718                vSetGDCLSRD(eGDC, u32Val);
0011f0  e51f571c          LDR      r5,|L1.2780|
0011f4  e7851100          STR      r1,[r5,r0,LSL #2]
;;;719                /* LVS & LHS: belong to low word of register: */
;;;720                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRD_REG__, u32GDCLSRD_REG__Var[eGDC]);
0011f8  e7955100          LDR      r5,[r5,r0,LSL #2]
0011fc  e51f77d4          LDR      r7,|L1.2608|
001200  e0876600          ADD      r6,r7,r0,LSL #12
001204  e58650a8          STR      r5,[r6,#0xa8]
;;;721                break;
001208  ea000009          B        |L1.4660|
                  |L1.4620|
;;;722    
;;;723            case GDC_LAYER_E:
00120c  e320f000          NOP      
;;;724                vSetGDCLSRE(eGDC, u32Val);
001210  e51f5738          LDR      r5,|L1.2784|
001214  e7851100          STR      r1,[r5,r0,LSL #2]
;;;725                /* LVS & LHS: belong to low word of register: */
;;;726                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRE_REG__, u32GDCLSRE_REG__Var[eGDC]);
001218  e7955100          LDR      r5,[r5,r0,LSL #2]
00121c  e51f77f4          LDR      r7,|L1.2608|
001220  e0876600          ADD      r6,r7,r0,LSL #12
001224  e58650b0          STR      r5,[r6,#0xb0]
;;;727                break;
001228  ea000001          B        |L1.4660|
                  |L1.4652|
;;;728    
;;;729            default:
00122c  e320f000          NOP      
;;;730                break;
001230  e320f000          NOP      
                  |L1.4660|
001234  e320f000          NOP                            ;703
;;;731        }
;;;732    }
001238  e8bd80f0          POP      {r4-r7,pc}
;;;733    
                          ENDP

                  i32GDC_SetLayerSize PROC
;;;735    /****************************************************************************/
;;;736    int32_t i32GDC_SetLayerSize(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16Width, uint16_t u16Height)
00123c  e92d40f0          PUSH     {r4-r7,lr}
;;;737    {
001240  e1a04000          MOV      r4,r0
001244  e1a05001          MOV      r5,r1
;;;738        int32_t i32Res = C_SUCCESS;
001248  e3a00000          MOV      r0,#0
00124c  e1a06002          MOV      r6,r2
;;;739        uint32_t u32Val;
;;;740    
;;;741    
;;;742        if( (u16Width & GDC_12_BIT_MASK) < GDC_DIMR_WIDTH_MIN_VAL  )
001250  e7df661f          BFC      r6,#12,#20
001254  e3560040          CMP      r6,#0x40
001258  2a000001          BCS      |L1.4708|
;;;743        {
;;;744            i32Res = C_FAILED;
00125c  e3e00000          MVN      r0,#0
001260  ea000038          B        |L1.4936|
                  |L1.4708|
001264  e1a06003          MOV      r6,r3
;;;745        }
;;;746        else
;;;747        {
;;;748            /* Compose the entire register value */
;;;749            u32Val = (((uint32_t) (u16Width & GDC_12_BIT_MASK)) << 16) | (u16Height & GDC_11_BIT_MASK);
001268  e7df659f          BFC      r6,#11,#21
00126c  e1a07002          MOV      r7,r2
001270  e7df761f          BFC      r7,#12,#20
001274  e1861807          ORR      r1,r6,r7,LSL #16
;;;750    
;;;751            /* Set */
;;;752            switch( eLayer )
001278  e3550005          CMP      r5,#5
00127c  308ff105          ADDCC    pc,pc,r5,LSL #2
001280  ea00002c          B        |L1.4920|
001284  ea000003          B        |L1.4760|
001288  ea00000a          B        |L1.4792|
00128c  ea000011          B        |L1.4824|
001290  ea000018          B        |L1.4856|
001294  ea00001f          B        |L1.4888|
                  |L1.4760|
;;;753            {
;;;754                case GDC_LAYER_A:
001298  e320f000          NOP      
;;;755                    vSetGDCLDRA(eGDC, u32Val);
00129c  e51f67c0          LDR      r6,|L1.2788|
0012a0  e7861104          STR      r1,[r6,r4,LSL #2]
;;;756                    /* LHEIGHT & LWIDTH: belong to low word of register: */
;;;757                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRA_REG__, u32GDCLDRA_REG__Var[eGDC]);
0012a4  e7966104          LDR      r6,[r6,r4,LSL #2]
0012a8  e51fc880          LDR      r12,|L1.2608|
0012ac  e08c7604          ADD      r7,r12,r4,LSL #12
0012b0  e58760b8          STR      r6,[r7,#0xb8]
;;;758                    break;
0012b4  ea000022          B        |L1.4932|
                  |L1.4792|
;;;759    
;;;760                case GDC_LAYER_B:
0012b8  e320f000          NOP      
;;;761                    vSetGDCLDRB(eGDC, u32Val);
0012bc  e51f67dc          LDR      r6,|L1.2792|
0012c0  e7861104          STR      r1,[r6,r4,LSL #2]
;;;762                    /* LHEIGHT & LWIDTH: belong to low word of register: */
;;;763                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRB_REG__, u32GDCLDRB_REG__Var[eGDC]);
0012c4  e7966104          LDR      r6,[r6,r4,LSL #2]
0012c8  e51fc8a0          LDR      r12,|L1.2608|
0012cc  e08c7604          ADD      r7,r12,r4,LSL #12
0012d0  e58760c0          STR      r6,[r7,#0xc0]
;;;764                    break;
0012d4  ea00001a          B        |L1.4932|
                  |L1.4824|
;;;765    
;;;766                case GDC_LAYER_C:
0012d8  e320f000          NOP      
;;;767                    vSetGDCLDRC(eGDC, u32Val);
0012dc  e51f67f8          LDR      r6,|L1.2796|
0012e0  e7861104          STR      r1,[r6,r4,LSL #2]
;;;768                    /* LHEIGHT & LWIDTH: belong to low word of register: */
;;;769                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRC_REG__, u32GDCLDRC_REG__Var[eGDC]);
0012e4  e7966104          LDR      r6,[r6,r4,LSL #2]
0012e8  e51fc8c0          LDR      r12,|L1.2608|
0012ec  e08c7604          ADD      r7,r12,r4,LSL #12
0012f0  e58760c8          STR      r6,[r7,#0xc8]
;;;770                    break;
0012f4  ea000012          B        |L1.4932|
                  |L1.4856|
;;;771    
;;;772                case GDC_LAYER_D:
0012f8  e320f000          NOP      
;;;773                    vSetGDCLDRD(eGDC, u32Val);
0012fc  e51f6814          LDR      r6,|L1.2800|
001300  e7861104          STR      r1,[r6,r4,LSL #2]
;;;774                    /* LHEIGHT & LWIDTH: belong to low word of register: */
;;;775                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRD_REG__, u32GDCLDRD_REG__Var[eGDC]);
001304  e7966104          LDR      r6,[r6,r4,LSL #2]
001308  e51fc8e0          LDR      r12,|L1.2608|
00130c  e08c7604          ADD      r7,r12,r4,LSL #12
001310  e58760d0          STR      r6,[r7,#0xd0]
;;;776                    break;
001314  ea00000a          B        |L1.4932|
                  |L1.4888|
;;;777    
;;;778                case GDC_LAYER_E:
001318  e320f000          NOP      
;;;779                    vSetGDCLDRE(eGDC, u32Val);
00131c  e51f6830          LDR      r6,|L1.2804|
001320  e7861104          STR      r1,[r6,r4,LSL #2]
;;;780                    /* LHEIGHT & LWIDTH: belong to low word of register: */
;;;781                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRE_REG__, u32GDCLDRE_REG__Var[eGDC]);
001324  e7966104          LDR      r6,[r6,r4,LSL #2]
001328  e51fc900          LDR      r12,|L1.2608|
00132c  e08c7604          ADD      r7,r12,r4,LSL #12
001330  e58760d8          STR      r6,[r7,#0xd8]
;;;782                    break;
001334  ea000002          B        |L1.4932|
                  |L1.4920|
;;;783    
;;;784                default:
001338  e320f000          NOP      
;;;785                    i32Res = C_FAILED;
00133c  e3e00000          MVN      r0,#0
;;;786                    break;
001340  e320f000          NOP      
                  |L1.4932|
001344  e320f000          NOP                            ;758
                  |L1.4936|
;;;787            }
;;;788        }
;;;789    
;;;790        return i32Res;
;;;791    }
001348  e8bd80f0          POP      {r4-r7,pc}
;;;792    
                          ENDP

                  vGDC_SetLayerOrder PROC
;;;794    /****************************************************************************/
;;;795    void vGDC_SetLayerOrder(gdc_ch_e eGDC, gdc_vord_e eOrder)
00134c  e92d4010          PUSH     {r4,lr}
;;;796    {
;;;797        vSetGDCDCR_VORD(eGDC, eOrder);
001350  e51f2924          LDR      r2,|L1.2612|
001354  e0822180          ADD      r2,r2,r0,LSL #3
001358  e1c220d0          LDRD     r2,r3,[r2,#0]
00135c  e7c72391          BFI      r2,r1,#7,#1
001360  e51f4934          LDR      r4,|L1.2612|
001364  e0844180          ADD      r4,r4,r0,LSL #3
001368  e1c420f0          STRD     r2,r3,[r4,#0]
;;;798        /* VORD: belongs to low word of register: */
;;;799        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
00136c  e51f2940          LDR      r2,|L1.2612|
001370  e0822180          ADD      r2,r2,r0,LSL #3
001374  e1c220d0          LDRD     r2,r3,[r2,#0]
001378  e51f4950          LDR      r4,|L1.2608|
00137c  e7842600          STR      r2,[r4,r0,LSL #12]
;;;800    }
001380  e8bd8010          POP      {r4,pc}
;;;801    
                          ENDP

                  i32GDC_SetCommonAlpha PROC
;;;803    /****************************************************************************/
;;;804    int32_t i32GDC_SetCommonAlpha(gdc_ch_e eGDC, gdc_seg_e eEntity, uint8_t u8Alpha)
001384  e92d4070          PUSH     {r4-r6,lr}
;;;805    {
001388  e1a03000          MOV      r3,r0
00138c  e1a04001          MOV      r4,r1
;;;806        int32_t i32Res = C_SUCCESS;
001390  e3a05000          MOV      r5,#0
;;;807    
;;;808        switch( eEntity )
001394  e354000b          CMP      r4,#0xb
001398  308ff104          ADDCC    pc,pc,r4,LSL #2
00139c  ea00009e          B        |L1.5660|
0013a0  ea00009d          B        |L1.5660|
0013a4  ea000008          B        |L1.5068|
0013a8  ea000016          B        |L1.5128|
0013ac  ea000024          B        |L1.5188|
0013b0  ea000032          B        |L1.5248|
0013b4  ea000040          B        |L1.5308|
0013b8  ea00004d          B        |L1.5364|
0013bc  ea00005b          B        |L1.5424|
0013c0  ea000069          B        |L1.5484|
0013c4  ea000077          B        |L1.5544|
0013c8  ea000085          B        |L1.5604|
                  |L1.5068|
;;;809        {
;;;810            case GDC_SEG_LAYER_A:
0013cc  e320f000          NOP      
;;;811                vSetGDCCAVRA_ALPHAA(eGDC, u8Alpha);
0013d0  e51f0984          LDR      r0,|L1.2644|
0013d4  e0800183          ADD      r0,r0,r3,LSL #3
0013d8  e1c000d0          LDRD     r0,r1,[r0,#0]
0013dc  e7c70012          BFI      r0,r2,#0,#8
0013e0  e51f6994          LDR      r6,|L1.2644|
0013e4  e0866183          ADD      r6,r6,r3,LSL #3
0013e8  e1c600f0          STRD     r0,r1,[r6,#0]
;;;812                /* ALPHAA: belongs to low word of register: */
;;;813                UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
0013ec  e51f09a0          LDR      r0,|L1.2644|
0013f0  e0800183          ADD      r0,r0,r3,LSL #3
0013f4  e1c000d0          LDRD     r0,r1,[r0,#0]
0013f8  e51f69d0          LDR      r6,|L1.2608|
0013fc  e0861603          ADD      r1,r6,r3,LSL #12
001400  e5810100          STR      r0,[r1,#0x100]
;;;814                break;
001404  ea000087          B        |L1.5672|
                  |L1.5128|
;;;815    
;;;816            case GDC_SEG_LAYER_B:
001408  e320f000          NOP      
;;;817                vSetGDCCAVRA_ALPHAB(eGDC, u8Alpha);
00140c  e51f09c0          LDR      r0,|L1.2644|
001410  e0800183          ADD      r0,r0,r3,LSL #3
001414  e1c000d0          LDRD     r0,r1,[r0,#0]
001418  e7d70812          BFI      r0,r2,#16,#8
00141c  e51f69d0          LDR      r6,|L1.2644|
001420  e0866183          ADD      r6,r6,r3,LSL #3
001424  e1c600f0          STRD     r0,r1,[r6,#0]
;;;818                /* ALPHAB: belongs to low word of register: */
;;;819                UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
001428  e51f09dc          LDR      r0,|L1.2644|
00142c  e0800183          ADD      r0,r0,r3,LSL #3
001430  e1c000d0          LDRD     r0,r1,[r0,#0]
001434  e51f6a0c          LDR      r6,|L1.2608|
001438  e0861603          ADD      r1,r6,r3,LSL #12
00143c  e5810100          STR      r0,[r1,#0x100]
;;;820                break;
001440  ea000078          B        |L1.5672|
                  |L1.5188|
;;;821    
;;;822            case GDC_SEG_LAYER_C:
001444  e320f000          NOP      
;;;823                vSetGDCCAVRA_ALPHAC(eGDC, u8Alpha);
001448  e51f09fc          LDR      r0,|L1.2644|
00144c  e0800183          ADD      r0,r0,r3,LSL #3
001450  e1c000d0          LDRD     r0,r1,[r0,#0]
001454  e7c71012          BFI      r1,r2,#0,#8
001458  e51f6a0c          LDR      r6,|L1.2644|
00145c  e0866183          ADD      r6,r6,r3,LSL #3
001460  e1c600f0          STRD     r0,r1,[r6,#0]
;;;824                /* ALPHAC: belongs to high word of register: */
;;;825                UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
001464  e51f0a18          LDR      r0,|L1.2644|
001468  e0800183          ADD      r0,r0,r3,LSL #3
00146c  e1c000d0          LDRD     r0,r1,[r0,#0]
001470  e51f0a28          LDR      r0,|L1.2640|
001474  e0800603          ADD      r0,r0,r3,LSL #12
001478  e5801004          STR      r1,[r0,#4]
;;;826                break;
00147c  ea000069          B        |L1.5672|
                  |L1.5248|
;;;827    
;;;828            case GDC_SEG_LAYER_D:
001480  e320f000          NOP      
;;;829                vSetGDCCAVRA_ALPHAD(eGDC, u8Alpha);
001484  e51f0a38          LDR      r0,|L1.2644|
001488  e0800183          ADD      r0,r0,r3,LSL #3
00148c  e1c000d0          LDRD     r0,r1,[r0,#0]
001490  e7d71812          BFI      r1,r2,#16,#8
001494  e51f6a48          LDR      r6,|L1.2644|
001498  e0866183          ADD      r6,r6,r3,LSL #3
00149c  e1c600f0          STRD     r0,r1,[r6,#0]
;;;830                /* ALPHAD: belongs to high word of register: */
;;;831                UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
0014a0  e51f0a54          LDR      r0,|L1.2644|
0014a4  e0800183          ADD      r0,r0,r3,LSL #3
0014a8  e1c000d0          LDRD     r0,r1,[r0,#0]
0014ac  e51f0a64          LDR      r0,|L1.2640|
0014b0  e0800603          ADD      r0,r0,r3,LSL #12
0014b4  e5801004          STR      r1,[r0,#4]
;;;832                break;
0014b8  ea00005a          B        |L1.5672|
                  |L1.5308|
;;;833    
;;;834            case GDC_SEG_LAYER_E:
0014bc  e320f000          NOP      
;;;835                vSetGDCCAVRB_ALPHAE(eGDC, u8Alpha);
0014c0  e51f09c0          LDR      r0,|L1.2824|
0014c4  e0800103          ADD      r0,r0,r3,LSL #2
0014c8  e1d000b0          LDRH     r0,[r0,#0]
0014cc  e7c70012          BFI      r0,r2,#0,#8
0014d0  e51f19d0          LDR      r1,|L1.2824|
0014d4  e0811103          ADD      r1,r1,r3,LSL #2
0014d8  e1c100b0          STRH     r0,[r1,#0]
;;;836                /* ALPHAE: belongs to low word of register: */
;;;837                UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRB_REG__, u32GDCCAVRB_REG__Var[eGDC]);
0014dc  e51f09dc          LDR      r0,|L1.2824|
0014e0  e7900103          LDR      r0,[r0,r3,LSL #2]
0014e4  e51f6abc          LDR      r6,|L1.2608|
0014e8  e0861603          ADD      r1,r6,r3,LSL #12
0014ec  e5810108          STR      r0,[r1,#0x108]
;;;838                break;
0014f0  ea00004c          B        |L1.5672|
                  |L1.5364|
;;;839    
;;;840            case GDC_SEG_WIN_A:
0014f4  e320f000          NOP      
;;;841                vSetGDCCAVRA_WALPHAA(eGDC, u8Alpha);
0014f8  e51f0aac          LDR      r0,|L1.2644|
0014fc  e0800183          ADD      r0,r0,r3,LSL #3
001500  e1c000d0          LDRD     r0,r1,[r0,#0]
001504  e7cf0412          BFI      r0,r2,#8,#8
001508  e51f6abc          LDR      r6,|L1.2644|
00150c  e0866183          ADD      r6,r6,r3,LSL #3
001510  e1c600f0          STRD     r0,r1,[r6,#0]
;;;842                /* WALPHAA: belongs to low word of register: */
;;;843                UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
001514  e51f0ac8          LDR      r0,|L1.2644|
001518  e0800183          ADD      r0,r0,r3,LSL #3
00151c  e1c000d0          LDRD     r0,r1,[r0,#0]
001520  e51f6af8          LDR      r6,|L1.2608|
001524  e0861603          ADD      r1,r6,r3,LSL #12
001528  e5810100          STR      r0,[r1,#0x100]
;;;844                break;
00152c  ea00003d          B        |L1.5672|
                  |L1.5424|
;;;845    
;;;846            case GDC_SEG_WIN_B:
001530  e320f000          NOP      
;;;847                vSetGDCCAVRA_WALPHAB(eGDC, u8Alpha);
001534  e51f0ae8          LDR      r0,|L1.2644|
001538  e0800183          ADD      r0,r0,r3,LSL #3
00153c  e1c000d0          LDRD     r0,r1,[r0,#0]
001540  e7df0c12          BFI      r0,r2,#24,#8
001544  e51f6af8          LDR      r6,|L1.2644|
001548  e0866183          ADD      r6,r6,r3,LSL #3
00154c  e1c600f0          STRD     r0,r1,[r6,#0]
;;;848                /* WALPHAB: belongs to low word of register: */
;;;849                UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
001550  e51f0b04          LDR      r0,|L1.2644|
001554  e0800183          ADD      r0,r0,r3,LSL #3
001558  e1c000d0          LDRD     r0,r1,[r0,#0]
00155c  e51f6b34          LDR      r6,|L1.2608|
001560  e0861603          ADD      r1,r6,r3,LSL #12
001564  e5810100          STR      r0,[r1,#0x100]
;;;850                break;
001568  ea00002e          B        |L1.5672|
                  |L1.5484|
;;;851    
;;;852            case GDC_SEG_WIN_C:
00156c  e320f000          NOP      
;;;853                vSetGDCCAVRA_WALPHAC(eGDC, u8Alpha);
001570  e51f0b24          LDR      r0,|L1.2644|
001574  e0800183          ADD      r0,r0,r3,LSL #3
001578  e1c000d0          LDRD     r0,r1,[r0,#0]
00157c  e7cf1412          BFI      r1,r2,#8,#8
001580  e51f6b34          LDR      r6,|L1.2644|
001584  e0866183          ADD      r6,r6,r3,LSL #3
001588  e1c600f0          STRD     r0,r1,[r6,#0]
;;;854                /* WALPHAC: belongs to high word of register: */
;;;855                UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
00158c  e51f0b40          LDR      r0,|L1.2644|
001590  e0800183          ADD      r0,r0,r3,LSL #3
001594  e1c000d0          LDRD     r0,r1,[r0,#0]
001598  e51f0b50          LDR      r0,|L1.2640|
00159c  e0800603          ADD      r0,r0,r3,LSL #12
0015a0  e5801004          STR      r1,[r0,#4]
;;;856                break;
0015a4  ea00001f          B        |L1.5672|
                  |L1.5544|
;;;857    
;;;858            case GDC_SEG_WIN_D:
0015a8  e320f000          NOP      
;;;859                vSetGDCCAVRA_WALPHAD(eGDC, u8Alpha);
0015ac  e51f0b60          LDR      r0,|L1.2644|
0015b0  e0800183          ADD      r0,r0,r3,LSL #3
0015b4  e1c000d0          LDRD     r0,r1,[r0,#0]
0015b8  e7df1c12          BFI      r1,r2,#24,#8
0015bc  e51f6b70          LDR      r6,|L1.2644|
0015c0  e0866183          ADD      r6,r6,r3,LSL #3
0015c4  e1c600f0          STRD     r0,r1,[r6,#0]
;;;860                /* WALPHAD: belongs to high word of register: */
;;;861                UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
0015c8  e51f0b7c          LDR      r0,|L1.2644|
0015cc  e0800183          ADD      r0,r0,r3,LSL #3
0015d0  e1c000d0          LDRD     r0,r1,[r0,#0]
0015d4  e51f0b8c          LDR      r0,|L1.2640|
0015d8  e0800603          ADD      r0,r0,r3,LSL #12
0015dc  e5801004          STR      r1,[r0,#4]
;;;862                break;
0015e0  ea000010          B        |L1.5672|
                  |L1.5604|
;;;863    
;;;864            case GDC_SEG_WIN_E:
0015e4  e320f000          NOP      
;;;865                vSetGDCCAVRB_WALPHAE(eGDC, u8Alpha);
0015e8  e51f0ae8          LDR      r0,|L1.2824|
0015ec  e0800103          ADD      r0,r0,r3,LSL #2
0015f0  e1d000b0          LDRH     r0,[r0,#0]
0015f4  e7cf0412          BFI      r0,r2,#8,#8
0015f8  e51f1af8          LDR      r1,|L1.2824|
0015fc  e0811103          ADD      r1,r1,r3,LSL #2
001600  e1c100b0          STRH     r0,[r1,#0]
;;;866                /* ALPHAE: belongs to low word of register: */
;;;867                UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRB_REG__, u32GDCCAVRB_REG__Var[eGDC]);
001604  e51f0b04          LDR      r0,|L1.2824|
001608  e7900103          LDR      r0,[r0,r3,LSL #2]
00160c  e51f6be4          LDR      r6,|L1.2608|
001610  e0861603          ADD      r1,r6,r3,LSL #12
001614  e5810108          STR      r0,[r1,#0x108]
;;;868                break;
001618  ea000002          B        |L1.5672|
                  |L1.5660|
;;;869            default:
00161c  e320f000          NOP      
;;;870                i32Res = C_FAILED;
001620  e3e05000          MVN      r5,#0
;;;871                break;
001624  e320f000          NOP      
                  |L1.5672|
001628  e320f000          NOP                            ;814
;;;872        }
;;;873        /* Report the result */
;;;874        return i32Res;
00162c  e1a00005          MOV      r0,r5
;;;875    }
001630  e8bd8070          POP      {r4-r6,pc}
;;;876    
                          ENDP

                  i32GDC_GetCommonAlpha PROC
;;;878    /****************************************************************************/
;;;879    int32_t i32GDC_GetCommonAlpha(gdc_ch_e eGDC, gdc_seg_e eEntity, uint8_t* pu8Alpha)
001634  e92d4030          PUSH     {r4,r5,lr}
;;;880    {
001638  e1a03000          MOV      r3,r0
00163c  e1a04001          MOV      r4,r1
;;;881        int32_t i32Res = C_SUCCESS;
001640  e3a05000          MOV      r5,#0
;;;882        
;;;883        /* check pointer: */
;;;884        if (0x00 != pu8Alpha)
001644  e3520000          CMP      r2,#0
001648  0a000054          BEQ      |L1.6048|
;;;885        {
;;;886            switch( eEntity )
00164c  e354000b          CMP      r4,#0xb
001650  308ff104          ADDCC    pc,pc,r4,LSL #2
001654  ea00004d          B        |L1.6032|
001658  ea00004c          B        |L1.6032|
00165c  ea000008          B        |L1.5764|
001660  ea00000d          B        |L1.5788|
001664  ea000013          B        |L1.5816|
001668  ea000018          B        |L1.5840|
00166c  ea00001e          B        |L1.5868|
001670  ea000023          B        |L1.5892|
001674  ea000029          B        |L1.5920|
001678  ea00002f          B        |L1.5948|
00167c  ea000035          B        |L1.5976|
001680  ea00003b          B        |L1.6004|
                  |L1.5764|
;;;887            {
;;;888                case GDC_SEG_LAYER_A:
001684  e320f000          NOP      
;;;889                    *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAA(eGDC);
001688  e51f0c3c          LDR      r0,|L1.2644|
00168c  e0800183          ADD      r0,r0,r3,LSL #3
001690  e1c000d0          LDRD     r0,r1,[r0,#0]
001694  e5c20000          STRB     r0,[r2,#0]
;;;890                    break;
001698  ea00003f          B        |L1.6044|
                  |L1.5788|
;;;891    
;;;892                case GDC_SEG_LAYER_B:
00169c  e320f000          NOP      
;;;893                    *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAB(eGDC);
0016a0  e51f0c54          LDR      r0,|L1.2644|
0016a4  e0800183          ADD      r0,r0,r3,LSL #3
0016a8  e1c000d0          LDRD     r0,r1,[r0,#0]
0016ac  e1a00820          LSR      r0,r0,#16
0016b0  e5c20000          STRB     r0,[r2,#0]
;;;894                    break;
0016b4  ea000038          B        |L1.6044|
                  |L1.5816|
;;;895    
;;;896                case GDC_SEG_LAYER_C:
0016b8  e320f000          NOP      
;;;897                    *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAC(eGDC);
0016bc  e51f0c70          LDR      r0,|L1.2644|
0016c0  e0800183          ADD      r0,r0,r3,LSL #3
0016c4  e1c000d0          LDRD     r0,r1,[r0,#0]
0016c8  e5c21000          STRB     r1,[r2,#0]
;;;898                    break;
0016cc  ea000032          B        |L1.6044|
                  |L1.5840|
;;;899    
;;;900                case GDC_SEG_LAYER_D:
0016d0  e320f000          NOP      
;;;901                    *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAD(eGDC);
0016d4  e51f0c88          LDR      r0,|L1.2644|
0016d8  e0800183          ADD      r0,r0,r3,LSL #3
0016dc  e1c000d0          LDRD     r0,r1,[r0,#0]
0016e0  e1a00821          LSR      r0,r1,#16
0016e4  e5c20000          STRB     r0,[r2,#0]
;;;902                    break;
0016e8  ea00002b          B        |L1.6044|
                  |L1.5868|
;;;903    
;;;904                case GDC_SEG_LAYER_E:
0016ec  e320f000          NOP      
;;;905                    *pu8Alpha= (uint8_t) biGetGDCCAVRB_ALPHAE(eGDC);
0016f0  e51f0bf0          LDR      r0,|L1.2824|
0016f4  e0800103          ADD      r0,r0,r3,LSL #2
0016f8  e1d000b0          LDRH     r0,[r0,#0]
0016fc  e5c20000          STRB     r0,[r2,#0]
;;;906                    break;
001700  ea000025          B        |L1.6044|
                  |L1.5892|
;;;907    
;;;908                case GDC_SEG_WIN_A:
001704  e320f000          NOP      
;;;909                    *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAA(eGDC);
001708  e51f0cbc          LDR      r0,|L1.2644|
00170c  e0800183          ADD      r0,r0,r3,LSL #3
001710  e1c000d0          LDRD     r0,r1,[r0,#0]
001714  e1a00420          LSR      r0,r0,#8
001718  e5c20000          STRB     r0,[r2,#0]
;;;910                    break;
00171c  ea00001e          B        |L1.6044|
                  |L1.5920|
;;;911    
;;;912                case GDC_SEG_WIN_B:
001720  e320f000          NOP      
;;;913                    *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAB(eGDC);
001724  e51f0cd8          LDR      r0,|L1.2644|
001728  e0800183          ADD      r0,r0,r3,LSL #3
00172c  e1c000d0          LDRD     r0,r1,[r0,#0]
001730  e1a00c20          LSR      r0,r0,#24
001734  e5c20000          STRB     r0,[r2,#0]
;;;914                    break;
001738  ea000017          B        |L1.6044|
                  |L1.5948|
;;;915    
;;;916                case GDC_SEG_WIN_C:
00173c  e320f000          NOP      
;;;917                    *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAC(eGDC);
001740  e51f0cf4          LDR      r0,|L1.2644|
001744  e0800183          ADD      r0,r0,r3,LSL #3
001748  e1c000d0          LDRD     r0,r1,[r0,#0]
00174c  e1a00421          LSR      r0,r1,#8
001750  e5c20000          STRB     r0,[r2,#0]
;;;918                    break;
001754  ea000010          B        |L1.6044|
                  |L1.5976|
;;;919    
;;;920                case GDC_SEG_WIN_D:
001758  e320f000          NOP      
;;;921                    *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAD(eGDC);
00175c  e51f0d10          LDR      r0,|L1.2644|
001760  e0800183          ADD      r0,r0,r3,LSL #3
001764  e1c000d0          LDRD     r0,r1,[r0,#0]
001768  e1a00c21          LSR      r0,r1,#24
00176c  e5c20000          STRB     r0,[r2,#0]
;;;922                    break;
001770  ea000009          B        |L1.6044|
                  |L1.6004|
;;;923    
;;;924                case GDC_SEG_WIN_E:
001774  e320f000          NOP      
;;;925                    *pu8Alpha = (uint8_t) biGetGDCCAVRB_WALPHAE(eGDC);
001778  e51f0c78          LDR      r0,|L1.2824|
00177c  e0800103          ADD      r0,r0,r3,LSL #2
001780  e1d000b0          LDRH     r0,[r0,#0]
001784  e1a00420          LSR      r0,r0,#8
001788  e5c20000          STRB     r0,[r2,#0]
;;;926                    break;
00178c  ea000002          B        |L1.6044|
                  |L1.6032|
;;;927    
;;;928                default:
001790  e320f000          NOP      
;;;929                    /* Unsupported entity */
;;;930                    i32Res = C_FAILED;
001794  e3e05000          MVN      r5,#0
;;;931                    break;
001798  e320f000          NOP      
                  |L1.6044|
00179c  ea000000          B        |L1.6052|
                  |L1.6048|
;;;932            }
;;;933        }
;;;934        else
;;;935        {
;;;936            i32Res = C_FAILED;
0017a0  e3e05000          MVN      r5,#0
                  |L1.6052|
;;;937        }
;;;938        return i32Res;
0017a4  e1a00005          MOV      r0,r5
;;;939    }
0017a8  e8bd8030          POP      {r4,r5,pc}
;;;940    
                          ENDP

                  i32GDC_FrameBuffConfig PROC
;;;942    /****************************************************************************/
;;;943    int32_t i32GDC_FrameBuffConfig(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_fbcfg_st* pstBuffCfg)
0017ac  e92d4070          PUSH     {r4-r6,lr}
;;;944    {
0017b0  e1a03000          MOV      r3,r0
;;;945        int32_t i32Res = C_SUCCESS;
0017b4  e3a00000          MOV      r0,#0
;;;946        
;;;947        /* check pointer: */
;;;948        if (0x00 != pstBuffCfg)
0017b8  e3520000          CMP      r2,#0
0017bc  0a0000ba          BEQ      |L1.6828|
;;;949        {
;;;950            switch( eLayer )
0017c0  e3510005          CMP      r1,#5
0017c4  308ff101          ADDCC    pc,pc,r1,LSL #2
0017c8  ea0000b3          B        |L1.6812|
0017cc  ea000003          B        |L1.6112|
0017d0  ea000025          B        |L1.6252|
0017d4  ea000047          B        |L1.6392|
0017d8  ea000069          B        |L1.6532|
0017dc  ea00008b          B        |L1.6672|
                  |L1.6112|
;;;951            {
;;;952                case GDC_LAYER_A:
0017e0  e320f000          NOP      
;;;953                    /*
;;;954                     *  Select default or secondary buffer, i.e. GDCLARA0 or
;;;955                     *  GDCLARA1 and write the 32 LSbits of the buffer start
;;;956                     *  address
;;;957                     */
;;;958                    if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
0017e4  e5d24000          LDRB     r4,[r2,#0]
0017e8  e3540000          CMP      r4,#0
0017ec  1a000008          BNE      |L1.6164|
;;;959                    {
;;;960                        vSetGDCLARA0(eGDC, pstBuffCfg->u32Addr);
0017f0  e51f5d68          LDR      r5,|L1.2704|
0017f4  e5924004          LDR      r4,[r2,#4]
0017f8  e7854103          STR      r4,[r5,r3,LSL #2]
;;;961                        /* Copy register data to shadow register: */
;;;962                        UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA0_REG__, u32GDCLARA0_REG__Var[eGDC]);
0017fc  e2854000          ADD      r4,r5,#0
001800  e7944103          LDR      r4,[r4,r3,LSL #2]
001804  e51f6ddc          LDR      r6,|L1.2608|
001808  e0865603          ADD      r5,r6,r3,LSL #12
00180c  e5854010          STR      r4,[r5,#0x10]
001810  ea000007          B        |L1.6196|
                  |L1.6164|
;;;963                    }
;;;964                    else
;;;965                    {
;;;966                        vSetGDCLARA1(eGDC, pstBuffCfg->u32Addr);
001814  e51f5d88          LDR      r5,|L1.2708|
001818  e5924004          LDR      r4,[r2,#4]
00181c  e7854103          STR      r4,[r5,r3,LSL #2]
;;;967                        /* Copy register data to shadow register: */
;;;968                        UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA1_REG__, u32GDCLARA1_REG__Var[eGDC]);
001820  e2854000          ADD      r4,r5,#0
001824  e7944103          LDR      r4,[r4,r3,LSL #2]
001828  e51f6e00          LDR      r6,|L1.2608|
00182c  e0865603          ADD      r5,r6,r3,LSL #12
001830  e5854018          STR      r4,[r5,#0x18]
                  |L1.6196|
;;;969                    }
;;;970                    vSetGDCMWRA_MWR(eGDC, pstBuffCfg->u16Width);
001834  e1d250b8          LDRH     r5,[r2,#8]
001838  e51f4d84          LDR      r4,|L1.2748|
00183c  e0844103          ADD      r4,r4,r3,LSL #2
001840  e1d440b0          LDRH     r4,[r4,#0]
001844  e7cc4015          BFI      r4,r5,#0,#13
001848  e51f5d94          LDR      r5,|L1.2748|
00184c  e0855103          ADD      r5,r5,r3,LSL #2
001850  e1c540b0          STRH     r4,[r5,#0]
;;;971                    /* Copy register data to shadow register: */
;;;972                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRA_REG__, u32GDCMWRA_REG__Var[eGDC]);
001854  e51f4da0          LDR      r4,|L1.2748|
001858  e7944103          LDR      r4,[r4,r3,LSL #2]
00185c  e51f6e34          LDR      r6,|L1.2608|
001860  e0865603          ADD      r5,r6,r3,LSL #12
001864  e5854068          STR      r4,[r5,#0x68]
;;;973                    break;
001868  ea00008e          B        |L1.6824|
                  |L1.6252|
;;;974                    
;;;975                case GDC_LAYER_B:
00186c  e320f000          NOP      
;;;976                    /*
;;;977                     *  Select default or secondary buffer, i.e. GDCSARB0 or
;;;978                     *  GDCSARB1 and write the 32 LSbits of the buffer start
;;;979                     *  address
;;;980                     */
;;;981                    if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
001870  e5d24000          LDRB     r4,[r2,#0]
001874  e3540000          CMP      r4,#0
001878  1a000008          BNE      |L1.6304|
;;;982                    {
;;;983                        vSetGDCLARB0(eGDC, pstBuffCfg->u32Addr);
00187c  e51f5de4          LDR      r5,|L1.2720|
001880  e5924004          LDR      r4,[r2,#4]
001884  e7854103          STR      r4,[r5,r3,LSL #2]
;;;984                        /* Copy register data to shadow register: */
;;;985                        UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB0_REG__, u32GDCLARB0_REG__Var[eGDC]);
001888  e2854000          ADD      r4,r5,#0
00188c  e7944103          LDR      r4,[r4,r3,LSL #2]
001890  e51f6e68          LDR      r6,|L1.2608|
001894  e0865603          ADD      r5,r6,r3,LSL #12
001898  e5854030          STR      r4,[r5,#0x30]
00189c  ea000007          B        |L1.6336|
                  |L1.6304|
;;;986                    }
;;;987                    else
;;;988                    {
;;;989                        vSetGDCLARB1(eGDC, pstBuffCfg->u32Addr);
0018a0  e51f5e04          LDR      r5,|L1.2724|
0018a4  e5924004          LDR      r4,[r2,#4]
0018a8  e7854103          STR      r4,[r5,r3,LSL #2]
;;;990                        /* Copy register data to shadow register: */
;;;991                        UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB1_REG__, u32GDCLARB1_REG__Var[eGDC]);
0018ac  e2854000          ADD      r4,r5,#0
0018b0  e7944103          LDR      r4,[r4,r3,LSL #2]
0018b4  e51f6e8c          LDR      r6,|L1.2608|
0018b8  e0865603          ADD      r5,r6,r3,LSL #12
0018bc  e5854038          STR      r4,[r5,#0x38]
                  |L1.6336|
;;;992                    }
;;;993                    vSetGDCMWRB_MWR(eGDC, pstBuffCfg->u16Width);
0018c0  e1d250b8          LDRH     r5,[r2,#8]
0018c4  e51f4e0c          LDR      r4,|L1.2752|
0018c8  e0844103          ADD      r4,r4,r3,LSL #2
0018cc  e1d440b0          LDRH     r4,[r4,#0]
0018d0  e7cc4015          BFI      r4,r5,#0,#13
0018d4  e51f5e1c          LDR      r5,|L1.2752|
0018d8  e0855103          ADD      r5,r5,r3,LSL #2
0018dc  e1c540b0          STRH     r4,[r5,#0]
;;;994                    /* Copy register data to shadow register: */
;;;995                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRB_REG__, u32GDCMWRB_REG__Var[eGDC]);
0018e0  e51f4e28          LDR      r4,|L1.2752|
0018e4  e7944103          LDR      r4,[r4,r3,LSL #2]
0018e8  e51f6ec0          LDR      r6,|L1.2608|
0018ec  e0865603          ADD      r5,r6,r3,LSL #12
0018f0  e5854070          STR      r4,[r5,#0x70]
;;;996                    break;
0018f4  ea00006b          B        |L1.6824|
                  |L1.6392|
;;;997    
;;;998                case GDC_LAYER_C:
0018f8  e320f000          NOP      
;;;999                    /*
;;;1000                    *  Select default or secondary buffer, i.e. GDCSARC0 or
;;;1001                    *  GDCSARC1 and write the 32 LSbits of the buffer start
;;;1002                    *  address
;;;1003                    */
;;;1004                   if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
0018fc  e5d24000          LDRB     r4,[r2,#0]
001900  e3540000          CMP      r4,#0
001904  1a000008          BNE      |L1.6444|
;;;1005                   {
;;;1006                       vSetGDCLARC0(eGDC, pstBuffCfg->u32Addr);
001908  e51f5e64          LDR      r5,|L1.2732|
00190c  e5924004          LDR      r4,[r2,#4]
001910  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1007                       /* Copy register data to shadow register: */
;;;1008                       UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC0_REG__, u32GDCLARC0_REG__Var[eGDC]);
001914  e2854000          ADD      r4,r5,#0
001918  e7944103          LDR      r4,[r4,r3,LSL #2]
00191c  e51f6ef4          LDR      r6,|L1.2608|
001920  e0865603          ADD      r5,r6,r3,LSL #12
001924  e5854048          STR      r4,[r5,#0x48]
001928  ea000007          B        |L1.6476|
                  |L1.6444|
;;;1009                   }
;;;1010                   else
;;;1011                   {
;;;1012                       vSetGDCLARC1(eGDC, pstBuffCfg->u32Addr);
00192c  e51f5e84          LDR      r5,|L1.2736|
001930  e5924004          LDR      r4,[r2,#4]
001934  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1013                       /* Copy register data to shadow register: */
;;;1014                       UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC1_REG__, u32GDCLARC1_REG__Var[eGDC]);
001938  e2854000          ADD      r4,r5,#0
00193c  e7944103          LDR      r4,[r4,r3,LSL #2]
001940  e51f6f18          LDR      r6,|L1.2608|
001944  e0865603          ADD      r5,r6,r3,LSL #12
001948  e5854050          STR      r4,[r5,#0x50]
                  |L1.6476|
;;;1015                   }
;;;1016                   vSetGDCMWRC_MWR(eGDC, pstBuffCfg->u16Width);
00194c  e1d250b8          LDRH     r5,[r2,#8]
001950  e51f4e94          LDR      r4,|L1.2756|
001954  e0844103          ADD      r4,r4,r3,LSL #2
001958  e1d440b0          LDRH     r4,[r4,#0]
00195c  e7cc4015          BFI      r4,r5,#0,#13
001960  e51f5ea4          LDR      r5,|L1.2756|
001964  e0855103          ADD      r5,r5,r3,LSL #2
001968  e1c540b0          STRH     r4,[r5,#0]
;;;1017                   /* Copy register data to shadow register: */
;;;1018                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRC_REG__, u32GDCMWRC_REG__Var[eGDC]);
00196c  e51f4eb0          LDR      r4,|L1.2756|
001970  e7944103          LDR      r4,[r4,r3,LSL #2]
001974  e51f6f4c          LDR      r6,|L1.2608|
001978  e0865603          ADD      r5,r6,r3,LSL #12
00197c  e5854078          STR      r4,[r5,#0x78]
;;;1019                   break;
001980  ea000048          B        |L1.6824|
                  |L1.6532|
;;;1020   
;;;1021               case GDC_LAYER_D:
001984  e320f000          NOP      
;;;1022                   /*
;;;1023                    *  Select default or secondary buffer, i.e. GDCSARD0 or
;;;1024                    *  GDCSARD1 and write the 32 LSbits of the buffer start
;;;1025                    *  address
;;;1026                    */
;;;1027                   if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
001988  e5d24000          LDRB     r4,[r2,#0]
00198c  e3540000          CMP      r4,#0
001990  1a000008          BNE      |L1.6584|
;;;1028                   {
;;;1029                       vSetGDCLARD0(eGDC, pstBuffCfg->u32Addr);
001994  e51f5ee8          LDR      r5,|L1.2740|
001998  e5924004          LDR      r4,[r2,#4]
00199c  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1030                       /* Copy register data to shadow register: */
;;;1031                       UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD0_REG__, u32GDCLARD0_REG__Var[eGDC]);
0019a0  e2854000          ADD      r4,r5,#0
0019a4  e7944103          LDR      r4,[r4,r3,LSL #2]
0019a8  e51f6f80          LDR      r6,|L1.2608|
0019ac  e0865603          ADD      r5,r6,r3,LSL #12
0019b0  e5854058          STR      r4,[r5,#0x58]
0019b4  ea000007          B        |L1.6616|
                  |L1.6584|
;;;1032                   }
;;;1033                   else
;;;1034                   {
;;;1035                       vSetGDCLARD1(eGDC, pstBuffCfg->u32Addr);
0019b8  e51f5f08          LDR      r5,|L1.2744|
0019bc  e5924004          LDR      r4,[r2,#4]
0019c0  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1036                       /* Copy register data to shadow register: */
;;;1037                       UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD1_REG__, u32GDCLARD1_REG__Var[eGDC]);
0019c4  e2854000          ADD      r4,r5,#0
0019c8  e7944103          LDR      r4,[r4,r3,LSL #2]
0019cc  e51f6fa4          LDR      r6,|L1.2608|
0019d0  e0865603          ADD      r5,r6,r3,LSL #12
0019d4  e5854060          STR      r4,[r5,#0x60]
                  |L1.6616|
;;;1038                   }
;;;1039                   vSetGDCMWRD_MWR(eGDC, pstBuffCfg->u16Width);
0019d8  e1d250b8          LDRH     r5,[r2,#8]
0019dc  e51f4f1c          LDR      r4,|L1.2760|
0019e0  e0844103          ADD      r4,r4,r3,LSL #2
0019e4  e1d440b0          LDRH     r4,[r4,#0]
0019e8  e7cc4015          BFI      r4,r5,#0,#13
0019ec  e51f5f2c          LDR      r5,|L1.2760|
0019f0  e0855103          ADD      r5,r5,r3,LSL #2
0019f4  e1c540b0          STRH     r4,[r5,#0]
;;;1040                   /* Copy register data to shadow register: */
;;;1041                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRD_REG__, u32GDCMWRD_REG__Var[eGDC]);
0019f8  e51f4f38          LDR      r4,|L1.2760|
0019fc  e7944103          LDR      r4,[r4,r3,LSL #2]
001a00  e51f6fd8          LDR      r6,|L1.2608|
001a04  e0865603          ADD      r5,r6,r3,LSL #12
001a08  e5854080          STR      r4,[r5,#0x80]
;;;1042                   break;
001a0c  ea000025          B        |L1.6824|
                  |L1.6672|
;;;1043   
;;;1044               case GDC_LAYER_E:
001a10  e320f000          NOP      
;;;1045                   /*
;;;1046                    *  Select default or secondary buffer, i.e. GDCSARE0 or
;;;1047                    *  GDCSARE1 and write the 32 LSbits of the buffer start
;;;1048                    *  address
;;;1049                    */
;;;1050                   if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
001a14  e5d24000          LDRB     r4,[r2,#0]
001a18  e3540000          CMP      r4,#0
001a1c  1a000008          BNE      |L1.6724|
;;;1051                   {
;;;1052                       vSetGDCLARE0(eGDC, pstBuffCfg->u32Addr);
001a20  e51f5ef4          LDR      r5,|L1.2868|
001a24  e5924004          LDR      r4,[r2,#4]
001a28  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1053                       /* Copy register data to shadow register: */
;;;1054                       UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE0_REG__, u32GDCLARE0_REG__Var[eGDC]);
001a2c  e2854000          ADD      r4,r5,#0
001a30  e7944103          LDR      r4,[r4,r3,LSL #2]
001a34  e59f6ed8          LDR      r6,|L1.10516|
001a38  e0865603          ADD      r5,r6,r3,LSL #12
001a3c  e5854230          STR      r4,[r5,#0x230]
001a40  ea000007          B        |L1.6756|
                  |L1.6724|
;;;1055                   }
;;;1056                   else
;;;1057                   {
;;;1058                       vSetGDCLARE1(eGDC, pstBuffCfg->u32Addr);
001a44  e51f5f14          LDR      r5,|L1.2872|
001a48  e5924004          LDR      r4,[r2,#4]
001a4c  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1059                       /* Copy register data to shadow register: */
;;;1060                       UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE1_REG__, u32GDCLARE1_REG__Var[eGDC]);
001a50  e2854000          ADD      r4,r5,#0
001a54  e7944103          LDR      r4,[r4,r3,LSL #2]
001a58  e59f6eb4          LDR      r6,|L1.10516|
001a5c  e0865603          ADD      r5,r6,r3,LSL #12
001a60  e5854238          STR      r4,[r5,#0x238]
                  |L1.6756|
;;;1061                   }
;;;1062                   vSetGDCMWRE_MWR(eGDC, pstBuffCfg->u16Width);
001a64  e1d250b8          LDRH     r5,[r2,#8]
001a68  e51f4fa4          LDR      r4,|L1.2764|
001a6c  e0844103          ADD      r4,r4,r3,LSL #2
001a70  e1d440b0          LDRH     r4,[r4,#0]
001a74  e7cc4015          BFI      r4,r5,#0,#13
001a78  e51f5fb4          LDR      r5,|L1.2764|
001a7c  e0855103          ADD      r5,r5,r3,LSL #2
001a80  e1c540b0          STRH     r4,[r5,#0]
;;;1063                   /* Copy register data to shadow register: */
;;;1064                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRE_REG__, u32GDCMWRE_REG__Var[eGDC]);
001a84  e51f4fc0          LDR      r4,|L1.2764|
001a88  e7944103          LDR      r4,[r4,r3,LSL #2]
001a8c  e59f6e80          LDR      r6,|L1.10516|
001a90  e0865603          ADD      r5,r6,r3,LSL #12
001a94  e5854088          STR      r4,[r5,#0x88]
;;;1065                   break;
001a98  ea000002          B        |L1.6824|
                  |L1.6812|
;;;1066   
;;;1067               default:
001a9c  e320f000          NOP      
;;;1068                   /* Unsupported Layer */
;;;1069                   i32Res = C_FAILED;
001aa0  e3e00000          MVN      r0,#0
;;;1070                   break;
001aa4  e320f000          NOP      
                  |L1.6824|
001aa8  ea000000          B        |L1.6832|
                  |L1.6828|
;;;1071           }
;;;1072       }
;;;1073       else
;;;1074       {
;;;1075           i32Res = C_FAILED;
001aac  e3e00000          MVN      r0,#0
                  |L1.6832|
;;;1076       }
;;;1077       return i32Res;
;;;1078   }
001ab0  e8bd8070          POP      {r4-r6,pc}
;;;1079   
                          ENDP

                  eGDC_GetActiveFrameBuff PROC
;;;1081   /****************************************************************************/
;;;1082   gdc_frmbuff_e eGDC_GetActiveFrameBuff(gdc_ch_e eGDC)
001ab4  e1a01000          MOV      r1,r0
;;;1083   {
;;;1084       return ((gdc_frmbuff_e) biGetGDCDCR_FBACT(eGDC) );
001ab8  e59f2e54          LDR      r2,|L1.10516|
001abc  e0820601          ADD      r0,r2,r1,LSL #12
001ac0  e1c020d0          LDRD     r2,r3,[r0,#0]
001ac4  e7e007d2          UBFX     r0,r2,#15,#1
001ac8  e20000ff          AND      r0,r0,#0xff
;;;1085   }
001acc  e12fff1e          BX       lr
;;;1086   
                          ENDP

                  vGDC_SetMemWidth PROC
;;;1088   /****************************************************************************/
;;;1089   void vGDC_SetMemWidth(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16Width)
001ad0  e92d4030          PUSH     {r4,r5,lr}
;;;1090   {
;;;1091       switch( eLayer )
001ad4  e3510005          CMP      r1,#5
001ad8  308ff101          ADDCC    pc,pc,r1,LSL #2
001adc  ea00004a          B        |L1.7180|
001ae0  ea000003          B        |L1.6900|
001ae4  ea000010          B        |L1.6956|
001ae8  ea00001d          B        |L1.7012|
001aec  ea00002a          B        |L1.7068|
001af0  ea000037          B        |L1.7124|
                  |L1.6900|
;;;1092       {
;;;1093           case GDC_LAYER_A:
001af4  e320f000          NOP      
;;;1094               vSetGDCMWRA_MWR(eGDC, u16Width);
001af8  e59f3e18          LDR      r3,|L1.10520|
001afc  e0833100          ADD      r3,r3,r0,LSL #2
001b00  e1d330b0          LDRH     r3,[r3,#0]
001b04  e7cc3012          BFI      r3,r2,#0,#13
001b08  e59f4e08          LDR      r4,|L1.10520|
001b0c  e0844100          ADD      r4,r4,r0,LSL #2
001b10  e1c430b0          STRH     r3,[r4,#0]
;;;1095               /* Copy register data to shadow register: */
;;;1096               UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRA_REG__, u32GDCMWRA_REG__Var[eGDC]);
001b14  e59f3dfc          LDR      r3,|L1.10520|
001b18  e7933100          LDR      r3,[r3,r0,LSL #2]
001b1c  e59f5df0          LDR      r5,|L1.10516|
001b20  e0854600          ADD      r4,r5,r0,LSL #12
001b24  e5843068          STR      r3,[r4,#0x68]
;;;1097               break;
001b28  ea000039          B        |L1.7188|
                  |L1.6956|
;;;1098   
;;;1099           case GDC_LAYER_B:
001b2c  e320f000          NOP      
;;;1100               vSetGDCMWRB_MWR(eGDC, u16Width);
001b30  e59f3de4          LDR      r3,|L1.10524|
001b34  e0833100          ADD      r3,r3,r0,LSL #2
001b38  e1d330b0          LDRH     r3,[r3,#0]
001b3c  e7cc3012          BFI      r3,r2,#0,#13
001b40  e59f4dd4          LDR      r4,|L1.10524|
001b44  e0844100          ADD      r4,r4,r0,LSL #2
001b48  e1c430b0          STRH     r3,[r4,#0]
;;;1101               /* Copy register data to shadow register: */
;;;1102               UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRB_REG__, u32GDCMWRB_REG__Var[eGDC]);
001b4c  e59f3dc8          LDR      r3,|L1.10524|
001b50  e7933100          LDR      r3,[r3,r0,LSL #2]
001b54  e59f5db8          LDR      r5,|L1.10516|
001b58  e0854600          ADD      r4,r5,r0,LSL #12
001b5c  e5843070          STR      r3,[r4,#0x70]
;;;1103               break;
001b60  ea00002b          B        |L1.7188|
                  |L1.7012|
;;;1104   
;;;1105           case GDC_LAYER_C:
001b64  e320f000          NOP      
;;;1106               vSetGDCMWRC_MWR(eGDC, u16Width);
001b68  e59f3db0          LDR      r3,|L1.10528|
001b6c  e0833100          ADD      r3,r3,r0,LSL #2
001b70  e1d330b0          LDRH     r3,[r3,#0]
001b74  e7cc3012          BFI      r3,r2,#0,#13
001b78  e59f4da0          LDR      r4,|L1.10528|
001b7c  e0844100          ADD      r4,r4,r0,LSL #2
001b80  e1c430b0          STRH     r3,[r4,#0]
;;;1107               /* Copy register data to shadow register: */
;;;1108               UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRC_REG__, u32GDCMWRC_REG__Var[eGDC]);
001b84  e59f3d94          LDR      r3,|L1.10528|
001b88  e7933100          LDR      r3,[r3,r0,LSL #2]
001b8c  e59f5d80          LDR      r5,|L1.10516|
001b90  e0854600          ADD      r4,r5,r0,LSL #12
001b94  e5843078          STR      r3,[r4,#0x78]
;;;1109               break;
001b98  ea00001d          B        |L1.7188|
                  |L1.7068|
;;;1110   
;;;1111           case GDC_LAYER_D:
001b9c  e320f000          NOP      
;;;1112               vSetGDCMWRD_MWR(eGDC, u16Width);
001ba0  e59f3d7c          LDR      r3,|L1.10532|
001ba4  e0833100          ADD      r3,r3,r0,LSL #2
001ba8  e1d330b0          LDRH     r3,[r3,#0]
001bac  e7cc3012          BFI      r3,r2,#0,#13
001bb0  e59f4d6c          LDR      r4,|L1.10532|
001bb4  e0844100          ADD      r4,r4,r0,LSL #2
001bb8  e1c430b0          STRH     r3,[r4,#0]
;;;1113               /* Copy register data to shadow register: */
;;;1114               UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRD_REG__, u32GDCMWRD_REG__Var[eGDC]);
001bbc  e59f3d60          LDR      r3,|L1.10532|
001bc0  e7933100          LDR      r3,[r3,r0,LSL #2]
001bc4  e59f5d48          LDR      r5,|L1.10516|
001bc8  e0854600          ADD      r4,r5,r0,LSL #12
001bcc  e5843080          STR      r3,[r4,#0x80]
;;;1115               break;
001bd0  ea00000f          B        |L1.7188|
                  |L1.7124|
;;;1116   
;;;1117           case GDC_LAYER_E:
001bd4  e320f000          NOP      
;;;1118               vSetGDCMWRE_MWR(eGDC, u16Width);
001bd8  e59f3d48          LDR      r3,|L1.10536|
001bdc  e0833100          ADD      r3,r3,r0,LSL #2
001be0  e1d330b0          LDRH     r3,[r3,#0]
001be4  e7cc3012          BFI      r3,r2,#0,#13
001be8  e59f4d38          LDR      r4,|L1.10536|
001bec  e0844100          ADD      r4,r4,r0,LSL #2
001bf0  e1c430b0          STRH     r3,[r4,#0]
;;;1119               /* Copy register data to shadow register: */
;;;1120               UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRE_REG__, u32GDCMWRE_REG__Var[eGDC]);
001bf4  e59f3d2c          LDR      r3,|L1.10536|
001bf8  e7933100          LDR      r3,[r3,r0,LSL #2]
001bfc  e59f5d10          LDR      r5,|L1.10516|
001c00  e0854600          ADD      r4,r5,r0,LSL #12
001c04  e5843088          STR      r3,[r4,#0x88]
;;;1121               break;
001c08  ea000001          B        |L1.7188|
                  |L1.7180|
;;;1122   
;;;1123           default:
001c0c  e320f000          NOP      
;;;1124               break;
001c10  e320f000          NOP      
                  |L1.7188|
001c14  e320f000          NOP                            ;1097
;;;1125       }
;;;1126   }
001c18  e8bd8030          POP      {r4,r5,pc}
;;;1127   
                          ENDP

                  i32GDC_SetLayerStartAddr PROC
;;;1129   /****************************************************************************/
;;;1130   int32_t i32GDC_SetLayerStartAddr(gdc_ch_e eGDC,  gdc_layer_e eLayer,
001c1c  e92d40f0          PUSH     {r4-r7,lr}
;;;1131                                    gdc_frmbuff_e eBuff, uint32_t u32Addr)
;;;1132   {
001c20  e1a04000          MOV      r4,r0
;;;1133       int32_t i32Res = C_SUCCESS;
001c24  e3a00000          MOV      r0,#0
;;;1134   
;;;1135       /* modify Bits "SAR" in GDCLARxx register with masking: */
;;;1136       u32Addr &= GDC_SARXN_SAR_MASK;
001c28  e3c33007          BIC      r3,r3,#7
;;;1137   
;;;1138       switch( eLayer )
001c2c  e3510005          CMP      r1,#5
001c30  308ff101          ADDCC    pc,pc,r1,LSL #2
001c34  ea000059          B        |L1.7584|
001c38  ea000003          B        |L1.7244|
001c3c  ea000013          B        |L1.7312|
001c40  ea000023          B        |L1.7380|
001c44  ea000033          B        |L1.7448|
001c48  ea000043          B        |L1.7516|
                  |L1.7244|
;;;1139       {
;;;1140           case GDC_LAYER_A:
001c4c  e320f000          NOP      
;;;1141               if( GDC_BUFF_DEFAULT == eBuff )
001c50  e3520000          CMP      r2,#0
001c54  1a000006          BNE      |L1.7284|
;;;1142               {
;;;1143                   vSetGDCLARA0(eGDC, u32Addr);
001c58  e59f5ccc          LDR      r5,|L1.10540|
001c5c  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1144                   /* Copy register data to shadow register: */
;;;1145                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA0_REG__, u32GDCLARA0_REG__Var[eGDC]);
001c60  e7955104          LDR      r5,[r5,r4,LSL #2]
001c64  e59f7ca8          LDR      r7,|L1.10516|
001c68  e0876604          ADD      r6,r7,r4,LSL #12
001c6c  e5865010          STR      r5,[r6,#0x10]
001c70  ea000005          B        |L1.7308|
                  |L1.7284|
;;;1146               }
;;;1147               else
;;;1148               {
;;;1149                   vSetGDCLARA1(eGDC, u32Addr);
001c74  e59f5cb4          LDR      r5,|L1.10544|
001c78  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1150                   /* Copy register data to shadow register: */
;;;1151                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA1_REG__, u32GDCLARA1_REG__Var[eGDC]);
001c7c  e7955104          LDR      r5,[r5,r4,LSL #2]
001c80  e59f7c8c          LDR      r7,|L1.10516|
001c84  e0876604          ADD      r6,r7,r4,LSL #12
001c88  e5865018          STR      r5,[r6,#0x18]
                  |L1.7308|
;;;1152               }
;;;1153               break;
001c8c  ea000046          B        |L1.7596|
                  |L1.7312|
;;;1154   
;;;1155           case GDC_LAYER_B:
001c90  e320f000          NOP      
;;;1156               if( GDC_BUFF_DEFAULT == eBuff )
001c94  e3520000          CMP      r2,#0
001c98  1a000006          BNE      |L1.7352|
;;;1157               {
;;;1158                   vSetGDCLARB0(eGDC, u32Addr);
001c9c  e59f5c90          LDR      r5,|L1.10548|
001ca0  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1159                   /* Copy register data to shadow register: */
;;;1160                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB0_REG__, u32GDCLARB0_REG__Var[eGDC]);
001ca4  e7955104          LDR      r5,[r5,r4,LSL #2]
001ca8  e59f7c64          LDR      r7,|L1.10516|
001cac  e0876604          ADD      r6,r7,r4,LSL #12
001cb0  e5865030          STR      r5,[r6,#0x30]
001cb4  ea000005          B        |L1.7376|
                  |L1.7352|
;;;1161               }
;;;1162               else
;;;1163               {
;;;1164                   vSetGDCLARB1(eGDC, u32Addr);
001cb8  e59f5c78          LDR      r5,|L1.10552|
001cbc  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1165                   /* Copy register data to shadow register: */
;;;1166                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB1_REG__, u32GDCLARB1_REG__Var[eGDC]);
001cc0  e7955104          LDR      r5,[r5,r4,LSL #2]
001cc4  e59f7c48          LDR      r7,|L1.10516|
001cc8  e0876604          ADD      r6,r7,r4,LSL #12
001ccc  e5865038          STR      r5,[r6,#0x38]
                  |L1.7376|
;;;1167               }
;;;1168               break;
001cd0  ea000035          B        |L1.7596|
                  |L1.7380|
;;;1169   
;;;1170           case GDC_LAYER_C:
001cd4  e320f000          NOP      
;;;1171               if( GDC_BUFF_DEFAULT == eBuff )
001cd8  e3520000          CMP      r2,#0
001cdc  1a000006          BNE      |L1.7420|
;;;1172               {
;;;1173                   vSetGDCLARC0(eGDC, u32Addr);
001ce0  e59f5c54          LDR      r5,|L1.10556|
001ce4  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1174                   /* Copy register data to shadow register: */
;;;1175                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC0_REG__, u32GDCLARC0_REG__Var[eGDC]);
001ce8  e7955104          LDR      r5,[r5,r4,LSL #2]
001cec  e59f7c20          LDR      r7,|L1.10516|
001cf0  e0876604          ADD      r6,r7,r4,LSL #12
001cf4  e5865048          STR      r5,[r6,#0x48]
001cf8  ea000005          B        |L1.7444|
                  |L1.7420|
;;;1176               }
;;;1177               else
;;;1178               {
;;;1179                   vSetGDCLARC1(eGDC, u32Addr);
001cfc  e59f5c3c          LDR      r5,|L1.10560|
001d00  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1180                   /* Copy register data to shadow register: */
;;;1181                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC1_REG__, u32GDCLARC1_REG__Var[eGDC]);
001d04  e7955104          LDR      r5,[r5,r4,LSL #2]
001d08  e59f7c04          LDR      r7,|L1.10516|
001d0c  e0876604          ADD      r6,r7,r4,LSL #12
001d10  e5865050          STR      r5,[r6,#0x50]
                  |L1.7444|
;;;1182               }
;;;1183               break;
001d14  ea000024          B        |L1.7596|
                  |L1.7448|
;;;1184   
;;;1185           case GDC_LAYER_D:
001d18  e320f000          NOP      
;;;1186               if( GDC_BUFF_DEFAULT == eBuff )
001d1c  e3520000          CMP      r2,#0
001d20  1a000006          BNE      |L1.7488|
;;;1187               {
;;;1188                   vSetGDCLARD0(eGDC, u32Addr);
001d24  e59f5c18          LDR      r5,|L1.10564|
001d28  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1189                   /* Copy register data to shadow register: */
;;;1190                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD0_REG__, u32GDCLARD0_REG__Var[eGDC]);
001d2c  e7955104          LDR      r5,[r5,r4,LSL #2]
001d30  e59f7bdc          LDR      r7,|L1.10516|
001d34  e0876604          ADD      r6,r7,r4,LSL #12
001d38  e5865058          STR      r5,[r6,#0x58]
001d3c  ea000005          B        |L1.7512|
                  |L1.7488|
;;;1191               }
;;;1192               else
;;;1193               {
;;;1194                   vSetGDCLARD1(eGDC, u32Addr);
001d40  e59f5c00          LDR      r5,|L1.10568|
001d44  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1195                   /* Copy register data to shadow register: */
;;;1196                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD1_REG__, u32GDCLARD1_REG__Var[eGDC]);
001d48  e7955104          LDR      r5,[r5,r4,LSL #2]
001d4c  e59f7bc0          LDR      r7,|L1.10516|
001d50  e0876604          ADD      r6,r7,r4,LSL #12
001d54  e5865060          STR      r5,[r6,#0x60]
                  |L1.7512|
;;;1197               }
;;;1198               break;
001d58  ea000013          B        |L1.7596|
                  |L1.7516|
;;;1199   
;;;1200           case GDC_LAYER_E:
001d5c  e320f000          NOP      
;;;1201               if( GDC_BUFF_DEFAULT == eBuff )
001d60  e3520000          CMP      r2,#0
001d64  1a000006          BNE      |L1.7556|
;;;1202               {
;;;1203                   vSetGDCLARE0(eGDC, u32Addr);
001d68  e59f5bdc          LDR      r5,|L1.10572|
001d6c  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1204                   /* Copy register data to shadow register: */
;;;1205                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE0_REG__, u32GDCLARE0_REG__Var[eGDC]);
001d70  e7955104          LDR      r5,[r5,r4,LSL #2]
001d74  e59f7b98          LDR      r7,|L1.10516|
001d78  e0876604          ADD      r6,r7,r4,LSL #12
001d7c  e5865230          STR      r5,[r6,#0x230]
001d80  ea000005          B        |L1.7580|
                  |L1.7556|
;;;1206               }
;;;1207               else
;;;1208               {
;;;1209                   vSetGDCLARE1(eGDC, u32Addr);
001d84  e59f5bc4          LDR      r5,|L1.10576|
001d88  e7853104          STR      r3,[r5,r4,LSL #2]
;;;1210                   /* Copy register data to shadow register: */
;;;1211                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE1_REG__, u32GDCLARE1_REG__Var[eGDC]);
001d8c  e7955104          LDR      r5,[r5,r4,LSL #2]
001d90  e59f7b7c          LDR      r7,|L1.10516|
001d94  e0876604          ADD      r6,r7,r4,LSL #12
001d98  e5865238          STR      r5,[r6,#0x238]
                  |L1.7580|
;;;1212               }
;;;1213               break;
001d9c  ea000002          B        |L1.7596|
                  |L1.7584|
;;;1214   
;;;1215           default:
001da0  e320f000          NOP      
;;;1216               /* Unsupported Layer */
;;;1217               i32Res = C_FAILED;
001da4  e3e00000          MVN      r0,#0
;;;1218               break;
001da8  e320f000          NOP      
                  |L1.7596|
001dac  e320f000          NOP                            ;1153
;;;1219       }
;;;1220   
;;;1221       return i32Res;
;;;1222   }
001db0  e8bd80f0          POP      {r4-r7,pc}
;;;1223   
                          ENDP

                  i32GDC_SetScrollVal PROC
;;;1225   /****************************************************************************/
;;;1226   int32_t i32GDC_SetScrollVal(gdc_ch_e eGDC, gdc_layer_e eLayer,
001db4  e92d40f0          PUSH     {r4-r7,lr}
;;;1227                               gdc_frmbuff_e eBuff, uint8_t u8ScrVal)
;;;1228   {
001db8  e1a04000          MOV      r4,r0
;;;1229       int32_t i32Res = C_SUCCESS;
001dbc  e3a00000          MOV      r0,#0
;;;1230   
;;;1231       switch( eLayer )
001dc0  e3510005          CMP      r1,#5
001dc4  308ff101          ADDCC    pc,pc,r1,LSL #2
001dc8  ea000081          B        |L1.8148|
001dcc  ea000003          B        |L1.7648|
001dd0  ea00001b          B        |L1.7748|
001dd4  ea000033          B        |L1.7848|
001dd8  ea00004b          B        |L1.7948|
001ddc  ea000063          B        |L1.8048|
                  |L1.7648|
;;;1232       {
;;;1233           case GDC_LAYER_A:
001de0  e320f000          NOP      
;;;1234               if( GDC_BUFF_DEFAULT == eBuff )
001de4  e3520000          CMP      r2,#0
001de8  1a00000a          BNE      |L1.7704|
;;;1235               {
;;;1236                   vSetGDCLARA0_SSCROLL(eGDC, u8ScrVal);
001dec  e59f5b38          LDR      r5,|L1.10540|
001df0  e7955104          LDR      r5,[r5,r4,LSL #2]
001df4  e7c25093          BFI      r5,r3,#1,#2
001df8  e59f6b2c          LDR      r6,|L1.10540|
001dfc  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1237                   /* Copy register data to shadow register: */
;;;1238                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA0_REG__, u32GDCLARA0_REG__Var[eGDC]);
001e00  e2865000          ADD      r5,r6,#0
001e04  e7955104          LDR      r5,[r5,r4,LSL #2]
001e08  e59f7b04          LDR      r7,|L1.10516|
001e0c  e0876604          ADD      r6,r7,r4,LSL #12
001e10  e5865010          STR      r5,[r6,#0x10]
001e14  ea000009          B        |L1.7744|
                  |L1.7704|
;;;1239               }
;;;1240               else
;;;1241               {
;;;1242                   vSetGDCLARA1_SSCROLL(eGDC, u8ScrVal);
001e18  e59f5b10          LDR      r5,|L1.10544|
001e1c  e7955104          LDR      r5,[r5,r4,LSL #2]
001e20  e7c25093          BFI      r5,r3,#1,#2
001e24  e59f6b04          LDR      r6,|L1.10544|
001e28  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1243                   /* Copy register data to shadow register: */
;;;1244                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA1_REG__, u32GDCLARA1_REG__Var[eGDC]);
001e2c  e2865000          ADD      r5,r6,#0
001e30  e7955104          LDR      r5,[r5,r4,LSL #2]
001e34  e59f7ad8          LDR      r7,|L1.10516|
001e38  e0876604          ADD      r6,r7,r4,LSL #12
001e3c  e5865018          STR      r5,[r6,#0x18]
                  |L1.7744|
;;;1245               }
;;;1246               break;
001e40  ea000066          B        |L1.8160|
                  |L1.7748|
;;;1247   
;;;1248           case GDC_LAYER_B:
001e44  e320f000          NOP      
;;;1249               if( GDC_BUFF_DEFAULT == eBuff )
001e48  e3520000          CMP      r2,#0
001e4c  1a00000a          BNE      |L1.7804|
;;;1250               {
;;;1251                   vSetGDCLARB0_SSCROLL(eGDC, u8ScrVal);
001e50  e59f5adc          LDR      r5,|L1.10548|
001e54  e7955104          LDR      r5,[r5,r4,LSL #2]
001e58  e7c25093          BFI      r5,r3,#1,#2
001e5c  e59f6ad0          LDR      r6,|L1.10548|
001e60  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1252                   /* Copy register data to shadow register: */
;;;1253                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB0_REG__, u32GDCLARB0_REG__Var[eGDC]);
001e64  e2865000          ADD      r5,r6,#0
001e68  e7955104          LDR      r5,[r5,r4,LSL #2]
001e6c  e59f7aa0          LDR      r7,|L1.10516|
001e70  e0876604          ADD      r6,r7,r4,LSL #12
001e74  e5865030          STR      r5,[r6,#0x30]
001e78  ea000009          B        |L1.7844|
                  |L1.7804|
;;;1254               }
;;;1255               else
;;;1256               {
;;;1257                   vSetGDCLARB1_SSCROLL(eGDC, u8ScrVal);
001e7c  e59f5ab4          LDR      r5,|L1.10552|
001e80  e7955104          LDR      r5,[r5,r4,LSL #2]
001e84  e7c25093          BFI      r5,r3,#1,#2
001e88  e59f6aa8          LDR      r6,|L1.10552|
001e8c  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1258                   /* Copy register data to shadow register: */
;;;1259                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB1_REG__, u32GDCLARB1_REG__Var[eGDC]);
001e90  e2865000          ADD      r5,r6,#0
001e94  e7955104          LDR      r5,[r5,r4,LSL #2]
001e98  e59f7a74          LDR      r7,|L1.10516|
001e9c  e0876604          ADD      r6,r7,r4,LSL #12
001ea0  e5865038          STR      r5,[r6,#0x38]
                  |L1.7844|
;;;1260               }
;;;1261               break;
001ea4  ea00004d          B        |L1.8160|
                  |L1.7848|
;;;1262   
;;;1263           case GDC_LAYER_C:
001ea8  e320f000          NOP      
;;;1264               if( GDC_BUFF_DEFAULT == eBuff )
001eac  e3520000          CMP      r2,#0
001eb0  1a00000a          BNE      |L1.7904|
;;;1265               {
;;;1266                   vSetGDCLARC0_SSCROLL(eGDC, u8ScrVal);
001eb4  e59f5a80          LDR      r5,|L1.10556|
001eb8  e7955104          LDR      r5,[r5,r4,LSL #2]
001ebc  e7c25093          BFI      r5,r3,#1,#2
001ec0  e59f6a74          LDR      r6,|L1.10556|
001ec4  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1267                   /* Copy register data to shadow register: */
;;;1268                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC0_REG__, u32GDCLARC0_REG__Var[eGDC]);
001ec8  e2865000          ADD      r5,r6,#0
001ecc  e7955104          LDR      r5,[r5,r4,LSL #2]
001ed0  e59f7a3c          LDR      r7,|L1.10516|
001ed4  e0876604          ADD      r6,r7,r4,LSL #12
001ed8  e5865048          STR      r5,[r6,#0x48]
001edc  ea000009          B        |L1.7944|
                  |L1.7904|
;;;1269               }
;;;1270               else
;;;1271               {
;;;1272                   vSetGDCLARC1_SSCROLL(eGDC, u8ScrVal);
001ee0  e59f5a58          LDR      r5,|L1.10560|
001ee4  e7955104          LDR      r5,[r5,r4,LSL #2]
001ee8  e7c25093          BFI      r5,r3,#1,#2
001eec  e59f6a4c          LDR      r6,|L1.10560|
001ef0  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1273                   /* Copy register data to shadow register: */
;;;1274                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC1_REG__, u32GDCLARC1_REG__Var[eGDC]);
001ef4  e2865000          ADD      r5,r6,#0
001ef8  e7955104          LDR      r5,[r5,r4,LSL #2]
001efc  e59f7a10          LDR      r7,|L1.10516|
001f00  e0876604          ADD      r6,r7,r4,LSL #12
001f04  e5865050          STR      r5,[r6,#0x50]
                  |L1.7944|
;;;1275               }
;;;1276               break;
001f08  ea000034          B        |L1.8160|
                  |L1.7948|
;;;1277   
;;;1278           case GDC_LAYER_D:
001f0c  e320f000          NOP      
;;;1279               if( GDC_BUFF_DEFAULT == eBuff )
001f10  e3520000          CMP      r2,#0
001f14  1a00000a          BNE      |L1.8004|
;;;1280               {
;;;1281                   vSetGDCLARD0_SSCROLL(eGDC, u8ScrVal);
001f18  e59f5a24          LDR      r5,|L1.10564|
001f1c  e7955104          LDR      r5,[r5,r4,LSL #2]
001f20  e7c25093          BFI      r5,r3,#1,#2
001f24  e59f6a18          LDR      r6,|L1.10564|
001f28  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1282                   /* Copy register data to shadow register: */
;;;1283                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD0_REG__, u32GDCLARD0_REG__Var[eGDC]);
001f2c  e2865000          ADD      r5,r6,#0
001f30  e7955104          LDR      r5,[r5,r4,LSL #2]
001f34  e59f79d8          LDR      r7,|L1.10516|
001f38  e0876604          ADD      r6,r7,r4,LSL #12
001f3c  e5865058          STR      r5,[r6,#0x58]
001f40  ea000009          B        |L1.8044|
                  |L1.8004|
;;;1284               }
;;;1285               else
;;;1286               {
;;;1287                   vSetGDCLARD1_SSCROLL(eGDC, u8ScrVal);
001f44  e59f59fc          LDR      r5,|L1.10568|
001f48  e7955104          LDR      r5,[r5,r4,LSL #2]
001f4c  e7c25093          BFI      r5,r3,#1,#2
001f50  e59f69f0          LDR      r6,|L1.10568|
001f54  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1288                   /* Copy register data to shadow register: */
;;;1289                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD1_REG__, u32GDCLARD1_REG__Var[eGDC]);
001f58  e2865000          ADD      r5,r6,#0
001f5c  e7955104          LDR      r5,[r5,r4,LSL #2]
001f60  e59f79ac          LDR      r7,|L1.10516|
001f64  e0876604          ADD      r6,r7,r4,LSL #12
001f68  e5865060          STR      r5,[r6,#0x60]
                  |L1.8044|
;;;1290               }
;;;1291               break;
001f6c  ea00001b          B        |L1.8160|
                  |L1.8048|
;;;1292   
;;;1293           case GDC_LAYER_E:
001f70  e320f000          NOP      
;;;1294               if( GDC_BUFF_DEFAULT == eBuff )
001f74  e3520000          CMP      r2,#0
001f78  1a00000a          BNE      |L1.8104|
;;;1295               {
;;;1296                   vSetGDCLARE0_SSCROLL(eGDC, u8ScrVal);
001f7c  e59f59c8          LDR      r5,|L1.10572|
001f80  e7955104          LDR      r5,[r5,r4,LSL #2]
001f84  e7c25093          BFI      r5,r3,#1,#2
001f88  e59f69bc          LDR      r6,|L1.10572|
001f8c  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1297                   /* Copy register data to shadow register: */
;;;1298                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE0_REG__, u32GDCLARE0_REG__Var[eGDC]);
001f90  e2865000          ADD      r5,r6,#0
001f94  e7955104          LDR      r5,[r5,r4,LSL #2]
001f98  e59f7974          LDR      r7,|L1.10516|
001f9c  e0876604          ADD      r6,r7,r4,LSL #12
001fa0  e5865230          STR      r5,[r6,#0x230]
001fa4  ea000009          B        |L1.8144|
                  |L1.8104|
;;;1299               }
;;;1300               else
;;;1301               {
;;;1302                   vSetGDCLARE1_SSCROLL(eGDC, u8ScrVal);
001fa8  e59f59a0          LDR      r5,|L1.10576|
001fac  e7955104          LDR      r5,[r5,r4,LSL #2]
001fb0  e7c25093          BFI      r5,r3,#1,#2
001fb4  e59f6994          LDR      r6,|L1.10576|
001fb8  e7865104          STR      r5,[r6,r4,LSL #2]
;;;1303                   /* Copy register data to shadow register: */
;;;1304                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE1_REG__, u32GDCLARE1_REG__Var[eGDC]);
001fbc  e2865000          ADD      r5,r6,#0
001fc0  e7955104          LDR      r5,[r5,r4,LSL #2]
001fc4  e59f7948          LDR      r7,|L1.10516|
001fc8  e0876604          ADD      r6,r7,r4,LSL #12
001fcc  e5865238          STR      r5,[r6,#0x238]
                  |L1.8144|
;;;1305               }
;;;1306               break;
001fd0  ea000002          B        |L1.8160|
                  |L1.8148|
;;;1307   
;;;1308           default:
001fd4  e320f000          NOP      
;;;1309               /* Unsupported Layer */
;;;1310               i32Res = C_FAILED;
001fd8  e3e00000          MVN      r0,#0
;;;1311               break;
001fdc  e320f000          NOP      
                  |L1.8160|
001fe0  e320f000          NOP                            ;1246
;;;1312       }
;;;1313   
;;;1314       return i32Res;
;;;1315   }
001fe4  e8bd80f0          POP      {r4-r7,pc}
;;;1316   
                          ENDP

                  vGDC_SetStartAddrCapture PROC
;;;1318   /****************************************************************************/
;;;1319   void vGDC_SetStartAddrCapture(gdc_ch_e eGDC, gdc_cbuff_e eBuff, uint32_t u32Addr)
001fe8  e92d4030          PUSH     {r4,r5,lr}
;;;1320   {
;;;1321       switch( eBuff )
001fec  e3510000          CMP      r1,#0
001ff0  0a000004          BEQ      |L1.8200|
001ff4  e3510001          CMP      r1,#1
001ff8  0a00000c          BEQ      |L1.8240|
001ffc  e3510002          CMP      r1,#2
002000  1a00001e          BNE      |L1.8320|
002004  ea000013          B        |L1.8280|
                  |L1.8200|
;;;1322       {
;;;1323           case GDC_CBUFF1:
002008  e320f000          NOP      
;;;1324               vSetGDCCBAR0(eGDC, (u32Addr & GDC_CBARX_MASK));
00200c  e3c23007          BIC      r3,r2,#7
002010  e59f493c          LDR      r4,|L1.10580|
002014  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1325               /* Copy register data to shadow register: */
;;;1326               UPDATE_REGISTER_LOW_WORD(eGDC, GDCCBAR0_REG__, u32GDCCBAR0_REG__Var[eGDC]);
002018  e2843000          ADD      r3,r4,#0
00201c  e7933100          LDR      r3,[r3,r0,LSL #2]
002020  e59f58ec          LDR      r5,|L1.10516|
002024  e0854600          ADD      r4,r5,r0,LSL #12
002028  e5843128          STR      r3,[r4,#0x128]
;;;1327               break;
00202c  ea000015          B        |L1.8328|
                  |L1.8240|
;;;1328   
;;;1329           case GDC_CBUFF2:
002030  e320f000          NOP      
;;;1330               vSetGDCCBAR1(eGDC, (u32Addr & GDC_CBARX_MASK));
002034  e3c23007          BIC      r3,r2,#7
002038  e59f4918          LDR      r4,|L1.10584|
00203c  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1331               /* Copy register data to shadow register: */
;;;1332               UPDATE_REGISTER_LOW_WORD(eGDC, GDCCBAR1_REG__, u32GDCCBAR1_REG__Var[eGDC]);
002040  e2843000          ADD      r3,r4,#0
002044  e7933100          LDR      r3,[r3,r0,LSL #2]
002048  e59f58c4          LDR      r5,|L1.10516|
00204c  e0854600          ADD      r4,r5,r0,LSL #12
002050  e5843130          STR      r3,[r4,#0x130]
;;;1333               break;
002054  ea00000b          B        |L1.8328|
                  |L1.8280|
;;;1334   
;;;1335           case GDC_CBUFF3:
002058  e320f000          NOP      
;;;1336               vSetGDCCBAR2(eGDC, (u32Addr & GDC_CBARX_MASK));
00205c  e3c23007          BIC      r3,r2,#7
002060  e59f48f4          LDR      r4,|L1.10588|
002064  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1337               /* Copy register data to shadow register: */
;;;1338               UPDATE_REGISTER_LOW_WORD(eGDC, GDCCBAR2_REG__, u32GDCCBAR2_REG__Var[eGDC]);
002068  e2843000          ADD      r3,r4,#0
00206c  e7933100          LDR      r3,[r3,r0,LSL #2]
002070  e59f589c          LDR      r5,|L1.10516|
002074  e0854600          ADD      r4,r5,r0,LSL #12
002078  e5843138          STR      r3,[r4,#0x138]
;;;1339               break;
00207c  ea000001          B        |L1.8328|
                  |L1.8320|
;;;1340   
;;;1341           default:
002080  e320f000          NOP      
;;;1342               break;
002084  e320f000          NOP      
                  |L1.8328|
002088  e320f000          NOP                            ;1327
;;;1343       }
;;;1344   }
00208c  e8bd8030          POP      {r4,r5,pc}
;;;1345   
                          ENDP

                  vGDC_InitCorrClut PROC
;;;1347   /****************************************************************************/
;;;1348   void vGDC_InitCorrClut(gdc_ch_e eGDC, gdc_clut_e eClut, const uint8_t* pu8Data)
002090  e92d4070          PUSH     {r4-r6,lr}
;;;1349   {
002094  e1a03000          MOV      r3,r0
;;;1350   
;;;1351       uint32_t u32Cnt;
;;;1352       
;;;1353       /* check pointer: */
;;;1354       if (0x00 != pu8Data)
002098  e3520000          CMP      r2,#0
00209c  0a00002d          BEQ      |L1.8536|
;;;1355       {
;;;1356           switch (eClut)
0020a0  e3510000          CMP      r1,#0
0020a4  0a000004          BEQ      |L1.8380|
0020a8  e3510001          CMP      r1,#1
0020ac  0a00000e          BEQ      |L1.8428|
0020b0  e3510002          CMP      r1,#2
0020b4  1a000024          BNE      |L1.8524|
0020b8  ea000017          B        |L1.8476|
                  |L1.8380|
;;;1357           {
;;;1358               case  GDC_CLUT_RED:
0020bc  e320f000          NOP      
;;;1359                   for(u32Cnt = 0; u32Cnt < GDC_CLUTSIZE_CORR; u32Cnt++)
0020c0  e3a00000          MOV      r0,#0
0020c4  ea000005          B        |L1.8416|
                  |L1.8392|
;;;1360                   {
;;;1361                       vSetGDCCCLUTR(eGDC, u32Cnt, pu8Data[u32Cnt]);
0020c8  e7d25000          LDRB     r5,[r2,r0]
0020cc  e59f488c          LDR      r4,|L1.10592|
0020d0  e0846603          ADD      r6,r4,r3,LSL #12
0020d4  e6ff4070          UXTH     r4,r0
0020d8  e7c65104          STRB     r5,[r6,r4,LSL #2]
0020dc  e2800001          ADD      r0,r0,#1              ;1359
                  |L1.8416|
0020e0  e3500c01          CMP      r0,#0x100             ;1359
0020e4  3afffff7          BCC      |L1.8392|
;;;1362                   }
;;;1363                   break;
0020e8  ea000019          B        |L1.8532|
                  |L1.8428|
;;;1364               case  GDC_CLUT_GREEN:
0020ec  e320f000          NOP      
;;;1365                   for(u32Cnt = 0; u32Cnt < GDC_CLUTSIZE_CORR; u32Cnt++)
0020f0  e3a00000          MOV      r0,#0
0020f4  ea000005          B        |L1.8464|
                  |L1.8440|
;;;1366                   {
;;;1367                       vSetGDCCCLUTG(eGDC, u32Cnt, pu8Data[u32Cnt]);
0020f8  e7d25000          LDRB     r5,[r2,r0]
0020fc  e59f4860          LDR      r4,|L1.10596|
002100  e0846603          ADD      r6,r4,r3,LSL #12
002104  e6ff4070          UXTH     r4,r0
002108  e7c65104          STRB     r5,[r6,r4,LSL #2]
00210c  e2800001          ADD      r0,r0,#1              ;1365
                  |L1.8464|
002110  e3500c01          CMP      r0,#0x100             ;1365
002114  3afffff7          BCC      |L1.8440|
;;;1368                   }
;;;1369                   break;
002118  ea00000d          B        |L1.8532|
                  |L1.8476|
;;;1370               case  GDC_CLUT_BLUE:
00211c  e320f000          NOP      
;;;1371                   for(u32Cnt = 0; u32Cnt < GDC_CLUTSIZE_CORR; u32Cnt++)
002120  e3a00000          MOV      r0,#0
002124  ea000005          B        |L1.8512|
                  |L1.8488|
;;;1372                   {
;;;1373                       vSetGDCCCLUTB(eGDC, u32Cnt, pu8Data[u32Cnt]);
002128  e7d25000          LDRB     r5,[r2,r0]
00212c  e59f4834          LDR      r4,|L1.10600|
002130  e0846603          ADD      r6,r4,r3,LSL #12
002134  e6ff4070          UXTH     r4,r0
002138  e7c65104          STRB     r5,[r6,r4,LSL #2]
00213c  e2800001          ADD      r0,r0,#1              ;1371
                  |L1.8512|
002140  e3500c01          CMP      r0,#0x100             ;1371
002144  3afffff7          BCC      |L1.8488|
;;;1374                   }
;;;1375                   break;
002148  ea000001          B        |L1.8532|
                  |L1.8524|
;;;1376               default:
00214c  e320f000          NOP      
;;;1377                   break;
002150  e320f000          NOP      
                  |L1.8532|
002154  e320f000          NOP                            ;1363
                  |L1.8536|
;;;1378           }
;;;1379       }
;;;1380   
;;;1381   }
002158  e8bd8070          POP      {r4-r6,pc}
;;;1382   
                          ENDP

                  vGDC_SetSelectCorrCompVal PROC
;;;1384   /****************************************************************************/
;;;1385   void vGDC_SetSelectCorrCompVal(gdc_ch_e eGDC,  gdc_cmp_e eSelection, uint32_t u32CorrCompVal)
00215c  e92d4030          PUSH     {r4,r5,lr}
;;;1386   {
;;;1387       switch( eSelection )
002160  e3510008          CMP      r1,#8
002164  308ff101          ADDCC    pc,pc,r1,LSL #2
002168  ea00007f          B        |L1.9068|
00216c  ea000006          B        |L1.8588|
002170  ea000014          B        |L1.8648|
002174  ea000022          B        |L1.8708|
002178  ea000030          B        |L1.8768|
00217c  ea00003e          B        |L1.8828|
002180  ea00004c          B        |L1.8888|
002184  ea00005a          B        |L1.8948|
002188  ea000068          B        |L1.9008|
                  |L1.8588|
;;;1388       {
;;;1389           /* Data from register: GDCSCVRA_REG__: */
;;;1390           case GDC_CCVAL0:  
00218c  e320f000          NOP      
;;;1391               vSetGDCSCVRA_CCV0(eGDC, u32CorrCompVal);
002190  e59f37d4          LDR      r3,|L1.10604|
002194  e0833180          ADD      r3,r3,r0,LSL #3
002198  e1c340d0          LDRD     r4,r5,[r3,#0]
00219c  e7d74012          BFI      r4,r2,#0,#24
0021a0  e59f37c4          LDR      r3,|L1.10604|
0021a4  e0833180          ADD      r3,r3,r0,LSL #3
0021a8  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1392               /* CCV0: belongs to low word of register: */
;;;1393               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
0021ac  e59f37b8          LDR      r3,|L1.10604|
0021b0  e0833180          ADD      r3,r3,r0,LSL #3
0021b4  e1c340d0          LDRD     r4,r5,[r3,#0]
0021b8  e59f5754          LDR      r5,|L1.10516|
0021bc  e0853600          ADD      r3,r5,r0,LSL #12
0021c0  e5834288          STR      r4,[r3,#0x288]
;;;1394               break;
0021c4  ea00006a          B        |L1.9076|
                  |L1.8648|
;;;1395               
;;;1396           case GDC_CCVAL1:
0021c8  e320f000          NOP      
;;;1397               vSetGDCSCVRA_CCV1(eGDC, u32CorrCompVal);
0021cc  e59f3798          LDR      r3,|L1.10604|
0021d0  e0833180          ADD      r3,r3,r0,LSL #3
0021d4  e1c340d0          LDRD     r4,r5,[r3,#0]
0021d8  e7d75012          BFI      r5,r2,#0,#24
0021dc  e59f3788          LDR      r3,|L1.10604|
0021e0  e0833180          ADD      r3,r3,r0,LSL #3
0021e4  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1398               /* CCV1: belongs to high word of register: */
;;;1399               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
0021e8  e59f377c          LDR      r3,|L1.10604|
0021ec  e0833180          ADD      r3,r3,r0,LSL #3
0021f0  e1c340d0          LDRD     r4,r5,[r3,#0]
0021f4  e59f3774          LDR      r3,|L1.10608|
0021f8  e0833600          ADD      r3,r3,r0,LSL #12
0021fc  e5835004          STR      r5,[r3,#4]
;;;1400               break;
002200  ea00005b          B        |L1.9076|
                  |L1.8708|
;;;1401               
;;;1402           /* Data from register: GDCSCVRB_REG__*/
;;;1403           case GDC_CCVAL2:
002204  e320f000          NOP      
;;;1404               vSetGDCSCVRB_CCV2(eGDC, u32CorrCompVal);
002208  e59f3764          LDR      r3,|L1.10612|
00220c  e0833180          ADD      r3,r3,r0,LSL #3
002210  e1c340d0          LDRD     r4,r5,[r3,#0]
002214  e7d74012          BFI      r4,r2,#0,#24
002218  e59f3754          LDR      r3,|L1.10612|
00221c  e0833180          ADD      r3,r3,r0,LSL #3
002220  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1405               /* CCV2: belongs to low word of register: */
;;;1406               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
002224  e59f3748          LDR      r3,|L1.10612|
002228  e0833180          ADD      r3,r3,r0,LSL #3
00222c  e1c340d0          LDRD     r4,r5,[r3,#0]
002230  e59f56dc          LDR      r5,|L1.10516|
002234  e0853600          ADD      r3,r5,r0,LSL #12
002238  e5834290          STR      r4,[r3,#0x290]
;;;1407               break;
00223c  ea00004c          B        |L1.9076|
                  |L1.8768|
;;;1408               
;;;1409           case GDC_CCVAL3:
002240  e320f000          NOP      
;;;1410               vSetGDCSCVRB_CCV3(eGDC, u32CorrCompVal);
002244  e59f3728          LDR      r3,|L1.10612|
002248  e0833180          ADD      r3,r3,r0,LSL #3
00224c  e1c340d0          LDRD     r4,r5,[r3,#0]
002250  e7d75012          BFI      r5,r2,#0,#24
002254  e59f3718          LDR      r3,|L1.10612|
002258  e0833180          ADD      r3,r3,r0,LSL #3
00225c  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1411               /* CCV3: belongs to high word of register: */
;;;1412               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
002260  e59f370c          LDR      r3,|L1.10612|
002264  e0833180          ADD      r3,r3,r0,LSL #3
002268  e1c340d0          LDRD     r4,r5,[r3,#0]
00226c  e59f3704          LDR      r3,|L1.10616|
002270  e0833600          ADD      r3,r3,r0,LSL #12
002274  e5835004          STR      r5,[r3,#4]
;;;1413               break;
002278  ea00003d          B        |L1.9076|
                  |L1.8828|
;;;1414               
;;;1415           /* Data from register: GDCSCVRC_REG__*/
;;;1416           case GDC_CCVAL4:
00227c  e320f000          NOP      
;;;1417               vSetGDCSCVRC_CCV4(eGDC, u32CorrCompVal);
002280  e59f36f4          LDR      r3,|L1.10620|
002284  e0833180          ADD      r3,r3,r0,LSL #3
002288  e1c340d0          LDRD     r4,r5,[r3,#0]
00228c  e7d74012          BFI      r4,r2,#0,#24
002290  e59f36e4          LDR      r3,|L1.10620|
002294  e0833180          ADD      r3,r3,r0,LSL #3
002298  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1418               /* CCV4: belongs to low word of register: */
;;;1419               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
00229c  e59f36d8          LDR      r3,|L1.10620|
0022a0  e0833180          ADD      r3,r3,r0,LSL #3
0022a4  e1c340d0          LDRD     r4,r5,[r3,#0]
0022a8  e59f5664          LDR      r5,|L1.10516|
0022ac  e0853600          ADD      r3,r5,r0,LSL #12
0022b0  e5834298          STR      r4,[r3,#0x298]
;;;1420               break;
0022b4  ea00002e          B        |L1.9076|
                  |L1.8888|
;;;1421               
;;;1422           case GDC_CCVAL5:
0022b8  e320f000          NOP      
;;;1423               vSetGDCSCVRC_CCV5(eGDC, u32CorrCompVal);
0022bc  e59f36b8          LDR      r3,|L1.10620|
0022c0  e0833180          ADD      r3,r3,r0,LSL #3
0022c4  e1c340d0          LDRD     r4,r5,[r3,#0]
0022c8  e7d75012          BFI      r5,r2,#0,#24
0022cc  e59f36a8          LDR      r3,|L1.10620|
0022d0  e0833180          ADD      r3,r3,r0,LSL #3
0022d4  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1424               /* CCV5: belongs to high word of register: */
;;;1425               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
0022d8  e59f369c          LDR      r3,|L1.10620|
0022dc  e0833180          ADD      r3,r3,r0,LSL #3
0022e0  e1c340d0          LDRD     r4,r5,[r3,#0]
0022e4  e59f3694          LDR      r3,|L1.10624|
0022e8  e0833600          ADD      r3,r3,r0,LSL #12
0022ec  e5835004          STR      r5,[r3,#4]
;;;1426               break;
0022f0  ea00001f          B        |L1.9076|
                  |L1.8948|
;;;1427               
;;;1428           /* Data from register: GDCSCVRD_REG__*/            
;;;1429           case GDC_CCVAL6:
0022f4  e320f000          NOP      
;;;1430               vSetGDCSCVRD_CCV6(eGDC, u32CorrCompVal);
0022f8  e59f3684          LDR      r3,|L1.10628|
0022fc  e0833180          ADD      r3,r3,r0,LSL #3
002300  e1c340d0          LDRD     r4,r5,[r3,#0]
002304  e7d74012          BFI      r4,r2,#0,#24
002308  e59f3674          LDR      r3,|L1.10628|
00230c  e0833180          ADD      r3,r3,r0,LSL #3
002310  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1431               /* CCV6: belongs to low word of register: */
;;;1432               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
002314  e59f3668          LDR      r3,|L1.10628|
002318  e0833180          ADD      r3,r3,r0,LSL #3
00231c  e1c340d0          LDRD     r4,r5,[r3,#0]
002320  e59f55ec          LDR      r5,|L1.10516|
002324  e0853600          ADD      r3,r5,r0,LSL #12
002328  e58342a0          STR      r4,[r3,#0x2a0]
;;;1433               break;
00232c  ea000010          B        |L1.9076|
                  |L1.9008|
;;;1434               
;;;1435           case GDC_CCVAL7:
002330  e320f000          NOP      
;;;1436               vSetGDCSCVRD_CCV7(eGDC, u32CorrCompVal);
002334  e59f3648          LDR      r3,|L1.10628|
002338  e0833180          ADD      r3,r3,r0,LSL #3
00233c  e1c340d0          LDRD     r4,r5,[r3,#0]
002340  e7d75012          BFI      r5,r2,#0,#24
002344  e59f3638          LDR      r3,|L1.10628|
002348  e0833180          ADD      r3,r3,r0,LSL #3
00234c  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1437               /* CCV7: belongs to high word of register: */
;;;1438               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
002350  e59f362c          LDR      r3,|L1.10628|
002354  e0833180          ADD      r3,r3,r0,LSL #3
002358  e1c340d0          LDRD     r4,r5,[r3,#0]
00235c  e59f3624          LDR      r3,|L1.10632|
002360  e0833600          ADD      r3,r3,r0,LSL #12
002364  e5835004          STR      r5,[r3,#4]
;;;1439               break;
002368  ea000001          B        |L1.9076|
                  |L1.9068|
;;;1440               
;;;1441           default:
00236c  e320f000          NOP      
;;;1442               break;
002370  e320f000          NOP      
                  |L1.9076|
002374  e320f000          NOP                            ;1394
;;;1443       }
;;;1444       return;
;;;1445   }
002378  e8bd8030          POP      {r4,r5,pc}
;;;1446   
                          ENDP

                  vGDC_ActivateCorrCompVal PROC
;;;1448   /****************************************************************************/
;;;1449   void  vGDC_ActivateCorrCompVal(gdc_ch_e eGDC, gdc_cmp_e eSelection, gdc_active_e eActive)
00237c  e92d4030          PUSH     {r4,r5,lr}
;;;1450   {
;;;1451       switch( eSelection )
002380  e3510008          CMP      r1,#8
002384  308ff101          ADDCC    pc,pc,r1,LSL #2
002388  ea00007f          B        |L1.9612|
00238c  ea000006          B        |L1.9132|
002390  ea000014          B        |L1.9192|
002394  ea000022          B        |L1.9252|
002398  ea000030          B        |L1.9312|
00239c  ea00003e          B        |L1.9372|
0023a0  ea00004c          B        |L1.9432|
0023a4  ea00005a          B        |L1.9492|
0023a8  ea000068          B        |L1.9552|
                  |L1.9132|
;;;1452       {
;;;1453           /* Data from register: GDCSCVRA_REG__: */
;;;1454           case GDC_CCVAL0:  
0023ac  e320f000          NOP      
;;;1455               vSetGDCSCVRA_ACT0(eGDC, eActive);
0023b0  e59f35b4          LDR      r3,|L1.10604|
0023b4  e0833180          ADD      r3,r3,r0,LSL #3
0023b8  e1c340d0          LDRD     r4,r5,[r3,#0]
0023bc  e7df4f92          BFI      r4,r2,#31,#1
0023c0  e59f35a4          LDR      r3,|L1.10604|
0023c4  e0833180          ADD      r3,r3,r0,LSL #3
0023c8  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1456               /* CCVAL0: belongs to low word of register: */
;;;1457               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
0023cc  e59f3598          LDR      r3,|L1.10604|
0023d0  e0833180          ADD      r3,r3,r0,LSL #3
0023d4  e1c340d0          LDRD     r4,r5,[r3,#0]
0023d8  e59f5534          LDR      r5,|L1.10516|
0023dc  e0853600          ADD      r3,r5,r0,LSL #12
0023e0  e5834288          STR      r4,[r3,#0x288]
;;;1458               break;
0023e4  ea00006a          B        |L1.9620|
                  |L1.9192|
;;;1459               
;;;1460           case GDC_CCVAL1:
0023e8  e320f000          NOP      
;;;1461               vSetGDCSCVRA_ACT1(eGDC, eActive);
0023ec  e59f3578          LDR      r3,|L1.10604|
0023f0  e0833180          ADD      r3,r3,r0,LSL #3
0023f4  e1c340d0          LDRD     r4,r5,[r3,#0]
0023f8  e7df5f92          BFI      r5,r2,#31,#1
0023fc  e59f3568          LDR      r3,|L1.10604|
002400  e0833180          ADD      r3,r3,r0,LSL #3
002404  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1462               /* CCVAL1: belongs to high word of register: */
;;;1463               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
002408  e59f355c          LDR      r3,|L1.10604|
00240c  e0833180          ADD      r3,r3,r0,LSL #3
002410  e1c340d0          LDRD     r4,r5,[r3,#0]
002414  e59f3554          LDR      r3,|L1.10608|
002418  e0833600          ADD      r3,r3,r0,LSL #12
00241c  e5835004          STR      r5,[r3,#4]
;;;1464               break;
002420  ea00005b          B        |L1.9620|
                  |L1.9252|
;;;1465               
;;;1466           /* Data from register: GDCSCVRB_REG__*/
;;;1467           case GDC_CCVAL2:
002424  e320f000          NOP      
;;;1468               vSetGDCSCVRB_ACT2(eGDC, eActive);
002428  e59f3544          LDR      r3,|L1.10612|
00242c  e0833180          ADD      r3,r3,r0,LSL #3
002430  e1c340d0          LDRD     r4,r5,[r3,#0]
002434  e7df4f92          BFI      r4,r2,#31,#1
002438  e59f3534          LDR      r3,|L1.10612|
00243c  e0833180          ADD      r3,r3,r0,LSL #3
002440  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1469               /* CCVAL2: belongs to low word of register: */
;;;1470               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
002444  e59f3528          LDR      r3,|L1.10612|
002448  e0833180          ADD      r3,r3,r0,LSL #3
00244c  e1c340d0          LDRD     r4,r5,[r3,#0]
002450  e59f54bc          LDR      r5,|L1.10516|
002454  e0853600          ADD      r3,r5,r0,LSL #12
002458  e5834290          STR      r4,[r3,#0x290]
;;;1471               break;
00245c  ea00004c          B        |L1.9620|
                  |L1.9312|
;;;1472               
;;;1473           case GDC_CCVAL3:
002460  e320f000          NOP      
;;;1474               vSetGDCSCVRB_ACT3(eGDC, eActive);
002464  e59f3508          LDR      r3,|L1.10612|
002468  e0833180          ADD      r3,r3,r0,LSL #3
00246c  e1c340d0          LDRD     r4,r5,[r3,#0]
002470  e7df5f92          BFI      r5,r2,#31,#1
002474  e59f34f8          LDR      r3,|L1.10612|
002478  e0833180          ADD      r3,r3,r0,LSL #3
00247c  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1475               /* CCVAL3: belongs to high word of register: */
;;;1476               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
002480  e59f34ec          LDR      r3,|L1.10612|
002484  e0833180          ADD      r3,r3,r0,LSL #3
002488  e1c340d0          LDRD     r4,r5,[r3,#0]
00248c  e59f34e4          LDR      r3,|L1.10616|
002490  e0833600          ADD      r3,r3,r0,LSL #12
002494  e5835004          STR      r5,[r3,#4]
;;;1477               break;
002498  ea00003d          B        |L1.9620|
                  |L1.9372|
;;;1478               
;;;1479           /* Data from register: GDCSCVRC_REG__*/
;;;1480           case GDC_CCVAL4:
00249c  e320f000          NOP      
;;;1481               vSetGDCSCVRC_ACT4(eGDC, eActive);
0024a0  e59f34d4          LDR      r3,|L1.10620|
0024a4  e0833180          ADD      r3,r3,r0,LSL #3
0024a8  e1c340d0          LDRD     r4,r5,[r3,#0]
0024ac  e7df4f92          BFI      r4,r2,#31,#1
0024b0  e59f34c4          LDR      r3,|L1.10620|
0024b4  e0833180          ADD      r3,r3,r0,LSL #3
0024b8  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1482               /* CCVAL4: belongs to low word of register: */
;;;1483               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
0024bc  e59f34b8          LDR      r3,|L1.10620|
0024c0  e0833180          ADD      r3,r3,r0,LSL #3
0024c4  e1c340d0          LDRD     r4,r5,[r3,#0]
0024c8  e59f5444          LDR      r5,|L1.10516|
0024cc  e0853600          ADD      r3,r5,r0,LSL #12
0024d0  e5834298          STR      r4,[r3,#0x298]
;;;1484               break;
0024d4  ea00002e          B        |L1.9620|
                  |L1.9432|
;;;1485               
;;;1486           case GDC_CCVAL5:
0024d8  e320f000          NOP      
;;;1487               vSetGDCSCVRC_ACT5(eGDC, eActive);
0024dc  e59f3498          LDR      r3,|L1.10620|
0024e0  e0833180          ADD      r3,r3,r0,LSL #3
0024e4  e1c340d0          LDRD     r4,r5,[r3,#0]
0024e8  e7df5f92          BFI      r5,r2,#31,#1
0024ec  e59f3488          LDR      r3,|L1.10620|
0024f0  e0833180          ADD      r3,r3,r0,LSL #3
0024f4  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1488               /* CCV5: belongs to high word of register: */
;;;1489               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
0024f8  e59f347c          LDR      r3,|L1.10620|
0024fc  e0833180          ADD      r3,r3,r0,LSL #3
002500  e1c340d0          LDRD     r4,r5,[r3,#0]
002504  e59f3474          LDR      r3,|L1.10624|
002508  e0833600          ADD      r3,r3,r0,LSL #12
00250c  e5835004          STR      r5,[r3,#4]
;;;1490               break;
002510  ea00001f          B        |L1.9620|
                  |L1.9492|
;;;1491               
;;;1492           /* Data from register: GDCSCVRD_REG__*/
;;;1493           case GDC_CCVAL6:
002514  e320f000          NOP      
;;;1494               vSetGDCSCVRD_ACT6(eGDC, eActive);
002518  e59f3464          LDR      r3,|L1.10628|
00251c  e0833180          ADD      r3,r3,r0,LSL #3
002520  e1c340d0          LDRD     r4,r5,[r3,#0]
002524  e7df4f92          BFI      r4,r2,#31,#1
002528  e59f3454          LDR      r3,|L1.10628|
00252c  e0833180          ADD      r3,r3,r0,LSL #3
002530  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1495               /* CCVAL5: belongs to low word of register: */
;;;1496               UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
002534  e59f3448          LDR      r3,|L1.10628|
002538  e0833180          ADD      r3,r3,r0,LSL #3
00253c  e1c340d0          LDRD     r4,r5,[r3,#0]
002540  e59f53cc          LDR      r5,|L1.10516|
002544  e0853600          ADD      r3,r5,r0,LSL #12
002548  e58342a0          STR      r4,[r3,#0x2a0]
;;;1497               break;
00254c  ea000010          B        |L1.9620|
                  |L1.9552|
;;;1498               
;;;1499           case GDC_CCVAL7:
002550  e320f000          NOP      
;;;1500               vSetGDCSCVRD_ACT7(eGDC, eActive);
002554  e59f3428          LDR      r3,|L1.10628|
002558  e0833180          ADD      r3,r3,r0,LSL #3
00255c  e1c340d0          LDRD     r4,r5,[r3,#0]
002560  e7df5f92          BFI      r5,r2,#31,#1
002564  e59f3418          LDR      r3,|L1.10628|
002568  e0833180          ADD      r3,r3,r0,LSL #3
00256c  e1c340f0          STRD     r4,r5,[r3,#0]
;;;1501               /* CCVAL6: belongs to high word of register: */
;;;1502               UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
002570  e59f340c          LDR      r3,|L1.10628|
002574  e0833180          ADD      r3,r3,r0,LSL #3
002578  e1c340d0          LDRD     r4,r5,[r3,#0]
00257c  e59f3404          LDR      r3,|L1.10632|
002580  e0833600          ADD      r3,r3,r0,LSL #12
002584  e5835004          STR      r5,[r3,#4]
;;;1503               break;
002588  ea000001          B        |L1.9620|
                  |L1.9612|
;;;1504   
;;;1505           default:
00258c  e320f000          NOP      
;;;1506               break;
002590  e320f000          NOP      
                  |L1.9620|
002594  e320f000          NOP                            ;1458
;;;1507       }
;;;1508   }
002598  e8bd8030          POP      {r4,r5,pc}
;;;1509   
                          ENDP

                  vGDC_EnableSelectiveCorr PROC
;;;1511   /****************************************************************************/
;;;1512   void vGDC_EnableSelectiveCorr(gdc_ch_e eGDC, gdc_en_e eEn, gdc_ccmode_e eMode)
00259c  e92d4070          PUSH     {r4-r6,lr}
;;;1513   {
0025a0  e1a04000          MOV      r4,r0
0025a4  e1a05001          MOV      r5,r1
0025a8  e1a06002          MOV      r6,r2
;;;1514       vSetGDCDCR_SCCM(eGDC, eMode);
0025ac  e59f03d8          LDR      r0,|L1.10636|
0025b0  e0800184          ADD      r0,r0,r4,LSL #3
0025b4  e1c000d0          LDRD     r0,r1,[r0,#0]
0025b8  e7ca1516          BFI      r1,r6,#10,#1
0025bc  e59f23c8          LDR      r2,|L1.10636|
0025c0  e0822184          ADD      r2,r2,r4,LSL #3
0025c4  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1515       vSetGDCDCR_SCCEN(eGDC, eEn);
0025c8  e59f03bc          LDR      r0,|L1.10636|
0025cc  e0800184          ADD      r0,r0,r4,LSL #3
0025d0  e1c000d0          LDRD     r0,r1,[r0,#0]
0025d4  e7c91495          BFI      r1,r5,#9,#1
0025d8  e59f23ac          LDR      r2,|L1.10636|
0025dc  e0822184          ADD      r2,r2,r4,LSL #3
0025e0  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1516       /* SCCM and SCCEN: belong to high word of register: */
;;;1517       /* GDCDCR register should be updated special: */  
;;;1518       vUpdateDCR_HighWord_Special(eGDC);
0025e4  e1a00004          MOV      r0,r4
0025e8  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;1519   }
0025ec  e8bd8070          POP      {r4-r6,pc}
;;;1520   
                          ENDP

                  i32GDC_SetDisplayStart PROC
;;;1522   /****************************************************************************/
;;;1523   int32_t i32GDC_SetDisplayStart(gdc_ch_e eGDC, uint16_t u16HStart, uint16_t u16VStart)
0025f0  e92d40f0          PUSH     {r4-r7,lr}
;;;1524   {
0025f4  e1a03000          MOV      r3,r0
;;;1525       uint32_t u32Val;
;;;1526       int32_t i32Res = C_SUCCESS;
0025f8  e3a00000          MOV      r0,#0
;;;1527       
;;;1528       if ( (u16HStart<GDC_DISP_HSTART_MIN)  || (u16HStart>GDC_DISP_HSTART_MAX) || 
0025fc  e3510040          CMP      r1,#0x40
002600  3a000005          BCC      |L1.9756|
002604  e3510b02          CMP      r1,#0x800
002608  2a000003          BCS      |L1.9756|
;;;1529             (u16VStart<GDC_DISP_VSTART_MIN) || (u16VStart>GDC_DISP_VSTART_MAX) )
00260c  e3520040          CMP      r2,#0x40
002610  3a000001          BCC      |L1.9756|
002614  e3520b01          CMP      r2,#0x400
002618  3a000001          BCC      |L1.9764|
                  |L1.9756|
;;;1530       {
;;;1531           i32Res = C_FAILED;
00261c  e3e00000          MVN      r0,#0
002620  ea00000a          B        |L1.9808|
                  |L1.9764|
002624  e1a05002          MOV      r5,r2
;;;1532       }
;;;1533       else
;;;1534       {
;;;1535           /* Compose the entire register value */
;;;1536           u32Val = (((uint32_t) (u16HStart & GDC_11_BIT_MASK)) << 16) | (u16VStart & GDC_10_BIT_MASK);
002628  e7df551f          BFC      r5,#10,#22
00262c  e1a06001          MOV      r6,r1
002630  e7df659f          BFC      r6,#11,#21
002634  e1854806          ORR      r4,r5,r6,LSL #16
;;;1537   
;;;1538           /* Set */
;;;1539           vSetGDCDSR(eGDC, u32Val);
002638  e59f5350          LDR      r5,|L1.10640|
00263c  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1540           /* DVS and DHS : belong to low word of register: */
;;;1541           UPDATE_REGISTER_LOW_WORD(eGDC, GDCDSR_REG__, u32GDCDSR_REG__Var[eGDC]);
002640  e7955103          LDR      r5,[r5,r3,LSL #2]
002644  e59f72c8          LDR      r7,|L1.10516|
002648  e0876603          ADD      r6,r7,r3,LSL #12
00264c  e58652b0          STR      r5,[r6,#0x2b0]
                  |L1.9808|
;;;1542       }
;;;1543       return i32Res;
;;;1544   }
002650  e8bd80f0          POP      {r4-r7,pc}
;;;1545   
                          ENDP

                  i32GDC_SetDisplaySize PROC
;;;1547   /****************************************************************************/
;;;1548   int32_t i32GDC_SetDisplaySize(gdc_ch_e eGDC, uint16_t u16Width, uint16_t u16Height)
002654  e92d40f0          PUSH     {r4-r7,lr}
;;;1549   {
002658  e1a03000          MOV      r3,r0
;;;1550       uint32_t u32Val;
;;;1551       int32_t i32Res = C_SUCCESS;
00265c  e3a00000          MOV      r0,#0
;;;1552       
;;;1553       if ( (u16Width<GDC_DISP_WIDTH_MIN)   || (u16Width>GDC_DISP_WIDTH_MAX) || 
002660  e3510040          CMP      r1,#0x40
002664  3a000005          BCC      |L1.9856|
002668  e3510b02          CMP      r1,#0x800
00266c  2a000003          BCS      |L1.9856|
;;;1554             (u16Height<GDC_DISP_HEIGHT_MIN) || (u16Height>GDC_DISP_HEIGHT_MAX) )
002670  e3520000          CMP      r2,#0
002674  0a000001          BEQ      |L1.9856|
002678  e3520b01          CMP      r2,#0x400
00267c  3a000001          BCC      |L1.9864|
                  |L1.9856|
;;;1555       {
;;;1556           i32Res = C_FAILED;
002680  e3e00000          MVN      r0,#0
002684  ea00000a          B        |L1.9908|
                  |L1.9864|
002688  e1a05002          MOV      r5,r2
;;;1557       }
;;;1558       else
;;;1559       {
;;;1560           /* Compose the entire register value */
;;;1561           u32Val = (((uint32_t) (u16Width & GDC_12_BIT_MASK)) << 16) | (u16Height & GDC_11_BIT_MASK);
00268c  e7df559f          BFC      r5,#11,#21
002690  e1a06001          MOV      r6,r1
002694  e7df661f          BFC      r6,#12,#20
002698  e1854806          ORR      r4,r5,r6,LSL #16
;;;1562   
;;;1563           /* Set */
;;;1564           vSetGDCDIMR(eGDC, u32Val);
00269c  e59f52f0          LDR      r5,|L1.10644|
0026a0  e7854103          STR      r4,[r5,r3,LSL #2]
;;;1565           /* DHEIGHT and DWIDTH : belong to low word of register: */
;;;1566           UPDATE_REGISTER_LOW_WORD(eGDC, GDCDIMR_REG__, u32GDCDIMR_REG__Var[eGDC]);
0026a4  e7955103          LDR      r5,[r5,r3,LSL #2]
0026a8  e59f7264          LDR      r7,|L1.10516|
0026ac  e0876603          ADD      r6,r7,r3,LSL #12
0026b0  e58652b8          STR      r5,[r6,#0x2b8]
                  |L1.9908|
;;;1567       }
;;;1568       return i32Res;
;;;1569   }
0026b4  e8bd80f0          POP      {r4-r7,pc}
;;;1570   
                          ENDP

                  vGDC_WindowEnable PROC
;;;1572   /****************************************************************************/
;;;1573   void vGDC_WindowEnable(gdc_ch_e eGDC, gdc_win_e eWindow, gdc_en_e eEn)
0026b8  e92d4070          PUSH     {r4-r6,lr}
;;;1574   {
0026bc  e1a04000          MOV      r4,r0
0026c0  e1a06001          MOV      r6,r1
0026c4  e1a05002          MOV      r5,r2
;;;1575       /* Single window selection */
;;;1576       switch( eWindow )
0026c8  e3560005          CMP      r6,#5
0026cc  308ff106          ADDCC    pc,pc,r6,LSL #2
0026d0  ea000047          B        |L1.10228|
0026d4  ea000003          B        |L1.9960|
0026d8  ea000010          B        |L1.10016|
0026dc  ea00001d          B        |L1.10072|
0026e0  ea00002a          B        |L1.10128|
0026e4  ea000037          B        |L1.10184|
                  |L1.9960|
;;;1577       {
;;;1578            case GDC_WIN_A:
0026e8  e320f000          NOP      
;;;1579                vSetGDCDCR_WAEN(eGDC, eEn);
0026ec  e59f0298          LDR      r0,|L1.10636|
0026f0  e0800184          ADD      r0,r0,r4,LSL #3
0026f4  e1c000d0          LDRD     r0,r1,[r0,#0]
0026f8  e7d90c95          BFI      r0,r5,#25,#1
0026fc  e59f2288          LDR      r2,|L1.10636|
002700  e0822184          ADD      r2,r2,r4,LSL #3
002704  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1580                /* WAEN: belongs to low word of register: */
;;;1581                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002708  e59f027c          LDR      r0,|L1.10636|
00270c  e0800184          ADD      r0,r0,r4,LSL #3
002710  e1c000d0          LDRD     r0,r1,[r0,#0]
002714  e59f21f8          LDR      r2,|L1.10516|
002718  e7820604          STR      r0,[r2,r4,LSL #12]
;;;1582                break;
00271c  ea000036          B        |L1.10236|
                  |L1.10016|
;;;1583   
;;;1584            case GDC_WIN_B:
002720  e320f000          NOP      
;;;1585                vSetGDCDCR_WBEN(eGDC, eEn);
002724  e59f0260          LDR      r0,|L1.10636|
002728  e0800184          ADD      r0,r0,r4,LSL #3
00272c  e1c000d0          LDRD     r0,r1,[r0,#0]
002730  e7db0d95          BFI      r0,r5,#27,#1
002734  e59f2250          LDR      r2,|L1.10636|
002738  e0822184          ADD      r2,r2,r4,LSL #3
00273c  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1586                /* WBEN: belongs to low word of register: */
;;;1587                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002740  e59f0244          LDR      r0,|L1.10636|
002744  e0800184          ADD      r0,r0,r4,LSL #3
002748  e1c000d0          LDRD     r0,r1,[r0,#0]
00274c  e59f21c0          LDR      r2,|L1.10516|
002750  e7820604          STR      r0,[r2,r4,LSL #12]
;;;1588                break;
002754  ea000028          B        |L1.10236|
                  |L1.10072|
;;;1589   
;;;1590            case GDC_WIN_C:
002758  e320f000          NOP      
;;;1591                vSetGDCDCR_WCEN(eGDC, eEn);
00275c  e59f0228          LDR      r0,|L1.10636|
002760  e0800184          ADD      r0,r0,r4,LSL #3
002764  e1c000d0          LDRD     r0,r1,[r0,#0]
002768  e7dd0e95          BFI      r0,r5,#29,#1
00276c  e59f2218          LDR      r2,|L1.10636|
002770  e0822184          ADD      r2,r2,r4,LSL #3
002774  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1592                /* WCEN: belongs to low word of register: */
;;;1593                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002778  e59f020c          LDR      r0,|L1.10636|
00277c  e0800184          ADD      r0,r0,r4,LSL #3
002780  e1c000d0          LDRD     r0,r1,[r0,#0]
002784  e59f2188          LDR      r2,|L1.10516|
002788  e7820604          STR      r0,[r2,r4,LSL #12]
;;;1594                break;
00278c  ea00001a          B        |L1.10236|
                  |L1.10128|
;;;1595   
;;;1596            case GDC_WIN_D:
002790  e320f000          NOP      
;;;1597                vSetGDCDCR_WDEN(eGDC, eEn);
002794  e59f01f0          LDR      r0,|L1.10636|
002798  e0800184          ADD      r0,r0,r4,LSL #3
00279c  e1c000d0          LDRD     r0,r1,[r0,#0]
0027a0  e7df0f95          BFI      r0,r5,#31,#1
0027a4  e59f21e0          LDR      r2,|L1.10636|
0027a8  e0822184          ADD      r2,r2,r4,LSL #3
0027ac  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1598                /* WDEN: belongs to low word of register: */
;;;1599                UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
0027b0  e59f01d4          LDR      r0,|L1.10636|
0027b4  e0800184          ADD      r0,r0,r4,LSL #3
0027b8  e1c000d0          LDRD     r0,r1,[r0,#0]
0027bc  e59f2150          LDR      r2,|L1.10516|
0027c0  e7820604          STR      r0,[r2,r4,LSL #12]
;;;1600                break;
0027c4  ea00000c          B        |L1.10236|
                  |L1.10184|
;;;1601   
;;;1602            case GDC_WIN_E:
0027c8  e320f000          NOP      
;;;1603                vSetGDCDCR_WEEN(eGDC, eEn);
0027cc  e59f01b8          LDR      r0,|L1.10636|
0027d0  e0800184          ADD      r0,r0,r4,LSL #3
0027d4  e1c000d0          LDRD     r0,r1,[r0,#0]
0027d8  e7c11095          BFI      r1,r5,#1,#1
0027dc  e59f21a8          LDR      r2,|L1.10636|
0027e0  e0822184          ADD      r2,r2,r4,LSL #3
0027e4  e1c200f0          STRD     r0,r1,[r2,#0]
;;;1604                /* WEEN: belongs to high word of register: */
;;;1605                /* GDCDCR register should be updated special: */
;;;1606                vUpdateDCR_HighWord_Special(eGDC);
0027e8  e1a00004          MOV      r0,r4
0027ec  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;1607                break;
0027f0  ea000001          B        |L1.10236|
                  |L1.10228|
;;;1608                
;;;1609            default:
0027f4  e320f000          NOP      
;;;1610                break;
0027f8  e320f000          NOP      
                  |L1.10236|
0027fc  e320f000          NOP                            ;1582
;;;1611       }
;;;1612   }
002800  e8bd8070          POP      {r4-r6,pc}
;;;1613   
                          ENDP

                  i32GDC_SetWindowSize PROC
;;;1615   /****************************************************************************/
;;;1616   int32_t i32GDC_SetWindowSize(gdc_ch_e eGDC, gdc_win_e eWindow,
002804  e92d40f0          PUSH     {r4-r7,lr}
;;;1617                                uint16_t u16Width, uint16_t u16Height)
;;;1618   {
002808  e1a04000          MOV      r4,r0
00280c  e1a05001          MOV      r5,r1
;;;1619       int32_t i32Res = C_SUCCESS;
002810  e3a00000          MOV      r0,#0
002814  e1a06002          MOV      r6,r2
;;;1620       uint32_t u32Val;
;;;1621   
;;;1622       if( (u16Width & GDC_12_BIT_MASK) < GDC_WIMR_WIDHT_MIN_VAL )
002818  e7df661f          BFC      r6,#12,#20
00281c  e3560008          CMP      r6,#8
002820  2a000001          BCS      |L1.10284|
;;;1623       {
;;;1624           i32Res = C_FAILED;
002824  e3e00000          MVN      r0,#0
002828  ea000038          B        |L1.10512|
                  |L1.10284|
00282c  e1a06003          MOV      r6,r3
;;;1625       }
;;;1626       else
;;;1627       {
;;;1628           /* Compose the entire register value */
;;;1629           u32Val = (((uint32_t) (u16Width & GDC_12_BIT_MASK)) << 16) | (u16Height & GDC_11_BIT_MASK);
002830  e7df659f          BFC      r6,#11,#21
002834  e1a07002          MOV      r7,r2
002838  e7df761f          BFC      r7,#12,#20
00283c  e1861807          ORR      r1,r6,r7,LSL #16
;;;1630   
;;;1631           /* Set */
;;;1632           switch( eWindow )
002840  e3550005          CMP      r5,#5
002844  308ff105          ADDCC    pc,pc,r5,LSL #2
002848  ea00002c          B        |L1.10496|
00284c  ea000003          B        |L1.10336|
002850  ea00000a          B        |L1.10368|
002854  ea000011          B        |L1.10400|
002858  ea000018          B        |L1.10432|
00285c  ea00001f          B        |L1.10464|
                  |L1.10336|
;;;1633           {
;;;1634               case GDC_WIN_A:
002860  e320f000          NOP      
;;;1635                   vSetGDCWIMRA(eGDC, u32Val);
002864  e59f612c          LDR      r6,|L1.10648|
002868  e7861104          STR      r1,[r6,r4,LSL #2]
;;;1636                   /* WHEIGHT & WWIDTH: belong to low word of register: */
;;;1637                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRA_REG__, u32GDCWIMRA_REG__Var[eGDC]);
00286c  e7966104          LDR      r6,[r6,r4,LSL #2]
002870  e59fc09c          LDR      r12,|L1.10516|
002874  e08c7604          ADD      r7,r12,r4,LSL #12
002878  e58760f0          STR      r6,[r7,#0xf0]
;;;1638                   break;
00287c  ea000022          B        |L1.10508|
                  |L1.10368|
;;;1639   
;;;1640               case GDC_WIN_B:
002880  e320f000          NOP      
;;;1641                   vSetGDCWIMRB(eGDC, u32Val);
002884  e59f6110          LDR      r6,|L1.10652|
002888  e7861104          STR      r1,[r6,r4,LSL #2]
;;;1642                   /* WHEIGHT & WWIDTH: belong to low word of register: */
;;;1643                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRB_REG__, u32GDCWIMRB_REG__Var[eGDC]);
00288c  e7966104          LDR      r6,[r6,r4,LSL #2]
002890  e59fc07c          LDR      r12,|L1.10516|
002894  e08c7604          ADD      r7,r12,r4,LSL #12
002898  e58760f8          STR      r6,[r7,#0xf8]
;;;1644                   break;
00289c  ea00001a          B        |L1.10508|
                  |L1.10400|
;;;1645   
;;;1646               case GDC_WIN_C:
0028a0  e320f000          NOP      
;;;1647                   vSetGDCWIMRC(eGDC, u32Val);
0028a4  e59f60f4          LDR      r6,|L1.10656|
0028a8  e7861104          STR      r1,[r6,r4,LSL #2]
;;;1648                   /* WHEIGHT & WWIDTH: belong to low word of register: */
;;;1649                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRC_REG__, u32GDCWIMRC_REG__Var[eGDC]);
0028ac  e7966104          LDR      r6,[r6,r4,LSL #2]
0028b0  e59fc05c          LDR      r12,|L1.10516|
0028b4  e08c7604          ADD      r7,r12,r4,LSL #12
0028b8  e5876270          STR      r6,[r7,#0x270]
;;;1650                   break;
0028bc  ea000012          B        |L1.10508|
                  |L1.10432|
;;;1651   
;;;1652               case GDC_WIN_D:
0028c0  e320f000          NOP      
;;;1653                   vSetGDCWIMRD(eGDC, u32Val);
0028c4  e59f60d8          LDR      r6,|L1.10660|
0028c8  e7861104          STR      r1,[r6,r4,LSL #2]
;;;1654                   /* WHEIGHT & WWIDTH: belong to low word of register: */
;;;1655                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRD_REG__, u32GDCWIMRD_REG__Var[eGDC]);
0028cc  e7966104          LDR      r6,[r6,r4,LSL #2]
0028d0  e59fc03c          LDR      r12,|L1.10516|
0028d4  e08c7604          ADD      r7,r12,r4,LSL #12
0028d8  e5876278          STR      r6,[r7,#0x278]
;;;1656                   break;
0028dc  ea00000a          B        |L1.10508|
                  |L1.10464|
;;;1657   
;;;1658               case GDC_WIN_E:
0028e0  e320f000          NOP      
;;;1659                   vSetGDCWIMRE(eGDC, u32Val);
0028e4  e59f60bc          LDR      r6,|L1.10664|
0028e8  e7861104          STR      r1,[r6,r4,LSL #2]
;;;1660                   /* WHEIGHT & WWIDTH: belong to low word of register: */
;;;1661                   UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRE_REG__, u32GDCWIMRE_REG__Var[eGDC]);
0028ec  e7966104          LDR      r6,[r6,r4,LSL #2]
0028f0  e59fc01c          LDR      r12,|L1.10516|
0028f4  e08c7604          ADD      r7,r12,r4,LSL #12
0028f8  e5876280          STR      r6,[r7,#0x280]
;;;1662                   break;
0028fc  ea000002          B        |L1.10508|
                  |L1.10496|
;;;1663                   
;;;1664               default:
002900  e320f000          NOP      
;;;1665                   i32Res = C_FAILED;
002904  e3e00000          MVN      r0,#0
;;;1666                   break;
002908  e320f000          NOP      
                  |L1.10508|
00290c  e320f000          NOP                            ;1638
                  |L1.10512|
;;;1667           }
;;;1668       }
;;;1669       return i32Res;
;;;1670   }
002910  e8bd80f0          POP      {r4-r7,pc}
                  |L1.10516|
                          DCD      0xc0c02000
                  |L1.10520|
                          DCD      u32GDCMWRA_REG__Var
                  |L1.10524|
                          DCD      u32GDCMWRB_REG__Var
                  |L1.10528|
                          DCD      u32GDCMWRC_REG__Var
                  |L1.10532|
                          DCD      u32GDCMWRD_REG__Var
                  |L1.10536|
                          DCD      u32GDCMWRE_REG__Var
                  |L1.10540|
                          DCD      u32GDCLARA0_REG__Var
                  |L1.10544|
                          DCD      u32GDCLARA1_REG__Var
                  |L1.10548|
                          DCD      u32GDCLARB0_REG__Var
                  |L1.10552|
                          DCD      u32GDCLARB1_REG__Var
                  |L1.10556|
                          DCD      u32GDCLARC0_REG__Var
                  |L1.10560|
                          DCD      u32GDCLARC1_REG__Var
                  |L1.10564|
                          DCD      u32GDCLARD0_REG__Var
                  |L1.10568|
                          DCD      u32GDCLARD1_REG__Var
                  |L1.10572|
                          DCD      u32GDCLARE0_REG__Var
                  |L1.10576|
                          DCD      u32GDCLARE1_REG__Var
                  |L1.10580|
                          DCD      u32GDCCBAR0_REG__Var
                  |L1.10584|
                          DCD      u32GDCCBAR1_REG__Var
                  |L1.10588|
                          DCD      u32GDCCBAR2_REG__Var
                  |L1.10592|
                          DCD      0xc0c02400
                  |L1.10596|
                          DCD      0xc0c02800
                  |L1.10600|
                          DCD      0xc0c02c00
                  |L1.10604|
                          DCD      u64GDCSCVRA_REG__Var
                  |L1.10608|
                          DCD      0xc0c02288
                  |L1.10612|
                          DCD      u64GDCSCVRB_REG__Var
                  |L1.10616|
                          DCD      0xc0c02290
                  |L1.10620|
                          DCD      u64GDCSCVRC_REG__Var
                  |L1.10624|
                          DCD      0xc0c02298
                  |L1.10628|
                          DCD      u64GDCSCVRD_REG__Var
                  |L1.10632|
                          DCD      0xc0c022a0
                  |L1.10636|
                          DCD      u64GDCDCR_REG__Var
                  |L1.10640|
                          DCD      u32GDCDSR_REG__Var
                  |L1.10644|
                          DCD      u32GDCDIMR_REG__Var
                  |L1.10648|
                          DCD      u32GDCWIMRA_REG__Var
                  |L1.10652|
                          DCD      u32GDCWIMRB_REG__Var
                  |L1.10656|
                          DCD      u32GDCWIMRC_REG__Var
                  |L1.10660|
                          DCD      u32GDCWIMRD_REG__Var
                  |L1.10664|
                          DCD      u32GDCWIMRE_REG__Var
                          ENDP

                  vGDC_SetWindowStartPos PROC
;;;1673   /****************************************************************************/
;;;1674   void vGDC_SetWindowStartPos(gdc_ch_e eGDC, gdc_win_e eWindow, uint16_t u16HStart, uint16_t u16VStart)
0029ac  e92d40f0          PUSH     {r4-r7,lr}
;;;1675   
;;;1676   {
0029b0  e1a04001          MOV      r4,r1
0029b4  e1a05003          MOV      r5,r3
;;;1677       uint32_t u32Val;
;;;1678   
;;;1679       /* Compose the entire register value */
;;;1680       u32Val = (((uint32_t) (u16HStart & GDC_11_BIT_MASK)) << 16) | (u16VStart & GDC_10_BIT_MASK);
0029b8  e7df551f          BFC      r5,#10,#22
0029bc  e1a06002          MOV      r6,r2
0029c0  e7df659f          BFC      r6,#11,#21
0029c4  e1851806          ORR      r1,r5,r6,LSL #16
;;;1681       switch( eWindow )
0029c8  e3540005          CMP      r4,#5
0029cc  308ff104          ADDCC    pc,pc,r4,LSL #2
0029d0  ea00002c          B        |L1.10888|
0029d4  ea000003          B        |L1.10728|
0029d8  ea00000a          B        |L1.10760|
0029dc  ea000011          B        |L1.10792|
0029e0  ea000018          B        |L1.10824|
0029e4  ea00001f          B        |L1.10856|
                  |L1.10728|
;;;1682       {
;;;1683           case GDC_WIN_A:
0029e8  e320f000          NOP      
;;;1684               vSetGDCWSRA(eGDC, u32Val);
0029ec  e59f5e48          LDR      r5,|L1.14396|
0029f0  e7851100          STR      r1,[r5,r0,LSL #2]
;;;1685               /* WVS & WHS: belong to low word of register: */
;;;1686               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRA_REG__, u32GDCWSRA_REG__Var[eGDC]);
0029f4  e7955100          LDR      r5,[r5,r0,LSL #2]
0029f8  e51f70ec          LDR      r7,|L1.10516|
0029fc  e0876600          ADD      r6,r7,r0,LSL #12
002a00  e58650e0          STR      r5,[r6,#0xe0]
;;;1687               break;
002a04  ea000021          B        |L1.10896|
                  |L1.10760|
;;;1688   
;;;1689           case GDC_WIN_B:
002a08  e320f000          NOP      
;;;1690               vSetGDCWSRB(eGDC, u32Val);
002a0c  e59f5e2c          LDR      r5,|L1.14400|
002a10  e7851100          STR      r1,[r5,r0,LSL #2]
;;;1691               /* WVS & WHS: belong to low word of register: */
;;;1692               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRB_REG__, u32GDCWSRB_REG__Var[eGDC]);
002a14  e7955100          LDR      r5,[r5,r0,LSL #2]
002a18  e51f710c          LDR      r7,|L1.10516|
002a1c  e0876600          ADD      r6,r7,r0,LSL #12
002a20  e58650e8          STR      r5,[r6,#0xe8]
;;;1693               break;
002a24  ea000019          B        |L1.10896|
                  |L1.10792|
;;;1694   
;;;1695           case GDC_WIN_C:
002a28  e320f000          NOP      
;;;1696               vSetGDCWSRC(eGDC, u32Val);
002a2c  e59f5e10          LDR      r5,|L1.14404|
002a30  e7851100          STR      r1,[r5,r0,LSL #2]
;;;1697               /* WVS & WHS: belong to low word of register: */
;;;1698               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRC_REG__, u32GDCWSRC_REG__Var[eGDC]);
002a34  e7955100          LDR      r5,[r5,r0,LSL #2]
002a38  e51f712c          LDR      r7,|L1.10516|
002a3c  e0876600          ADD      r6,r7,r0,LSL #12
002a40  e5865258          STR      r5,[r6,#0x258]
;;;1699               break;
002a44  ea000011          B        |L1.10896|
                  |L1.10824|
;;;1700   
;;;1701           case GDC_WIN_D:
002a48  e320f000          NOP      
;;;1702               vSetGDCWSRD(eGDC, u32Val);
002a4c  e59f5df4          LDR      r5,|L1.14408|
002a50  e7851100          STR      r1,[r5,r0,LSL #2]
;;;1703               /* WVS & WHS: belong to low word of register: */
;;;1704               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRD_REG__, u32GDCWSRD_REG__Var[eGDC]);
002a54  e7955100          LDR      r5,[r5,r0,LSL #2]
002a58  e51f714c          LDR      r7,|L1.10516|
002a5c  e0876600          ADD      r6,r7,r0,LSL #12
002a60  e5865260          STR      r5,[r6,#0x260]
;;;1705               break;
002a64  ea000009          B        |L1.10896|
                  |L1.10856|
;;;1706   
;;;1707           case GDC_WIN_E:
002a68  e320f000          NOP      
;;;1708               vSetGDCWSRE(eGDC, u32Val);
002a6c  e59f5dd8          LDR      r5,|L1.14412|
002a70  e7851100          STR      r1,[r5,r0,LSL #2]
;;;1709               /* WVS & WHS: belong to low word of register: */
;;;1710               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRE_REG__, u32GDCWSRE_REG__Var[eGDC]);
002a74  e7955100          LDR      r5,[r5,r0,LSL #2]
002a78  e51f716c          LDR      r7,|L1.10516|
002a7c  e0876600          ADD      r6,r7,r0,LSL #12
002a80  e5865268          STR      r5,[r6,#0x268]
;;;1711               break;
002a84  ea000001          B        |L1.10896|
                  |L1.10888|
;;;1712               
;;;1713           default:
002a88  e320f000          NOP      
;;;1714               break;
002a8c  e320f000          NOP      
                  |L1.10896|
002a90  e320f000          NOP                            ;1687
;;;1715       }
;;;1716   }
002a94  e8bd80f0          POP      {r4-r7,pc}
;;;1717   
                          ENDP

                  i32GDC_SetWindowStartAddr PROC
;;;1719   /****************************************************************************/
;;;1720   int32_t i32GDC_SetWindowStartAddr(gdc_ch_e eGDC, gdc_win_e eWindow, uint32_t u32Addr)
002a98  e92d4070          PUSH     {r4-r6,lr}
;;;1721   {
002a9c  e1a03000          MOV      r3,r0
;;;1722       int32_t i32Res = C_SUCCESS;
002aa0  e3a00000          MOV      r0,#0
;;;1723   
;;;1724       /* Mask out the zero wired bits */
;;;1725       u32Addr &= GDC_WARXN_WAR_MASK;
002aa4  e3c22001          BIC      r2,r2,#1
;;;1726   
;;;1727       /* Window selection */
;;;1728       switch( eWindow )
002aa8  e3510005          CMP      r1,#5
002aac  308ff101          ADDCC    pc,pc,r1,LSL #2
002ab0  ea00002c          B        |L1.11112|
002ab4  ea000003          B        |L1.10952|
002ab8  ea00000a          B        |L1.10984|
002abc  ea000011          B        |L1.11016|
002ac0  ea000018          B        |L1.11048|
002ac4  ea00001f          B        |L1.11080|
                  |L1.10952|
;;;1729       {
;;;1730           case GDC_WIN_A:
002ac8  e320f000          NOP      
;;;1731               vSetGDCWARA(eGDC, u32Addr);
002acc  e59f4d7c          LDR      r4,|L1.14416|
002ad0  e7842103          STR      r2,[r4,r3,LSL #2]
;;;1732               /* WAR: belongs to low word of register: */
;;;1733               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARA_REG__, u32GDCWARA_REG__Var[eGDC]);
002ad4  e7944103          LDR      r4,[r4,r3,LSL #2]
002ad8  e51f61cc          LDR      r6,|L1.10516|
002adc  e0865603          ADD      r5,r6,r3,LSL #12
002ae0  e5854020          STR      r4,[r5,#0x20]
;;;1734               break;
002ae4  ea000022          B        |L1.11124|
                  |L1.10984|
;;;1735   
;;;1736           case GDC_WIN_B:
002ae8  e320f000          NOP      
;;;1737               vSetGDCWARB(eGDC, u32Addr);
002aec  e59f4d60          LDR      r4,|L1.14420|
002af0  e7842103          STR      r2,[r4,r3,LSL #2]
;;;1738               /* WAR: belongs to low word of register: */
;;;1739               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARB_REG__, u32GDCWARB_REG__Var[eGDC]);
002af4  e7944103          LDR      r4,[r4,r3,LSL #2]
002af8  e51f61ec          LDR      r6,|L1.10516|
002afc  e0865603          ADD      r5,r6,r3,LSL #12
002b00  e5854040          STR      r4,[r5,#0x40]
;;;1740               break;
002b04  ea00001a          B        |L1.11124|
                  |L1.11016|
;;;1741   
;;;1742           case GDC_WIN_C:
002b08  e320f000          NOP      
;;;1743               vSetGDCWARC(eGDC, u32Addr);
002b0c  e59f4d44          LDR      r4,|L1.14424|
002b10  e7842103          STR      r2,[r4,r3,LSL #2]
;;;1744               /* WAR: belongs to low word of register: */
;;;1745               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARC_REG__, u32GDCWARC_REG__Var[eGDC]);
002b14  e7944103          LDR      r4,[r4,r3,LSL #2]
002b18  e51f620c          LDR      r6,|L1.10516|
002b1c  e0865603          ADD      r5,r6,r3,LSL #12
002b20  e5854240          STR      r4,[r5,#0x240]
;;;1746               break;
002b24  ea000012          B        |L1.11124|
                  |L1.11048|
;;;1747   
;;;1748           case GDC_WIN_D:
002b28  e320f000          NOP      
;;;1749               vSetGDCWARD(eGDC, u32Addr);
002b2c  e59f4d28          LDR      r4,|L1.14428|
002b30  e7842103          STR      r2,[r4,r3,LSL #2]
;;;1750               /* WAR: belongs to low word of register: */
;;;1751               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARD_REG__, u32GDCWARD_REG__Var[eGDC]);
002b34  e7944103          LDR      r4,[r4,r3,LSL #2]
002b38  e51f622c          LDR      r6,|L1.10516|
002b3c  e0865603          ADD      r5,r6,r3,LSL #12
002b40  e5854248          STR      r4,[r5,#0x248]
;;;1752               break;
002b44  ea00000a          B        |L1.11124|
                  |L1.11080|
;;;1753   
;;;1754           case GDC_WIN_E:
002b48  e320f000          NOP      
;;;1755               vSetGDCWARE(eGDC, u32Addr);
002b4c  e59f4d0c          LDR      r4,|L1.14432|
002b50  e7842103          STR      r2,[r4,r3,LSL #2]
;;;1756               /* WAR: belongs to low word of register: */
;;;1757               UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARE_REG__, u32GDCWARE_REG__Var[eGDC]);
002b54  e7944103          LDR      r4,[r4,r3,LSL #2]
002b58  e51f624c          LDR      r6,|L1.10516|
002b5c  e0865603          ADD      r5,r6,r3,LSL #12
002b60  e5854250          STR      r4,[r5,#0x250]
;;;1758               break;
002b64  ea000002          B        |L1.11124|
                  |L1.11112|
;;;1759   
;;;1760           default:
002b68  e320f000          NOP      
;;;1761               /* Unsupported window */
;;;1762               i32Res = C_FAILED;
002b6c  e3e00000          MVN      r0,#0
;;;1763               break;
002b70  e320f000          NOP      
                  |L1.11124|
002b74  e320f000          NOP                            ;1734
;;;1764       }
;;;1765       /* Result reporting */
;;;1766       return i32Res;
;;;1767   }
002b78  e8bd8070          POP      {r4-r6,pc}
;;;1768   
                          ENDP

                  vGDC_SyncConfig PROC
;;;1770   /****************************************************************************/
;;;1771   void vGDC_SyncConfig(gdc_ch_e eGDC, gdc_sync_st* pstSyncCfg)
002b7c  e92d4010          PUSH     {r4,lr}
;;;1772   {
;;;1773   #ifdef HW_UPDATE_BUG_FIXED
;;;1774       gdc_reg_update_mode_e eLastUpdateMode;
;;;1775   #endif
;;;1776       if (0x00 != pstSyncCfg)
002b80  e3510000          CMP      r1,#0
002b84  0a00003c          BEQ      |L1.11388|
;;;1777       {
;;;1778           vSetGDCDCR_CSYNC(eGDC, pstSyncCfg->eSyncType);
002b88  e5d14000          LDRB     r4,[r1,#0]
002b8c  e51f2208          LDR      r2,|L1.10636|
002b90  e0822180          ADD      r2,r2,r0,LSL #3
002b94  e1c220d0          LDRD     r2,r3,[r2,#0]
002b98  e7c32194          BFI      r2,r4,#3,#1
002b9c  e51f4218          LDR      r4,|L1.10636|
002ba0  e0844180          ADD      r4,r4,r0,LSL #3
002ba4  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1779           vSetGDCDCR_PVSYNC(eGDC, pstSyncCfg->eVSyncPol);
002ba8  e5d14001          LDRB     r4,[r1,#1]
002bac  e51f2228          LDR      r2,|L1.10636|
002bb0  e0822180          ADD      r2,r2,r0,LSL #3
002bb4  e1c220d0          LDRD     r2,r3,[r2,#0]
002bb8  e7c22114          BFI      r2,r4,#2,#1
002bbc  e51f4238          LDR      r4,|L1.10636|
002bc0  e0844180          ADD      r4,r4,r0,LSL #3
002bc4  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1780           vSetGDCDCR_PHSYNC(eGDC, pstSyncCfg->eHSyncPol);
002bc8  e5d14002          LDRB     r4,[r1,#2]
002bcc  e51f2248          LDR      r2,|L1.10636|
002bd0  e0822180          ADD      r2,r2,r0,LSL #3
002bd4  e1c220d0          LDRD     r2,r3,[r2,#0]
002bd8  e7c12094          BFI      r2,r4,#1,#1
002bdc  e51f4258          LDR      r4,|L1.10636|
002be0  e0844180          ADD      r4,r4,r0,LSL #3
002be4  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1781           
;;;1782           vSetGDCHSR_HSPWR(eGDC, pstSyncCfg->u8HsyncWdth);
002be8  e5d13003          LDRB     r3,[r1,#3]
002bec  e59f2c70          LDR      r2,|L1.14436|
002bf0  e7922100          LDR      r2,[r2,r0,LSL #2]
002bf4  e7d72813          BFI      r2,r3,#16,#8
002bf8  e59f3c64          LDR      r3,|L1.14436|
002bfc  e7832100          STR      r2,[r3,r0,LSL #2]
;;;1783           vSetGDCHSR_HCR(eGDC, pstSyncCfg->u16HLineLen);
002c00  e1d130b6          LDRH     r3,[r1,#6]
002c04  e59f2c58          LDR      r2,|L1.14436|
002c08  e7922100          LDR      r2,[r2,r0,LSL #2]
002c0c  e7cc2013          BFI      r2,r3,#0,#13
002c10  e59f3c4c          LDR      r3,|L1.14436|
002c14  e7832100          STR      r2,[r3,r0,LSL #2]
;;;1784   
;;;1785           vSetGDCVSR_VSPWR(eGDC, pstSyncCfg->u8VsyncWdth);
002c18  e5d13004          LDRB     r3,[r1,#4]
002c1c  e59f2c44          LDR      r2,|L1.14440|
002c20  e7922100          LDR      r2,[r2,r0,LSL #2]
002c24  e7d72813          BFI      r2,r3,#16,#8
002c28  e59f3c38          LDR      r3,|L1.14440|
002c2c  e7832100          STR      r2,[r3,r0,LSL #2]
;;;1786           vSetGDCVSR_VCR(eGDC, pstSyncCfg->u16VFrameLen);
002c30  e1d130b8          LDRH     r3,[r1,#8]
002c34  e59f2c2c          LDR      r2,|L1.14440|
002c38  e7922100          LDR      r2,[r2,r0,LSL #2]
002c3c  e7ca2013          BFI      r2,r3,#0,#11
002c40  e59f3c20          LDR      r3,|L1.14440|
002c44  e7832100          STR      r2,[r3,r0,LSL #2]
;;;1787           
;;;1788   #ifdef HW_UPDATE_BUG_FIXED
;;;1789           /* get last actual update mode for later restore:*/
;;;1790           eLastUpdateMode = eGetShadowRegUpdateStatus(eGDC);
;;;1791   
;;;1792           /* Disable Update Mode if it was not disabled: */
;;;1793           if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
;;;1794           {
;;;1795               vGDC_SetShadowRegUpdateMode(eGDC, GDC_NO_UPDATE_BY_VSYNC);
;;;1796           }
;;;1797   #endif
;;;1798           /* All modified bit fields belong to Low Word of registers,
;;;1799            * so Copy register data to shadow register: */
;;;1800           UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002c48  e51f22c4          LDR      r2,|L1.10636|
002c4c  e0822180          ADD      r2,r2,r0,LSL #3
002c50  e1c220d0          LDRD     r2,r3,[r2,#0]
002c54  e51f4348          LDR      r4,|L1.10516|
002c58  e7842600          STR      r2,[r4,r0,LSL #12]
;;;1801           UPDATE_REGISTER_LOW_WORD(eGDC, GDCHSR_REG__, u32GDCHSR_REG__Var[eGDC]);
002c5c  e59f2c00          LDR      r2,|L1.14436|
002c60  e7922100          LDR      r2,[r2,r0,LSL #2]
002c64  e0843600          ADD      r3,r4,r0,LSL #12
002c68  e5832110          STR      r2,[r3,#0x110]
;;;1802           UPDATE_REGISTER_LOW_WORD(eGDC, GDCVSR_REG__, u32GDCVSR_REG__Var[eGDC]);
002c6c  e59f2bf4          LDR      r2,|L1.14440|
002c70  e7922100          LDR      r2,[r2,r0,LSL #2]
002c74  e0843600          ADD      r3,r4,r0,LSL #12
002c78  e5832118          STR      r2,[r3,#0x118]
                  |L1.11388|
;;;1803           
;;;1804   #ifdef HW_UPDATE_BUG_FIXED
;;;1805           /* restore Update Mode if necessary */
;;;1806           if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
;;;1807           {
;;;1808               vGDC_SetShadowRegUpdateMode(eGDC, eLastUpdateMode);
;;;1809           }
;;;1810   #endif
;;;1811       }
;;;1812   }
002c7c  e8bd8010          POP      {r4,pc}
;;;1813   
                          ENDP

                  vGDC_SetSyncDir PROC
;;;1814   /****************************************************************************/
;;;1815   void vGDC_SetSyncDir(gdc_ch_e eGDC, gdc_dir_e eDir)
002c80  e92d4010          PUSH     {r4,lr}
;;;1816   {
;;;1817       vSetGDCDCR_EXTSYNC(eGDC, eDir);
002c84  e51f2300          LDR      r2,|L1.10636|
002c88  e0822180          ADD      r2,r2,r0,LSL #3
002c8c  e1c220d0          LDRD     r2,r3,[r2,#0]
002c90  e7c42211          BFI      r2,r1,#4,#1
002c94  e51f4310          LDR      r4,|L1.10636|
002c98  e0844180          ADD      r4,r4,r0,LSL #3
002c9c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1818       /* EXTSYNC: belongs to low word of register: */
;;;1819       UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002ca0  e51f231c          LDR      r2,|L1.10636|
002ca4  e0822180          ADD      r2,r2,r0,LSL #3
002ca8  e1c220d0          LDRD     r2,r3,[r2,#0]
002cac  e51f43a0          LDR      r4,|L1.10516|
002cb0  e7842600          STR      r2,[r4,r0,LSL #12]
;;;1820   }
002cb4  e8bd8010          POP      {r4,pc}
;;;1821   
                          ENDP

                  vGDC_SelectCompSync PROC
;;;1823   /****************************************************************************/
;;;1824   void vGDC_SelectCompSync(gdc_ch_e eGDC, gdc_csync_e eSync)
002cb8  e92d4010          PUSH     {r4,lr}
;;;1825   {
;;;1826       vSetGDCDCR_CSYNC(eGDC, eSync);
002cbc  e51f2338          LDR      r2,|L1.10636|
002cc0  e0822180          ADD      r2,r2,r0,LSL #3
002cc4  e1c220d0          LDRD     r2,r3,[r2,#0]
002cc8  e7c32191          BFI      r2,r1,#3,#1
002ccc  e51f4348          LDR      r4,|L1.10636|
002cd0  e0844180          ADD      r4,r4,r0,LSL #3
002cd4  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1827       /* CSYNC: belongs to low word of register: */
;;;1828       UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002cd8  e51f2354          LDR      r2,|L1.10636|
002cdc  e0822180          ADD      r2,r2,r0,LSL #3
002ce0  e1c220d0          LDRD     r2,r3,[r2,#0]
002ce4  e51f43d8          LDR      r4,|L1.10516|
002ce8  e7842600          STR      r2,[r4,r0,LSL #12]
;;;1829   }
002cec  e8bd8010          POP      {r4,pc}
;;;1830   
                          ENDP

                  vGDC_SetPolVSync PROC
;;;1832   /****************************************************************************/
;;;1833   void vGDC_SetPolVSync(gdc_ch_e eGDC, gdc_pol_e eMode)
002cf0  e92d4010          PUSH     {r4,lr}
;;;1834   {
;;;1835       vSetGDCDCR_PVSYNC(eGDC, eMode);
002cf4  e51f2370          LDR      r2,|L1.10636|
002cf8  e0822180          ADD      r2,r2,r0,LSL #3
002cfc  e1c220d0          LDRD     r2,r3,[r2,#0]
002d00  e7c22111          BFI      r2,r1,#2,#1
002d04  e51f4380          LDR      r4,|L1.10636|
002d08  e0844180          ADD      r4,r4,r0,LSL #3
002d0c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1836       /* PVSYNC belongs to low word of register: */
;;;1837       UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002d10  e51f238c          LDR      r2,|L1.10636|
002d14  e0822180          ADD      r2,r2,r0,LSL #3
002d18  e1c220d0          LDRD     r2,r3,[r2,#0]
002d1c  e51f4410          LDR      r4,|L1.10516|
002d20  e7842600          STR      r2,[r4,r0,LSL #12]
;;;1838   }
002d24  e8bd8010          POP      {r4,pc}
;;;1839   
                          ENDP

                  vGDC_SetPolHSync PROC
;;;1841   /****************************************************************************/
;;;1842   void vGDC_SetPolHSync(gdc_ch_e eGDC, gdc_pol_e eMode)
002d28  e92d4010          PUSH     {r4,lr}
;;;1843   {
;;;1844       vSetGDCDCR_PHSYNC(eGDC, eMode);
002d2c  e51f23a8          LDR      r2,|L1.10636|
002d30  e0822180          ADD      r2,r2,r0,LSL #3
002d34  e1c220d0          LDRD     r2,r3,[r2,#0]
002d38  e7c12091          BFI      r2,r1,#1,#1
002d3c  e51f43b8          LDR      r4,|L1.10636|
002d40  e0844180          ADD      r4,r4,r0,LSL #3
002d44  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1845       /* PHSYNC belongs to low word of register: */
;;;1846       UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002d48  e51f23c4          LDR      r2,|L1.10636|
002d4c  e0822180          ADD      r2,r2,r0,LSL #3
002d50  e1c220d0          LDRD     r2,r3,[r2,#0]
002d54  e51f4448          LDR      r4,|L1.10516|
002d58  e7842600          STR      r2,[r4,r0,LSL #12]
;;;1847   }
002d5c  e8bd8010          POP      {r4,pc}
;;;1848   
                          ENDP

                  vGDC_SetPolHDisp PROC
;;;1850   /****************************************************************************/
;;;1851   void vGDC_SetPolHDisp(gdc_ch_e eGDC, gdc_pol_e eMode)
002d60  e92d4010          PUSH     {r4,lr}
;;;1852   {
;;;1853       vSetGDCDCR_PHDISP(eGDC, eMode);
002d64  e51f23e0          LDR      r2,|L1.10636|
002d68  e0822180          ADD      r2,r2,r0,LSL #3
002d6c  e1c220d0          LDRD     r2,r3,[r2,#0]
002d70  e7c02011          BFI      r2,r1,#0,#1
002d74  e51f43f0          LDR      r4,|L1.10636|
002d78  e0844180          ADD      r4,r4,r0,LSL #3
002d7c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1854       /* PHDISP: belongs to low word of register: */
;;;1855       UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
002d80  e51f23fc          LDR      r2,|L1.10636|
002d84  e0822180          ADD      r2,r2,r0,LSL #3
002d88  e1c220d0          LDRD     r2,r3,[r2,#0]
002d8c  e51f4480          LDR      r4,|L1.10516|
002d90  e7842600          STR      r2,[r4,r0,LSL #12]
;;;1856   }
002d94  e8bd8010          POP      {r4,pc}
;;;1857   
                          ENDP

                  vGDC_SetHSync PROC
;;;1859   /****************************************************************************/
;;;1860   void vGDC_SetHSync(gdc_ch_e eGDC, uint8_t u8PulseWidth, uint16_t u16LineLen)
002d98  e92d4030          PUSH     {r4,r5,lr}
;;;1861   {
;;;1862       vSetGDCHSR_HSPWR(eGDC, u8PulseWidth);
002d9c  e59f3ac0          LDR      r3,|L1.14436|
002da0  e7933100          LDR      r3,[r3,r0,LSL #2]
002da4  e7d73811          BFI      r3,r1,#16,#8
002da8  e59f4ab4          LDR      r4,|L1.14436|
002dac  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1863       vSetGDCHSR_HCR(eGDC, u16LineLen);
002db0  e2843000          ADD      r3,r4,#0
002db4  e7933100          LDR      r3,[r3,r0,LSL #2]
002db8  e7cc3012          BFI      r3,r2,#0,#13
002dbc  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1864       /* Copy register data to shadow register: */
;;;1865       UPDATE_REGISTER_LOW_WORD(eGDC, GDCHSR_REG__, u32GDCHSR_REG__Var[eGDC]);
002dc0  e2843000          ADD      r3,r4,#0
002dc4  e7933100          LDR      r3,[r3,r0,LSL #2]
002dc8  e51f54bc          LDR      r5,|L1.10516|
002dcc  e0854600          ADD      r4,r5,r0,LSL #12
002dd0  e5843110          STR      r3,[r4,#0x110]
;;;1866   }
002dd4  e8bd8030          POP      {r4,r5,pc}
;;;1867   
                          ENDP

                  vGDC_SetVSync PROC
;;;1869   /****************************************************************************/
;;;1870   void vGDC_SetVSync(gdc_ch_e eGDC, uint8_t u8PulseWidth, uint16_t u16VFrameLen)
002dd8  e92d4030          PUSH     {r4,r5,lr}
;;;1871   {
;;;1872       vSetGDCVSR_VSPWR(eGDC, u8PulseWidth);
002ddc  e59f3a84          LDR      r3,|L1.14440|
002de0  e7933100          LDR      r3,[r3,r0,LSL #2]
002de4  e7d73811          BFI      r3,r1,#16,#8
002de8  e59f4a78          LDR      r4,|L1.14440|
002dec  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1873       vSetGDCVSR_VCR(eGDC, u16VFrameLen);
002df0  e2843000          ADD      r3,r4,#0
002df4  e7933100          LDR      r3,[r3,r0,LSL #2]
002df8  e7ca3012          BFI      r3,r2,#0,#11
002dfc  e7843100          STR      r3,[r4,r0,LSL #2]
;;;1874       /* Copy register data to shadow register: */
;;;1875       UPDATE_REGISTER_LOW_WORD(eGDC, GDCVSR_REG__, u32GDCVSR_REG__Var[eGDC]);
002e00  e2843000          ADD      r3,r4,#0
002e04  e7933100          LDR      r3,[r3,r0,LSL #2]
002e08  e51f54fc          LDR      r5,|L1.10516|
002e0c  e0854600          ADD      r4,r5,r0,LSL #12
002e10  e5843118          STR      r3,[r4,#0x118]
;;;1876   }
002e14  e8bd8030          POP      {r4,r5,pc}
;;;1877   
                          ENDP

                  vGDC_IrqConfig PROC
;;;1879   /****************************************************************************/
;;;1880   void vGDC_IrqConfig(gdc_ch_e eGDC, gdc_irqcgf_st* pstCfg)
002e18  e92d4030          PUSH     {r4,r5,lr}
;;;1881   {
;;;1882       if (0x00 != pstCfg)
002e1c  e3510000          CMP      r1,#0
002e20  0a00002a          BEQ      |L1.11984|
;;;1883       {
;;;1884           vSetGDCINTR_APCMSK(eGDC, pstCfg->eAPCIrqEn);
002e24  e5d14000          LDRB     r4,[r1,#0]
002e28  e59f3a3c          LDR      r3,|L1.14444|
002e2c  e0832600          ADD      r2,r3,r0,LSL #12
002e30  e1c220d0          LDRD     r2,r3,[r2,#0]
002e34  e7c03014          BFI      r3,r4,#0,#1
002e38  e59f5a2c          LDR      r5,|L1.14444|
002e3c  e0854600          ADD      r4,r5,r0,LSL #12
002e40  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1885           vSetGDCINTR_LINE(eGDC, pstCfg->u16LineNr);
002e44  e1d140b2          LDRH     r4,[r1,#2]
002e48  e1a03005          MOV      r3,r5
002e4c  e0832600          ADD      r2,r3,r0,LSL #12
002e50  e1c220d0          LDRD     r2,r3,[r2,#0]
002e54  e7da2814          BFI      r2,r4,#16,#11
002e58  e0854600          ADD      r4,r5,r0,LSL #12
002e5c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1886           vSetGDCINTR_HSYNCMSK(eGDC, pstCfg->eHSyncIrqEn);
002e60  e5d14004          LDRB     r4,[r1,#4]
002e64  e1a03005          MOV      r3,r5
002e68  e0832600          ADD      r2,r3,r0,LSL #12
002e6c  e1c220d0          LDRD     r2,r3,[r2,#0]
002e70  e7c12094          BFI      r2,r4,#1,#1
002e74  e0854600          ADD      r4,r5,r0,LSL #12
002e78  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1887           vSetGDCINTR_VSYNCMSK(eGDC, pstCfg->eVSyncIrqEn);
002e7c  e5d14005          LDRB     r4,[r1,#5]
002e80  e1a03005          MOV      r3,r5
002e84  e0832600          ADD      r2,r3,r0,LSL #12
002e88  e1c220d0          LDRD     r2,r3,[r2,#0]
002e8c  e7c22114          BFI      r2,r4,#2,#1
002e90  e0854600          ADD      r4,r5,r0,LSL #12
002e94  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1888   
;;;1889           vSetGDCINTR_IFURMSK(eGDC, pstCfg->eIfurIrqEn);
002e98  e5d14006          LDRB     r4,[r1,#6]
002e9c  e1a03005          MOV      r3,r5
002ea0  e0832600          ADD      r2,r3,r0,LSL #12
002ea4  e1c220d0          LDRD     r2,r3,[r2,#0]
002ea8  e7c82414          BFI      r2,r4,#8,#1
002eac  e0854600          ADD      r4,r5,r0,LSL #12
002eb0  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1890           vSetGDCINTR_OFURMSK(eGDC, pstCfg->eOfurIrqEn);
002eb4  e5d14007          LDRB     r4,[r1,#7]
002eb8  e1a03005          MOV      r3,r5
002ebc  e0832600          ADD      r2,r3,r0,LSL #12
002ec0  e1c220d0          LDRD     r2,r3,[r2,#0]
002ec4  e7c92494          BFI      r2,r4,#9,#1
002ec8  e0854600          ADD      r4,r5,r0,LSL #12
002ecc  e1c420f0          STRD     r2,r3,[r4,#0]
                  |L1.11984|
;;;1891       }
;;;1892   }
002ed0  e8bd8030          POP      {r4,r5,pc}
;;;1893   
                          ENDP

                  vGDC_SetIrqMaskAPC PROC
;;;1895   /****************************************************************************/
;;;1896   void vGDC_SetIrqMaskAPC(gdc_ch_e eGDC, gdc_en_e eEn)
002ed4  e92d4030          PUSH     {r4,r5,lr}
;;;1897   {
;;;1898       vSetGDCINTR_APCMSK(eGDC, eEn);
002ed8  e59f398c          LDR      r3,|L1.14444|
002edc  e0832600          ADD      r2,r3,r0,LSL #12
002ee0  e1c220d0          LDRD     r2,r3,[r2,#0]
002ee4  e7c03011          BFI      r3,r1,#0,#1
002ee8  e59f597c          LDR      r5,|L1.14444|
002eec  e0854600          ADD      r4,r5,r0,LSL #12
002ef0  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1899   }
002ef4  e8bd8030          POP      {r4,r5,pc}
;;;1900   
                          ENDP

                  vGDC_SetHsyncIrqLine PROC
;;;1902   /****************************************************************************/
;;;1903   void vGDC_SetHsyncIrqLine(gdc_ch_e eGDC, uint16_t u16LineNr)
002ef8  e92d4030          PUSH     {r4,r5,lr}
;;;1904   {
;;;1905       vSetGDCINTR_LINE(eGDC, u16LineNr);
002efc  e59f3968          LDR      r3,|L1.14444|
002f00  e0832600          ADD      r2,r3,r0,LSL #12
002f04  e1c220d0          LDRD     r2,r3,[r2,#0]
002f08  e7da2811          BFI      r2,r1,#16,#11
002f0c  e59f5958          LDR      r5,|L1.14444|
002f10  e0854600          ADD      r4,r5,r0,LSL #12
002f14  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1906   }
002f18  e8bd8030          POP      {r4,r5,pc}
;;;1907   
                          ENDP

                  vGDC_SetIrqMaskFifoIn PROC
;;;1909   /****************************************************************************/
;;;1910   void vGDC_SetIrqMaskFifoIn(gdc_ch_e eGDC, gdc_en_e eEn)
002f1c  e92d4030          PUSH     {r4,r5,lr}
;;;1911   {
;;;1912       vSetGDCINTR_IFURMSK(eGDC, eEn);
002f20  e59f3944          LDR      r3,|L1.14444|
002f24  e0832600          ADD      r2,r3,r0,LSL #12
002f28  e1c220d0          LDRD     r2,r3,[r2,#0]
002f2c  e7c82411          BFI      r2,r1,#8,#1
002f30  e59f5934          LDR      r5,|L1.14444|
002f34  e0854600          ADD      r4,r5,r0,LSL #12
002f38  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1913   }
002f3c  e8bd8030          POP      {r4,r5,pc}
;;;1914   
                          ENDP

                  vGDC_SetIrqMaskFifoOut PROC
;;;1916   /****************************************************************************/
;;;1917   void vGDC_SetIrqMaskFifoOut(gdc_ch_e eGDC, gdc_en_e eEn)
002f40  e92d4030          PUSH     {r4,r5,lr}
;;;1918   {
;;;1919       vSetGDCINTR_OFURMSK(eGDC, eEn);
002f44  e59f3920          LDR      r3,|L1.14444|
002f48  e0832600          ADD      r2,r3,r0,LSL #12
002f4c  e1c220d0          LDRD     r2,r3,[r2,#0]
002f50  e7c92491          BFI      r2,r1,#9,#1
002f54  e59f5910          LDR      r5,|L1.14444|
002f58  e0854600          ADD      r4,r5,r0,LSL #12
002f5c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1920   }
002f60  e8bd8030          POP      {r4,r5,pc}
;;;1921   
                          ENDP

                  vGDC_SetIrqMaskVSync PROC
;;;1923   /****************************************************************************/
;;;1924   void vGDC_SetIrqMaskVSync(gdc_ch_e eGDC, gdc_en_e eEn)
002f64  e92d4030          PUSH     {r4,r5,lr}
;;;1925   {
;;;1926       vSetGDCINTR_VSYNCMSK(eGDC, eEn);
002f68  e59f38fc          LDR      r3,|L1.14444|
002f6c  e0832600          ADD      r2,r3,r0,LSL #12
002f70  e1c220d0          LDRD     r2,r3,[r2,#0]
002f74  e7c22111          BFI      r2,r1,#2,#1
002f78  e59f58ec          LDR      r5,|L1.14444|
002f7c  e0854600          ADD      r4,r5,r0,LSL #12
002f80  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1927   }
002f84  e8bd8030          POP      {r4,r5,pc}
;;;1928   
                          ENDP

                  vGDC_SetIrqMaskHSync PROC
;;;1930   /****************************************************************************/
;;;1931   void vGDC_SetIrqMaskHSync(gdc_ch_e eGDC, gdc_en_e eEn)
002f88  e92d4030          PUSH     {r4,r5,lr}
;;;1932   {
;;;1933       vSetGDCINTR_HSYNCMSK(eGDC, eEn);
002f8c  e59f38d8          LDR      r3,|L1.14444|
002f90  e0832600          ADD      r2,r3,r0,LSL #12
002f94  e1c220d0          LDRD     r2,r3,[r2,#0]
002f98  e7c12091          BFI      r2,r1,#1,#1
002f9c  e59f58c8          LDR      r5,|L1.14444|
002fa0  e0854600          ADD      r4,r5,r0,LSL #12
002fa4  e1c420f0          STRD     r2,r3,[r4,#0]
;;;1934   }
002fa8  e8bd8030          POP      {r4,r5,pc}
;;;1935   
                          ENDP

                  eGDC_IsIrqHSync PROC
;;;1936   /****************************************************************************/
;;;1937   gdc_irqact_e eGDC_IsIrqHSync(gdc_ch_e eGDC)
002fac  e92d4030          PUSH     {r4,r5,lr}
;;;1938   {
002fb0  e1a01000          MOV      r1,r0
;;;1939       int32_t i32IrqStat;
;;;1940   
;;;1941       i32IrqStat = (int32_t)biGetGDCINTR_HSYNCINT(eGDC);
002fb4  e59f28b0          LDR      r2,|L1.14444|
002fb8  e0820601          ADD      r0,r2,r1,LSL #12
002fbc  e1c020d0          LDRD     r2,r3,[r0,#0]
002fc0  e7e042d2          UBFX     r4,r2,#5,#1
;;;1942   
;;;1943       /* Clear the flag if the interrupt is active */
;;;1944       if( 1 == i32IrqStat )
002fc4  e3540001          CMP      r4,#1
002fc8  1a000007          BNE      |L1.12268|
002fcc  e3a00001          MOV      r0,#1
;;;1945       {
;;;1946           vClrGDCINTR_HSYNCINT(eGDC);
002fd0  e59f3894          LDR      r3,|L1.14444|
002fd4  e0832601          ADD      r2,r3,r1,LSL #12
002fd8  e1c220d0          LDRD     r2,r3,[r2,#0]
002fdc  e7c52290          BFI      r2,r0,#5,#1
002fe0  e59f5884          LDR      r5,|L1.14444|
002fe4  e0850601          ADD      r0,r5,r1,LSL #12
002fe8  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.12268|
;;;1947       }
;;;1948   
;;;1949       return (gdc_irqact_e) i32IrqStat;
002fec  e20400ff          AND      r0,r4,#0xff
;;;1950   }
002ff0  e8bd8030          POP      {r4,r5,pc}
;;;1951   
                          ENDP

                  eGDC_IsIrqVSync PROC
;;;1953   /****************************************************************************/
;;;1954   gdc_irqact_e eGDC_IsIrqVSync(gdc_ch_e eGDC)
002ff4  e92d4030          PUSH     {r4,r5,lr}
;;;1955   {
002ff8  e1a01000          MOV      r1,r0
;;;1956       int32_t i32IrqStat;
;;;1957   
;;;1958       i32IrqStat = (int32_t)biGetGDCINTR_VSYNCINT(eGDC);
002ffc  e59f2868          LDR      r2,|L1.14444|
003000  e0820601          ADD      r0,r2,r1,LSL #12
003004  e1c020d0          LDRD     r2,r3,[r0,#0]
003008  e7e04352          UBFX     r4,r2,#6,#1
;;;1959   
;;;1960       /* Clear the flag if the interrupt is active */
;;;1961       if( 1 == i32IrqStat )
00300c  e3540001          CMP      r4,#1
003010  1a000007          BNE      |L1.12340|
003014  e3a00001          MOV      r0,#1
;;;1962       {
;;;1963           vClrGDCINTR_VSYNCINT(eGDC);
003018  e59f384c          LDR      r3,|L1.14444|
00301c  e0832601          ADD      r2,r3,r1,LSL #12
003020  e1c220d0          LDRD     r2,r3,[r2,#0]
003024  e7c62310          BFI      r2,r0,#6,#1
003028  e59f583c          LDR      r5,|L1.14444|
00302c  e0850601          ADD      r0,r5,r1,LSL #12
003030  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.12340|
;;;1964       }
;;;1965   
;;;1966       return (gdc_irqact_e) i32IrqStat;
003034  e20400ff          AND      r0,r4,#0xff
;;;1967   }
003038  e8bd8030          POP      {r4,r5,pc}
;;;1968   
                          ENDP

                  eGDC_IsIrqFifoIn PROC
;;;1969   /****************************************************************************/
;;;1970   gdc_irqact_e eGDC_IsIrqFifoIn(gdc_ch_e eGDC)
00303c  e92d4030          PUSH     {r4,r5,lr}
;;;1971   {
003040  e1a01000          MOV      r1,r0
;;;1972       int32_t i32IrqStat;
;;;1973   
;;;1974       i32IrqStat = (int32_t)biGetGDCINTR_IFURINT(eGDC);
003044  e59f2820          LDR      r2,|L1.14444|
003048  e0820601          ADD      r0,r2,r1,LSL #12
00304c  e1c020d0          LDRD     r2,r3,[r0,#0]
003050  e7e04652          UBFX     r4,r2,#12,#1
;;;1975   
;;;1976       /* Clear the flag if the interrupt is active */
;;;1977       if( 1 == i32IrqStat )
003054  e3540001          CMP      r4,#1
003058  1a000007          BNE      |L1.12412|
00305c  e3a00001          MOV      r0,#1
;;;1978       {
;;;1979           vClrGDCINTR_IFURINT(eGDC);
003060  e59f3804          LDR      r3,|L1.14444|
003064  e0832601          ADD      r2,r3,r1,LSL #12
003068  e1c220d0          LDRD     r2,r3,[r2,#0]
00306c  e7cc2610          BFI      r2,r0,#12,#1
003070  e59f57f4          LDR      r5,|L1.14444|
003074  e0850601          ADD      r0,r5,r1,LSL #12
003078  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.12412|
;;;1980       }
;;;1981   
;;;1982       return (gdc_irqact_e) i32IrqStat;
00307c  e20400ff          AND      r0,r4,#0xff
;;;1983   }
003080  e8bd8030          POP      {r4,r5,pc}
;;;1984   
                          ENDP

                  eGDC_IsIrqFifoOut PROC
;;;1986   /****************************************************************************/
;;;1987   gdc_irqact_e eGDC_IsIrqFifoOut(gdc_ch_e eGDC)
003084  e92d4030          PUSH     {r4,r5,lr}
;;;1988   {
003088  e1a01000          MOV      r1,r0
;;;1989       int32_t i32IrqStat;
;;;1990   
;;;1991       i32IrqStat = (int32_t)biGetGDCINTR_OFURINT(eGDC);
00308c  e59f27d8          LDR      r2,|L1.14444|
003090  e0820601          ADD      r0,r2,r1,LSL #12
003094  e1c020d0          LDRD     r2,r3,[r0,#0]
003098  e7e046d2          UBFX     r4,r2,#13,#1
;;;1992   
;;;1993       /* Clear the flag if the interrupt is active */
;;;1994       if( 1 == i32IrqStat )
00309c  e3540001          CMP      r4,#1
0030a0  1a000007          BNE      |L1.12484|
0030a4  e3a00001          MOV      r0,#1
;;;1995       {
;;;1996           vClrGDCINTR_OFURINT(eGDC);
0030a8  e59f37bc          LDR      r3,|L1.14444|
0030ac  e0832601          ADD      r2,r3,r1,LSL #12
0030b0  e1c220d0          LDRD     r2,r3,[r2,#0]
0030b4  e7cd2690          BFI      r2,r0,#13,#1
0030b8  e59f57ac          LDR      r5,|L1.14444|
0030bc  e0850601          ADD      r0,r5,r1,LSL #12
0030c0  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.12484|
;;;1997       }
;;;1998   
;;;1999       return (gdc_irqact_e) i32IrqStat;
0030c4  e20400ff          AND      r0,r4,#0xff
;;;2000   }
0030c8  e8bd8030          POP      {r4,r5,pc}
;;;2001   
                          ENDP

                  eGDC_IsIrqAPC PROC
;;;2003   /****************************************************************************/
;;;2004   gdc_irqact_e eGDC_IsIrqAPC(gdc_ch_e eGDC)
0030cc  e92d4030          PUSH     {r4,r5,lr}
;;;2005   {
0030d0  e1a01000          MOV      r1,r0
;;;2006       int32_t i32IrqStat;
;;;2007   
;;;2008       i32IrqStat = (int32_t)biGetGDCINTR_APCINT(eGDC);
0030d4  e59f2790          LDR      r2,|L1.14444|
0030d8  e0820601          ADD      r0,r2,r1,LSL #12
0030dc  e1c020d0          LDRD     r2,r3,[r0,#0]
0030e0  e7e04253          UBFX     r4,r3,#4,#1
;;;2009   
;;;2010       /* Clear the flag if the interrupt is active */
;;;2011       if( 1 == i32IrqStat )
0030e4  e3540001          CMP      r4,#1
0030e8  1a000007          BNE      |L1.12556|
0030ec  e3a00001          MOV      r0,#1
;;;2012       {
;;;2013           vClrGDCINTR_APCINT(eGDC);
0030f0  e59f3774          LDR      r3,|L1.14444|
0030f4  e0832601          ADD      r2,r3,r1,LSL #12
0030f8  e1c220d0          LDRD     r2,r3,[r2,#0]
0030fc  e7c43210          BFI      r3,r0,#4,#1
003100  e59f5764          LDR      r5,|L1.14444|
003104  e0850601          ADD      r0,r5,r1,LSL #12
003108  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.12556|
;;;2014       }
;;;2015   
;;;2016       return (gdc_irqact_e) i32IrqStat;
00310c  e20400ff          AND      r0,r4,#0xff
;;;2017   }
003110  e8bd8030          POP      {r4,r5,pc}
;;;2018   
                          ENDP

                  vGDC_PnlGppOutEnable PROC
;;;2020   /****************************************************************************/
;;;2021   void vGDC_PnlGppOutEnable(gdc_gpp_e ePin, gdc_en_e eEn)
003114  e92d4030          PUSH     {r4,r5,lr}
;;;2022   {
003118  e1a02000          MOV      r2,r0
00311c  e1a03001          MOV      r3,r1
;;;2023       uint32_t u32PinStat;
;;;2024       uint32_t u32Tmp;
;;;2025   
;;;2026       /* API valid only for GDC0 : */
;;;2027       u32PinStat = u32GetGDCPTCR(GDC0);
003120  e59f4748          LDR      r4,|L1.14448|
003124  e5940000          LDR      r0,[r4,#0]  ; u32GDCPTCR_REG__Var
;;;2028   
;;;2029       u32Tmp = 0x1;
003128  e3a01001          MOV      r1,#1
;;;2030       u32Tmp <<= (uint32_t) ePin;
00312c  e1a01211          LSL      r1,r1,r2
;;;2031   
;;;2032       if( 1 == eEn )
003130  e3530001          CMP      r3,#1
003134  1a000001          BNE      |L1.12608|
;;;2033       {
;;;2034          u32PinStat |= u32Tmp;
003138  e1800001          ORR      r0,r0,r1
00313c  ea000000          B        |L1.12612|
                  |L1.12608|
;;;2035       }
;;;2036       else
;;;2037       {
;;;2038           u32PinStat &= ~u32Tmp;
003140  e1c00001          BIC      r0,r0,r1
                  |L1.12612|
;;;2039       }
;;;2040   
;;;2041       vSetGDCPTCR(GDC0, u32PinStat);
003144  e59f4724          LDR      r4,|L1.14448|
003148  e5840000          STR      r0,[r4,#0]  ; u32GDCPTCR_REG__Var
;;;2042       /* Copy register data to shadow register: */
;;;2043       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
00314c  e5944000          LDR      r4,[r4,#0]  ; u32GDCPTCR_REG__Var
003150  e51f5844          LDR      r5,|L1.10516|
003154  e5854148          STR      r4,[r5,#0x148]
;;;2044   }
003158  e8bd8030          POP      {r4,r5,pc}
;;;2045   
                          ENDP

                  vGDC_SetPnlPositiveSyncSelect PROC
;;;2046   /****************************************************************************/
;;;2047   void vGDC_SetPnlPositiveSyncSelect(gdc_ppsync_e eSync)
00315c  e59f170c          LDR      r1,|L1.14448|
;;;2048   {
;;;2049       /* API valid only for GDC0 : */
;;;2050       vSetGDCPTCR_PPSYNC(GDC0, eSync);
003160  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003164  e7c71390          BFI      r1,r0,#7,#1
003168  e59f2700          LDR      r2,|L1.14448|
00316c  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2051       /* PPSYNC: belongs to low word of register: */
;;;2052       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003170  e2821000          ADD      r1,r2,#0
003174  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003178  e51f286c          LDR      r2,|L1.10516|
00317c  e5821148          STR      r1,[r2,#0x148]
;;;2053   }
003180  e12fff1e          BX       lr
;;;2054   
                          ENDP

                  boGDC_IsPnlRSPowerUpFinished PROC
;;;2055   /****************************************************************************/
;;;2056   bool_t boGDC_IsPnlRSPowerUpFinished(void)
003184  e3a00000          MOV      r0,#0
;;;2057   {
;;;2058       bool_t boRes = C_FALSE;
;;;2059       
;;;2060       /* API valid only for GDC0 : */
;;;2061       if( biGetGDCPTCR_RSPUP(GDC0) )
003188  e51f187c          LDR      r1,|L1.10516|
00318c  e5911148          LDR      r1,[r1,#0x148]
003190  e7e01a51          UBFX     r1,r1,#20,#1
003194  e3510000          CMP      r1,#0
003198  0a000000          BEQ      |L1.12704|
;;;2062       {
;;;2063           boRes = C_TRUE;
00319c  e3a00001          MOV      r0,#1
                  |L1.12704|
;;;2064       }
;;;2065       return boRes;
;;;2066   }
0031a0  e12fff1e          BX       lr
;;;2067   
                          ENDP

                  boGDC_IsPnlRSReady PROC
;;;2068   /****************************************************************************/
;;;2069   bool_t boGDC_IsPnlRSReady(void)
0031a4  e3a00000          MOV      r0,#0
;;;2070   {
;;;2071       bool_t boRes = C_FALSE;
;;;2072       
;;;2073       /* API valid only for GDC0 : */
;;;2074       if( biGetGDCPTCR_RSDRDY(GDC0) )
0031a8  e51f189c          LDR      r1,|L1.10516|
0031ac  e5911148          LDR      r1,[r1,#0x148]
0031b0  e7e01ad1          UBFX     r1,r1,#21,#1
0031b4  e3510000          CMP      r1,#0
0031b8  0a000000          BEQ      |L1.12736|
;;;2075       {
;;;2076           boRes = C_TRUE;
0031bc  e3a00001          MOV      r0,#1
                  |L1.12736|
;;;2077       }
;;;2078       return boRes;
;;;2079   }
0031c0  e12fff1e          BX       lr
;;;2080   
                          ENDP

                  vGDC_SetPnlRSDSEnable PROC
;;;2081   /****************************************************************************/
;;;2082   void vGDC_SetPnlRSDSEnable(gdc_rsdsen_e eOutput)
0031c4  e59f16a4          LDR      r1,|L1.14448|
;;;2083   {
;;;2084       /* API valid only for GDC0 : */
;;;2085       vSetGDCPTCR_RSDSEN(GDC0, eOutput);
0031c8  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0031cc  e7d61b10          BFI      r1,r0,#22,#1
0031d0  e59f2698          LDR      r2,|L1.14448|
0031d4  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2086       /* RSDSEN: belongs to low word of register: */
;;;2087       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
0031d8  e2821000          ADD      r1,r2,#0
0031dc  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0031e0  e51f28d4          LDR      r2,|L1.10516|
0031e4  e5821148          STR      r1,[r2,#0x148]
;;;2088   }
0031e8  e12fff1e          BX       lr
;;;2089   
                          ENDP

                  vGDC_SetPnlSyncModeEnable PROC
;;;2090   /****************************************************************************/
;;;2091   void vGDC_SetPnlSyncModeEnable(gdc_en_e eEn)
0031ec  e59f167c          LDR      r1,|L1.14448|
;;;2092   {
;;;2093       /* API valid only for GDC0 : */
;;;2094       vSetGDCPTCR_PSMEN(GDC0, eEn);
0031f0  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0031f4  e7d71b90          BFI      r1,r0,#23,#1
0031f8  e59f2670          LDR      r2,|L1.14448|
0031fc  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2095       /* PSMEN: belongs to low word of register: */
;;;2096       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003200  e2821000          ADD      r1,r2,#0
003204  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003208  e51f28fc          LDR      r2,|L1.10516|
00320c  e5821148          STR      r1,[r2,#0x148]
;;;2097   }
003210  e12fff1e          BX       lr
;;;2098   
                          ENDP

                  vGDC_SetPnlRSDSOutputCurrentMode PROC
;;;2099   /****************************************************************************/
;;;2100   void vGDC_SetPnlRSDSOutputCurrentMode(gdc_rsdsoutmode_e eOutMode)
003214  e59f1654          LDR      r1,|L1.14448|
;;;2101   {
;;;2102       /* API valid only for GDC0 : */
;;;2103       vSetGDCPTCR_OCMD(GDC0, eOutMode);
003218  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
00321c  e7d91c10          BFI      r1,r0,#24,#2
003220  e59f2648          LDR      r2,|L1.14448|
003224  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2104       /* OCMD: belongs to low word of register: */
;;;2105       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003228  e2821000          ADD      r1,r2,#0
00322c  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003230  e51f2924          LDR      r2,|L1.10516|
003234  e5821148          STR      r1,[r2,#0x148]
;;;2106   }
003238  e12fff1e          BX       lr
;;;2107   
                          ENDP

                  vGDC_SetPnlRSDSPreEmphasisMode PROC
;;;2108   /****************************************************************************/
;;;2109   void vGDC_SetPnlRSDSPreEmphasisMode(gdc_rsdspreemp_e ePreEmp)
00323c  e59f162c          LDR      r1,|L1.14448|
;;;2110   {
;;;2111       /* API valid only for GDC0 : */
;;;2112       vSetGDCPTCR_PEMD(GDC0, ePreEmp);
003240  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003244  e7db1d10          BFI      r1,r0,#26,#2
003248  e59f2620          LDR      r2,|L1.14448|
00324c  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2113       /* PEMD: belongs to low word of register: */
;;;2114       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003250  e2821000          ADD      r1,r2,#0
003254  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003258  e51f294c          LDR      r2,|L1.10516|
00325c  e5821148          STR      r1,[r2,#0x148]
;;;2115   }
003260  e12fff1e          BX       lr
;;;2116   
                          ENDP

                  vGDC_SetPnlRSDSHighImpedanceEnable PROC
;;;2117   /****************************************************************************/
;;;2118   void vGDC_SetPnlRSDSHighImpedanceEnable(gdc_en_e eEn)
003264  e59f1604          LDR      r1,|L1.14448|
;;;2119   {
;;;2120       /* API valid only for GDC0 : */
;;;2121       vSetGDCPTCR_HIZEN(GDC0, eEn);
003268  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
00326c  e7dc1e10          BFI      r1,r0,#28,#1
003270  e59f25f8          LDR      r2,|L1.14448|
003274  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2122       /* HIZEN: belongs to low word of register: */
;;;2123       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003278  e2821000          ADD      r1,r2,#0
00327c  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003280  e51f2974          LDR      r2,|L1.10516|
003284  e5821148          STR      r1,[r2,#0x148]
;;;2124   }
003288  e12fff1e          BX       lr
;;;2125   
                          ENDP

                  boGDC_IsPnlInputSync PROC
;;;2126   /****************************************************************************/
;;;2127   bool_t boGDC_IsPnlInputSync(void)
00328c  e3a00000          MOV      r0,#0
;;;2128   {
;;;2129       bool_t boRes = C_FALSE;
;;;2130   
;;;2131       /* API valid only for GDC0 : */
;;;2132       if( biGetGDCPTCR_PSYNC(GDC0) )
003290  e51f1984          LDR      r1,|L1.10516|
003294  e5911148          LDR      r1,[r1,#0x148]
003298  e7e01f51          UBFX     r1,r1,#30,#1
00329c  e3510000          CMP      r1,#0
0032a0  0a000000          BEQ      |L1.12968|
;;;2133       {
;;;2134           boRes = C_TRUE;
0032a4  e3a00001          MOV      r0,#1
                  |L1.12968|
;;;2135       }
;;;2136       return boRes;
;;;2137   }
0032a8  e12fff1e          BX       lr
;;;2138   /****************************************************************************/
                          ENDP

                  boGDC_IsPnlTimingControlInterfaceEnabled PROC
;;;2139   bool_t boGDC_IsPnlTimingControlInterfaceEnabled(void)
0032ac  e3a00000          MOV      r0,#0
;;;2140   {
;;;2141       bool_t boRes = C_FALSE;
;;;2142   
;;;2143       /* API valid only for GDC0 : */
;;;2144       if( biGetGDCPTCR_PTCEN(GDC0) )
0032b0  e51f19a4          LDR      r1,|L1.10516|
0032b4  e5911148          LDR      r1,[r1,#0x148]
0032b8  e1a01fa1          LSR      r1,r1,#31
0032bc  e3510000          CMP      r1,#0
0032c0  0a000000          BEQ      |L1.13000|
;;;2145       {
;;;2146           boRes = C_TRUE;
0032c4  e3a00001          MOV      r0,#1
                  |L1.13000|
;;;2147       }
;;;2148       return boRes;
;;;2149   }
0032c8  e12fff1e          BX       lr
;;;2150   
                          ENDP

                  vGDC_SetAlignData PROC
;;;2151   /****************************************************************************/
;;;2152   void vGDC_SetAlignData(gdc_ddal_e eAllign)
0032cc  e59f159c          LDR      r1,|L1.14448|
;;;2153   {
;;;2154       /* API valid only for GDC0 : */
;;;2155       vSetGDCPTCR_DDAL(GDC0, eAllign);
0032d0  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0032d4  e7c61310          BFI      r1,r0,#6,#1
0032d8  e59f2590          LDR      r2,|L1.14448|
0032dc  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2156       /* DDAL: belongs to low word of register: */
;;;2157       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
0032e0  e2821000          ADD      r1,r2,#0
0032e4  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0032e8  e51f29dc          LDR      r2,|L1.10516|
0032ec  e5821148          STR      r1,[r2,#0x148]
;;;2158   }
0032f0  e12fff1e          BX       lr
;;;2159   
                          ENDP

                  vGDC_SetPnlAlignClock PROC
;;;2161   /****************************************************************************/
;;;2162   void vGDC_SetPnlAlignClock(gdc_dcal_e eEdge)
0032f4  e59f1574          LDR      r1,|L1.14448|
;;;2163   {
;;;2164       /* API valid only for GDC0 : */
;;;2165       vSetGDCPTCR_DCAL(GDC0, eEdge);
0032f8  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0032fc  e7c51290          BFI      r1,r0,#5,#1
003300  e59f2568          LDR      r2,|L1.14448|
003304  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2166       /* DCAL: belongs to low word of register: */
;;;2167       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003308  e2821000          ADD      r1,r2,#0
00330c  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003310  e51f2a04          LDR      r2,|L1.10516|
003314  e5821148          STR      r1,[r2,#0x148]
;;;2168   }
003318  e12fff1e          BX       lr
;;;2169   
                          ENDP

                  vGDC_PnlAlterEnable PROC
;;;2171   /****************************************************************************/
;;;2172   void vGDC_PnlAlterEnable(gdc_en_e eEn)
00331c  e59f154c          LDR      r1,|L1.14448|
;;;2173   {
;;;2174       /* API valid only for GDC0 : */
;;;2175       vSetGDCPTCR_ALT(GDC0, eEn);
003320  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003324  e7c41210          BFI      r1,r0,#4,#1
003328  e59f2540          LDR      r2,|L1.14448|
00332c  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2176       /* ALT: belongs to low word of register: */
;;;2177       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003330  e2821000          ADD      r1,r2,#0
003334  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003338  e51f2a2c          LDR      r2,|L1.10516|
00333c  e5821148          STR      r1,[r2,#0x148]
;;;2178   }
003340  e12fff1e          BX       lr
;;;2179   
                          ENDP

                  vGDC_PnlEvenDataInvEnable PROC
;;;2181   /****************************************************************************/
;;;2182   void vGDC_PnlEvenDataInvEnable(gdc_en_e eEn)
003344  e59f1524          LDR      r1,|L1.14448|
;;;2183   {
;;;2184       /* API valid only for GDC0 : */
;;;2185       vSetGDCPTCR_EINVEN(GDC0, eEn);
003348  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
00334c  e7c31190          BFI      r1,r0,#3,#1
003350  e59f2518          LDR      r2,|L1.14448|
003354  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2186       /* EINVEN: belongs to low word of register: */
;;;2187       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003358  e2821000          ADD      r1,r2,#0
00335c  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003360  e51f2a54          LDR      r2,|L1.10516|
003364  e5821148          STR      r1,[r2,#0x148]
;;;2188   }
003368  e12fff1e          BX       lr
;;;2189   
                          ENDP

                  vGDC_PnlEvenRgbOutEnable PROC
;;;2191   /****************************************************************************/
;;;2192   void vGDC_PnlEvenRgbOutEnable(gdc_en_e eEn)
00336c  e59f14fc          LDR      r1,|L1.14448|
;;;2193   {
;;;2194       /* API valid only for GDC0 : */
;;;2195       vSetGDCPTCR_ERGBEN(GDC0, eEn);
003370  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003374  e7c21110          BFI      r1,r0,#2,#1
003378  e59f24f0          LDR      r2,|L1.14448|
00337c  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2196       /* ERGBEN: belongs to low word of register: */
;;;2197       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
003380  e2821000          ADD      r1,r2,#0
003384  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
003388  e51f2a7c          LDR      r2,|L1.10516|
00338c  e5821148          STR      r1,[r2,#0x148]
;;;2198   }
003390  e12fff1e          BX       lr
;;;2199   
                          ENDP

                  vGDC_PnlOddDataInvEnable PROC
;;;2201   /****************************************************************************/
;;;2202   void vGDC_PnlOddDataInvEnable(gdc_en_e eEn)
003394  e59f14d4          LDR      r1,|L1.14448|
;;;2203   {
;;;2204       /* API valid only for GDC0 : */
;;;2205       vSetGDCPTCR_OINVEN(GDC0, eEn);
003398  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
00339c  e7c11090          BFI      r1,r0,#1,#1
0033a0  e59f24c8          LDR      r2,|L1.14448|
0033a4  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2206       /* OINVEN: belongs to low word of register: */
;;;2207       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
0033a8  e2821000          ADD      r1,r2,#0
0033ac  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0033b0  e51f2aa4          LDR      r2,|L1.10516|
0033b4  e5821148          STR      r1,[r2,#0x148]
;;;2208   }
0033b8  e12fff1e          BX       lr
;;;2209   
                          ENDP

                  vGDC_PnlOddRgbOutEnable PROC
;;;2211   /****************************************************************************/
;;;2212   void vGDC_PnlOddRgbOutEnable(gdc_en_e eEn)
0033bc  e59f14ac          LDR      r1,|L1.14448|
;;;2213   {
;;;2214       /* API valid only for GDC0 : */
;;;2215       vSetGDCPTCR_ORGBEN(GDC0, eEn);
0033c0  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0033c4  e7c01010          BFI      r1,r0,#0,#1
0033c8  e59f24a0          LDR      r2,|L1.14448|
0033cc  e5821000          STR      r1,[r2,#0]  ; u32GDCPTCR_REG__Var
;;;2216       /* ORGBEN: belongs to low word of register: */
;;;2217       UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
0033d0  e2821000          ADD      r1,r2,#0
0033d4  e5911000          LDR      r1,[r1,#0]  ; u32GDCPTCR_REG__Var
0033d8  e51f2acc          LDR      r2,|L1.10516|
0033dc  e5821148          STR      r1,[r2,#0x148]
;;;2218   }
0033e0  e12fff1e          BX       lr
;;;2219   
                          ENDP

                  i32GDC_PnlSyncMode PROC
;;;2220   /****************************************************************************/
;;;2221   int32_t i32GDC_PnlSyncMode(uint16_t u16PnlSyncModeDelay, uint8_t u8PnlSyncDataDelay)
0033e4  e92d4010          PUSH     {r4,lr}
;;;2222   {
0033e8  e1a02000          MOV      r2,r0
;;;2223       int32_t iRes = C_SUCCESS;
0033ec  e3a00000          MOV      r0,#0
;;;2224   
;;;2225       /* API valid only for GDC0 : */
;;;2226       /* parameter range check: */
;;;2227       if ( (u16PnlSyncModeDelay<7) || (u16PnlSyncModeDelay>2047) )
0033f0  e3520007          CMP      r2,#7
0033f4  ba000001          BLT      |L1.13312|
0033f8  e3520b02          CMP      r2,#0x800
0033fc  ba000001          BLT      |L1.13320|
                  |L1.13312|
;;;2228       {
;;;2229           iRes = C_FAILED; 
003400  e3e00000          MVN      r0,#0
003404  ea000010          B        |L1.13388|
                  |L1.13320|
;;;2230       }
;;;2231       else
;;;2232       {
;;;2233           if (u8PnlSyncDataDelay>15) 
003408  e351000f          CMP      r1,#0xf
00340c  da000001          BLE      |L1.13336|
;;;2234           {
;;;2235               iRes = C_FAILED; 
003410  e3e00000          MVN      r0,#0
003414  ea00000c          B        |L1.13388|
                  |L1.13336|
;;;2236           }
;;;2237           else
;;;2238           {
;;;2239               vSetGDCPSMR_PSDEL(GDC0, u16PnlSyncModeDelay);
003418  e59f3454          LDR      r3,|L1.14452|
00341c  e5933000          LDR      r3,[r3,#0]  ; u32GDCPSMR_REG__Var
003420  e7ca3012          BFI      r3,r2,#0,#11
003424  e59f4448          LDR      r4,|L1.14452|
003428  e5843000          STR      r3,[r4,#0]  ; u32GDCPSMR_REG__Var
;;;2240               vSetGDCPSMR_PSDDEL(GDC0, u8PnlSyncDataDelay);
00342c  e2843000          ADD      r3,r4,#0
003430  e5933000          LDR      r3,[r3,#0]  ; u32GDCPSMR_REG__Var
003434  e7d33811          BFI      r3,r1,#16,#4
003438  e5843000          STR      r3,[r4,#0]  ; u32GDCPSMR_REG__Var
;;;2241               
;;;2242               /* PSDEL & PSDDEL: belong to low word of register: */
;;;2243               UPDATE_REGISTER_LOW_WORD(GDC0, GDCPSMR_REG__, u32GDCPSMR_REG__Var[GDC0]);
00343c  e2843000          ADD      r3,r4,#0
003440  e5933000          LDR      r3,[r3,#0]  ; u32GDCPSMR_REG__Var
003444  e51f4b38          LDR      r4,|L1.10516|
003448  e5843228          STR      r3,[r4,#0x228]
                  |L1.13388|
;;;2244           }
;;;2245       }
;;;2246       return iRes;
;;;2247   }
00344c  e8bd8010          POP      {r4,pc}
;;;2248   
                          ENDP

                  vGDC_APCConfigure PROC
;;;2250   /****************************************************************************/
;;;2251   void vGDC_APCConfigure(gdc_ch_e eGDC, gdc_apccfg_st* pstCfg)
003450  e92d4030          PUSH     {r4,r5,lr}
;;;2252   {
;;;2253   #ifdef HW_UPDATE_BUG_FIXED
;;;2254       gdc_reg_update_mode_e  eLastUpdateMode;
;;;2255   #endif
;;;2256       if (0x00 != pstCfg)
003454  e3510000          CMP      r1,#0
003458  0a00004a          BEQ      |L1.13704|
;;;2257       {
;;;2258           
;;;2259           /* General */
;;;2260           vSetAPCCR_APCAUTO(eGDC, pstCfg->eMode);
00345c  e5d14000          LDRB     r4,[r1,#0]
003460  e59f2410          LDR      r2,|L1.14456|
003464  e0822180          ADD      r2,r2,r0,LSL #3
003468  e1c220d0          LDRD     r2,r3,[r2,#0]
00346c  e7de2f14          BFI      r2,r4,#30,#1
003470  e59f4400          LDR      r4,|L1.14456|
003474  e0844180          ADD      r4,r4,r0,LSL #3
003478  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2261           vSetAPCCR_APCCHKFR(eGDC, pstCfg->u8Frames);
00347c  e5d14001          LDRB     r4,[r1,#1]
003480  e59f23f0          LDR      r2,|L1.14456|
003484  e0822180          ADD      r2,r2,r0,LSL #3
003488  e1c220d0          LDRD     r2,r3,[r2,#0]
00348c  e7c62014          BFI      r2,r4,#0,#7
003490  e59f43e0          LDR      r4,|L1.14456|
003494  e0844180          ADD      r4,r4,r0,LSL #3
003498  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2262   
;;;2263           /* Compare window definition */
;;;2264           vSetAPCCWR_CWWIDTH(eGDC, pstCfg->u8WWidth);
00349c  e5d14002          LDRB     r4,[r1,#2]
0034a0  e59f23d4          LDR      r2,|L1.14460|
0034a4  e0822180          ADD      r2,r2,r0,LSL #3
0034a8  e1c220d0          LDRD     r2,r3,[r2,#0]
0034ac  e7d73814          BFI      r3,r4,#16,#8
0034b0  e59f43c4          LDR      r4,|L1.14460|
0034b4  e0844180          ADD      r4,r4,r0,LSL #3
0034b8  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2265           vSetAPCCWR_CWHEIGHT(eGDC, pstCfg->u8WHeight);
0034bc  e5d14003          LDRB     r4,[r1,#3]
0034c0  e59f23b4          LDR      r2,|L1.14460|
0034c4  e0822180          ADD      r2,r2,r0,LSL #3
0034c8  e1c220d0          LDRD     r2,r3,[r2,#0]
0034cc  e7c63014          BFI      r3,r4,#0,#7
0034d0  e59f43a4          LDR      r4,|L1.14460|
0034d4  e0844180          ADD      r4,r4,r0,LSL #3
0034d8  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2266           vSetAPCCWR_HCWS(eGDC, pstCfg->u16HStart);
0034dc  e1d140b4          LDRH     r4,[r1,#4]
0034e0  e59f2394          LDR      r2,|L1.14460|
0034e4  e0822180          ADD      r2,r2,r0,LSL #3
0034e8  e1c220d0          LDRD     r2,r3,[r2,#0]
0034ec  e7db2814          BFI      r2,r4,#16,#12
0034f0  e59f4384          LDR      r4,|L1.14460|
0034f4  e0844180          ADD      r4,r4,r0,LSL #3
0034f8  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2267           vSetAPCCWR_VCWS(eGDC, pstCfg->u16VStart);
0034fc  e1d140b6          LDRH     r4,[r1,#6]
003500  e59f2374          LDR      r2,|L1.14460|
003504  e0822180          ADD      r2,r2,r0,LSL #3
003508  e1c220d0          LDRD     r2,r3,[r2,#0]
00350c  e7ca2014          BFI      r2,r4,#0,#11
003510  e59f4364          LDR      r4,|L1.14460|
003514  e0844180          ADD      r4,r4,r0,LSL #3
003518  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2268   
;;;2269           /* Expected checksum */
;;;2270           vSetAPCCSR_EXPCHKSUM(eGDC, pstCfg->u32AutoChkSum);
00351c  e59f235c          LDR      r2,|L1.14464|
003520  e0822180          ADD      r2,r2,r0,LSL #3
003524  e5914008          LDR      r4,[r1,#8]
003528  e1c220d0          LDRD     r2,r3,[r2,#0]
00352c  e7d53014          BFI      r3,r4,#0,#22
003530  e59f4348          LDR      r4,|L1.14464|
003534  e0844180          ADD      r4,r4,r0,LSL #3
003538  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2271           
;;;2272   #ifdef HW_UPDATE_BUG_FIXED
;;;2273           /* get last actual update mode for later restore:*/
;;;2274            eLastUpdateMode = eGetShadowRegUpdateStatus(eGDC);
;;;2275   
;;;2276            /* Disable Update Mode if it was not disabled: */
;;;2277            if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
;;;2278            {
;;;2279                vGDC_SetShadowRegUpdateMode(eGDC, GDC_NO_UPDATE_BY_VSYNC);
;;;2280            }
;;;2281   #endif
;;;2282   
;;;2283           UPDATE_REGISTER_LOW_WORD (eGDC, APCCR_REG__,  u64APCCR_REG__Var[eGDC]);
00353c  e59f2334          LDR      r2,|L1.14456|
003540  e0822180          ADD      r2,r2,r0,LSL #3
003544  e1c220d0          LDRD     r2,r3,[r2,#0]
003548  e51f4c3c          LDR      r4,|L1.10516|
00354c  e0843600          ADD      r3,r4,r0,LSL #12
003550  e5832300          STR      r2,[r3,#0x300]
;;;2284           UPDATE_REGISTER_HIGH_WORD(eGDC, APCCSR_REG__, u64APCCSR_REG__Var[eGDC]);
003554  e59f2324          LDR      r2,|L1.14464|
003558  e0822180          ADD      r2,r2,r0,LSL #3
00355c  e1c220d0          LDRD     r2,r3,[r2,#0]
003560  e1a02003          MOV      r2,r3
003564  e2843e31          ADD      r3,r4,#0x310
003568  e0833600          ADD      r3,r3,r0,LSL #12
00356c  e5832004          STR      r2,[r3,#4]
;;;2285           UPDATE_REGISTER_64BITS   (eGDC, APCCWR_REG__, u64APCCWR_REG__Var[eGDC]);
003570  e59f2304          LDR      r2,|L1.14460|
003574  e0822180          ADD      r2,r2,r0,LSL #3
003578  e1c220d0          LDRD     r2,r3,[r2,#0]
00357c  e2845fc2          ADD      r5,r4,#0x308
003580  e0854600          ADD      r4,r5,r0,LSL #12
003584  e1c420f0          STRD     r2,r3,[r4,#0]
                  |L1.13704|
;;;2286   
;;;2287   #ifdef HW_UPDATE_BUG_FIXED
;;;2288           /* restore Update Mode if necessary */
;;;2289           if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
;;;2290           {
;;;2291               vGDC_SetShadowRegUpdateMode(eGDC, eLastUpdateMode);
;;;2292           }
;;;2293   #endif
;;;2294       }
;;;2295   }
003588  e8bd8030          POP      {r4,r5,pc}
;;;2296   
                          ENDP

                  vGDC_APCEnable PROC
;;;2298   /****************************************************************************/
;;;2299   void vGDC_APCEnable(gdc_ch_e eGDC, gdc_en_e eEn)
00358c  e92d4010          PUSH     {r4,lr}
;;;2300   {
;;;2301       /* Enable/disable */
;;;2302       vSetAPCCR_APCON(eGDC, eEn);
003590  e59f22e0          LDR      r2,|L1.14456|
003594  e0822180          ADD      r2,r2,r0,LSL #3
003598  e1c220d0          LDRD     r2,r3,[r2,#0]
00359c  e7df2f91          BFI      r2,r1,#31,#1
0035a0  e59f42d0          LDR      r4,|L1.14456|
0035a4  e0844180          ADD      r4,r4,r0,LSL #3
0035a8  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2303       /* APCON: belongs to low word of register: */
;;;2304       UPDATE_REGISTER_LOW_WORD(eGDC, APCCR_REG__, u64APCCR_REG__Var[eGDC]);
0035ac  e59f22c4          LDR      r2,|L1.14456|
0035b0  e0822180          ADD      r2,r2,r0,LSL #3
0035b4  e1c220d0          LDRD     r2,r3,[r2,#0]
0035b8  e51f4cac          LDR      r4,|L1.10516|
0035bc  e0843600          ADD      r3,r4,r0,LSL #12
0035c0  e5832300          STR      r2,[r3,#0x300]
;;;2305   }
0035c4  e8bd8010          POP      {r4,pc}
;;;2306   
                          ENDP

                  boGDC_IsAPCError PROC
;;;2308   /****************************************************************************/
;;;2309   bool_t boGDC_IsAPCError(gdc_ch_e eGDC)
0035c8  e1a01000          MOV      r1,r0
;;;2310   {
;;;2311       bool_t boRes = C_FALSE;
0035cc  e3a00000          MOV      r0,#0
;;;2312   
;;;2313       if( biGetAPCCR_APCCHKERR(eGDC) )
0035d0  e59f32ac          LDR      r3,|L1.14468|
0035d4  e0832601          ADD      r2,r3,r1,LSL #12
0035d8  e1c220d0          LDRD     r2,r3,[r2,#0]
0035dc  e7e023d2          UBFX     r2,r2,#7,#1
0035e0  e3520000          CMP      r2,#0
0035e4  0a000000          BEQ      |L1.13804|
;;;2314       {
;;;2315           boRes = C_TRUE;
0035e8  e3a00001          MOV      r0,#1
                  |L1.13804|
;;;2316       }
;;;2317       return boRes;
;;;2318   }
0035ec  e12fff1e          BX       lr
;;;2319   
                          ENDP

                  vGDC_SetAPCCR_PolynomialGen PROC
;;;2321   /****************************************************************************/
;;;2322   void vGDC_SetAPCCR_PolynomialGen(gdc_ch_e eGDC, uint8_t u8PgValue)
0035f0  e92d4010          PUSH     {r4,lr}
;;;2323   {
;;;2324       /* Set PG Value for APC : */
;;;2325       vSetAPCCR_APCPG(eGDC, u8PgValue);
0035f4  e59f227c          LDR      r2,|L1.14456|
0035f8  e0822180          ADD      r2,r2,r0,LSL #3
0035fc  e1c220d0          LDRD     r2,r3,[r2,#0]
003600  e7c63011          BFI      r3,r1,#0,#7
003604  e59f426c          LDR      r4,|L1.14456|
003608  e0844180          ADD      r4,r4,r0,LSL #3
00360c  e1c420f0          STRD     r2,r3,[r4,#0]
;;;2326       /* APCPG: belongs to high word of register: */
;;;2327       UPDATE_REGISTER_HIGH_WORD(eGDC, APCCR_REG__, u64APCCR_REG__Var[eGDC]);
003610  e59f2260          LDR      r2,|L1.14456|
003614  e0822180          ADD      r2,r2,r0,LSL #3
003618  e1c220d0          LDRD     r2,r3,[r2,#0]
00361c  e1a02003          MOV      r2,r3
003620  e59f325c          LDR      r3,|L1.14468|
003624  e0833600          ADD      r3,r3,r0,LSL #12
003628  e5832004          STR      r2,[r3,#4]
;;;2328   }
00362c  e8bd8010          POP      {r4,pc}
;;;2329   
                          ENDP

                  u32GDC_GetAPCResult PROC
;;;2331   /****************************************************************************/
;;;2332   uint32_t u32GDC_GetAPCResult(gdc_ch_e eGDC)
003630  e1a01000          MOV      r1,r0
;;;2333   {
;;;2334       /* Note: CURCHKSUM is a R/C Bit, it means after read CURCHKSUM will be reset!: */
;;;2335       return (uint32_t) biGetAPCCSR_CURCHKSUM(eGDC);
003634  e59f224c          LDR      r2,|L1.14472|
003638  e0820601          ADD      r0,r2,r1,LSL #12
00363c  e1c020d0          LDRD     r2,r3,[r0,#0]
003640  e59f0244          LDR      r0,|L1.14476|
003644  e0000002          AND      r0,r0,r2
;;;2336   }
003648  e12fff1e          BX       lr
;;;2337   
                          ENDP

                  u32GDC_GetAPCPixelVal PROC
;;;2339   /****************************************************************************/
;;;2340   uint32_t u32GDC_GetAPCPixelVal(gdc_ch_e eGDC, gdc_apcp_e ePix)
00364c  e92d4030          PUSH     {r4,r5,lr}
;;;2341   {
003650  e1a02000          MOV      r2,r0
003654  e1a03001          MOV      r3,r1
;;;2342       uint32_t u32Res;
;;;2343   
;;;2344       if( GDC_CURR_PIXVAL == ePix )
003658  e3530000          CMP      r3,#0
00365c  1a000003          BNE      |L1.13936|
;;;2345       {
;;;2346           u32Res = (uint32_t) (u64GetAPCPVR(eGDC));
003660  e59f4228          LDR      r4,|L1.14480|
003664  e0841602          ADD      r1,r4,r2,LSL #12
003668  e1c100d0          LDRD     r0,r1,[r1,#0]
00366c  ea000003          B        |L1.13952|
                  |L1.13936|
;;;2347       }
;;;2348       else
;;;2349       {
;;;2350           u32Res = (uint32_t) (u64GetAPCPVR(eGDC)>> 32);
003670  e59f4218          LDR      r4,|L1.14480|
003674  e0841602          ADD      r1,r4,r2,LSL #12
003678  e1c140d0          LDRD     r4,r5,[r1,#0]
00367c  e1a00005          MOV      r0,r5
                  |L1.13952|
;;;2351       }
;;;2352       return u32Res;
;;;2353   }
003680  e8bd8030          POP      {r4,r5,pc}
;;;2354   
                          ENDP

                  vGDC_SetGdcWriteProtection PROC
;;;2360    
;;;2361   void vGDC_SetGdcWriteProtection(gdc_ch_e eGDC, gdc_write_protect_e eProtection)
003684  e92d4010          PUSH     {r4,lr}
;;;2362   {
;;;2363       /* set protection level for GDC: */
;;;2364       vSetGDCPROTR_GDCWPL(eGDC, eProtection);
003688  e59f2204          LDR      r2,|L1.14484|
00368c  e7d22100          LDRB     r2,[r2,r0,LSL #2]
003690  e7c12011          BFI      r2,r1,#0,#2
003694  e59f31f8          LDR      r3,|L1.14484|
003698  e7c32100          STRB     r2,[r3,r0,LSL #2]
;;;2365       
;;;2366       /* GDCWPL: belongs to low word of register: */
;;;2367       UPDATE_REGISTER_LOW_WORD(eGDC, GDCPROTR_REG__, u32GDCPROTR_REG__Var[eGDC]);
00369c  e2832000          ADD      r2,r3,#0
0036a0  e7922100          LDR      r2,[r2,r0,LSL #2]
0036a4  e51f4d98          LDR      r4,|L1.10516|
0036a8  e0843600          ADD      r3,r4,r0,LSL #12
0036ac  e58322c0          STR      r2,[r3,#0x2c0]
;;;2368   }
0036b0  e8bd8010          POP      {r4,pc}
;;;2369   
                          ENDP

                  vGDC_SetApcWriteProtection PROC
;;;2371   /****************************************************************************/
;;;2372   void vGDC_SetApcWriteProtection(gdc_ch_e eGDC, gdc_write_protect_e eProtection)
0036b4  e92d4010          PUSH     {r4,lr}
;;;2373   {
;;;2374       /* set protection level for APC: */
;;;2375       vSetAPCPROTR_APCWPL(eGDC, eProtection);
0036b8  e59f21d8          LDR      r2,|L1.14488|
0036bc  e7d22100          LDRB     r2,[r2,r0,LSL #2]
0036c0  e7c12011          BFI      r2,r1,#0,#2
0036c4  e59f31cc          LDR      r3,|L1.14488|
0036c8  e7c32100          STRB     r2,[r3,r0,LSL #2]
;;;2376       
;;;2377       /* APCWPL: belongs to low word of register: */
;;;2378       UPDATE_REGISTER_LOW_WORD(eGDC, APCPROTR_REG__, u32APCPROTR_REG__Var[eGDC]);
0036cc  e2832000          ADD      r2,r3,#0
0036d0  e7922100          LDR      r2,[r2,r0,LSL #2]
0036d4  e51f4dc8          LDR      r4,|L1.10516|
0036d8  e0843600          ADD      r3,r4,r0,LSL #12
0036dc  e5832320          STR      r2,[r3,#0x320]
;;;2379   }
0036e0  e8bd8010          POP      {r4,pc}
;;;2380   
                          ENDP

                  boGDC_SetPulseGen PROC
;;;2382   /****************************************************************************/
;;;2383   bool_t boGDC_SetPulseGen(gdc_ch_e eGDC,
0036e4  e92d47f0          PUSH     {r4-r10,lr}
;;;2384                            gdc_pg_gen_id_e   ePGenID,
;;;2385                            gdc_pg_outsel_e   ePGenOut,
;;;2386                            gdc_pg_cgsel_e    ePGenClk,
;;;2387                            gdc_pg_trigger_e  ePGenTrig)
;;;2388   {
0036e8  e1a04000          MOV      r4,r0
0036ec  e1a05001          MOV      r5,r1
0036f0  e1a06002          MOV      r6,r2
0036f4  e1a07003          MOV      r7,r3
0036f8  e59de020          LDR      lr,[sp,#0x20]
;;;2389       uint8_t  u8shift;
;;;2390       bool_t   boRes = C_TRUE;
0036fc  e3a08001          MOV      r8,#1
;;;2391       uint32_t u32NewData, u32RegData, u32RegMask;
;;;2392       
;;;2393       /* program
;;;2394                    ePGenTrig, ePGenClk, ePGenOut
;;;2395        * +--------+---------+----------+---------+
;;;2396        * | 1 bit  |  3 bits |  1 bit   | 3 bits  |
;;;2397        * | resv.  |  TRIGx  |  CGSELx  | OUTSELx |
;;;2398        * +--------+---------+----------+---------+
;;;2399        */
;;;2400       u32NewData =  ((uint32_t)ePGenTrig & GDC_3_BIT_MASK) << 4;
003700  e1a00e8e          LSL      r0,lr,#29
003704  e1a02ca0          LSR      r2,r0,#25
;;;2401       u32NewData += ((uint32_t)ePGenClk  & GDC_1_BIT_MASK) << 3;
003708  e2070001          AND      r0,r7,#1
00370c  e0822180          ADD      r2,r2,r0,LSL #3
;;;2402       u32NewData += ((uint32_t)ePGenOut  & GDC_3_BIT_MASK);
003710  e2060007          AND      r0,r6,#7
003714  e0822000          ADD      r2,r2,r0
;;;2403       
;;;2404       u8shift = (ePGenID%4)*8;
003718  e1a00005          MOV      r0,r5
00371c  e1a09fc5          ASR      r9,r5,#31
003720  e0859f29          ADD      r9,r5,r9,LSR #30
003724  e1a09149          ASR      r9,r9,#2
003728  e0459109          SUB      r9,r5,r9,LSL #2
00372c  e1a09d89          LSL      r9,r9,#27
003730  e1a0cc29          LSR      r12,r9,#24
;;;2405       
;;;2406       u32NewData <<= u8shift;
003734  e1a02c12          LSL      r2,r2,r12
;;;2407       u32RegMask = GDC_8_BIT_MASK << u8shift;
003738  e3a000ff          MOV      r0,#0xff
00373c  e1a03c10          LSL      r3,r0,r12
;;;2408       switch( ePGenID )
003740  e355000c          CMP      r5,#0xc
003744  308ff105          ADDCC    pc,pc,r5,LSL #2
003748  ea000035          B        |L1.14372|
00374c  ea00000a          B        |L1.14204|
003750  ea00000b          B        |L1.14212|
003754  ea00000b          B        |L1.14216|
003758  ea00000b          B        |L1.14220|
00375c  ea000014          B        |L1.14260|
003760  ea000015          B        |L1.14268|
003764  ea000015          B        |L1.14272|
003768  ea000015          B        |L1.14276|
00376c  ea00001e          B        |L1.14316|
003770  ea00001f          B        |L1.14324|
003774  ea00001f          B        |L1.14328|
003778  ea00001f          B        |L1.14332|
                  |L1.14204|
;;;2409       {
;;;2410           case GDC_PULSE_GEN_0:
00377c  e320f000          NOP      
;;;2411           case GDC_PULSE_GEN_1:
003780  e320f000          NOP      
                  |L1.14212|
;;;2412           case GDC_PULSE_GEN_2:
003784  e320f000          NOP      
                  |L1.14216|
;;;2413           case GDC_PULSE_GEN_3:
003788  e320f000          NOP      
                  |L1.14220|
;;;2414               /* Register GDCGPCRA should be modfied, first get actual data: */
;;;2415               u32RegData = u32GetGDCGPCRA(eGDC);
00378c  e59f0108          LDR      r0,|L1.14492|
003790  e7901104          LDR      r1,[r0,r4,LSL #2]
;;;2416               /* delete related 8 bits: */
;;;2417               u32RegData &= ~u32RegMask;
003794  e1c11003          BIC      r1,r1,r3
;;;2418               
;;;2419               /* insert new bits and write it back: */
;;;2420               u32RegData |= u32NewData;
003798  e1811002          ORR      r1,r1,r2
;;;2421               vSetGDCGPCRA(eGDC, u32RegData);
00379c  e7801104          STR      r1,[r0,r4,LSL #2]
;;;2422               
;;;2423               /* Copy register data to shadow register: */
;;;2424               UPDATE_REGISTER_LOW_WORD(eGDC, GDCGPCRA_REG__, u32GDCGPCRA_REG__Var[eGDC]);
0037a0  e7900104          LDR      r0,[r0,r4,LSL #2]
0037a4  e51fae98          LDR      r10,|L1.10516|
0037a8  e08a9604          ADD      r9,r10,r4,LSL #12
0037ac  e5890150          STR      r0,[r9,#0x150]
;;;2425   
;;;2426               break;
0037b0  ea00001e          B        |L1.14384|
                  |L1.14260|
;;;2427   
;;;2428           case GDC_PULSE_GEN_4:
0037b4  e320f000          NOP      
;;;2429           case GDC_PULSE_GEN_5:
0037b8  e320f000          NOP      
                  |L1.14268|
;;;2430           case GDC_PULSE_GEN_6:
0037bc  e320f000          NOP      
                  |L1.14272|
;;;2431           case GDC_PULSE_GEN_7:
0037c0  e320f000          NOP      
                  |L1.14276|
;;;2432               /* Register GDCGPCRB should be modfied, first get actual data: */
;;;2433               u32RegData = u32GetGDCGPCRB(eGDC);
0037c4  e59f00d4          LDR      r0,|L1.14496|
0037c8  e7901104          LDR      r1,[r0,r4,LSL #2]
;;;2434               /* delete related 8 bits: */
;;;2435               u32RegData &= ~u32RegMask;
0037cc  e1c11003          BIC      r1,r1,r3
;;;2436               
;;;2437               /* insert new bits and write it back: */
;;;2438               u32RegData |= u32NewData;
0037d0  e1811002          ORR      r1,r1,r2
;;;2439               vSetGDCGPCRB(eGDC, u32RegData);
0037d4  e7801104          STR      r1,[r0,r4,LSL #2]
;;;2440               
;;;2441               /* Copy register data to shadow register: */
;;;2442               UPDATE_REGISTER_LOW_WORD(eGDC, GDCGPCRB_REG__, u32GDCGPCRB_REG__Var[eGDC]);
0037d8  e7900104          LDR      r0,[r0,r4,LSL #2]
0037dc  e51faed0          LDR      r10,|L1.10516|
0037e0  e08a9604          ADD      r9,r10,r4,LSL #12
0037e4  e5890158          STR      r0,[r9,#0x158]
;;;2443               break;
0037e8  ea000010          B        |L1.14384|
                  |L1.14316|
;;;2444   
;;;2445           case GDC_PULSE_GEN_8:
0037ec  e320f000          NOP      
;;;2446           case GDC_PULSE_GEN_9:
0037f0  e320f000          NOP      
                  |L1.14324|
;;;2447           case GDC_PULSE_GEN_10:
0037f4  e320f000          NOP      
                  |L1.14328|
;;;2448           case GDC_PULSE_GEN_11:
0037f8  e320f000          NOP      
                  |L1.14332|
;;;2449               /* Register GDCGPCRC should be modfied, first get actual data: */
;;;2450               u32RegData = u32GetGDCGPCRC(eGDC);
0037fc  e59f00a0          LDR      r0,|L1.14500|
003800  e7901104          LDR      r1,[r0,r4,LSL #2]
;;;2451               /* delete related 8 bits: */
;;;2452               u32RegData &= ~u32RegMask;
003804  e1c11003          BIC      r1,r1,r3
;;;2453               
;;;2454               /* insert new bits and write it back: */
;;;2455               u32RegData |= u32NewData;
003808  e1811002          ORR      r1,r1,r2
;;;2456               vSetGDCGPCRC(eGDC, u32RegData);
00380c  e7801104          STR      r1,[r0,r4,LSL #2]
;;;2457               
;;;2458               /* Copy register data to shadow register: */
;;;2459               UPDATE_REGISTER_LOW_WORD(eGDC, GDCGPCRC_REG__, u32GDCGPCRC_REG__Var[eGDC]);
003810  e7900104          LDR      r0,[r0,r4,LSL #2]
003814  e51faf08          LDR      r10,|L1.10516|
003818  e08a9604          ADD      r9,r10,r4,LSL #12
00381c  e5890160          STR      r0,[r9,#0x160]
;;;2460               break;
003820  ea000002          B        |L1.14384|
                  |L1.14372|
;;;2461   
;;;2462           default:
003824  e320f000          NOP      
;;;2463               /* Invalid Generator ID */
;;;2464               boRes = C_FALSE;
003828  e3a08000          MOV      r8,#0
;;;2465               break;
00382c  e320f000          NOP      
                  |L1.14384|
003830  e320f000          NOP                            ;2426
;;;2466       }
;;;2467   
;;;2468       return boRes;
003834  e1a00008          MOV      r0,r8
;;;2469   }
003838  e8bd87f0          POP      {r4-r10,pc}
                  |L1.14396|
                          DCD      u32GDCWSRA_REG__Var
                  |L1.14400|
                          DCD      u32GDCWSRB_REG__Var
                  |L1.14404|
                          DCD      u32GDCWSRC_REG__Var
                  |L1.14408|
                          DCD      u32GDCWSRD_REG__Var
                  |L1.14412|
                          DCD      u32GDCWSRE_REG__Var
                  |L1.14416|
                          DCD      u32GDCWARA_REG__Var
                  |L1.14420|
                          DCD      u32GDCWARB_REG__Var
                  |L1.14424|
                          DCD      u32GDCWARC_REG__Var
                  |L1.14428|
                          DCD      u32GDCWARD_REG__Var
                  |L1.14432|
                          DCD      u32GDCWARE_REG__Var
                  |L1.14436|
                          DCD      u32GDCHSR_REG__Var
                  |L1.14440|
                          DCD      u32GDCVSR_REG__Var
                  |L1.14444|
                          DCD      0xc0c02140
                  |L1.14448|
                          DCD      u32GDCPTCR_REG__Var
                  |L1.14452|
                          DCD      u32GDCPSMR_REG__Var
                  |L1.14456|
                          DCD      u64APCCR_REG__Var
                  |L1.14460|
                          DCD      u64APCCWR_REG__Var
                  |L1.14464|
                          DCD      u64APCCSR_REG__Var
                  |L1.14468|
                          DCD      0xc0c02300
                  |L1.14472|
                          DCD      0xc0c02310
                  |L1.14476|
                          DCD      0x003fffff
                  |L1.14480|
                          DCD      0xc0c02318
                  |L1.14484|
                          DCD      u32GDCPROTR_REG__Var
                  |L1.14488|
                          DCD      u32APCPROTR_REG__Var
                  |L1.14492|
                          DCD      u32GDCGPCRA_REG__Var
                  |L1.14496|
                          DCD      u32GDCGPCRB_REG__Var
                  |L1.14500|
                          DCD      u32GDCGPCRC_REG__Var
                          ENDP

                  boGDC_ConfigPulseGenA_B PROC
;;;2472   /****************************************************************************/
;;;2473   bool_t boGDC_ConfigPulseGenA_B(gdc_ch_e eGDC,
0038a8  e92d4fff          PUSH     {r0-r11,lr}
;;;2474                                  gdc_pg_gen_id_e      ePGenID,
;;;2475                                  gdc_pg_A_B_e         eGenA_B,
;;;2476                                  gdc_pulse_config_st* pstConfig)
;;;2477   
;;;2478   {
0038ac  e24dd074          SUB      sp,sp,#0x74
0038b0  e1a07000          MOV      r7,r0
0038b4  e1a08001          MOV      r8,r1
0038b8  e1a05003          MOV      r5,r3
;;;2479       uint8_t  u8Err = 0;
0038bc  e3a06000          MOV      r6,#0
;;;2480       bool_t   boRes = C_TRUE;
0038c0  e3a00001          MOV      r0,#1
0038c4  e58d0070          STR      r0,[sp,#0x70]
;;;2481       uint32_t u32RegData;
;;;2482       /* pulse generator properties: */
;;;2483       gdc_pg_active_level_e  eActiveLevel_x;    /* Pulse generator active level select: */
;;;2484       gdc_pg_input_e         eSelectedInput_x;  /* Pulse generator input signal select: */
;;;2485       gdc_en_e               eByPassEnb_x;      /* Pulse generator bypass enable: */
;;;2486       uint16_t               u16PulseDelay_x;   /* Delay of generated pulse */
;;;2487       gdc_pg_divider_e       ePulseDivider_x;   /* Divider value is defined by DIV+1 */
;;;2488       gdc_en_e               eInvertEnb_x;      /* Pulse generator inversion enable: */
;;;2489       uint16_t               u16PulseWidth_x;   /* Width of generated pulse, measured in dot clock cycles for all input sources but VSYNC and VDISP */
;;;2490       
;;;2491       uint32_t u32GDCPxGAR_array[12] = {GDCP0GAR_REG__, GDCP1GAR_REG__, GDCP2GAR_REG__,  GDCP3GAR_REG__,
0038c8  e3a02030          MOV      r2,#0x30
0038cc  e59f16b4          LDR      r1,|L1.16264|
0038d0  e28d0030          ADD      r0,sp,#0x30
0038d4  ebfffffe          BL       __aeabi_memcpy4
;;;2492                                         GDCP4GAR_REG__, GDCP5GAR_REG__, GDCP6GAR_REG__,  GDCP7GAR_REG__,
;;;2493                                         GDCP8GAR_REG__, GDCP9GAR_REG__, GDCP10GAR_REG__, GDCP11GAR_REG__
;;;2494                                         };
;;;2495       uint32_t u32GDCPxGBR_array[12] = {GDCP0GBR_REG__, GDCP1GBR_REG__, GDCP2GBR_REG__,  GDCP3GBR_REG__,
0038d8  e3a02030          MOV      r2,#0x30
0038dc  e59f16a8          LDR      r1,|L1.16268|
0038e0  e1a0000d          MOV      r0,sp
0038e4  ebfffffe          BL       __aeabi_memcpy4
;;;2496                                         GDCP4GBR_REG__, GDCP5GBR_REG__, GDCP6GBR_REG__,  GDCP7GBR_REG__,
;;;2497                                         GDCP8GBR_REG__, GDCP9GBR_REG__, GDCP10GBR_REG__, GDCP11GBR_REG__
;;;2498                                         };
;;;2499   
;;;2500       if ((0x00 == pstConfig) || (ePGenID > GDC_PULSE_GEN_11) )
0038e8  e3550000          CMP      r5,#0
0038ec  0a000001          BEQ      |L1.14584|
0038f0  e358000b          CMP      r8,#0xb
0038f4  da000002          BLE      |L1.14596|
                  |L1.14584|
;;;2501       {
;;;2502           boRes = C_FALSE;
0038f8  e3a00000          MOV      r0,#0
0038fc  e58d0070          STR      r0,[sp,#0x70]
003900  ea00005d          B        |L1.14972|
                  |L1.14596|
;;;2503       }
;;;2504       else
;;;2505       {
;;;2506           eActiveLevel_x   = pstConfig->eActiveLevel;
003904  e5d59000          LDRB     r9,[r5,#0]
;;;2507           eSelectedInput_x = pstConfig->eSelectedInput;
003908  e5d5a001          LDRB     r10,[r5,#1]
;;;2508           eByPassEnb_x     = pstConfig->eByPassEnb;
00390c  e5d5b002          LDRB     r11,[r5,#2]
;;;2509           u16PulseDelay_x  = pstConfig->u16PulseDelay;
003910  e1d500b4          LDRH     r0,[r5,#4]
003914  e58d006c          STR      r0,[sp,#0x6c]
;;;2510           ePulseDivider_x  = pstConfig->ePulseDivider;
003918  e5d50006          LDRB     r0,[r5,#6]
00391c  e58d0068          STR      r0,[sp,#0x68]
;;;2511           eInvertEnb_x     = pstConfig->eInvertEnb;
003920  e5d50007          LDRB     r0,[r5,#7]
003924  e58d0064          STR      r0,[sp,#0x64]
;;;2512           u16PulseWidth_x  = pstConfig->u16PulseWidth;
003928  e1d500b8          LDRH     r0,[r5,#8]
00392c  e58d0060          STR      r0,[sp,#0x60]
;;;2513           
;;;2514           /* check parameters: */
;;;2515           if ( (GDC_ACTIVE_LVL_0 != eActiveLevel_x) && (GDC_ACTIVE_LVL_1 != eActiveLevel_x) )
003930  e3590000          CMP      r9,#0
003934  0a000003          BEQ      |L1.14664|
003938  e3590001          CMP      r9,#1
00393c  0a000001          BEQ      |L1.14664|
;;;2516           {
;;;2517               u8Err++;
003940  e2860001          ADD      r0,r6,#1
003944  e20060ff          AND      r6,r0,#0xff
                  |L1.14664|
;;;2518           }
;;;2519           if ( (eSelectedInput_x < GDC_INP_DOTCLK) || (eSelectedInput_x > GDC_INP_PNL) )
003948  e35a0001          CMP      r10,#1
00394c  ba000001          BLT      |L1.14680|
003950  e35a0006          CMP      r10,#6
003954  da000001          BLE      |L1.14688|
                  |L1.14680|
;;;2520           {
;;;2521               u8Err++;
003958  e2860001          ADD      r0,r6,#1
00395c  e20060ff          AND      r6,r0,#0xff
                  |L1.14688|
;;;2522           }
;;;2523           if ( (GDC_DISABLE != eByPassEnb_x) && (GDC_ENABLE != eByPassEnb_x) )
003960  e35b0000          CMP      r11,#0
003964  0a000003          BEQ      |L1.14712|
003968  e35b0001          CMP      r11,#1
00396c  0a000001          BEQ      |L1.14712|
;;;2524           {
;;;2525               u8Err++;
003970  e2860001          ADD      r0,r6,#1
003974  e20060ff          AND      r6,r0,#0xff
                  |L1.14712|
;;;2526           }
;;;2527           if (u16PulseDelay_x > GDC_GADEL_MAX)
003978  e59d006c          LDR      r0,[sp,#0x6c]
00397c  e3500b01          CMP      r0,#0x400
003980  ba000001          BLT      |L1.14732|
;;;2528           {
;;;2529               u8Err++;
003984  e2860001          ADD      r0,r6,#1
003988  e20060ff          AND      r6,r0,#0xff
                  |L1.14732|
;;;2530           }
;;;2531           if (ePulseDivider_x > GDC_DIVIDER_16)
00398c  e59d0068          LDR      r0,[sp,#0x68]
003990  e350000f          CMP      r0,#0xf
003994  da000001          BLE      |L1.14752|
;;;2532           {
;;;2533               u8Err++;
003998  e2860001          ADD      r0,r6,#1
00399c  e20060ff          AND      r6,r0,#0xff
                  |L1.14752|
;;;2534           }
;;;2535           if ( (GDC_DISABLE != eInvertEnb_x) && (GDC_ENABLE != eInvertEnb_x) )
0039a0  e59d0064          LDR      r0,[sp,#0x64]
0039a4  e3500000          CMP      r0,#0
0039a8  0a000004          BEQ      |L1.14784|
0039ac  e59d0064          LDR      r0,[sp,#0x64]
0039b0  e3500001          CMP      r0,#1
0039b4  0a000001          BEQ      |L1.14784|
;;;2536           {
;;;2537               u8Err++;
0039b8  e2860001          ADD      r0,r6,#1
0039bc  e20060ff          AND      r6,r0,#0xff
                  |L1.14784|
;;;2538           }
;;;2539           if (u16PulseWidth_x > GDC_GAWID_MAX)
0039c0  e59d0060          LDR      r0,[sp,#0x60]
0039c4  e3500b01          CMP      r0,#0x400
0039c8  ba000001          BLT      |L1.14804|
;;;2540           {
;;;2541               u8Err++;
0039cc  e2860001          ADD      r0,r6,#1
0039d0  e20060ff          AND      r6,r0,#0xff
                  |L1.14804|
;;;2542           }
;;;2543           /* if no error by parameters: */
;;;2544           if (0x00 == u8Err)
0039d4  e3560000          CMP      r6,#0
0039d8  1a000010          BNE      |L1.14880|
;;;2545           {
;;;2546               /* program configuration of one shot pulse generator A or B:
;;;2547                * +-------+----------+-------+-----------+----------+-------+-----------+
;;;2548                * | 1 bit |  3 bits  | 1 bit |  11 bits  |  4 bits  | 1 bit |  11 bits  |
;;;2549                * | GALVL |  GAINSEL | GABYP |   GADEL   |  GADIV   | GAINV |   GAWID   |
;;;2550                * +-------+----------+-------+-----------+----------+-------+-----------+
;;;2551                */
;;;2552               u32RegData = eActiveLevel_x;
0039dc  e1a04009          MOV      r4,r9
;;;2553               u32RegData <<= GDC_PGEN_GAINSEL_BITS;
0039e0  e1a04184          LSL      r4,r4,#3
;;;2554   
;;;2555               u32RegData |= (uint32_t)eSelectedInput_x;
0039e4  e184400a          ORR      r4,r4,r10
;;;2556               u32RegData <<= GDC_PGEN_GABYP_BIT; 
0039e8  e1a04084          LSL      r4,r4,#1
;;;2557   
;;;2558               u32RegData |= (uint32_t)eByPassEnb_x;
0039ec  e184400b          ORR      r4,r4,r11
;;;2559               u32RegData <<= GDC_PGEN_GADEL_BIT;
0039f0  e1a04584          LSL      r4,r4,#11
;;;2560   
;;;2561               u32RegData |= u16PulseDelay_x;
0039f4  e59d006c          LDR      r0,[sp,#0x6c]
0039f8  e1844000          ORR      r4,r4,r0
;;;2562               u32RegData <<= GDC_PGEN_GADIV_BIT;
0039fc  e1a04204          LSL      r4,r4,#4
;;;2563   
;;;2564               u32RegData |= (uint32_t)ePulseDivider_x;
003a00  e59d0068          LDR      r0,[sp,#0x68]
003a04  e1844000          ORR      r4,r4,r0
;;;2565               u32RegData <<= GDC_PGEN_GAINV_BIT;
003a08  e1a04084          LSL      r4,r4,#1
;;;2566   
;;;2567               u32RegData |= (uint32_t)eInvertEnb_x;
003a0c  e59d0064          LDR      r0,[sp,#0x64]
003a10  e1844000          ORR      r4,r4,r0
;;;2568               u32RegData <<= GDC_PGEN_GAWID_BIT;
003a14  e1a04584          LSL      r4,r4,#11
;;;2569   
;;;2570               u32RegData |= u16PulseWidth_x;
003a18  e59d0060          LDR      r0,[sp,#0x60]
003a1c  e1844000          ORR      r4,r4,r0
                  |L1.14880|
;;;2571           }
;;;2572           if (GDC_PULSE_GEN_A == eGenA_B)
003a20  e59d007c          LDR      r0,[sp,#0x7c]
003a24  e3500000          CMP      r0,#0
003a28  1a000007          BNE      |L1.14924|
;;;2573           {
;;;2574               /* update back up of register in local variable: */
;;;2575               u32GDCPxGAR_REG__Var[eGDC][ePGenID] = u32RegData;
003a2c  e0870087          ADD      r0,r7,r7,LSL #1
003a30  e59f1558          LDR      r1,|L1.16272|
003a34  e0810200          ADD      r0,r1,r0,LSL #4
003a38  e7804108          STR      r4,[r0,r8,LSL #2]
;;;2576               
;;;2577               /* Copy GDCPxGAR (x:0..11) register data to shadow register: */
;;;2578               UPDATE_REGISTER_LOW_WORD(eGDC, u32GDCPxGAR_array[ePGenID], u32RegData);
003a3c  e28d0030          ADD      r0,sp,#0x30
003a40  e7900108          LDR      r0,[r0,r8,LSL #2]
003a44  e7804607          STR      r4,[r0,r7,LSL #12]
003a48  ea00000b          B        |L1.14972|
                  |L1.14924|
;;;2579           }
;;;2580           else if (GDC_PULSE_GEN_B == eGenA_B)
003a4c  e59d007c          LDR      r0,[sp,#0x7c]
003a50  e3500001          CMP      r0,#1
003a54  1a000006          BNE      |L1.14964|
;;;2581           {
;;;2582               /* update back up of register in local variable: */
;;;2583               u32GDCPxGBR_REG__Var[eGDC][ePGenID] = u32RegData;
003a58  e0870087          ADD      r0,r7,r7,LSL #1
003a5c  e59f1530          LDR      r1,|L1.16276|
003a60  e0810200          ADD      r0,r1,r0,LSL #4
003a64  e7804108          STR      r4,[r0,r8,LSL #2]
;;;2584               
;;;2585               /* Copy GDCPxGAR (x:0..11) register data to shadow register: */
;;;2586               UPDATE_REGISTER_LOW_WORD(eGDC, u32GDCPxGBR_array[ePGenID], u32RegData);
003a68  e79d0108          LDR      r0,[sp,r8,LSL #2]
003a6c  e7804607          STR      r4,[r0,r7,LSL #12]
003a70  ea000001          B        |L1.14972|
                  |L1.14964|
;;;2587           }
;;;2588           else
;;;2589           {
;;;2590               boRes = C_FALSE;
003a74  e3a00000          MOV      r0,#0
003a78  e58d0070          STR      r0,[sp,#0x70]
                  |L1.14972|
;;;2591           }
;;;2592       }
;;;2593       return boRes;
003a7c  e59d0070          LDR      r0,[sp,#0x70]
003a80  e28dd084          ADD      sp,sp,#0x84
;;;2594   }
003a84  e8bd8ff0          POP      {r4-r11,pc}
;;;2595   
                          ENDP

                  u16GDC_GetLastGAPIFColAddr PROC
;;;2597   /****************************************************************************/
;;;2598   uint16_t u16GDC_GetLastGAPIFColAddr(gdc_ch_e eGDC)
003a88  e1a01000          MOV      r1,r0
;;;2599   {
;;;2600       uint16_t u16LastColAddr;
;;;2601       /* Note: GCAR is R/C bits, so after read it will be reset to 0: */
;;;2602       u16LastColAddr = u16GetGDCGCAR(eGDC);
003a8c  e59f3504          LDR      r3,|L1.16280|
003a90  e0832601          ADD      r2,r3,r1,LSL #12
003a94  e1d20ab8          LDRH     r0,[r2,#0xa8]
;;;2603       
;;;2604       return u16LastColAddr;
;;;2605   }
003a98  e12fff1e          BX       lr
;;;2606   
                          ENDP

                  boGDC_GetBusErrAddr PROC
;;;2608   /****************************************************************************/
;;;2609   bool_t boGDC_GetBusErrAddr(gdc_ch_e eGDC, uint32_t* pu32BusErrAddr)
003a9c  e92d4030          PUSH     {r4,r5,lr}
;;;2610   {
003aa0  e1a02000          MOV      r2,r0
;;;2611       bool_t boRes = C_TRUE;
003aa4  e3a00001          MOV      r0,#1
;;;2612       uint32_t u32BusErrAddr;
;;;2613       if (0x00 != pu32BusErrAddr)
003aa8  e3510000          CMP      r1,#0
003aac  0a000004          BEQ      |L1.15044|
;;;2614       {
;;;2615           u32BusErrAddr = (uint32_t) u32GetGDCGBEAR(eGDC);
003ab0  e59f54e4          LDR      r5,|L1.16284|
003ab4  e0854602          ADD      r4,r5,r2,LSL #12
003ab8  e59432c8          LDR      r3,[r4,#0x2c8]
;;;2616           *pu32BusErrAddr = u32BusErrAddr;
003abc  e5813000          STR      r3,[r1,#0]
003ac0  ea000000          B        |L1.15048|
                  |L1.15044|
;;;2617       }
;;;2618       else
;;;2619       {
;;;2620           boRes = C_FALSE;
003ac4  e3a00000          MOV      r0,#0
                  |L1.15048|
;;;2621       }
;;;2622       return boRes;
;;;2623   }
003ac8  e8bd8030          POP      {r4,r5,pc}
;;;2624   
                          ENDP

                  boGDC_GetBusErrCtrlStatus PROC
;;;2625   /****************************************************************************/
;;;2626   bool_t boGDC_GetBusErrCtrlStatus(gdc_ch_e eGDC, gdc_bus_err_ctrl_st* pstCtrlStatus)
003acc  e92d4010          PUSH     {r4,lr}
;;;2627   {
003ad0  e1a02000          MOV      r2,r0
;;;2628       bool_t boRes = C_TRUE;
003ad4  e3a00001          MOV      r0,#1
;;;2629       if(0x00 != pstCtrlStatus)
003ad8  e3510000          CMP      r1,#0
003adc  0a00001d          BEQ      |L1.15192|
;;;2630       {
;;;2631           pstCtrlStatus->eDirection    = (gdc_buserr_dir_e) biGetGDCGBECR_WR(eGDC);
003ae0  e59f44b4          LDR      r4,|L1.16284|
003ae4  e0843602          ADD      r3,r4,r2,LSL #12
003ae8  e59332d0          LDR      r3,[r3,#0x2d0]
003aec  e2033001          AND      r3,r3,#1
003af0  e5c13000          STRB     r3,[r1,#0]
;;;2632           pstCtrlStatus->eBurstType    = (gdc_buserr_bursttype_e) biGetGDCGBECR_BTYPE(eGDC);
003af4  e0843602          ADD      r3,r4,r2,LSL #12
003af8  e59332d0          LDR      r3,[r3,#0x2d0]
003afc  e7e030d3          UBFX     r3,r3,#1,#1
003b00  e5c13001          STRB     r3,[r1,#1]
;;;2633           pstCtrlStatus->eBurstSize    = (gdc_buserr_burstsize_e) biGetGDCGBECR_BSIZE(eGDC);
003b04  e0843602          ADD      r3,r4,r2,LSL #12
003b08  e59332d0          LDR      r3,[r3,#0x2d0]
003b0c  e7e23153          UBFX     r3,r3,#2,#3
003b10  e5c13002          STRB     r3,[r1,#2]
;;;2634           pstCtrlStatus->eRespType     = (gdc_buserr_resptype_e) biGetGDCGBECR_RTYPE(eGDC);
003b14  e0843602          ADD      r3,r4,r2,LSL #12
003b18  e59332d0          LDR      r3,[r3,#0x2d0]
003b1c  e7e132d3          UBFX     r3,r3,#5,#2
003b20  e5c13003          STRB     r3,[r1,#3]
;;;2635           pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGDCGBECR_BEN(eGDC);
003b24  e0843602          ADD      r3,r4,r2,LSL #12
003b28  e59332d0          LDR      r3,[r3,#0x2d0]
003b2c  e1a03423          LSR      r3,r3,#8
003b30  e5c13004          STRB     r3,[r1,#4]
;;;2636           pstCtrlStatus->u8ID          = (uint8_t) biGetGDCGBECR_ID(eGDC);
003b34  e0843602          ADD      r3,r4,r2,LSL #12
003b38  e59332d0          LDR      r3,[r3,#0x2d0]
003b3c  e7e33853          UBFX     r3,r3,#16,#4
003b40  e5c13005          STRB     r3,[r1,#5]
;;;2637           pstCtrlStatus->u8BurstLength = (uint8_t) biGetGDCGBECR_LEN(eGDC);
003b44  e0843602          ADD      r3,r4,r2,LSL #12
003b48  e59332d0          LDR      r3,[r3,#0x2d0]
003b4c  e7e33a53          UBFX     r3,r3,#20,#4
003b50  e5c13006          STRB     r3,[r1,#6]
003b54  ea000000          B        |L1.15196|
                  |L1.15192|
;;;2638       }
;;;2639       else
;;;2640       {
;;;2641           boRes = C_FALSE;
003b58  e3a00000          MOV      r0,#0
                  |L1.15196|
;;;2642       }
;;;2643       return  boRes;
;;;2644   }
003b5c  e8bd8010          POP      {r4,pc}
;;;2645   
                          ENDP

                  eGDC_GetDcrBusErrors PROC
;;;2647   /****************************************************************************/
;;;2648   gdc_dcr_err_e eGDC_GetDcrBusErrors(gdc_ch_e eGDC)
003b60  e92d40f0          PUSH     {r4-r7,lr}
;;;2649   {
003b64  e1a03000          MOV      r3,r0
;;;2650       gdc_dcr_err_e  eRes;
;;;2651       uint64_t       u64GdcDcr_HW;
;;;2652       bool_t boRes_GBER   = C_FALSE;
003b68  e3a07000          MOV      r7,#0
;;;2653       bool_t boRes_GAPCOL = C_FALSE;
003b6c  e3a06000          MOV      r6,#0
;;;2654       
;;;2655       /* read HW register: */
;;;2656       u64GdcDcr_HW = READ_REGISTER_64BITS(GDCDCR_REG__ , eGDC);
003b70  e59f5424          LDR      r5,|L1.16284|
003b74  e0854603          ADD      r4,r5,r3,LSL #12
003b78  e1c440d0          LDRD     r4,r5,[r4,#0]
003b7c  e1a01004          MOV      r1,r4
003b80  e1a02005          MOV      r2,r5
003b84  e2014702          AND      r4,r1,#0x80000
003b88  e3a05000          MOV      r5,#0
003b8c  e0244005          EOR      r4,r4,r5
003b90  e0255005          EOR      r5,r5,r5
;;;2657       
;;;2658       /* check related bits: */
;;;2659       if (0x00 != (u64GdcDcr_HW & GDC_DCR_ERR_GBER_MASK))
003b94  e1944005          ORRS     r4,r4,r5
003b98  0a000000          BEQ      |L1.15264|
;;;2660       {
;;;2661           boRes_GBER = C_TRUE;
003b9c  e3a07001          MOV      r7,#1
                  |L1.15264|
003ba0  e3a04000          MOV      r4,#0
003ba4  e202c402          AND      r12,r2,#0x2000000
003ba8  e1a0e004          MOV      lr,r4
003bac  e0244004          EOR      r4,r4,r4
003bb0  e02e500c          EOR      r5,lr,r12
;;;2662       }
;;;2663       /* check related bits: */
;;;2664       if (0x00 != (u64GdcDcr_HW & GDC_DCR_ERR_GAPCOL_MASK))
003bb4  e1944005          ORRS     r4,r4,r5
003bb8  0a000000          BEQ      |L1.15296|
;;;2665       {
;;;2666           boRes_GAPCOL = C_TRUE;
003bbc  e3a06001          MOV      r6,#1
                  |L1.15296|
;;;2667       }
;;;2668       if (C_TRUE == boRes_GBER)
003bc0  e3570001          CMP      r7,#1
003bc4  1a000006          BNE      |L1.15332|
;;;2669       {
;;;2670           eRes = (C_TRUE == boRes_GAPCOL)? GDC_DCR_ERR_GBER_AND_GAPCOL : GDC_DCR_ERR_GBER;
003bc8  e3560001          CMP      r6,#1
003bcc  1a000001          BNE      |L1.15320|
003bd0  e3a04003          MOV      r4,#3
003bd4  ea000000          B        |L1.15324|
                  |L1.15320|
003bd8  e3a04001          MOV      r4,#1
                  |L1.15324|
003bdc  e1a00004          MOV      r0,r4
003be0  ea000004          B        |L1.15352|
                  |L1.15332|
;;;2671       }
;;;2672       else if (C_TRUE == boRes_GAPCOL)
003be4  e3560001          CMP      r6,#1
003be8  1a000001          BNE      |L1.15348|
;;;2673       {
;;;2674           eRes = GDC_DCR_ERR_GAPCOL;
003bec  e3a00002          MOV      r0,#2
003bf0  ea000000          B        |L1.15352|
                  |L1.15348|
;;;2675       }
;;;2676       else
;;;2677       {
;;;2678           eRes = GDC_DCR_ERR_NONE;
003bf4  e3a00000          MOV      r0,#0
                  |L1.15352|
;;;2679       }
;;;2680       return eRes;
;;;2681   }
003bf8  e8bd80f0          POP      {r4-r7,pc}
;;;2682   
                          ENDP

                  boGDC_ClrDcrBusErrors PROC
;;;2684   /****************************************************************************/
;;;2685   bool_t boGDC_ClrDcrBusErrors(gdc_ch_e eGDC, gdc_dcr_err_e eClrBits)
003bfc  e92d47f0          PUSH     {r4-r10,lr}
;;;2686   {
003c00  e1a04000          MOV      r4,r0
003c04  e1a07001          MOV      r7,r1
;;;2687       uint32_t u32Cntr;
;;;2688       uint64_t u64GdcDcr_HW;
;;;2689       bool_t boRes = C_TRUE;
003c08  e3a09001          MOV      r9,#1
;;;2690   
;;;2691       /* Important Not: 
;;;2692        * clear bits can not be written directly to shadow register, because it can happen that
;;;2693        * last modification of GDCDCR which are in shadow register but still waiting for VSYNC
;;;2694        * to be copied into HW register, will be overwritten:
;;;2695        *************/
;;;2696       switch(eClrBits)
003c0c  e3570001          CMP      r7,#1
003c10  0a000004          BEQ      |L1.15400|
003c14  e3570002          CMP      r7,#2
003c18  0a000010          BEQ      |L1.15456|
003c1c  e3570003          CMP      r7,#3
003c20  1a000025          BNE      |L1.15548|
003c24  ea000018          B        |L1.15500|
                  |L1.15400|
;;;2697       {
;;;2698           case GDC_DCR_ERR_GBER:
003c28  e320f000          NOP      
;;;2699               /* set GBER bit in local variable before write to shadow register: */
;;;2700               u64GDCDCR_REG__Var [eGDC] |= GDC_DCR_ERR_GBER_MASK;
003c2c  e59f036c          LDR      r0,|L1.16288|
003c30  e0800184          ADD      r0,r0,r4,LSL #3
003c34  e1c000d0          LDRD     r0,r1,[r0,#0]
003c38  e3800702          ORR      r0,r0,#0x80000
003c3c  e59f235c          LDR      r2,|L1.16288|
003c40  e0822184          ADD      r2,r2,r4,LSL #3
003c44  e1c200f0          STRD     r0,r1,[r2,#0]
;;;2701               /* GBER: belongs to low word of register: */
;;;2702               UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
003c48  e59f0350          LDR      r0,|L1.16288|
003c4c  e0800184          ADD      r0,r0,r4,LSL #3
003c50  e1c000d0          LDRD     r0,r1,[r0,#0]
003c54  e59f2340          LDR      r2,|L1.16284|
003c58  e7820604          STR      r0,[r2,r4,LSL #12]
;;;2703               break;
003c5c  ea000019          B        |L1.15560|
                  |L1.15456|
;;;2704               
;;;2705           case GDC_DCR_ERR_GAPCOL:
003c60  e320f000          NOP      
;;;2706               /* set GAPCOL bit in local variable before write to shadow register: */
;;;2707               u64GDCDCR_REG__Var [eGDC] |= GDC_DCR_ERR_GAPCOL_MASK;
003c64  e59f0334          LDR      r0,|L1.16288|
003c68  e0800184          ADD      r0,r0,r4,LSL #3
003c6c  e1c000d0          LDRD     r0,r1,[r0,#0]
003c70  e3811402          ORR      r1,r1,#0x2000000
003c74  e59f2324          LDR      r2,|L1.16288|
003c78  e0822184          ADD      r2,r2,r4,LSL #3
003c7c  e1c200f0          STRD     r0,r1,[r2,#0]
;;;2708               /* GAPCOL: belongs to high word of register: */
;;;2709               vUpdateDCR_HighWord_Special(eGDC);
003c80  e1a00004          MOV      r0,r4
003c84  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;2710               break;
003c88  ea00000e          B        |L1.15560|
                  |L1.15500|
;;;2711   
;;;2712           case GDC_DCR_ERR_GBER_AND_GAPCOL:
003c8c  e320f000          NOP      
;;;2713               /* set GBER and GAPCOL bit in local variable before write to shadow register: */
;;;2714               u64GDCDCR_REG__Var [eGDC] |= GDC_DCR_ERR_GBER_AND_GAPCOL_MASK;
003c90  e59f0308          LDR      r0,|L1.16288|
003c94  e0800184          ADD      r0,r0,r4,LSL #3
003c98  e1c000d0          LDRD     r0,r1,[r0,#0]
003c9c  e3800702          ORR      r0,r0,#0x80000
003ca0  e3811402          ORR      r1,r1,#0x2000000
003ca4  e59f22f4          LDR      r2,|L1.16288|
003ca8  e0822184          ADD      r2,r2,r4,LSL #3
003cac  e1c200f0          STRD     r0,r1,[r2,#0]
;;;2715               /* GBER and GAPCOL: belong to Low and high word of register: */
;;;2716               vUpdateDCR_Special(eGDC);
003cb0  e1a00004          MOV      r0,r4
003cb4  ebfffffe          BL       vUpdateDCR_Special
;;;2717               break;
003cb8  ea000002          B        |L1.15560|
                  |L1.15548|
;;;2718   
;;;2719           default:
003cbc  e320f000          NOP      
;;;2720               boRes = C_FALSE;
003cc0  e3a09000          MOV      r9,#0
;;;2721               break;
003cc4  e320f000          NOP      
                  |L1.15560|
003cc8  e320f000          NOP                            ;2703
;;;2722       }
;;;2723       if (C_TRUE == boRes)
003ccc  e3590001          CMP      r9,#1
003cd0  1a00002f          BNE      |L1.15764|
;;;2724       {
;;;2725           boRes = C_FALSE;
003cd4  e3a09000          MOV      r9,#0
;;;2726           /* set Loop Counter to 0 : */
;;;2727           u32Cntr = 0;
003cd8  e3a08000          MOV      r8,#0
;;;2728           /* Wait until Clear bit(s) is(are) reset: */
;;;2729           while ( (u32Cntr<MAX_WAIT_FOR_CLEAR) && (C_FALSE==boRes) )
003cdc  ea000028          B        |L1.15748|
                  |L1.15584|
;;;2730           {
;;;2731               u64GdcDcr_HW = READ_REGISTER_64BITS(GDCDCR_REG__ , eGDC);
003ce0  e59f12b4          LDR      r1,|L1.16284|
003ce4  e0810604          ADD      r0,r1,r4,LSL #12
003ce8  e1c000d0          LDRD     r0,r1,[r0,#0]
003cec  e1a05000          MOV      r5,r0
003cf0  e1a06001          MOV      r6,r1
;;;2732               switch(eClrBits)
003cf4  e3570001          CMP      r7,#1
003cf8  0a000002          BEQ      |L1.15624|
003cfc  e3570002          CMP      r7,#2
003d00  1a000013          BNE      |L1.15700|
003d04  ea000008          B        |L1.15660|
                  |L1.15624|
;;;2733               {
;;;2734               
;;;2735                   case GDC_DCR_ERR_GBER:
003d08  e320f000          NOP      
003d0c  e2050702          AND      r0,r5,#0x80000
003d10  e3a02000          MOV      r2,#0
003d14  e0200002          EOR      r0,r0,r2
003d18  e0221002          EOR      r1,r2,r2
;;;2736                       /* read clear bit from HW register, if it is 0 then clear has been done: */
;;;2737                       if (0x00 == (u64GdcDcr_HW & GDC_DCR_ERR_GBER_MASK))
003d1c  e1900001          ORRS     r0,r0,r1
003d20  1a000000          BNE      |L1.15656|
;;;2738                       {
;;;2739                           boRes = C_TRUE;
003d24  e3a09001          MOV      r9,#1
                  |L1.15656|
;;;2740                       }
;;;2741                       break;
003d28  ea000013          B        |L1.15740|
                  |L1.15660|
;;;2742                       
;;;2743                   case GDC_DCR_ERR_GAPCOL:
003d2c  e320f000          NOP      
003d30  e3a00000          MOV      r0,#0
003d34  e2062402          AND      r2,r6,#0x2000000
003d38  e1a03000          MOV      r3,r0
003d3c  e0200000          EOR      r0,r0,r0
003d40  e0231002          EOR      r1,r3,r2
;;;2744                       /* read clear bit from HW register, if it is 0 then clear has been done: */
;;;2745                       if (0x00 == (u64GdcDcr_HW & GDC_DCR_ERR_GAPCOL_MASK))
003d44  e1900001          ORRS     r0,r0,r1
003d48  1a000000          BNE      |L1.15696|
;;;2746                       {
;;;2747                           boRes = C_TRUE;
003d4c  e3a09001          MOV      r9,#1
                  |L1.15696|
;;;2748                       }
;;;2749                       break;
003d50  ea000009          B        |L1.15740|
                  |L1.15700|
;;;2750                       
;;;2751                   default:
003d54  e320f000          NOP      
003d58  e2051702          AND      r1,r5,#0x80000
003d5c  e2062402          AND      r2,r6,#0x2000000
003d60  e3a03000          MOV      r3,#0
003d64  e0211003          EOR      r1,r1,r3
003d68  e0230002          EOR      r0,r3,r2
;;;2752                       /* read both clear bits from HW register, if both are 0 then clear has been done: */
;;;2753                       if (0x00 == (u64GdcDcr_HW & GDC_DCR_ERR_GBER_AND_GAPCOL_MASK))
003d6c  e1900001          ORRS     r0,r0,r1
003d70  1a000000          BNE      |L1.15736|
;;;2754                       {
;;;2755                           boRes = C_TRUE;
003d74  e3a09001          MOV      r9,#1
                  |L1.15736|
;;;2756                       }
;;;2757                       break;
003d78  e320f000          NOP      
                  |L1.15740|
003d7c  e320f000          NOP                            ;2741
;;;2758               }
;;;2759               u32Cntr++;
003d80  e2888001          ADD      r8,r8,#1
                  |L1.15748|
003d84  e3580ffa          CMP      r8,#0x3e8             ;2729
003d88  2a000001          BCS      |L1.15764|
003d8c  e3590000          CMP      r9,#0                 ;2729
003d90  0affffd2          BEQ      |L1.15584|
                  |L1.15764|
;;;2760           } /* while .. */
;;;2761       }
;;;2762      /* Set clear bits in any case again to "0" in local variable: */
;;;2763      u64GDCDCR_REG__Var[eGDC] &= (~GDC_DCR_ERR_GBER_AND_GAPCOL_MASK);
003d94  e59f0204          LDR      r0,|L1.16288|
003d98  e0800184          ADD      r0,r0,r4,LSL #3
003d9c  e1c000d0          LDRD     r0,r1,[r0,#0]
003da0  e3c00702          BIC      r0,r0,#0x80000
003da4  e3c11402          BIC      r1,r1,#0x2000000
003da8  e59f21f0          LDR      r2,|L1.16288|
003dac  e0822184          ADD      r2,r2,r4,LSL #3
003db0  e1c200f0          STRD     r0,r1,[r2,#0]
;;;2764       
;;;2765      return boRes;
003db4  e1a00009          MOV      r0,r9
;;;2766   }
003db8  e8bd87f0          POP      {r4-r10,pc}
;;;2767   
                          ENDP

                  vGDC_GAPIFEnable PROC
;;;2769   /****************************************************************************/
;;;2770   void vGDC_GAPIFEnable(gdc_ch_e eGDC, gdc_en_e eEn)
003dbc  e92d4070          PUSH     {r4-r6,lr}
;;;2771   {
003dc0  e1a05000          MOV      r5,r0
003dc4  e1a04001          MOV      r4,r1
;;;2772       vSetGDCDCR_GAPEN(eGDC, eEn);
003dc8  e59f01d0          LDR      r0,|L1.16288|
003dcc  e0800185          ADD      r0,r0,r5,LSL #3
003dd0  e1c000d0          LDRD     r0,r1,[r0,#0]
003dd4  e7d81c14          BFI      r1,r4,#24,#1
003dd8  e59f21c0          LDR      r2,|L1.16288|
003ddc  e0822185          ADD      r2,r2,r5,LSL #3
003de0  e1c200f0          STRD     r0,r1,[r2,#0]
;;;2773       /* GAPEN: belongs to high word of register: */
;;;2774       /* GDCDCR register should be updated special: */  
;;;2775       vUpdateDCR_HighWord_Special(eGDC);
003de4  e1a00005          MOV      r0,r5
003de8  ebfffffe          BL       vUpdateDCR_HighWord_Special
;;;2776   }
003dec  e8bd8070          POP      {r4-r6,pc}
;;;2777   
                          ENDP

                  boGDC_AccessToGapif PROC
;;;2779   /****************************************************************************/
;;;2780   bool_t boGDC_AccessToGapif(gdc_ch_e eGDC)
003df0  e1a01000          MOV      r1,r0
;;;2781   {
;;;2782       bool_t boRes;
;;;2783       boRes = ( 0x00 == biGetGDCDCR_GAPACC(eGDC))? C_FALSE : C_TRUE;
003df4  e59f31a0          LDR      r3,|L1.16284|
003df8  e0832601          ADD      r2,r3,r1,LSL #12
003dfc  e1c220d0          LDRD     r2,r3,[r2,#0]
003e00  e7e02d53          UBFX     r2,r3,#26,#1
003e04  e3520000          CMP      r2,#0
003e08  0a000001          BEQ      |L1.15892|
003e0c  e3a02001          MOV      r2,#1
003e10  ea000000          B        |L1.15896|
                  |L1.15892|
003e14  e3a02000          MOV      r2,#0
                  |L1.15896|
003e18  e1a00002          MOV      r0,r2
;;;2784       return boRes;
;;;2785   }
003e1c  e12fff1e          BX       lr
;;;2786   
                          ENDP

                  eGDC_IsIrqGap PROC
;;;2788   /****************************************************************************/
;;;2789   gdc_irqact_e eGDC_IsIrqGap(gdc_ch_e eGDC)
003e20  e92d4030          PUSH     {r4,r5,lr}
;;;2790   {
003e24  e1a01000          MOV      r1,r0
;;;2791       int32_t i32IrqStat;
;;;2792       i32IrqStat = biGetGDCINTR_GAPINT(eGDC);
003e28  e51f25c4          LDR      r2,|L1.14444|
003e2c  e0820601          ADD      r0,r2,r1,LSL #12
003e30  e1c020d0          LDRD     r2,r3,[r0,#0]
003e34  e7e04252          UBFX     r4,r2,#4,#1
;;;2793   
;;;2794       /* Clear the flag if the interrupt is active */
;;;2795       if( 1 == i32IrqStat )
003e38  e3540001          CMP      r4,#1
003e3c  1a000007          BNE      |L1.15968|
003e40  e3a00001          MOV      r0,#1
;;;2796       {
;;;2797           /*
;;;2798            * Note:
;;;2799            *    By clearing GAPINT the error bit GAPCOL in GDCDCR register
;;;2800            *    will also be cleared. */
;;;2801           vClrGDCINTR_GAPINT(eGDC);
003e44  e51f35e0          LDR      r3,|L1.14444|
003e48  e0832601          ADD      r2,r3,r1,LSL #12
003e4c  e1c220d0          LDRD     r2,r3,[r2,#0]
003e50  e7c42210          BFI      r2,r0,#4,#1
003e54  e51f55f0          LDR      r5,|L1.14444|
003e58  e0850601          ADD      r0,r5,r1,LSL #12
003e5c  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.15968|
;;;2802       }
;;;2803   
;;;2804       return (gdc_irqact_e) i32IrqStat;
003e60  e20400ff          AND      r0,r4,#0xff
;;;2805   }
003e64  e8bd8030          POP      {r4,r5,pc}
;;;2806   
                          ENDP

                  eGDC_IsIrqGber PROC
;;;2808   /****************************************************************************/
;;;2809   gdc_irqact_e eGDC_IsIrqGber(gdc_ch_e eGDC)
003e68  e92d4030          PUSH     {r4,r5,lr}
;;;2810   {
003e6c  e1a01000          MOV      r1,r0
;;;2811       int32_t i32IrqStat;
;;;2812   
;;;2813       i32IrqStat = biGetGDCINTR_GBERINT(eGDC);
003e70  e51f260c          LDR      r2,|L1.14444|
003e74  e0820601          ADD      r0,r2,r1,LSL #12
003e78  e1c020d0          LDRD     r2,r3,[r0,#0]
003e7c  e7e043d2          UBFX     r4,r2,#7,#1
;;;2814   
;;;2815       /* Clear the flag if the interrupt is active */
;;;2816       if( 1 == i32IrqStat )
003e80  e3540001          CMP      r4,#1
003e84  1a000007          BNE      |L1.16040|
003e88  e3a00001          MOV      r0,#1
;;;2817       {
;;;2818           vClrGDCINTR_GBERINT(eGDC);
003e8c  e51f3628          LDR      r3,|L1.14444|
003e90  e0832601          ADD      r2,r3,r1,LSL #12
003e94  e1c220d0          LDRD     r2,r3,[r2,#0]
003e98  e7c72390          BFI      r2,r0,#7,#1
003e9c  e51f5638          LDR      r5,|L1.14444|
003ea0  e0850601          ADD      r0,r5,r1,LSL #12
003ea4  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.16040|
;;;2819       }
;;;2820   
;;;2821       return (gdc_irqact_e) i32IrqStat;
003ea8  e20400ff          AND      r0,r4,#0xff
;;;2822   }
003eac  e8bd8030          POP      {r4,r5,pc}
;;;2823   
                          ENDP

                  eGDC_IsIrqGpe PROC
;;;2825   /****************************************************************************/
;;;2826   gdc_irqact_e eGDC_IsIrqGpe(gdc_ch_e eGDC)
003eb0  e92d4030          PUSH     {r4,r5,lr}
;;;2827   {
003eb4  e1a01000          MOV      r1,r0
;;;2828       int32_t i32IrqStat;
;;;2829   
;;;2830       i32IrqStat = biGetGDCINTR_GPEINT(eGDC);
003eb8  e51f2654          LDR      r2,|L1.14444|
003ebc  e0820601          ADD      r0,r2,r1,LSL #12
003ec0  e1c020d0          LDRD     r2,r3,[r0,#0]
003ec4  e7e047d2          UBFX     r4,r2,#15,#1
;;;2831   
;;;2832       /* Clear the flag if the interrupt is active */
;;;2833       if( 1 == i32IrqStat )
003ec8  e3540001          CMP      r4,#1
003ecc  1a000007          BNE      |L1.16112|
003ed0  e3a00001          MOV      r0,#1
;;;2834       {
;;;2835           vClrGDCINTR_GPEINT(eGDC);
003ed4  e51f3670          LDR      r3,|L1.14444|
003ed8  e0832601          ADD      r2,r3,r1,LSL #12
003edc  e1c220d0          LDRD     r2,r3,[r2,#0]
003ee0  e7cf2790          BFI      r2,r0,#15,#1
003ee4  e51f5680          LDR      r5,|L1.14444|
003ee8  e0850601          ADD      r0,r5,r1,LSL #12
003eec  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.16112|
;;;2836       }
;;;2837   
;;;2838       return (gdc_irqact_e) i32IrqStat;
003ef0  e20400ff          AND      r0,r4,#0xff
;;;2839   }
003ef4  e8bd8030          POP      {r4,r5,pc}
;;;2840   
                          ENDP

                  eGDC_IsIrqDle PROC
;;;2842   /****************************************************************************/
;;;2843   gdc_irqact_e eGDC_IsIrqDle(gdc_ch_e eGDC)
003ef8  e92d4030          PUSH     {r4,r5,lr}
;;;2844   {
003efc  e1a01000          MOV      r1,r0
;;;2845       int32_t i32IrqStat;
;;;2846   
;;;2847       i32IrqStat = biGetGDCINTR_DLEINT(eGDC);
003f00  e51f269c          LDR      r2,|L1.14444|
003f04  e0820601          ADD      r0,r2,r1,LSL #12
003f08  e1c020d0          LDRD     r2,r3,[r0,#0]
003f0c  e1a04fa2          LSR      r4,r2,#31
;;;2848   
;;;2849       /* Clear the flag if the interrupt is active */
;;;2850       if( 1 == i32IrqStat )
003f10  e3540001          CMP      r4,#1
003f14  1a000007          BNE      |L1.16184|
003f18  e3a00001          MOV      r0,#1
;;;2851       {
;;;2852           vClrGDCINTR_DLEINT(eGDC);
003f1c  e51f36b8          LDR      r3,|L1.14444|
003f20  e0832601          ADD      r2,r3,r1,LSL #12
003f24  e1c220d0          LDRD     r2,r3,[r2,#0]
003f28  e7df2f90          BFI      r2,r0,#31,#1
003f2c  e51f56c8          LDR      r5,|L1.14444|
003f30  e0850601          ADD      r0,r5,r1,LSL #12
003f34  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.16184|
;;;2853       }
;;;2854   
;;;2855       return (gdc_irqact_e) i32IrqStat;
003f38  e20400ff          AND      r0,r4,#0xff
;;;2856   }
003f3c  e8bd8030          POP      {r4,r5,pc}
;;;2857   
                          ENDP

                  eGDC_IsIrqApe PROC
;;;2859   /****************************************************************************/
;;;2860   gdc_irqact_e eGDC_IsIrqApe(gdc_ch_e eGDC)
003f40  e92d4030          PUSH     {r4,r5,lr}
;;;2861   {
003f44  e1a01000          MOV      r1,r0
;;;2862       int32_t i32IrqStat;
;;;2863   
;;;2864       i32IrqStat = biGetGDCINTR_APEINT(eGDC);
003f48  e51f26e4          LDR      r2,|L1.14444|
003f4c  e0820601          ADD      r0,r2,r1,LSL #12
003f50  e1c020d0          LDRD     r2,r3,[r0,#0]
003f54  e7e042d3          UBFX     r4,r3,#5,#1
;;;2865   
;;;2866       /* Clear the flag if the interrupt is active */
;;;2867       if( 1 == i32IrqStat )
003f58  e3540001          CMP      r4,#1
003f5c  1a000007          BNE      |L1.16256|
003f60  e3a00001          MOV      r0,#1
;;;2868       {
;;;2869           vClrGDCINTR_APEINT(eGDC);
003f64  e51f3700          LDR      r3,|L1.14444|
003f68  e0832601          ADD      r2,r3,r1,LSL #12
003f6c  e1c220d0          LDRD     r2,r3,[r2,#0]
003f70  e7c53290          BFI      r3,r0,#5,#1
003f74  e51f5710          LDR      r5,|L1.14444|
003f78  e0850601          ADD      r0,r5,r1,LSL #12
003f7c  e1c020f0          STRD     r2,r3,[r0,#0]
                  |L1.16256|
;;;2870       }
;;;2871   
;;;2872       return (gdc_irqact_e) i32IrqStat;
003f80  e20400ff          AND      r0,r4,#0xff
;;;2873   }
003f84  e8bd8030          POP      {r4,r5,pc}
;;;2874   /*+-----------------------------------------------------------------------+*
                          ENDP

                  |L1.16264|
                          DCD      ||.constdata||
                  |L1.16268|
                          DCD      ||.constdata||+0x30
                  |L1.16272|
                          DCD      u32GDCPxGAR_REG__Var
                  |L1.16276|
                          DCD      u32GDCPxGBR_REG__Var
                  |L1.16280|
                          DCD      0xc0c02200
                  |L1.16284|
                          DCD      0xc0c02000
                  |L1.16288|
                          DCD      u64GDCDCR_REG__Var

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  u64GDCDCR_REG__Var
                          %        16
                  u64GDCCAVRA_REG__Var
                          %        16
                  u64GDCSCVRA_REG__Var
                          %        16
                  u64GDCSCVRB_REG__Var
                          %        16
                  u64GDCSCVRC_REG__Var
                          %        16
                  u64GDCSCVRD_REG__Var
                          %        16
                  u64APCCR_REG__Var
                          %        16
                  u64APCCWR_REG__Var
                          %        16
                  u64APCCSR_REG__Var
                          %        16
                  u32GDCPxGAR_REG__Var
                          %        96
                  u32GDCPxGBR_REG__Var
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0xc0c02168
                          DCD      0xc0c02170
                          DCD      0xc0c02178
                          DCD      0xc0c02180
                          DCD      0xc0c02188
                          DCD      0xc0c02190
                          DCD      0xc0c02198
                          DCD      0xc0c021a0
                          DCD      0xc0c021a8
                          DCD      0xc0c021b0
                          DCD      0xc0c021b8
                          DCD      0xc0c021c0
                          DCD      0xc0c021c8
                          DCD      0xc0c021d0
                          DCD      0xc0c021d8
                          DCD      0xc0c021e0
                          DCD      0xc0c021e8
                          DCD      0xc0c021f0
                          DCD      0xc0c021f8
                          DCD      0xc0c02200
                          DCD      0xc0c02208
                          DCD      0xc0c02210
                          DCD      0xc0c02218
                          DCD      0xc0c02220

                          AREA ||.data||, DATA, ALIGN=3

                  u32GDCLARA0_REG__Var
                          %        8
                  u32GDCLARA1_REG__Var
                          %        8
                  u32GDCWARA_REG__Var
                          %        8
                  u32GDCBGCR_REG__Var
                          %        8
                  u32GDCLARB0_REG__Var
                          %        8
                  u32GDCLARB1_REG__Var
                          %        8
                  u32GDCWARB_REG__Var
                          %        8
                  u32GDCLARC0_REG__Var
                          %        8
                  u32GDCLARC1_REG__Var
                          %        8
                  u32GDCLARD0_REG__Var
                          %        8
                  u32GDCLARD1_REG__Var
                          %        8
                  u32GDCMWRA_REG__Var
                          %        8
                  u32GDCMWRB_REG__Var
                          %        8
                  u32GDCMWRC_REG__Var
                          %        8
                  u32GDCMWRD_REG__Var
                          %        8
                  u32GDCMWRE_REG__Var
                          %        8
                  u32GDCLSRA_REG__Var
                          %        8
                  u32GDCLSRB_REG__Var
                          %        8
                  u32GDCLSRC_REG__Var
                          %        8
                  u32GDCLSRD_REG__Var
                          %        8
                  u32GDCLSRE_REG__Var
                          %        8
                  u32GDCLDRA_REG__Var
                          %        8
                  u32GDCLDRB_REG__Var
                          %        8
                  u32GDCLDRC_REG__Var
                          %        8
                  u32GDCLDRD_REG__Var
                          %        8
                  u32GDCLDRE_REG__Var
                          %        8
                  u32GDCWSRA_REG__Var
                          %        8
                  u32GDCWSRB_REG__Var
                          %        8
                  u32GDCWIMRA_REG__Var
                          %        8
                  u32GDCWIMRB_REG__Var
                          %        8
                  u32GDCCAVRB_REG__Var
                          %        8
                  u32GDCHSR_REG__Var
                          %        8
                  u32GDCVSR_REG__Var
                          %        8
                  u32GDCCBAR0_REG__Var
                          %        8
                  u32GDCCBAR1_REG__Var
                          %        8
                  u32GDCCBAR2_REG__Var
                          %        8
                  u32GDCPTCR_REG__Var
                          %        8
                  u32GDCGPCRA_REG__Var
                          %        8
                  u32GDCGPCRB_REG__Var
                          %        8
                  u32GDCGPCRC_REG__Var
                          %        8
                  u32GDCPSMR_REG__Var
                          %        8
                  u32GDCLARE0_REG__Var
                          %        8
                  u32GDCLARE1_REG__Var
                          %        8
                  u32GDCWARC_REG__Var
                          %        8
                  u32GDCWARD_REG__Var
                          %        8
                  u32GDCWARE_REG__Var
                          %        8
                  u32GDCWSRC_REG__Var
                          %        8
                  u32GDCWSRD_REG__Var
                          %        8
                  u32GDCWSRE_REG__Var
                          %        8
                  u32GDCWIMRC_REG__Var
                          %        8
                  u32GDCWIMRD_REG__Var
                          %        8
                  u32GDCWIMRE_REG__Var
                          %        8
                  u32GDCDSR_REG__Var
                          %        8
                  u32GDCDIMR_REG__Var
                          %        8
                  u32GDCPROTR_REG__Var
                          %        8
                  u32APCPROTR_REG__Var
                          %        8
                  au8LLDD_GDC_C_REVISION
0001c0  24526576          DCB      0x24,0x52,0x65,0x76
0001c4  6973696f          DCB      0x69,0x73,0x69,0x6f
0001c8  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
0001cc  2e313920          DCB      0x2e,0x31,0x39,0x20
0001d0  2400              DCB      0x24,0x00
                  au8LLDD_GDC_C_TAG
0001d2  244e              DCB      0x24,0x4e
0001d4  616d653a          DCB      0x61,0x6d,0x65,0x3a
0001d8  204c4c44          DCB      0x20,0x4c,0x4c,0x44
0001dc  445f315f          DCB      0x44,0x5f,0x31,0x5f
0001e0  375f4746          DCB      0x37,0x5f,0x47,0x46
0001e4  58202400          DCB      0x58,0x20,0x24,0x00
                  au8LLDD_GDC_H_REVISION
0001e8  24526576          DCB      0x24,0x52,0x65,0x76
0001ec  6973696f          DCB      0x69,0x73,0x69,0x6f
0001f0  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
0001f4  2e323020          DCB      0x2e,0x32,0x30,0x20
0001f8  2400              DCB      0x24,0x00
                  au8LLDD_GDC_H_TAG
0001fa  244e              DCB      0x24,0x4e
0001fc  616d653a          DCB      0x61,0x6d,0x65,0x3a
000200  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000204  445f315f          DCB      0x44,0x5f,0x31,0x5f
000208  375f4746          DCB      0x37,0x5f,0x47,0x46
00020c  58202400          DCB      0x58,0x20,0x24,0x00
                  au8LLDD_GDC_IO_H_REVISION
000210  24526576          DCB      0x24,0x52,0x65,0x76
000214  6973696f          DCB      0x69,0x73,0x69,0x6f
000218  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00021c  2e313220          DCB      0x2e,0x31,0x32,0x20
000220  2400              DCB      0x24,0x00
                  au8LLDD_GDC_IO_H_TAG
000222  244e              DCB      0x24,0x4e
000224  616d653a          DCB      0x61,0x6d,0x65,0x3a
000228  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00022c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000230  375f4746          DCB      0x37,0x5f,0x47,0x46
000234  58202400          DCB      0x58,0x20,0x24,0x00
