; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\iic.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\iic.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\iic.crf ..\..\..\..\lldd\src\iic.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  IIC_IO_ShadowSBI0CR1 PROC
;;;112     ***************************************************************************/
;;;113    static uint8_t IIC_IO_ShadowSBI0CR1(iic_io_RegSetGet_e eRegSetGet, uint8_t u8AllSubBits,
000000  e92d4070          PUSH     {r4-r6,lr}
;;;114                                        uint8_t u8NewSubBits, uint8_t u8BitsShift)
;;;115    {
000004  e1a04000          MOV      r4,r0
;;;116        static u8SBI0CR1_byte_view u8ShadowCrOne = IIC_IO_SBI0CR1_DEFAULT;
;;;117        u8SBI0CR1_byte_view u8RetVal = 0;
000008  e3a00000          MOV      r0,#0
;;;118        
;;;119        /* Prepare clear mask */
;;;120        u8AllSubBits = u8AllSubBits << u8BitsShift;
00000c  e1a05311          LSL      r5,r1,r3
000010  e20510ff          AND      r1,r5,#0xff
;;;121        /* Prepare set maks */
;;;122        u8NewSubBits = u8NewSubBits << u8BitsShift;
000014  e1a05312          LSL      r5,r2,r3
000018  e20520ff          AND      r2,r5,#0xff
;;;123        
;;;124        if( IIC_IO_SET == eRegSetGet )
00001c  e3540000          CMP      r4,#0
000020  1a00000f          BNE      |L1.100|
;;;125        {
;;;126            /*
;;;127               Clear all bits belonging to the group
;;;128               Set bits to be changed
;;;129               Perform real register update
;;;130               Update the return value
;;;131             */
;;;132            u8ShadowCrOne = (u8ShadowCrOne & ~u8AllSubBits);
000024  e59f5874          LDR      r5,|L1.2208|
000028  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowCrOne
00002c  e1c55001          BIC      r5,r5,r1
000030  e59f6868          LDR      r6,|L1.2208|
000034  e5c65000          STRB     r5,[r6,#0]  ; u8ShadowCrOne
;;;133            u8ShadowCrOne = u8ShadowCrOne | (u8NewSubBits);
000038  e2865000          ADD      r5,r6,#0
00003c  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowCrOne
000040  e1855002          ORR      r5,r5,r2
000044  e5c65000          STRB     r5,[r6,#0]  ; u8ShadowCrOne
;;;134            *pu8SBI0CR1 = u8ShadowCrOne;
000048  e2865000          ADD      r5,r6,#0
00004c  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowCrOne
000050  e59f684c          LDR      r6,|L1.2212|
000054  e5c65000          STRB     r5,[r6,#0]
;;;135            u8RetVal = u8ShadowCrOne;
000058  e59f5840          LDR      r5,|L1.2208|
00005c  e5d50000          LDRB     r0,[r5,#0]  ; u8ShadowCrOne
000060  ea000003          B        |L1.116|
                  |L1.100|
;;;136        }
;;;137        else
;;;138        {
;;;139            /* In this case return only interesting bits */
;;;140            u8RetVal = (u8ShadowCrOne & u8AllSubBits) >> u8BitsShift;
000064  e59f5834          LDR      r5,|L1.2208|
000068  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowCrOne
00006c  e0055001          AND      r5,r5,r1
000070  e1a00355          ASR      r0,r5,r3
                  |L1.116|
;;;141        }
;;;142        return u8RetVal;
;;;143    }
000074  e8bd8070          POP      {r4-r6,pc}
;;;144    
                          ENDP

                  IIC_IO_ShadowSBI0AR PROC
;;;256     ***************************************************************************/
;;;257    static uint8_t IIC_IO_ShadowSBI0AR(iic_io_RegSetGet_e eRegSetGet, uint8_t u8AllSubBits,
000078  e92d4070          PUSH     {r4-r6,lr}
;;;258                                       uint8_t u8NewSubBits, uint8_t u8BitsShift)
;;;259    {
00007c  e1a04000          MOV      r4,r0
;;;260        static u8SBI0AR_byte_view u8ShadowAr = IIC_IO_SBI0AR_DEFAULT;
;;;261        u8SBI0AR_byte_view u8RetVal = 0;
000080  e3a00000          MOV      r0,#0
;;;262        
;;;263        /* Prepare clear mask */
;;;264        u8AllSubBits = u8AllSubBits << u8BitsShift;
000084  e1a05311          LSL      r5,r1,r3
000088  e20510ff          AND      r1,r5,#0xff
;;;265        /* Prepare Set mask */
;;;266        u8NewSubBits = u8NewSubBits << u8BitsShift;
00008c  e1a05312          LSL      r5,r2,r3
000090  e20520ff          AND      r2,r5,#0xff
;;;267        
;;;268        if( IIC_IO_SET == eRegSetGet )
000094  e3540000          CMP      r4,#0
000098  1a00000f          BNE      |L1.220|
;;;269        {
;;;270            /*
;;;271                Clear all bits belonging to the group
;;;272                Set bits to be changed
;;;273                Perform real register update
;;;274                Update the return value
;;;275             */
;;;276            u8ShadowAr = (u8ShadowAr & ~u8AllSubBits);
00009c  e59f5804          LDR      r5,|L1.2216|
0000a0  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowAr
0000a4  e1c55001          BIC      r5,r5,r1
0000a8  e59f67f8          LDR      r6,|L1.2216|
0000ac  e5c65000          STRB     r5,[r6,#0]  ; u8ShadowAr
;;;277            u8ShadowAr = u8ShadowAr | (u8NewSubBits);
0000b0  e2865000          ADD      r5,r6,#0
0000b4  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowAr
0000b8  e1855002          ORR      r5,r5,r2
0000bc  e5c65000          STRB     r5,[r6,#0]  ; u8ShadowAr
;;;278            *pu8SBI0AR = u8ShadowAr;
0000c0  e2865000          ADD      r5,r6,#0
0000c4  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowAr
0000c8  e59f67d4          LDR      r6,|L1.2212|
0000cc  e5c65008          STRB     r5,[r6,#8]
;;;279            u8RetVal = u8ShadowAr;
0000d0  e59f57d0          LDR      r5,|L1.2216|
0000d4  e5d50000          LDRB     r0,[r5,#0]  ; u8ShadowAr
0000d8  ea000003          B        |L1.236|
                  |L1.220|
;;;280        }
;;;281        else
;;;282        {
;;;283            /* In this case return only the bits of interest */
;;;284            u8RetVal = (u8ShadowAr & u8AllSubBits) >> u8BitsShift;
0000dc  e59f57c4          LDR      r5,|L1.2216|
0000e0  e5d55000          LDRB     r5,[r5,#0]  ; u8ShadowAr
0000e4  e0055001          AND      r5,r5,r1
0000e8  e1a00355          ASR      r0,r5,r3
                  |L1.236|
;;;285        }
;;;286        return u8RetVal;
;;;287    }
0000ec  e8bd8070          POP      {r4-r6,pc}
;;;288    
                          ENDP

                  vIIC_GetVersion PROC
;;;54     /****************************************************************************/
;;;55     void vIIC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
0000f0  e92d4070          PUSH     {r4-r6,lr}
;;;56                          uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
;;;57                          uint8_t** pau8IORevision, uint8_t** pau8IOTag)
;;;58     {
0000f4  e1cd41d0          LDRD     r4,r5,[sp,#0x10]
;;;59        *pau8ModuleRevision = &au8LLDD_IIC_C_REVISION[0];
0000f8  e59f67ac          LDR      r6,|L1.2220|
0000fc  e5806000          STR      r6,[r0,#0]
;;;60        *pau8ModuleTag      = &au8LLDD_IIC_C_TAG[0];
000100  e59f67a8          LDR      r6,|L1.2224|
000104  e5816000          STR      r6,[r1,#0]
;;;61        *pau8HeaderRevision = &au8LLDD_IIC_H_REVISION[0];
000108  e59f67a4          LDR      r6,|L1.2228|
00010c  e5826000          STR      r6,[r2,#0]
;;;62        *pau8HeaderTag      = &au8LLDD_IIC_H_TAG[0];
000110  e59f67a0          LDR      r6,|L1.2232|
000114  e5836000          STR      r6,[r3,#0]
;;;63        *pau8IORevision     = &au8LLDD_IIC_IO_H_REVISION[0];
000118  e59f679c          LDR      r6,|L1.2236|
00011c  e5846000          STR      r6,[r4,#0]
;;;64        *pau8IOTag          = &au8LLDD_IIC_IO_H_TAG[0];
000120  e59f6798          LDR      r6,|L1.2240|
000124  e5856000          STR      r6,[r5,#0]
;;;65     }
000128  e8bd8070          POP      {r4-r6,pc}
;;;66     
                          ENDP

                  eIIC_SetSlaveAdr PROC
;;;197    /****************************************************************************/
;;;198    iic_InitErrors_e eIIC_SetSlaveAdr(uint8_t u8SlaveAdr)
00012c  e92d4070          PUSH     {r4-r6,lr}
;;;199    {
000130  e1a04000          MOV      r4,r0
;;;200        iic_InitErrors_e eInitErrorCode = IIC_INIT_OK;
000134  e3a05000          MOV      r5,#0
;;;201        
;;;202        if ((u8SlaveAdr > 0x00) && (u8SlaveAdr <= 0x7F))
000138  e3540000          CMP      r4,#0
00013c  da000007          BLE      |L1.352|
000140  e354007f          CMP      r4,#0x7f
000144  ca000005          BGT      |L1.352|
;;;203        {      
;;;204            vSetSBI0AR_SA(u8SlaveAdr);
000148  e3a03001          MOV      r3,#1
00014c  e1a02004          MOV      r2,r4
000150  e3a0107f          MOV      r1,#0x7f
000154  e3a00000          MOV      r0,#0
000158  ebfffffe          BL       IIC_IO_ShadowSBI0AR
00015c  ea000000          B        |L1.356|
                  |L1.352|
;;;205        }
;;;206        else
;;;207        {
;;;208            /* Wrong slave address */
;;;209            eInitErrorCode = IIC_INIT_SA_ERR; 
000160  e3a05004          MOV      r5,#4
                  |L1.356|
;;;210        }
;;;211        return eInitErrorCode;
000164  e1a00005          MOV      r0,r5
;;;212    }
000168  e8bd8070          POP      {r4-r6,pc}
;;;213    
                          ENDP

                  eIIC_SetOutClkFreq PROC
;;;146    /****************************************************************************/
;;;147    iic_InitErrors_e eIIC_SetOutClkFreq(iic_OutClkFreq_e eOutClkFreq)
00016c  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000170  e1a04000          MOV      r4,r0
;;;149        iic_InitErrors_e eInitErrorCode = IIC_INIT_OK;
000174  e3a05000          MOV      r5,#0
;;;150        uint8_t u8Clock_low;
;;;151        uint8_t u8Clock_high;
;;;152    
;;;153        u8Clock_low = IIC_OUTCLK_7_KHZ;
000178  e3a06006          MOV      r6,#6
;;;154        u8Clock_high = IIC_OUTCLK_340_KHZ;
00017c  e3a07000          MOV      r7,#0
;;;155    
;;;156        if( (eOutClkFreq < u8Clock_high) || (eOutClkFreq > u8Clock_low) )
000180  e1540007          CMP      r4,r7
000184  ba000001          BLT      |L1.400|
000188  e1540006          CMP      r4,r6
00018c  da000001          BLE      |L1.408|
                  |L1.400|
;;;157        {
;;;158            /* Invalid clock request */
;;;159            eInitErrorCode = IIC_INIT_SCK_ERR; 
000190  e3a05003          MOV      r5,#3
000194  ea000004          B        |L1.428|
                  |L1.408|
;;;160        }
;;;161        else
;;;162        {
;;;163            vSetSBI0CR1_SCK((uint8_t)eOutClkFreq);        
000198  e3a03000          MOV      r3,#0
00019c  e1a02004          MOV      r2,r4
0001a0  e3a01007          MOV      r1,#7
0001a4  e1a00003          MOV      r0,r3
0001a8  ebfffffe          BL       IIC_IO_ShadowSBI0CR1
                  |L1.428|
;;;164        }
;;;165        return eInitErrorCode;
0001ac  e1a00005          MOV      r0,r5
;;;166    }
0001b0  e8bd81f0          POP      {r4-r8,pc}
;;;167    
                          ENDP

                  eIIC_SetAckCycMode PROC
;;;169    /****************************************************************************/
;;;170    iic_InitErrors_e eIIC_SetAckCycMode(iic_AckCycle_e eAckCycle)
0001b4  e92d4070          PUSH     {r4-r6,lr}
;;;171    {
0001b8  e1a04000          MOV      r4,r0
;;;172        iic_InitErrors_e eInitErrorCode = IIC_INIT_OK;
0001bc  e3a05000          MOV      r5,#0
;;;173        
;;;174        if( (IIC_ACK_DISABLE == eAckCycle) || (IIC_ACK_ENABLE == eAckCycle) )
0001c0  e3540000          CMP      r4,#0
0001c4  0a000001          BEQ      |L1.464|
0001c8  e3540001          CMP      r4,#1
0001cc  1a000005          BNE      |L1.488|
                  |L1.464|
;;;175        {
;;;176            vSetSBI0CR1_ACK((uint8_t)eAckCycle);
0001d0  e3a03004          MOV      r3,#4
0001d4  e1a02004          MOV      r2,r4
0001d8  e3a01001          MOV      r1,#1
0001dc  e3a00000          MOV      r0,#0
0001e0  ebfffffe          BL       IIC_IO_ShadowSBI0CR1
0001e4  ea000000          B        |L1.492|
                  |L1.488|
;;;177        }
;;;178        else
;;;179        {
;;;180            /* Wrong acknowledge bit selection */
;;;181            eInitErrorCode = IIC_INIT_ACK_ERR; 
0001e8  e3a05002          MOV      r5,#2
                  |L1.492|
;;;182        }
;;;183        return eInitErrorCode;
0001ec  e1a00005          MOV      r0,r5
;;;184    }
0001f0  e8bd8070          POP      {r4-r6,pc}
;;;185    
                          ENDP

                  eIIC_SetNoOfBits PROC
;;;121    /****************************************************************************/
;;;122    iic_InitErrors_e eIIC_SetNoOfBits(iic_NoOfBits_e eNoOfBits)
0001f4  e92d41f0          PUSH     {r4-r8,lr}
;;;123    {
0001f8  e1a04000          MOV      r4,r0
;;;124        iic_InitErrors_e eInitErrorCode = IIC_INIT_OK;
0001fc  e3a05000          MOV      r5,#0
;;;125        uint8_t u8DataBits_7;
;;;126        uint8_t u8DataBits_8;
;;;127    
;;;128        u8DataBits_7 = IIC_DATA_BITS_7;
000200  e3a06007          MOV      r6,#7
;;;129        u8DataBits_8 = IIC_DATA_BITS_8;
000204  e3a07000          MOV      r7,#0
;;;130    
;;;131        /* The check may look strange, but it is based on the enumeration values */
;;;132        if( (eNoOfBits < u8DataBits_8) || (eNoOfBits > u8DataBits_7) )
000208  e1540007          CMP      r4,r7
00020c  ba000001          BLT      |L1.536|
000210  e1540006          CMP      r4,r6
000214  da000001          BLE      |L1.544|
                  |L1.536|
;;;133        {
;;;134            /* Invalid request */
;;;135            eInitErrorCode = IIC_INIT_BC_ERR;
000218  e3a05001          MOV      r5,#1
00021c  ea000004          B        |L1.564|
                  |L1.544|
;;;136        }
;;;137        else
;;;138        {
;;;139            vSetSBI0CR1_BC((uint8_t)eNoOfBits);
000220  e3a03005          MOV      r3,#5
000224  e1a02004          MOV      r2,r4
000228  e3a01007          MOV      r1,#7
00022c  e3a00000          MOV      r0,#0
000230  ebfffffe          BL       IIC_IO_ShadowSBI0CR1
                  |L1.564|
;;;140        }
;;;141        
;;;142        return eInitErrorCode;
000234  e1a00005          MOV      r0,r5
;;;143    }
000238  e8bd81f0          POP      {r4-r8,pc}
;;;144    
                          ENDP

                  vIIC_Reset PROC
;;;94     /****************************************************************************/
;;;95     void vIIC_Reset(void)
00023c  e92d4010          PUSH     {r4,lr}
;;;96     {
;;;97         /* Trigger reset */
;;;98         vSetSBI0CR2(IIC_1ST_RESET_VAL);
000240  e3a00002          MOV      r0,#2
000244  e59f1658          LDR      r1,|L1.2212|
000248  e5c1000c          STRB     r0,[r1,#0xc]
;;;99         vSetSBI0CR2(IIC_2ND_RESET_VAL);
00024c  e3a00001          MOV      r0,#1
000250  e5c1000c          STRB     r0,[r1,#0xc]
;;;100        
;;;101        /* Set the appropriate mode */
;;;102        vSetSBI0CR2(IIC_BUS_RELEASE_CONDITION);
000254  e3a00018          MOV      r0,#0x18
000258  e5c1000c          STRB     r0,[r1,#0xc]
;;;103        
;;;104        /* Update the shadow variables with the default values */
;;;105        vSetSBI0AR_DEFAULT();
00025c  e3a03000          MOV      r3,#0
000260  e1a02003          MOV      r2,r3
000264  e3a010ff          MOV      r1,#0xff
000268  e1a00003          MOV      r0,r3
00026c  ebfffffe          BL       IIC_IO_ShadowSBI0AR
;;;106        vSetSBI0CR1_DEFAULT();
000270  e3a03000          MOV      r3,#0
000274  e3a02009          MOV      r2,#9
000278  e3a010ff          MOV      r1,#0xff
00027c  e1a00003          MOV      r0,r3
000280  ebfffffe          BL       IIC_IO_ShadowSBI0CR1
;;;107    }
000284  e8bd8010          POP      {r4,pc}
;;;108    
                          ENDP

                  eIIC_Init PROC
;;;67     /****************************************************************************/
;;;68     iic_InitErrors_e eIIC_Init(iic_NoOfBits_e eNoOfBits, iic_AckCycle_e eAckCycle,
000288  e92d41f0          PUSH     {r4-r8,lr}
;;;69                                iic_OutClkFreq_e eOutClkFreq, uint8_t u8SlaveAdr)
;;;70     {
00028c  e1a08000          MOV      r8,r0
000290  e1a05001          MOV      r5,r1
000294  e1a06002          MOV      r6,r2
000298  e1a07003          MOV      r7,r3
;;;71         iic_InitErrors_e eInitErrorCode = IIC_INIT_OK;
00029c  e3a04000          MOV      r4,#0
;;;72         
;;;73         /* Reset the SBI module */
;;;74         vIIC_Reset();
0002a0  ebfffffe          BL       vIIC_Reset
;;;75     
;;;76         /* Perform initialization according to input parameters */
;;;77         eInitErrorCode = eIIC_SetNoOfBits(eNoOfBits);
0002a4  e1a00008          MOV      r0,r8
0002a8  ebfffffe          BL       eIIC_SetNoOfBits
0002ac  e1a04000          MOV      r4,r0
;;;78         if (eInitErrorCode == IIC_INIT_OK)
0002b0  e3540000          CMP      r4,#0
0002b4  1a00000c          BNE      |L1.748|
;;;79         {
;;;80             eInitErrorCode = eIIC_SetAckCycMode(eAckCycle);
0002b8  e1a00005          MOV      r0,r5
0002bc  ebfffffe          BL       eIIC_SetAckCycMode
0002c0  e1a04000          MOV      r4,r0
;;;81             if (eInitErrorCode == IIC_INIT_OK)
0002c4  e3540000          CMP      r4,#0
0002c8  1a000007          BNE      |L1.748|
;;;82             {
;;;83                 eInitErrorCode = eIIC_SetOutClkFreq(eOutClkFreq);
0002cc  e1a00006          MOV      r0,r6
0002d0  ebfffffe          BL       eIIC_SetOutClkFreq
0002d4  e1a04000          MOV      r4,r0
;;;84                 if(IIC_INIT_OK == eInitErrorCode)
0002d8  e3540000          CMP      r4,#0
0002dc  1a000002          BNE      |L1.748|
;;;85                 {
;;;86                     eInitErrorCode = eIIC_SetSlaveAdr(u8SlaveAdr);
0002e0  e1a00007          MOV      r0,r7
0002e4  ebfffffe          BL       eIIC_SetSlaveAdr
0002e8  e1a04000          MOV      r4,r0
                  |L1.748|
;;;87                 }
;;;88             }
;;;89         }
;;;90         return eInitErrorCode;
0002ec  e1a00004          MOV      r0,r4
;;;91     }
0002f0  e8bd81f0          POP      {r4-r8,pc}
;;;92     
                          ENDP

                  eIIC_GetNoOfBits PROC
;;;110    /****************************************************************************/
;;;111    iic_NoOfBits_e eIIC_GetNoOfBits(void)
0002f4  e92d4010          PUSH     {r4,lr}
;;;112    {
;;;113        iic_NoOfBits_e eReturn = IIC_DATA_BITS_8;
0002f8  e3a04000          MOV      r4,#0
;;;114        
;;;115        /* Get bits count */
;;;116        eReturn = (iic_NoOfBits_e)biGetSBI0CR1_BC();
0002fc  e3a03005          MOV      r3,#5
000300  e3a02000          MOV      r2,#0
000304  e3a01007          MOV      r1,#7
000308  e3a00001          MOV      r0,#1
00030c  ebfffffe          BL       IIC_IO_ShadowSBI0CR1
000310  e1a04000          MOV      r4,r0
;;;117        return eReturn;
000314  e1a00004          MOV      r0,r4
;;;118    }
000318  e8bd8010          POP      {r4,pc}
;;;119    
                          ENDP

                  eIIC_GetAckCycMode PROC
;;;187    /****************************************************************************/
;;;188    iic_AckCycle_e eIIC_GetAckCycMode(void)
00031c  e92d4010          PUSH     {r4,lr}
;;;189    {
;;;190        iic_AckCycle_e eReturn = IIC_ACK_DISABLE;
000320  e3a04000          MOV      r4,#0
;;;191        
;;;192        eReturn = (iic_AckCycle_e)biGetSBI0CR1_ACK ();
000324  e3a03004          MOV      r3,#4
000328  e3a02000          MOV      r2,#0
00032c  e3a01001          MOV      r1,#1
000330  e1a00001          MOV      r0,r1
000334  ebfffffe          BL       IIC_IO_ShadowSBI0CR1
000338  e1a04000          MOV      r4,r0
;;;193        return eReturn;
00033c  e1a00004          MOV      r0,r4
;;;194    }
000340  e8bd8010          POP      {r4,pc}
;;;195    
                          ENDP

                  eIIC_SetAdrRecMode PROC
;;;215    /****************************************************************************/
;;;216    iic_InitErrors_e eIIC_SetAdrRecMode(iic_AdrRecMode_e eAdrRecMode)
000344  e92d4070          PUSH     {r4-r6,lr}
;;;217    {
000348  e1a04000          MOV      r4,r0
;;;218        iic_InitErrors_e eInitErrorCode = IIC_INIT_OK;
00034c  e3a05000          MOV      r5,#0
;;;219        
;;;220        if( (IIC_ADR_REC_ENABLE == eAdrRecMode) || (IIC_ADR_REC_DISABLE == eAdrRecMode) )
000350  e3540000          CMP      r4,#0
000354  0a000001          BEQ      |L1.864|
000358  e3540001          CMP      r4,#1
00035c  1a000005          BNE      |L1.888|
                  |L1.864|
;;;221        {      
;;;222            vSetSBI0AR_ALS((uint8_t)(eAdrRecMode));
000360  e3a03000          MOV      r3,#0
000364  e1a02004          MOV      r2,r4
000368  e3a01001          MOV      r1,#1
00036c  e1a00003          MOV      r0,r3
000370  ebfffffe          BL       IIC_IO_ShadowSBI0AR
000374  ea000000          B        |L1.892|
                  |L1.888|
;;;223        }
;;;224        else
;;;225        {
;;;226            /* Wrong address recognition bit selection */
;;;227            eInitErrorCode = IIC_INIT_ALS_ERR; 
000378  e3a05005          MOV      r5,#5
                  |L1.892|
;;;228        }
;;;229        
;;;230        return eInitErrorCode;
00037c  e1a00005          MOV      r0,r5
;;;231    }
000380  e8bd8070          POP      {r4-r6,pc}
;;;232    
                          ENDP

                  vIIC_SendStart PROC
;;;234    /****************************************************************************/
;;;235    void vIIC_SendStart(void)
000384  e3a000f8          MOV      r0,#0xf8
;;;236    {
;;;237        vSetSBI0CR2(IIC_BUS_START_CONDITION);
000388  e59f1514          LDR      r1,|L1.2212|
00038c  e5c1000c          STRB     r0,[r1,#0xc]
;;;238    }
000390  e12fff1e          BX       lr
;;;239    
                          ENDP

                  vIIC_SendStop PROC
;;;241    /****************************************************************************/
;;;242    void vIIC_SendStop(void)
000394  e3a000d8          MOV      r0,#0xd8
;;;243    {
;;;244        vSetSBI0CR2(IIC_BUS_STOP_CONDITION);
000398  e59f1504          LDR      r1,|L1.2212|
00039c  e5c1000c          STRB     r0,[r1,#0xc]
;;;245    }
0003a0  e12fff1e          BX       lr
;;;246    
                          ENDP

                  eIIC_GetLastRxBit PROC
;;;493    /****************************************************************************/
;;;494    iic_LastRxBitStat_e eIIC_GetLastRxBit(void)
0003a4  e59f14f8          LDR      r1,|L1.2212|
;;;495    {
;;;496        iic_LastRxBitStat_e eLastRxBitStat = (iic_LastRxBitStat_e)biGetSBI0SR_LRB();
0003a8  e5d1100c          LDRB     r1,[r1,#0xc]
0003ac  e2010001          AND      r0,r1,#1
;;;497        return eLastRxBitStat;
;;;498    }
0003b0  e12fff1e          BX       lr
;;;499    
                          ENDP

                  eIIC_WaitHighClkTimeout PROC
;;;362    /****************************************************************************/
;;;363    iic_ErrorCodes_e eIIC_WaitHighClkTimeout(void)
0003b4  e92d4070          PUSH     {r4-r6,lr}
;;;364    {
;;;365        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
0003b8  e3a06004          MOV      r6,#4
;;;366        iic_LastRxBitStat_e eLastRxBitStat = IIC_LST_BIT_NOACK;
0003bc  e3a04001          MOV      r4,#1
;;;367        iic_TimerStatus_e eTimerStatus = IIC_TIMER_STOPPED;
0003c0  e3a05000          MOV      r5,#0
;;;368        
;;;369        vIIC_TimerStart(IIC_TIMER_IRQ_ACK_SEL);
0003c4  e3a00001          MOV      r0,#1
0003c8  ebfffffe          BL       vIIC_TimerStart
;;;370        do
0003cc  e320f000          NOP      
                  |L1.976|
;;;371        {
;;;372            eLastRxBitStat = eIIC_GetLastRxBit();    
0003d0  ebfffffe          BL       eIIC_GetLastRxBit
0003d4  e1a04000          MOV      r4,r0
;;;373            eTimerStatus = eIIC_TimerQuery(IIC_TIMER_IRQ_ACK_SEL);
0003d8  e3a00001          MOV      r0,#1
0003dc  ebfffffe          BL       eIIC_TimerQuery
0003e0  e1a05000          MOV      r5,r0
;;;374        }
;;;375        while( (IIC_LST_BIT_ACK == eLastRxBitStat) && (IIC_TIMER_RUNNING == eTimerStatus) );
0003e4  e3540000          CMP      r4,#0
0003e8  1a000001          BNE      |L1.1012|
0003ec  e3550001          CMP      r5,#1
0003f0  0afffff6          BEQ      |L1.976|
                  |L1.1012|
;;;376        
;;;377        /* Reconfirm the reason for loop break */
;;;378        if( (IIC_TIMER_EXPIRED == eTimerStatus) || (IIC_LST_BIT_ACK == eLastRxBitStat) )
0003f4  e3550002          CMP      r5,#2
0003f8  0a000001          BEQ      |L1.1028|
0003fc  e3540000          CMP      r4,#0
000400  1a000001          BNE      |L1.1036|
                  |L1.1028|
;;;379        {
;;;380            eErrorCode = IIC_CLK_LINE_TIMEOUT;
000404  e3a06003          MOV      r6,#3
000408  ea000002          B        |L1.1048|
                  |L1.1036|
;;;381        }
;;;382        else 
;;;383        {
;;;384            /* ACK */
;;;385            vIIC_TimerStop(IIC_TIMER_IRQ_ACK_SEL);
00040c  e3a00001          MOV      r0,#1
000410  ebfffffe          BL       vIIC_TimerStop
;;;386            eErrorCode = IIC_READY;
000414  e3a06000          MOV      r6,#0
                  |L1.1048|
;;;387        }
;;;388        return eErrorCode;
000418  e1a00006          MOV      r0,r6
;;;389    }
00041c  e8bd8070          POP      {r4-r6,pc}
;;;390    
                          ENDP

                  eIIC_GetBusyStatus PROC
;;;453    /****************************************************************************/
;;;454    iic_BusyStat_e eIIC_GetBusyStatus(void)
000420  e59f147c          LDR      r1,|L1.2212|
;;;455    {
;;;456        iic_BusyStat_e eBusyStat = (iic_BusyStat_e)biGetSBI0SR_BB();
000424  e5d1100c          LDRB     r1,[r1,#0xc]
000428  e7e002d1          UBFX     r0,r1,#5,#1
;;;457        return eBusyStat;
;;;458    }
00042c  e12fff1e          BX       lr
;;;459    
                          ENDP

                  eIIC_WaitBusyTimeout PROC
;;;271    /****************************************************************************/
;;;272    iic_ErrorCodes_e eIIC_WaitBusyTimeout(void)
000430  e92d4070          PUSH     {r4-r6,lr}
;;;273    {
;;;274        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
000434  e3a06004          MOV      r6,#4
;;;275        iic_BusyStat_e eBusyStat = IIC_BUS_BUSY;
000438  e3a04001          MOV      r4,#1
;;;276        iic_TimerStatus_e eTimerStatus = IIC_TIMER_STOPPED;
00043c  e3a05000          MOV      r5,#0
;;;277        
;;;278        vIIC_TimerStart(IIC_TIMER_BUSY_SEL);
000440  e3a00002          MOV      r0,#2
000444  ebfffffe          BL       vIIC_TimerStart
;;;279        do
000448  e320f000          NOP      
                  |L1.1100|
;;;280        {
;;;281            eBusyStat = eIIC_GetBusyStatus();        
00044c  ebfffffe          BL       eIIC_GetBusyStatus
000450  e1a04000          MOV      r4,r0
;;;282            eTimerStatus = eIIC_TimerQuery(IIC_TIMER_BUSY_SEL);
000454  e3a00002          MOV      r0,#2
000458  ebfffffe          BL       eIIC_TimerQuery
00045c  e1a05000          MOV      r5,r0
;;;283        
;;;284        }
;;;285        while( (IIC_BUS_BUSY == eBusyStat) && (IIC_TIMER_RUNNING == eTimerStatus) );
000460  e3540001          CMP      r4,#1
000464  1a000001          BNE      |L1.1136|
000468  e3550001          CMP      r5,#1
00046c  0afffff6          BEQ      |L1.1100|
                  |L1.1136|
;;;286        
;;;287        if( (IIC_TIMER_EXPIRED == eTimerStatus) || (IIC_BUS_BUSY == eBusyStat) )
000470  e3550002          CMP      r5,#2
000474  0a000001          BEQ      |L1.1152|
000478  e3540001          CMP      r4,#1
00047c  1a000001          BNE      |L1.1160|
                  |L1.1152|
;;;288        {
;;;289            eErrorCode = IIC_BUSY_TIMEOUT;
000480  e3a06001          MOV      r6,#1
000484  ea000002          B        |L1.1172|
                  |L1.1160|
;;;290        }
;;;291        else
;;;292        {
;;;293            vIIC_TimerStop(IIC_TIMER_BUSY_SEL);
000488  e3a00002          MOV      r0,#2
00048c  ebfffffe          BL       vIIC_TimerStop
;;;294            eErrorCode = IIC_READY;
000490  e3a06000          MOV      r6,#0
                  |L1.1172|
;;;295        }
;;;296        return eErrorCode;
000494  e1a00006          MOV      r0,r6
;;;297    }
000498  e8bd8070          POP      {r4-r6,pc}
;;;298    
                          ENDP

                  eIIC_PrepareRestart PROC
;;;248    /****************************************************************************/
;;;249    iic_ErrorCodes_e eIIC_PrepareRestart(void)
00049c  e92d4010          PUSH     {r4,lr}
;;;250    {
;;;251        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
0004a0  e3a04004          MOV      r4,#4
;;;252        
;;;253        /* Release the bus witout sending STOP condition - bus is still in BUSY state */
;;;254        vSetSBI0CR2(IIC_BUS_RELEASE_CONDITION);
0004a4  e3a00018          MOV      r0,#0x18
0004a8  e59f13f4          LDR      r1,|L1.2212|
0004ac  e5c1000c          STRB     r0,[r1,#0xc]
;;;255        /* Check if bus is free */
;;;256        eErrorCode = eIIC_WaitBusyTimeout();
0004b0  ebfffffe          BL       eIIC_WaitBusyTimeout
0004b4  e1a04000          MOV      r4,r0
;;;257        if( IIC_READY == eErrorCode )
0004b8  e3540000          CMP      r4,#0
0004bc  1a000005          BNE      |L1.1240|
;;;258        {
;;;259            /* Check if the clock line is not pulled LOW by some device */
;;;260            eErrorCode = eIIC_WaitHighClkTimeout();
0004c0  ebfffffe          BL       eIIC_WaitHighClkTimeout
0004c4  e1a04000          MOV      r4,r0
;;;261            if( IIC_READY == eErrorCode )
0004c8  e3540000          CMP      r4,#0
0004cc  1a000001          BNE      |L1.1240|
;;;262            {
;;;263                /* Wait additonal 4.7 us */
;;;264                iic_Timer_Delay_us(IIC_TIMER_RESTART_GUARD);
0004d0  e30003e8          MOVW     r0,#0x3e8
0004d4  ebfffffe          BL       iic_Timer_Delay_us
                  |L1.1240|
;;;265            }
;;;266        }
;;;267        return eErrorCode;
0004d8  e1a00004          MOV      r0,r4
;;;268    }
0004dc  e8bd8010          POP      {r4,pc}
;;;269    
                          ENDP

                  eIIC_GetIrqStatus PROC
;;;461    /****************************************************************************/
;;;462    iic_IrqStat_e eIIC_GetIrqStatus(void)
0004e0  e59f13bc          LDR      r1,|L1.2212|
;;;463    {
;;;464        iic_IrqStat_e eIrqStat = (iic_IrqStat_e)biGetSBI0SR_PIN();
0004e4  e5d1100c          LDRB     r1,[r1,#0xc]
0004e8  e7e00251          UBFX     r0,r1,#4,#1
;;;465        return eIrqStat;
;;;466    }
0004ec  e12fff1e          BX       lr
;;;467    
                          ENDP

                  eIIC_WaitAckTimeout PROC
;;;300    /****************************************************************************/
;;;301    iic_ErrorCodes_e eIIC_WaitAckTimeout(void)
0004f0  e92d41f0          PUSH     {r4-r8,lr}
;;;302    {
;;;303        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
0004f4  e3a05004          MOV      r5,#4
;;;304        iic_LastRxBitStat_e eLastRxBitStat = IIC_LST_BIT_NOACK;
0004f8  e3a06001          MOV      r6,#1
;;;305        iic_IrqStat_e eIrqStat = IIC_IRQ_CANCEL;
0004fc  e3a07001          MOV      r7,#1
;;;306        iic_TimerStatus_e eTimerStatus = IIC_TIMER_STOPPED;
000500  e3a04000          MOV      r4,#0
;;;307        
;;;308        vIIC_TimerStart(IIC_TIMER_IRQ_ACK_SEL);
000504  e3a00001          MOV      r0,#1
000508  ebfffffe          BL       vIIC_TimerStart
;;;309        do
00050c  e320f000          NOP      
                  |L1.1296|
;;;310        {
;;;311            eIrqStat = eIIC_GetIrqStatus();    
000510  ebfffffe          BL       eIIC_GetIrqStatus
000514  e1a07000          MOV      r7,r0
;;;312            eTimerStatus = eIIC_TimerQuery(IIC_TIMER_IRQ_ACK_SEL);
000518  e3a00001          MOV      r0,#1
00051c  ebfffffe          BL       eIIC_TimerQuery
000520  e1a04000          MOV      r4,r0
;;;313        }
;;;314        while( (IIC_IRQ_CANCEL == eIrqStat) && (IIC_TIMER_RUNNING == eTimerStatus) );
000524  e3570001          CMP      r7,#1
000528  1a000001          BNE      |L1.1332|
00052c  e3540001          CMP      r4,#1
000530  0afffff6          BEQ      |L1.1296|
                  |L1.1332|
;;;315        
;;;316        /* Reconfirm if ACK bit from Slave device was "0" */
;;;317        eLastRxBitStat = eIIC_GetLastRxBit ();
000534  ebfffffe          BL       eIIC_GetLastRxBit
000538  e1a06000          MOV      r6,r0
;;;318        
;;;319        if( (IIC_TIMER_EXPIRED == eTimerStatus) || (IIC_LST_BIT_NOACK == eLastRxBitStat) )
00053c  e3540002          CMP      r4,#2
000540  0a000001          BEQ      |L1.1356|
000544  e3560001          CMP      r6,#1
000548  1a000001          BNE      |L1.1364|
                  |L1.1356|
;;;320        {
;;;321            eErrorCode = IIC_IRQ_ACK_TIMEOUT;
00054c  e3a05002          MOV      r5,#2
000550  ea000002          B        |L1.1376|
                  |L1.1364|
;;;322        }
;;;323        else 
;;;324        {
;;;325            /* IRQ and ACK OK */
;;;326            vIIC_TimerStop(IIC_TIMER_IRQ_ACK_SEL);
000554  e3a00001          MOV      r0,#1
000558  ebfffffe          BL       vIIC_TimerStop
;;;327            eErrorCode = IIC_READY;
00055c  e3a05000          MOV      r5,#0
                  |L1.1376|
;;;328        }
;;;329        return eErrorCode;
000560  e1a00005          MOV      r0,r5
;;;330    }
000564  e8bd81f0          POP      {r4-r8,pc}
;;;331    
                          ENDP

                  eIIC_WaitIrqTimeout PROC
;;;333    /****************************************************************************/
;;;334    iic_ErrorCodes_e eIIC_WaitIrqTimeout(void)
000568  e92d4070          PUSH     {r4-r6,lr}
;;;335    {
;;;336        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
00056c  e3a06004          MOV      r6,#4
;;;337        iic_IrqStat_e eIrqStat = IIC_IRQ_CANCEL;
000570  e3a04001          MOV      r4,#1
;;;338        iic_TimerStatus_e eTimerStatus = IIC_TIMER_STOPPED;
000574  e3a05000          MOV      r5,#0
;;;339        
;;;340        vIIC_TimerStart(IIC_TIMER_IRQ_ACK_SEL);
000578  e3a00001          MOV      r0,#1
00057c  ebfffffe          BL       vIIC_TimerStart
;;;341        do
000580  e320f000          NOP      
                  |L1.1412|
;;;342        {
;;;343            eIrqStat = eIIC_GetIrqStatus();    
000584  ebfffffe          BL       eIIC_GetIrqStatus
000588  e1a04000          MOV      r4,r0
;;;344            eTimerStatus = eIIC_TimerQuery(IIC_TIMER_IRQ_ACK_SEL);
00058c  e3a00001          MOV      r0,#1
000590  ebfffffe          BL       eIIC_TimerQuery
000594  e1a05000          MOV      r5,r0
;;;345        }
;;;346        while( (IIC_IRQ_CANCEL == eIrqStat) && (IIC_TIMER_RUNNING == eTimerStatus) );
000598  e3540001          CMP      r4,#1
00059c  1a000001          BNE      |L1.1448|
0005a0  e3550001          CMP      r5,#1
0005a4  0afffff6          BEQ      |L1.1412|
                  |L1.1448|
;;;347        
;;;348        if( (IIC_TIMER_EXPIRED == eTimerStatus) || (IIC_IRQ_CANCEL == eIrqStat) )
0005a8  e3550002          CMP      r5,#2
0005ac  0a000001          BEQ      |L1.1464|
0005b0  e3540001          CMP      r4,#1
0005b4  1a000001          BNE      |L1.1472|
                  |L1.1464|
;;;349        {
;;;350            eErrorCode = IIC_IRQ_ACK_TIMEOUT;
0005b8  e3a06002          MOV      r6,#2
0005bc  ea000002          B        |L1.1484|
                  |L1.1472|
;;;351        }
;;;352        else 
;;;353        {
;;;354            /* IRQ OK */
;;;355            vIIC_TimerStop(IIC_TIMER_IRQ_ACK_SEL);
0005c0  e3a00001          MOV      r0,#1
0005c4  ebfffffe          BL       vIIC_TimerStop
;;;356            eErrorCode = IIC_READY;
0005c8  e3a06000          MOV      r6,#0
                  |L1.1484|
;;;357        }
;;;358        return eErrorCode;
0005cc  e1a00006          MOV      r0,r6
;;;359    }
0005d0  e8bd8070          POP      {r4-r6,pc}
;;;360    
                          ENDP

                  vIIC_WriteByte PROC
;;;501    /****************************************************************************/
;;;502    void vIIC_WriteByte(uint8_t u8Data)
0005d4  e59f12c8          LDR      r1,|L1.2212|
;;;503    {
;;;504        vSetSBI0DBR(u8Data);
0005d8  e5c10004          STRB     r0,[r1,#4]
;;;505    }
0005dc  e12fff1e          BX       lr
;;;506    
                          ENDP

                  eIIC_SendSlaveAdr PROC
;;;392    /****************************************************************************/
;;;393    iic_ErrorCodes_e eIIC_SendSlaveAdr(uint8_t u8SlaveAddress, iic_SendDirBit_e eSendDirBit)
0005e0  e92d41f0          PUSH     {r4-r8,lr}
;;;394    {
0005e4  e1a04000          MOV      r4,r0
0005e8  e1a05001          MOV      r5,r1
;;;395        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
0005ec  e3a06004          MOV      r6,#4
;;;396        uint8_t u8ByteToSend = 0;
0005f0  e3a07000          MOV      r7,#0
;;;397        
;;;398        /* If bus is free send the device alave address and direction bit */
;;;399        eErrorCode = eIIC_WaitBusyTimeout();
0005f4  ebfffffe          BL       eIIC_WaitBusyTimeout
0005f8  e1a06000          MOV      r6,r0
;;;400        
;;;401        if( IIC_READY == eErrorCode )
0005fc  e3560000          CMP      r6,#0
000600  1a000006          BNE      |L1.1568|
;;;402        {
;;;403            /* Send slave address and the direction bit WRITE */
;;;404            u8ByteToSend = (uint8_t)((u8SlaveAddress << 1) | eSendDirBit);
000604  e1850084          ORR      r0,r5,r4,LSL #1
000608  e20070ff          AND      r7,r0,#0xff
;;;405            vIIC_WriteByte(u8ByteToSend);        
00060c  e1a00007          MOV      r0,r7
000610  ebfffffe          BL       vIIC_WriteByte
;;;406            /* Send Start condition to begin transfer */
;;;407            vIIC_SendStart();        
000614  ebfffffe          BL       vIIC_SendStart
;;;408            /* Wait until complete word is send or Ack-Timeout expires */
;;;409            eErrorCode = eIIC_WaitAckTimeout();
000618  ebfffffe          BL       eIIC_WaitAckTimeout
00061c  e1a06000          MOV      r6,r0
                  |L1.1568|
;;;410        }
;;;411        return eErrorCode;
000620  e1a00006          MOV      r0,r6
;;;412    }
000624  e8bd81f0          POP      {r4-r8,pc}
;;;413    
                          ENDP

                  eIIC_SendSubAdr PROC
;;;415    /****************************************************************************/
;;;416    iic_ErrorCodes_e eIIC_SendSubAdr(uint8_t u8SubAdrLen, uint32_t u32SubAdr)
000628  e92d41f0          PUSH     {r4-r8,lr}
;;;417    {
00062c  e1a04000          MOV      r4,r0
000630  e1a06001          MOV      r6,r1
;;;418        iic_ErrorCodes_e eErrorCode = IIC_READY;
000634  e3a07000          MOV      r7,#0
;;;419        uint8_t u8SubAdrIdx = 0;
000638  e3a05000          MOV      r5,#0
;;;420        uint8_t u8SubAdrByte = 0;
00063c  e3a08000          MOV      r8,#0
;;;421        
;;;422        /* Sub-address write loop with acknowledge check */
;;;423        u8SubAdrIdx = 0;
000640  e320f000          NOP      
;;;424        while( (IIC_READY == eErrorCode) && (u8SubAdrIdx < (u8SubAdrLen * 8)) )
000644  ea000007          B        |L1.1640|
                  |L1.1608|
;;;425        {
;;;426            u8SubAdrByte = (uint8_t)((u32SubAdr >> u8SubAdrIdx));
000648  e1a00536          LSR      r0,r6,r5
00064c  e20080ff          AND      r8,r0,#0xff
;;;427            
;;;428            vIIC_WriteByte(u8SubAdrByte);
000650  e1a00008          MOV      r0,r8
000654  ebfffffe          BL       vIIC_WriteByte
;;;429            eErrorCode = eIIC_WaitAckTimeout();
000658  ebfffffe          BL       eIIC_WaitAckTimeout
00065c  e1a07000          MOV      r7,r0
;;;430            
;;;431            u8SubAdrIdx = (u8SubAdrIdx + 8);
000660  e2850008          ADD      r0,r5,#8
000664  e20050ff          AND      r5,r0,#0xff
                  |L1.1640|
000668  e3570000          CMP      r7,#0                 ;424
00066c  1a000001          BNE      |L1.1656|
000670  e1550184          CMP      r5,r4,LSL #3          ;424
000674  bafffff3          BLT      |L1.1608|
                  |L1.1656|
;;;432        }
;;;433        return eErrorCode;
000678  e1a00007          MOV      r0,r7
;;;434    }
00067c  e8bd81f0          POP      {r4-r8,pc}
;;;435    
                          ENDP

                  eIIC_GetTransfDir PROC
;;;437    /****************************************************************************/
;;;438    iic_TransfDir_e eIIC_GetTransfDir(void)
000680  e59f121c          LDR      r1,|L1.2212|
;;;439    {
;;;440        iic_TransfDir_e eTransfDir = (iic_TransfDir_e)biGetSBI0SR_TRX();    
000684  e5d1100c          LDRB     r1,[r1,#0xc]
000688  e7e00351          UBFX     r0,r1,#6,#1
;;;441        return eTransfDir;
;;;442    }
00068c  e12fff1e          BX       lr
;;;443    
                          ENDP

                  eIIC_GetCtrlMode PROC
;;;445    /****************************************************************************/
;;;446    iic_CtrlMode_e eIIC_GetCtrlMode(void)
000690  e59f120c          LDR      r1,|L1.2212|
;;;447    {
;;;448        iic_CtrlMode_e eCtrlMode = (iic_CtrlMode_e)biGetSBI0SR_MST();
000694  e5d1100c          LDRB     r1,[r1,#0xc]
000698  e1a003a1          LSR      r0,r1,#7
;;;449        return eCtrlMode;
;;;450    }
00069c  e12fff1e          BX       lr
;;;451    
                          ENDP

                  eIIC_IsArbitrLost PROC
;;;469    /****************************************************************************/
;;;470    iic_ArbitrStat_e eIIC_IsArbitrLost(void)
0006a0  e59f11fc          LDR      r1,|L1.2212|
;;;471    {
;;;472        iic_ArbitrStat_e eArbitrStat = (iic_ArbitrStat_e)biGetSBI0SR_AL();
0006a4  e5d1100c          LDRB     r1,[r1,#0xc]
0006a8  e7e001d1          UBFX     r0,r1,#3,#1
;;;473        return eArbitrStat;
;;;474    }
0006ac  e12fff1e          BX       lr
;;;475    
                          ENDP

                  eIIC_IsAdrMatch PROC
;;;477    /****************************************************************************/
;;;478    iic_AdrMatchStat_e eIIC_IsAdrMatch(void)
0006b0  e59f11ec          LDR      r1,|L1.2212|
;;;479    {
;;;480        iic_AdrMatchStat_e eAdrMatchStat = (iic_AdrMatchStat_e)biGetSBI0SR_AAS();
0006b4  e5d1100c          LDRB     r1,[r1,#0xc]
0006b8  e7e00151          UBFX     r0,r1,#2,#1
;;;481        return eAdrMatchStat;
;;;482    }
0006bc  e12fff1e          BX       lr
;;;483    
                          ENDP

                  eIIC_IsGenCall PROC
;;;485    /****************************************************************************/
;;;486    iic_GenCallStat_e eIIC_IsGenCall(void)
0006c0  e59f11dc          LDR      r1,|L1.2212|
;;;487    {
;;;488        iic_GenCallStat_e eGenCallStat = (iic_GenCallStat_e)biGetSBI0SR_AD0();
0006c4  e5d1100c          LDRB     r1,[r1,#0xc]
0006c8  e7e000d1          UBFX     r0,r1,#1,#1
;;;489        return eGenCallStat;
;;;490    }
0006cc  e12fff1e          BX       lr
;;;491    
                          ENDP

                  u8IIC_ReadByte PROC
;;;508    /****************************************************************************/
;;;509    uint8_t u8IIC_ReadByte(void)
0006d0  e59f11cc          LDR      r1,|L1.2212|
;;;510    {
;;;511        uint8_t u8Data = u8GetSBI0DBR();
0006d4  e5d10004          LDRB     r0,[r1,#4]
;;;512        return u8Data;
;;;513    }
0006d8  e12fff1e          BX       lr
;;;514    
                          ENDP

                  eIIC_WriteData PROC
;;;516    /****************************************************************************/
;;;517    iic_ErrorCodes_e eIIC_WriteData(uint8_t u8SlaveAddress, uint8_t u8SubAdrLen, 
0006dc  e92d47f0          PUSH     {r4-r10,lr}
;;;518                                    uint32_t u32SubAdr, uint8_t u8DataLen, 
;;;519                                    const uint8_t pau8Data[])
;;;520    {
0006e0  e1a09000          MOV      r9,r0
0006e4  e1a06001          MOV      r6,r1
0006e8  e1a07002          MOV      r7,r2
0006ec  e1a08003          MOV      r8,r3
0006f0  e59da020          LDR      r10,[sp,#0x20]
;;;521        /* error code */
;;;522        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
0006f4  e3a04004          MOV      r4,#4
;;;523        /* Send-data counter */
;;;524        uint8_t u8DataIdx = 0; 
0006f8  e3a05000          MOV      r5,#0
;;;525        
;;;526        /* Start condition and slave address */
;;;527        eErrorCode = eIIC_SendSlaveAdr(u8SlaveAddress, IIC_WR_TO_SLAVE);
0006fc  e3a01000          MOV      r1,#0
000700  e1a00009          MOV      r0,r9
000704  ebfffffe          BL       eIIC_SendSlaveAdr
000708  e1a04000          MOV      r4,r0
;;;528        if( IIC_READY == eErrorCode )
00070c  e3540000          CMP      r4,#0
000710  1a000010          BNE      |L1.1880|
;;;529        {
;;;530            /* Sub-address */
;;;531            eErrorCode = eIIC_SendSubAdr(u8SubAdrLen, u32SubAdr);
000714  e1a01007          MOV      r1,r7
000718  e1a00006          MOV      r0,r6
00071c  ebfffffe          BL       eIIC_SendSubAdr
000720  e1a04000          MOV      r4,r0
;;;532            if( IIC_READY == eErrorCode )
000724  e3540000          CMP      r4,#0
000728  1a00000a          BNE      |L1.1880|
;;;533            {                    
;;;534                /* Data write loop with acknowledge check */          
;;;535                while( (IIC_READY == eErrorCode) && (u8DataIdx < u8DataLen) )
00072c  ea000005          B        |L1.1864|
                  |L1.1840|
;;;536                {
;;;537                    vIIC_WriteByte(pau8Data[u8DataIdx]);
000730  e7da0005          LDRB     r0,[r10,r5]
000734  ebfffffe          BL       vIIC_WriteByte
;;;538                    eErrorCode = eIIC_WaitAckTimeout();
000738  ebfffffe          BL       eIIC_WaitAckTimeout
00073c  e1a04000          MOV      r4,r0
;;;539                    u8DataIdx++;
000740  e2850001          ADD      r0,r5,#1
000744  e20050ff          AND      r5,r0,#0xff
                  |L1.1864|
000748  e3540000          CMP      r4,#0                 ;535
00074c  1a000001          BNE      |L1.1880|
000750  e1550008          CMP      r5,r8                 ;535
000754  bafffff5          BLT      |L1.1840|
                  |L1.1880|
;;;540                }
;;;541            }
;;;542        }
;;;543        /* STOP condition */
;;;544        vIIC_SendStop ();
000758  ebfffffe          BL       vIIC_SendStop
;;;545        
;;;546        return eErrorCode;
00075c  e1a00004          MOV      r0,r4
;;;547    }
000760  e8bd87f0          POP      {r4-r10,pc}
;;;548    
                          ENDP

                  eIIC_ReadData PROC
;;;550    /****************************************************************************/
;;;551    iic_ErrorCodes_e eIIC_ReadData(uint8_t u8SlaveAddress, uint8_t u8SubAdrLen, 
000764  e92d5ffc          PUSH     {r2-r12,lr}
;;;552                                   uint32_t u32SubAdr, uint8_t u8DataLen, 
;;;553                                   uint8_t pau8Data[])
;;;554    {
000768  e1a0a000          MOV      r10,r0
00076c  e1a06001          MOV      r6,r1
000770  e1a07002          MOV      r7,r2
000774  e1a08003          MOV      r8,r3
000778  e59d9030          LDR      r9,[sp,#0x30]
;;;555        iic_ErrorCodes_e eErrorCode = IIC_NOT_READY;
00077c  e3a04004          MOV      r4,#4
;;;556        iic_NoOfBits_e eOldNoOfBits = IIC_DATA_BITS_8;
000780  e3a00000          MOV      r0,#0
000784  e58d0004          STR      r0,[sp,#4]
;;;557        iic_AckCycle_e eOldAckCycle = IIC_ACK_DISABLE;
000788  e58d0000          STR      r0,[sp,#0]
;;;558        /* send-data counter */
;;;559        uint8_t u8DataIdx = 0; 
00078c  e3a05000          MOV      r5,#0
;;;560        
;;;561        /* Remember no of bits and acknowledge mode */     
;;;562        eOldAckCycle = eIIC_GetAckCycMode();    
000790  ebfffffe          BL       eIIC_GetAckCycMode
000794  e58d0000          STR      r0,[sp,#0]
;;;563        eOldNoOfBits = eIIC_GetNoOfBits();
000798  ebfffffe          BL       eIIC_GetNoOfBits
00079c  e58d0004          STR      r0,[sp,#4]
;;;564        /* Start condition, slave address */
;;;565        eErrorCode = eIIC_SendSlaveAdr(u8SlaveAddress, IIC_WR_TO_SLAVE);
0007a0  e3a01000          MOV      r1,#0
0007a4  e1a0000a          MOV      r0,r10
0007a8  ebfffffe          BL       eIIC_SendSlaveAdr
0007ac  e1a04000          MOV      r4,r0
;;;566        if( IIC_READY == eErrorCode )
0007b0  e3540000          CMP      r4,#0
0007b4  1a000032          BNE      |L1.2180|
;;;567        {
;;;568            /* Sub-address */
;;;569            eErrorCode = eIIC_SendSubAdr(u8SubAdrLen, u32SubAdr);
0007b8  e1a01007          MOV      r1,r7
0007bc  e1a00006          MOV      r0,r6
0007c0  ebfffffe          BL       eIIC_SendSubAdr
0007c4  e1a04000          MOV      r4,r0
;;;570            if( IIC_READY == eErrorCode )
0007c8  e3540000          CMP      r4,#0
0007cc  1a00002c          BNE      |L1.2180|
;;;571            {
;;;572                /* 
;;;573                 *  Change the direction without stopping the 
;;;574                 *  current transfer: Restart condition
;;;575                 */
;;;576                eErrorCode = eIIC_PrepareRestart();
0007d0  ebfffffe          BL       eIIC_PrepareRestart
0007d4  e1a04000          MOV      r4,r0
;;;577                if( IIC_READY == eErrorCode )
0007d8  e3540000          CMP      r4,#0
0007dc  1a000028          BNE      |L1.2180|
;;;578                {
;;;579                    /* Slave address with READ direction */
;;;580                    eErrorCode = eIIC_SendSlaveAdr(u8SlaveAddress, IIC_RD_FROM_SLAVE);
0007e0  e3a01001          MOV      r1,#1
0007e4  e1a0000a          MOV      r0,r10
0007e8  ebfffffe          BL       eIIC_SendSlaveAdr
0007ec  e1a04000          MOV      r4,r0
;;;581                    if( IIC_READY == eErrorCode )
0007f0  e3540000          CMP      r4,#0
0007f4  1a000022          BNE      |L1.2180|
;;;582                    {            
;;;583                        /* Perform dummy read */
;;;584                        u8IIC_ReadByte();
0007f8  ebfffffe          BL       u8IIC_ReadByte
;;;585                        /* Wait for Rx IRQ */
;;;586                        eErrorCode = eIIC_WaitIrqTimeout();
0007fc  ebfffffe          BL       eIIC_WaitIrqTimeout
000800  e1a04000          MOV      r4,r0
;;;587                        if( IIC_READY == eErrorCode )
000804  e3540000          CMP      r4,#0
000808  1a00000e          BNE      |L1.2120|
;;;588                        {
;;;589                            uint8_t u8DataLenTmp = (u8DataLen - 1);
00080c  e2480001          SUB      r0,r8,#1
000810  e200b0ff          AND      r11,r0,#0xff
;;;590                            
;;;591                            /* READ all data, besides the last byte */
;;;592                            u8DataIdx = 0;
000814  e320f000          NOP      
;;;593                            while( (IIC_READY == eErrorCode) && (u8DataIdx < u8DataLenTmp) )
000818  ea000005          B        |L1.2100|
                  |L1.2076|
;;;594                            {
;;;595                                pau8Data[u8DataIdx] = u8IIC_ReadByte();
00081c  ebfffffe          BL       u8IIC_ReadByte
000820  e7c90005          STRB     r0,[r9,r5]
;;;596                                eErrorCode = eIIC_WaitIrqTimeout();
000824  ebfffffe          BL       eIIC_WaitIrqTimeout
000828  e1a04000          MOV      r4,r0
;;;597                                u8DataIdx++;
00082c  e2850001          ADD      r0,r5,#1
000830  e20050ff          AND      r5,r0,#0xff
                  |L1.2100|
000834  e3540000          CMP      r4,#0                 ;593
000838  1a000001          BNE      |L1.2116|
00083c  e155000b          CMP      r5,r11                ;593
000840  bafffff5          BLT      |L1.2076|
                  |L1.2116|
;;;598                            }
;;;599                        }
000844  e320f000          NOP      
                  |L1.2120|
;;;600                        /* Check the last error code to decide what to do  */
;;;601                        if( IIC_READY == eErrorCode )
000848  e3540000          CMP      r4,#0
00084c  1a00000c          BNE      |L1.2180|
;;;602                        {
;;;603                            /* Disable generation of ack clock cycle */                                                  
;;;604                            eIIC_SetAckCycMode(IIC_ACK_DISABLE);
000850  e3a00000          MOV      r0,#0
000854  ebfffffe          BL       eIIC_SetAckCycMode
;;;605                            /* Receive the last data and wait until completion */
;;;606                            pau8Data[u8DataIdx] = u8IIC_ReadByte();
000858  ebfffffe          BL       u8IIC_ReadByte
00085c  e7c90005          STRB     r0,[r9,r5]
;;;607                            /* Wait for Rx IRQ */
;;;608                            eErrorCode = eIIC_WaitIrqTimeout();
000860  ebfffffe          BL       eIIC_WaitIrqTimeout
000864  e1a04000          MOV      r4,r0
;;;609                            if( IIC_READY == eErrorCode )
000868  e3540000          CMP      r4,#0
00086c  1a000004          BNE      |L1.2180|
;;;610                            {
;;;611                                /* 
;;;612                                 *  All read, the master must finish the transfer, so
;;;613                                 *  change the number of bits in controller to one, 
;;;614                                 *  read out dummy data - this will generate 1 clock 
;;;615                                 *  pulse
;;;616                                 */
;;;617                                eIIC_SetNoOfBits(IIC_DATA_BITS_1);
000870  e3a00001          MOV      r0,#1
000874  ebfffffe          BL       eIIC_SetNoOfBits
;;;618                                u8IIC_ReadByte();
000878  ebfffffe          BL       u8IIC_ReadByte
;;;619                                /* Wait for completion */
;;;620                                eErrorCode = eIIC_WaitIrqTimeout();
00087c  ebfffffe          BL       eIIC_WaitIrqTimeout
000880  e1a04000          MOV      r4,r0
                  |L1.2180|
;;;621                            }
;;;622                        }
;;;623                    }
;;;624                }
;;;625            }
;;;626        }
;;;627    
;;;628        /* STOP condition */
;;;629        vIIC_SendStop();
000884  ebfffffe          BL       vIIC_SendStop
;;;630    
;;;631        /* Restore the previous no of bits and ack mode */
;;;632        eIIC_SetNoOfBits(eOldNoOfBits);
000888  e59d0004          LDR      r0,[sp,#4]
00088c  ebfffffe          BL       eIIC_SetNoOfBits
;;;633        eIIC_SetAckCycMode(eOldAckCycle);
000890  e59d0000          LDR      r0,[sp,#0]
000894  ebfffffe          BL       eIIC_SetAckCycMode
;;;634        
;;;635        return eErrorCode;
000898  e1a00004          MOV      r0,r4
;;;636    }
00089c  e8bd9ffc          POP      {r2-r12,pc}
;;;637    
                          ENDP

                  |L1.2208|
                          DCD      u8ShadowCrOne
                  |L1.2212|
                          DCD      0xc0324000
                  |L1.2216|
                          DCD      u8ShadowAr
                  |L1.2220|
                          DCD      au8LLDD_IIC_C_REVISION
                  |L1.2224|
                          DCD      au8LLDD_IIC_C_TAG
                  |L1.2228|
                          DCD      au8LLDD_IIC_H_REVISION
                  |L1.2232|
                          DCD      au8LLDD_IIC_H_TAG
                  |L1.2236|
                          DCD      au8LLDD_IIC_IO_H_REVISION
                  |L1.2240|
                          DCD      au8LLDD_IIC_IO_H_TAG

                          AREA ||.data||, DATA, ALIGN=0

                  au8LLDD_IIC_C_REVISION
000000  24526576          DCB      0x24,0x52,0x65,0x76
000004  6973696f          DCB      0x69,0x73,0x69,0x6f
000008  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00000c  2e313020          DCB      0x2e,0x31,0x30,0x20
000010  2400              DCB      0x24,0x00
                  au8LLDD_IIC_C_TAG
000012  244e              DCB      0x24,0x4e
000014  616d653a          DCB      0x61,0x6d,0x65,0x3a
000018  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00001c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000020  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_IIC_H_REVISION
000024  24526576          DCB      0x24,0x52,0x65,0x76
000028  6973696f          DCB      0x69,0x73,0x69,0x6f
00002c  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000030  2e313020          DCB      0x2e,0x31,0x30,0x20
000034  2400              DCB      0x24,0x00
                  au8LLDD_IIC_H_TAG
000036  244e              DCB      0x24,0x4e
000038  616d653a          DCB      0x61,0x6d,0x65,0x3a
00003c  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000040  445f315f          DCB      0x44,0x5f,0x31,0x5f
000044  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_IIC_IO_H_REVISION
000048  24526576          DCB      0x24,0x52,0x65,0x76
00004c  6973696f          DCB      0x69,0x73,0x69,0x6f
000050  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000054  2e382024          DCB      0x2e,0x38,0x20,0x24
000058  00                DCB      0x00
                  au8LLDD_IIC_IO_H_TAG
000059  244e61            DCB      0x24,0x4e,0x61
00005c  6d653a20          DCB      0x6d,0x65,0x3a,0x20
000060  4c4c4444          DCB      0x4c,0x4c,0x44,0x44
000064  5f315f36          DCB      0x5f,0x31,0x5f,0x36
000068  202400            DCB      0x20,0x24,0x00
                  u8ShadowCrOne
00006b  09                DCB      0x09
                  u8ShadowAr
00006c  00                DCB      0x00
