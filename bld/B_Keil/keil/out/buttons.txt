; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\buttons.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\buttons.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\buttons.crf ..\..\usecases\src\buttons.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  i8GetEncoder PROC
;;;85     
;;;86     int8_t i8GetEncoder(void)
000000  e3a00000          MOV      r0,#0
;;;87     {
;;;88         int8_t i8Value = 0;
;;;89     
;;;90         if (i8Enc_delta != 0)
000004  e59f159c          LDR      r1,|L1.1448|
000008  e5d11000          LDRB     r1,[r1,#0]  ; i8Enc_delta
00000c  e3510000          CMP      r1,#0
000010  0a000009          BEQ      |L1.60|
;;;91         {
;;;92             if (i8Enc_delta > 0)
000014  e59f158c          LDR      r1,|L1.1448|
000018  e1d110d0          LDRSB    r1,[r1,#0]  ; i8Enc_delta
00001c  e3510000          CMP      r1,#0
000020  da000001          BLE      |L1.44|
;;;93             {
;;;94                 i8Value = 1;
000024  e3a00001          MOV      r0,#1
000028  ea000000          B        |L1.48|
                  |L1.44|
;;;95             }
;;;96             else
;;;97             {
;;;98                 i8Value = -1;
00002c  e3e00000          MVN      r0,#0
                  |L1.48|
;;;99             }
;;;100            i8Enc_delta = 0;
000030  e3a01000          MOV      r1,#0
000034  e59f256c          LDR      r2,|L1.1448|
000038  e5c21000          STRB     r1,[r2,#0]  ; i8Enc_delta
                  |L1.60|
;;;101        }
;;;102        
;;;103        return i8Value;
;;;104    }
00003c  e12fff1e          BX       lr
;;;105    
                          ENDP

                  vISREncoder PROC
                  |L1.64|
;;;113    #else
;;;114    __irq void vISREncoder(void)
000040  e92d500f          PUSH     {r0-r3,r12,lr}
;;;115    #endif /* defined(__GHS__) || defined(__ghs__) */
;;;116    {
;;;117        u16TimerCount++;
000044  e59f0560          LDR      r0,|L1.1452|
000048  e1d000b0          LDRH     r0,[r0,#0]  ; u16TimerCount
00004c  e2800001          ADD      r0,r0,#1
000050  e59f1554          LDR      r1,|L1.1452|
000054  e1c100b0          STRH     r0,[r1,#0]  ; u16TimerCount
;;;118    	u8SpeedChangeTimeFlag++;
000058  e59f0550          LDR      r0,|L1.1456|
00005c  e5d00000          LDRB     r0,[r0,#0]  ; u8SpeedChangeTimeFlag
000060  e2800001          ADD      r0,r0,#1
000064  e59f1544          LDR      r1,|L1.1456|
000068  e5c10000          STRB     r0,[r1,#0]  ; u8SpeedChangeTimeFlag
;;;119    	u16Timer1SFlag++;
00006c  e59f0540          LDR      r0,|L1.1460|
000070  e1d000b0          LDRH     r0,[r0,#0]  ; u16Timer1SFlag
000074  e2800001          ADD      r0,r0,#1
000078  e59f1534          LDR      r1,|L1.1460|
00007c  e1c100b0          STRH     r0,[r1,#0]  ; u16Timer1SFlag
;;;120    	u16TimerAlpha++;
000080  e59f0530          LDR      r0,|L1.1464|
000084  e1d000b0          LDRH     r0,[r0,#0]  ; u16TimerAlpha
000088  e2800001          ADD      r0,r0,#1
00008c  e59f1524          LDR      r1,|L1.1464|
000090  e1c100b0          STRH     r0,[r1,#0]  ; u16TimerAlpha
;;;121    	if(u8SpeedChangeTimeFlag > 200) u8SpeedChangeTimeFlag = 0;
000094  e59f0514          LDR      r0,|L1.1456|
000098  e5d00000          LDRB     r0,[r0,#0]  ; u8SpeedChangeTimeFlag
00009c  e35000c8          CMP      r0,#0xc8
0000a0  da000002          BLE      |L1.176|
0000a4  e3a00000          MOV      r0,#0
0000a8  e59f1500          LDR      r1,|L1.1456|
0000ac  e5c10000          STRB     r0,[r1,#0]  ; u8SpeedChangeTimeFlag
                  |L1.176|
;;;122    	if(u16TimerCount > 10000) u16TimerCount = 0;
0000b0  e59f04f4          LDR      r0,|L1.1452|
0000b4  e1d000b0          LDRH     r0,[r0,#0]  ; u16TimerCount
0000b8  e3021710          MOV      r1,#0x2710
0000bc  e1500001          CMP      r0,r1
0000c0  da000002          BLE      |L1.208|
0000c4  e3a00000          MOV      r0,#0
0000c8  e59f14dc          LDR      r1,|L1.1452|
0000cc  e1c100b0          STRH     r0,[r1,#0]  ; u16TimerCount
                  |L1.208|
;;;123    	if(u16Timer1SFlag > 10000) u16Timer1SFlag = 0;
0000d0  e59f04dc          LDR      r0,|L1.1460|
0000d4  e1d000b0          LDRH     r0,[r0,#0]  ; u16Timer1SFlag
0000d8  e3021710          MOV      r1,#0x2710
0000dc  e1500001          CMP      r0,r1
0000e0  da000002          BLE      |L1.240|
0000e4  e3a00000          MOV      r0,#0
0000e8  e59f14c4          LDR      r1,|L1.1460|
0000ec  e1c100b0          STRH     r0,[r1,#0]  ; u16Timer1SFlag
                  |L1.240|
;;;124    	if(u16TimerAlpha > 10000) u16TimerAlpha = 0;
0000f0  e59f04c0          LDR      r0,|L1.1464|
0000f4  e1d000b0          LDRH     r0,[r0,#0]  ; u16TimerAlpha
0000f8  e3021710          MOV      r1,#0x2710
0000fc  e1500001          CMP      r0,r1
000100  da000002          BLE      |L1.272|
000104  e3a00000          MOV      r0,#0
000108  e59f14a8          LDR      r1,|L1.1464|
00010c  e1c100b0          STRH     r0,[r1,#0]  ; u16TimerAlpha
                  |L1.272|
;;;125        vINTC_ModifyIrqLevel(INTC_RESTORE_OLD, INTC_LEVEL_7);
000110  e3a01007          MOV      r1,#7
000114  e3a00000          MOV      r0,#0
000118  ebfffffe          BL       vINTC_ModifyIrqLevel
;;;126    }
00011c  e8bd500f          POP      {r0-r3,r12,lr}
000120  e25ef004          SUBS     pc,lr,#4
;;;127    
                          ENDP

                  vAOBInstallEncPollTimer PROC
;;;130    
;;;131    void vAOBInstallEncPollTimer(uint8_t n)
000124  e92d403e          PUSH     {r1-r5,lr}
;;;132    {
000128  e1a04000          MOV      r4,r0
;;;133        timer_cmplx_genCfg_st timer_cmplx;
;;;134        uint16_t u16CompVal;
;;;135    
;;;136        /* configure complex timer 1 for encoder update */
;;;137        timer_cmplx.eDblBuffEn   = TIMER_CMPLX_DISABLE;    /* do not use double buffer */
00012c  e3a00000          MOV      r0,#0
000130  e5cd0004          STRB     r0,[sp,#4]
;;;138        timer_cmplx.eSyncRstEn   = TIMER_CMPLX_DISABLE;    /* disable synchronous reset acceptance */
000134  e5cd0005          STRB     r0,[sp,#5]
;;;139        timer_cmplx.eIdle        = TIMER_CMPLX_NORMAL;     /* Normal operation */
000138  e3a00001          MOV      r0,#1
00013c  e5cd0006          STRB     r0,[sp,#6]
;;;140        timer_cmplx.ePresclStart = TIMER_CMPLX_STOP;       /* Prescaler stop */
000140  e3a00000          MOV      r0,#0
000144  e5cd0007          STRB     r0,[sp,#7]
;;;141        timer_cmplx.eOvrflwIrqEn = TIMER_CMPLX_DISABLE;    /* Overflow interrupt on/off */
000148  e5cd0008          STRB     r0,[sp,#8]
;;;142        timer_cmplx.eClkSource   = TIMER_CMPLX_CLK_DIV64;  /* Peripheral clock frequency [75MHz]/64 */
00014c  e3a00007          MOV      r0,#7
000150  e5cd0009          STRB     r0,[sp,#9]
;;;143        timer_cmplx.eCountCtrl   = TIMER_CMPLX_ONE_SHOT;   /* On match of compare value 1 reset the counter  */
000154  e3a00001          MOV      r0,#1
000158  e5cd000a          STRB     r0,[sp,#0xa]
;;;144        timer_cmplx.eTimerStart  = TIMER_CMPLX_STOP;       /* Timer start/stop */
00015c  e3a00000          MOV      r0,#0
000160  e5cd000b          STRB     r0,[sp,#0xb]
;;;145        vTIMER_CMPLX_Config(TIMER_CMPLX_PM_1, timer_cmplx);
000164  e3010000          MOVW     r0,#0x1000
000168  e99d0006          LDMIB    sp,{r1,r2}
00016c  ebfffffe          BL       vTIMER_CMPLX_Config
;;;146    
;;;147        // calculate counter value
;;;148        u16CompVal = TIMERCOMPLX_NUMBER(n);//ENCODER_TICK_RATIO;
000170  e0640204          RSB      r0,r4,r4,LSL #4
000174  e0800100          ADD      r0,r0,r0,LSL #2
000178  e0600200          RSB      r0,r0,r0,LSL #4
00017c  e6ff5070          UXTH     r5,r0
;;;149        vTIMER_CMPLX_SetCompareVal1(TIMER_CMPLX_PM_1, u16CompVal);
000180  e1a01005          MOV      r1,r5
000184  e3010000          MOVW     r0,#0x1000
000188  ebfffffe          BL       vTIMER_CMPLX_SetCompareVal1
;;;150    
;;;151        /* configure interrupt modes */
;;;152        i32INTC_SourceConfig(INTC_TIM1_MAVAL1, INTC_TO_CPU, INTC_EDGE_FALL, INTC_LEVEL_3, INTC_AUTO_CLEAR_ENABLE);
00018c  e3a00001          MOV      r0,#1
000190  e3a03003          MOV      r3,#3
000194  e3a02002          MOV      r2,#2
000198  e3a01000          MOV      r1,#0
00019c  e58d0000          STR      r0,[sp,#0]
0001a0  e59f0414          LDR      r0,|L1.1468|
0001a4  ebfffffe          BL       i32INTC_SourceConfig
;;;153        
;;;154        /* set callback function for tick timer IRQ */
;;;155        vINTC_SetISRStartAddress(INTC_TIM1_MAVAL1, (uint32_t)&vISREncoder);
0001a8  e24f1e17          ADR      r1,|L1.64|
0001ac  e59f0408          LDR      r0,|L1.1468|
0001b0  ebfffffe          BL       vINTC_SetISRStartAddress
;;;156    
;;;157        vTIMER_CMPLX_StartPrescaler(TIMER_CMPLX_PM_1);     /* start timer prescaler */
0001b4  e3010000          MOVW     r0,#0x1000
0001b8  ebfffffe          BL       vTIMER_CMPLX_StartPrescaler
;;;158        vTIMER_CMPLX_Start(TIMER_CMPLX_PM_1);              /* start tick timer */
0001bc  e3010000          MOVW     r0,#0x1000
0001c0  ebfffffe          BL       vTIMER_CMPLX_Start
;;;159    }
0001c4  e8bd803e          POP      {r1-r5,pc}
;;;160    
                          ENDP

                  vInitPushbuttons PROC
;;;163    
;;;164    void vInitPushbuttons(void)
0001c8  e3a00000          MOV      r0,#0
;;;165    {
;;;166        i8Encoder_Rest = 0;
0001cc  e59f13ec          LDR      r1,|L1.1472|
0001d0  e5c10000          STRB     r0,[r1,#0]  ; i8Encoder_Rest
;;;167        u8Graycode = 0;
0001d4  e59f13e8          LDR      r1,|L1.1476|
0001d8  e5c10000          STRB     r0,[r1,#0]  ; u8Graycode
;;;168    
;;;169        /* Encoder increment */
;;;170        i8Enc_delta = 0;
0001dc  e59f13c4          LDR      r1,|L1.1448|
0001e0  e5c10000          STRB     r0,[r1,#0]  ; i8Enc_delta
;;;171    
;;;172       // vPinconfig_Buttons();
;;;173        //vAOBInstallEncPollTimer();
;;;174    
;;;175        /* button 1 */
;;;176        u32Pushbutton1_wait = 0;
0001e4  e59f13dc          LDR      r1,|L1.1480|
0001e8  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_wait
;;;177        u32Pushbutton1_new  = 0;
0001ec  e59f13d8          LDR      r1,|L1.1484|
0001f0  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_new
;;;178        u32Pushbutton1_old  = 0;    
0001f4  e59f13d4          LDR      r1,|L1.1488|
0001f8  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_old
;;;179    
;;;180        /* button 2 */
;;;181        u32Pushbutton2_wait = 0;
0001fc  e59f13d0          LDR      r1,|L1.1492|
000200  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_wait
;;;182        u32Pushbutton2_new  = 0;
000204  e59f13cc          LDR      r1,|L1.1496|
000208  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_new
;;;183        u32Pushbutton2_old  = 0;
00020c  e59f13c8          LDR      r1,|L1.1500|
000210  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_old
;;;184    
;;;185        /* button 3 */
;;;186        u32Pushbutton3_wait = 0;
000214  e59f13c4          LDR      r1,|L1.1504|
000218  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_wait
;;;187        u32Pushbutton3_new  = 0;
00021c  e59f13c0          LDR      r1,|L1.1508|
000220  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_new
;;;188        u32Pushbutton3_old  = 0;
000224  e59f13bc          LDR      r1,|L1.1512|
000228  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_old
;;;189    
;;;190        /* button 4 */
;;;191        u32Pushbutton4_wait = 0;
00022c  e59f13b8          LDR      r1,|L1.1516|
000230  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_wait
;;;192        u32Pushbutton4_new  = 0;
000234  e59f13b4          LDR      r1,|L1.1520|
000238  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_new
;;;193        u32Pushbutton4_old  = 0;    
00023c  e59f13b0          LDR      r1,|L1.1524|
000240  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_old
;;;194    
;;;195        /* button encoder */
;;;196        u32Pushbutton5_wait = 0;
000244  e59f13ac          LDR      r1,|L1.1528|
000248  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_wait
;;;197        u32Pushbutton5_new  = 0;
00024c  e59f13a8          LDR      r1,|L1.1532|
000250  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_new
;;;198        u32Pushbutton5_old  = 0;    
000254  e59f13a4          LDR      r1,|L1.1536|
000258  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_old
;;;199    }
00025c  e12fff1e          BX       lr
;;;200    
                          ENDP

                  vUpdatePushbuttons PROC
;;;203    
;;;204    void vUpdatePushbuttons(void)
000260  e92d4008          PUSH     {r3,lr}
;;;205    {
;;;206        gpio_state_e ePBState = GPIO_LOW;
000264  e3a00000          MOV      r0,#0
000268  e58d0000          STR      r0,[sp,#0]
;;;207    
;;;208        /* AOB: encoder increment */
;;;209        stStatevariables.i8EncoderInc = i8GetEncoder();
00026c  ebfffffe          BL       i8GetEncoder
000270  e59f138c          LDR      r1,|L1.1540|
000274  e5c10019          STRB     r0,[r1,#0x19]  ; stStatevariables
;;;210    
;;;211        /* button 1 */
;;;212        i32GPIO_GetPinState(PORT_I2SMCLK, &ePBState);
000278  e1a0100d          MOV      r1,sp
00027c  e3000101          MOV      r0,#0x101
000280  ebfffffe          BL       i32GPIO_GetPinState
;;;213        if( ePBState == 0 )
000284  e5dd0000          LDRB     r0,[sp,#0]
000288  e3500000          CMP      r0,#0
00028c  1a000019          BNE      |L1.760|
;;;214        {
;;;215            u32Pushbutton1_wait = u32Pushbutton1_wait + 1;
000290  e59f0330          LDR      r0,|L1.1480|
000294  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton1_wait
000298  e2800001          ADD      r0,r0,#1
00029c  e59f1324          LDR      r1,|L1.1480|
0002a0  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_wait
;;;216            if( u32Pushbutton1_wait > PB_DELAY )
0002a4  e2810000          ADD      r0,r1,#0
0002a8  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton1_wait
0002ac  e3500003          CMP      r0,#3
0002b0  9a000017          BLS      |L1.788|
;;;217            {
;;;218                u32Pushbutton1_new = 1;
0002b4  e3a00001          MOV      r0,#1
0002b8  e59f130c          LDR      r1,|L1.1484|
0002bc  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_new
;;;219                if( u32Pushbutton1_new != u32Pushbutton1_old )
0002c0  e2810000          ADD      r0,r1,#0
0002c4  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton1_new
0002c8  e59f1300          LDR      r1,|L1.1488|
0002cc  e5911000          LDR      r1,[r1,#0]  ; u32Pushbutton1_old
0002d0  e1500001          CMP      r0,r1
0002d4  0a00000e          BEQ      |L1.788|
;;;220                {
;;;221                    u32Pushbutton1_old = u32Pushbutton1_new;
0002d8  e59f02ec          LDR      r0,|L1.1484|
0002dc  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton1_new
0002e0  e59f12e8          LDR      r1,|L1.1488|
0002e4  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_old
;;;222            
;;;223                    stStatevariables.u16Button_1 = 1;
0002e8  e3a00001          MOV      r0,#1
0002ec  e59f1310          LDR      r1,|L1.1540|
0002f0  e1c101ba          STRH     r0,[r1,#0x1a]  ; stStatevariables
0002f4  ea000006          B        |L1.788|
                  |L1.760|
;;;224                }
;;;225            }
;;;226        }
;;;227        else
;;;228        {
;;;229            u32Pushbutton1_wait = 0;
0002f8  e3a00000          MOV      r0,#0
0002fc  e59f12c4          LDR      r1,|L1.1480|
000300  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_wait
;;;230            u32Pushbutton1_new = 0;
000304  e59f12c0          LDR      r1,|L1.1484|
000308  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_new
;;;231            u32Pushbutton1_old = 0;
00030c  e59f12bc          LDR      r1,|L1.1488|
000310  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton1_old
                  |L1.788|
;;;232        }
;;;233    
;;;234        /* button 2 */
;;;235        i32GPIO_GetPinState(PORT_I2S0CLK, &ePBState);
000314  e1a0100d          MOV      r1,sp
000318  e3a000fe          MOV      r0,#0xfe
00031c  ebfffffe          BL       i32GPIO_GetPinState
;;;236        if( ePBState == 0)
000320  e5dd0000          LDRB     r0,[sp,#0]
000324  e3500000          CMP      r0,#0
000328  1a000019          BNE      |L1.916|
;;;237        {
;;;238            u32Pushbutton2_wait = u32Pushbutton2_wait + 1;
00032c  e59f02a0          LDR      r0,|L1.1492|
000330  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton2_wait
000334  e2800001          ADD      r0,r0,#1
000338  e59f1294          LDR      r1,|L1.1492|
00033c  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_wait
;;;239            if( u32Pushbutton2_wait > PB_DELAY )
000340  e2810000          ADD      r0,r1,#0
000344  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton2_wait
000348  e3500003          CMP      r0,#3
00034c  9a000017          BLS      |L1.944|
;;;240            {
;;;241                u32Pushbutton2_new = 1;
000350  e3a00001          MOV      r0,#1
000354  e59f127c          LDR      r1,|L1.1496|
000358  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_new
;;;242                if( u32Pushbutton2_new != u32Pushbutton2_old )
00035c  e2810000          ADD      r0,r1,#0
000360  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton2_new
000364  e59f1270          LDR      r1,|L1.1500|
000368  e5911000          LDR      r1,[r1,#0]  ; u32Pushbutton2_old
00036c  e1500001          CMP      r0,r1
000370  0a00000e          BEQ      |L1.944|
;;;243                {
;;;244                    u32Pushbutton2_old = u32Pushbutton2_new;
000374  e59f025c          LDR      r0,|L1.1496|
000378  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton2_new
00037c  e59f1258          LDR      r1,|L1.1500|
000380  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_old
;;;245    
;;;246                    stStatevariables.u16Button_2 = 1;
000384  e3a00001          MOV      r0,#1
000388  e59f1274          LDR      r1,|L1.1540|
00038c  e1c101bc          STRH     r0,[r1,#0x1c]  ; stStatevariables
000390  ea000006          B        |L1.944|
                  |L1.916|
;;;247                }
;;;248            }
;;;249        }
;;;250        else
;;;251        {
;;;252            u32Pushbutton2_wait = 0;
000394  e3a00000          MOV      r0,#0
000398  e59f1234          LDR      r1,|L1.1492|
00039c  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_wait
;;;253            u32Pushbutton2_new = 0;
0003a0  e59f1230          LDR      r1,|L1.1496|
0003a4  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_new
;;;254            u32Pushbutton2_old = 0;
0003a8  e59f122c          LDR      r1,|L1.1500|
0003ac  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton2_old
                  |L1.944|
;;;255        }
;;;256    
;;;257        /* button 3 */
;;;258        i32GPIO_GetPinState(PORT_I2S0WS, &ePBState);
0003b0  e1a0100d          MOV      r1,sp
0003b4  e3a000ff          MOV      r0,#0xff
0003b8  ebfffffe          BL       i32GPIO_GetPinState
;;;259        if( ePBState == 0)
0003bc  e5dd0000          LDRB     r0,[sp,#0]
0003c0  e3500000          CMP      r0,#0
0003c4  1a000019          BNE      |L1.1072|
;;;260        {
;;;261            u32Pushbutton3_wait = u32Pushbutton3_wait + 1;
0003c8  e59f0210          LDR      r0,|L1.1504|
0003cc  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton3_wait
0003d0  e2800001          ADD      r0,r0,#1
0003d4  e59f1204          LDR      r1,|L1.1504|
0003d8  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_wait
;;;262            if( u32Pushbutton3_wait > PB_DELAY )
0003dc  e2810000          ADD      r0,r1,#0
0003e0  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton3_wait
0003e4  e3500003          CMP      r0,#3
0003e8  9a000017          BLS      |L1.1100|
;;;263            {
;;;264                u32Pushbutton3_new = 1;
0003ec  e3a00001          MOV      r0,#1
0003f0  e59f11ec          LDR      r1,|L1.1508|
0003f4  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_new
;;;265                if( u32Pushbutton3_new != u32Pushbutton3_old )
0003f8  e2810000          ADD      r0,r1,#0
0003fc  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton3_new
000400  e59f11e0          LDR      r1,|L1.1512|
000404  e5911000          LDR      r1,[r1,#0]  ; u32Pushbutton3_old
000408  e1500001          CMP      r0,r1
00040c  0a00000e          BEQ      |L1.1100|
;;;266                {
;;;267                    u32Pushbutton3_old = u32Pushbutton3_new;
000410  e59f01cc          LDR      r0,|L1.1508|
000414  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton3_new
000418  e59f11c8          LDR      r1,|L1.1512|
00041c  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_old
;;;268    
;;;269                    stStatevariables.u16Button_3 = 1;
000420  e3a00001          MOV      r0,#1
000424  e59f11d8          LDR      r1,|L1.1540|
000428  e1c101be          STRH     r0,[r1,#0x1e]  ; stStatevariables
00042c  ea000006          B        |L1.1100|
                  |L1.1072|
;;;270                }
;;;271            }
;;;272        }
;;;273        else
;;;274        {
;;;275            u32Pushbutton3_wait = 0;
000430  e3a00000          MOV      r0,#0
000434  e59f11a4          LDR      r1,|L1.1504|
000438  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_wait
;;;276            u32Pushbutton3_new = 0;
00043c  e59f11a0          LDR      r1,|L1.1508|
000440  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_new
;;;277            u32Pushbutton3_old = 0;
000444  e59f119c          LDR      r1,|L1.1512|
000448  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton3_old
                  |L1.1100|
;;;278        }
;;;279    
;;;280        /* button 4 */
;;;281        i32GPIO_GetPinState(PORT_I2S0SD, &ePBState);
00044c  e1a0100d          MOV      r1,sp
000450  e3000100          MOVW     r0,#0x100
000454  ebfffffe          BL       i32GPIO_GetPinState
;;;282        if( ePBState == 0)
000458  e5dd0000          LDRB     r0,[sp,#0]
00045c  e3500000          CMP      r0,#0
000460  1a000019          BNE      |L1.1228|
;;;283        {
;;;284            u32Pushbutton4_wait = u32Pushbutton4_wait + 1;
000464  e59f0180          LDR      r0,|L1.1516|
000468  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton4_wait
00046c  e2800001          ADD      r0,r0,#1
000470  e59f1174          LDR      r1,|L1.1516|
000474  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_wait
;;;285            if( u32Pushbutton4_wait > PB_DELAY )
000478  e2810000          ADD      r0,r1,#0
00047c  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton4_wait
000480  e3500003          CMP      r0,#3
000484  9a000017          BLS      |L1.1256|
;;;286            {
;;;287                u32Pushbutton4_new = 1;
000488  e3a00001          MOV      r0,#1
00048c  e59f115c          LDR      r1,|L1.1520|
000490  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_new
;;;288                if( u32Pushbutton4_new != u32Pushbutton4_old )
000494  e2810000          ADD      r0,r1,#0
000498  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton4_new
00049c  e59f1150          LDR      r1,|L1.1524|
0004a0  e5911000          LDR      r1,[r1,#0]  ; u32Pushbutton4_old
0004a4  e1500001          CMP      r0,r1
0004a8  0a00000e          BEQ      |L1.1256|
;;;289                {
;;;290                    u32Pushbutton4_old = u32Pushbutton4_new;
0004ac  e59f013c          LDR      r0,|L1.1520|
0004b0  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton4_new
0004b4  e59f1138          LDR      r1,|L1.1524|
0004b8  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_old
;;;291    
;;;292                    stStatevariables.u16Button_4 = 1;
0004bc  e3a00001          MOV      r0,#1
0004c0  e59f113c          LDR      r1,|L1.1540|
0004c4  e1c102b0          STRH     r0,[r1,#0x20]  ; stStatevariables
0004c8  ea000006          B        |L1.1256|
                  |L1.1228|
;;;293                }
;;;294            }
;;;295        }
;;;296        else
;;;297        {
;;;298            u32Pushbutton4_wait = 0;
0004cc  e3a00000          MOV      r0,#0
0004d0  e59f1114          LDR      r1,|L1.1516|
0004d4  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_wait
;;;299            u32Pushbutton4_new = 0;
0004d8  e59f1110          LDR      r1,|L1.1520|
0004dc  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_new
;;;300            u32Pushbutton4_old = 0;
0004e0  e59f110c          LDR      r1,|L1.1524|
0004e4  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton4_old
                  |L1.1256|
;;;301        }	
;;;302    
;;;303        /* button encoder */
;;;304        i32GPIO_GetPinState(PORT_PNLGPP6, &ePBState);
0004e8  e1a0100d          MOV      r1,sp
0004ec  e3a00090          MOV      r0,#0x90
0004f0  ebfffffe          BL       i32GPIO_GetPinState
;;;305        if( ePBState == 0)
0004f4  e5dd0000          LDRB     r0,[sp,#0]
0004f8  e3500000          CMP      r0,#0
0004fc  1a000019          BNE      |L1.1384|
;;;306        {
;;;307            u32Pushbutton5_wait = u32Pushbutton5_wait + 1;
000500  e59f00f0          LDR      r0,|L1.1528|
000504  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton5_wait
000508  e2800001          ADD      r0,r0,#1
00050c  e59f10e4          LDR      r1,|L1.1528|
000510  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_wait
;;;308            if( u32Pushbutton5_wait > PB_DELAY )
000514  e2810000          ADD      r0,r1,#0
000518  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton5_wait
00051c  e3500003          CMP      r0,#3
000520  9a000017          BLS      |L1.1412|
;;;309            {
;;;310                u32Pushbutton5_new = 1;
000524  e3a00001          MOV      r0,#1
000528  e59f10cc          LDR      r1,|L1.1532|
00052c  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_new
;;;311                if( u32Pushbutton5_new != u32Pushbutton5_old )
000530  e2810000          ADD      r0,r1,#0
000534  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton5_new
000538  e59f10c0          LDR      r1,|L1.1536|
00053c  e5911000          LDR      r1,[r1,#0]  ; u32Pushbutton5_old
000540  e1500001          CMP      r0,r1
000544  0a00000e          BEQ      |L1.1412|
;;;312                {
;;;313                    u32Pushbutton5_old = u32Pushbutton5_new;
000548  e59f00ac          LDR      r0,|L1.1532|
00054c  e5900000          LDR      r0,[r0,#0]  ; u32Pushbutton5_new
000550  e59f10a8          LDR      r1,|L1.1536|
000554  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_old
;;;314    
;;;315                    stStatevariables.u16Button_enc = 1;
000558  e3a00001          MOV      r0,#1
00055c  e59f10a0          LDR      r1,|L1.1540|
000560  e1c102b2          STRH     r0,[r1,#0x22]  ; stStatevariables
000564  ea000006          B        |L1.1412|
                  |L1.1384|
;;;316                }
;;;317            }
;;;318        }
;;;319        else
;;;320        {
;;;321            u32Pushbutton5_wait = 0;
000568  e3a00000          MOV      r0,#0
00056c  e59f1084          LDR      r1,|L1.1528|
000570  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_wait
;;;322            u32Pushbutton5_new = 0;
000574  e59f1080          LDR      r1,|L1.1532|
000578  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_new
;;;323            u32Pushbutton5_old = 0;
00057c  e59f107c          LDR      r1,|L1.1536|
000580  e5810000          STR      r0,[r1,#0]  ; u32Pushbutton5_old
                  |L1.1412|
;;;324        }	
;;;325        stStatevariables.i8EncoderInc  = 0;
000584  e3a00000          MOV      r0,#0
000588  e59f1074          LDR      r1,|L1.1540|
00058c  e5c10019          STRB     r0,[r1,#0x19]  ; stStatevariables
;;;326        stStatevariables.u16Button_1   = 0;
000590  e1c101ba          STRH     r0,[r1,#0x1a]  ; stStatevariables
;;;327        stStatevariables.u16Button_2   = 0;
000594  e1c101bc          STRH     r0,[r1,#0x1c]  ; stStatevariables
;;;328        stStatevariables.u16Button_3   = 0;
000598  e1c101be          STRH     r0,[r1,#0x1e]  ; stStatevariables
;;;329        stStatevariables.u16Button_4   = 0;
00059c  e1c102b0          STRH     r0,[r1,#0x20]  ; stStatevariables
;;;330        stStatevariables.u16Button_enc = 0;
0005a0  e1c102b2          STRH     r0,[r1,#0x22]  ; stStatevariables
;;;331    
;;;332    }
0005a4  e8bd8008          POP      {r3,pc}
;;;333    
                          ENDP

                  |L1.1448|
                          DCD      i8Enc_delta
                  |L1.1452|
                          DCD      u16TimerCount
                  |L1.1456|
                          DCD      u8SpeedChangeTimeFlag
                  |L1.1460|
                          DCD      u16Timer1SFlag
                  |L1.1464|
                          DCD      u16TimerAlpha
                  |L1.1468|
                          DCD      0x02012449
                  |L1.1472|
                          DCD      i8Encoder_Rest
                  |L1.1476|
                          DCD      u8Graycode
                  |L1.1480|
                          DCD      u32Pushbutton1_wait
                  |L1.1484|
                          DCD      u32Pushbutton1_new
                  |L1.1488|
                          DCD      u32Pushbutton1_old
                  |L1.1492|
                          DCD      u32Pushbutton2_wait
                  |L1.1496|
                          DCD      u32Pushbutton2_new
                  |L1.1500|
                          DCD      u32Pushbutton2_old
                  |L1.1504|
                          DCD      u32Pushbutton3_wait
                  |L1.1508|
                          DCD      u32Pushbutton3_new
                  |L1.1512|
                          DCD      u32Pushbutton3_old
                  |L1.1516|
                          DCD      u32Pushbutton4_wait
                  |L1.1520|
                          DCD      u32Pushbutton4_new
                  |L1.1524|
                          DCD      u32Pushbutton4_old
                  |L1.1528|
                          DCD      u32Pushbutton5_wait
                  |L1.1532|
                          DCD      u32Pushbutton5_new
                  |L1.1536|
                          DCD      u32Pushbutton5_old
                  |L1.1540|
                          DCD      stStatevariables

                          AREA ||.data||, DATA, ALIGN=2

                  u32Pushbutton1_wait
                          DCD      0x00000000
                  u32Pushbutton1_new
                          DCD      0x00000000
                  u32Pushbutton1_old
                          DCD      0x00000000
                  u32Pushbutton2_wait
                          DCD      0x00000000
                  u32Pushbutton2_new
                          DCD      0x00000000
                  u32Pushbutton2_old
                          DCD      0x00000000
                  u32Pushbutton3_wait
                          DCD      0x00000000
                  u32Pushbutton3_new
                          DCD      0x00000000
                  u32Pushbutton3_old
                          DCD      0x00000000
                  u32Pushbutton4_wait
                          DCD      0x00000000
                  u32Pushbutton4_new
                          DCD      0x00000000
                  u32Pushbutton4_old
                          DCD      0x00000000
                  u32Pushbutton5_wait
                          DCD      0x00000000
                  u32Pushbutton5_new
                          DCD      0x00000000
                  u32Pushbutton5_old
                          DCD      0x00000000
                  i8Graytab
00003c  0001ff00          DCB      0x00,0x01,0xff,0x00
000040  ff000001          DCB      0xff,0x00,0x00,0x01
000044  010000ff          DCB      0x01,0x00,0x00,0xff
000048  00ff0100          DCB      0x00,0xff,0x01,0x00
                  i8Enc_delta
00004c  00                DCB      0x00
                  i8Encoder_Rest
00004d  00                DCB      0x00
                  u8Graycode
00004e  0000              DCB      0x00,0x00
                  u16TimerCount
000050  0000              DCW      0x0000
                  u16Timer1SFlag
000052  0000              DCW      0x0000
                  u16TimerAlpha
000054  0000              DCW      0x0000
