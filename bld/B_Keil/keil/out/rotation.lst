L 1 "..\..\..\..\mw\src\rotation.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Some helper functions for ratation, scaling, shearing, 
N*                 perspective operation.
N*                 Reference Low-Level Driver (Rotation Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Rotation Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/07/21 12:43:33 $
N*   TAG         : $Name: Graphic_Middleware_V1_5 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 25 "..\..\..\..\mw\src\rotation.c" 2
N#include "rotation.h"
L 1 "..\..\..\..\mw\inc\rotation.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Some helper functions for ratation, scaling, shearing, 
N*                 perspective operation.
N*                 Reference Low-Level Driver (Rotation Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Rotation Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.10 $
N*   DATE        : $Date: 2015/07/21 12:38:46 $
N*   TAG         : $Name: Graphic_Middleware_V1_5 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef ROTATION_LIB_H
N#define ROTATION_LIB_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N#include "gf.h"
L 1 "..\..\..\..\mw\inc\gf.h" 1
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronic Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : Contains declarations for Image structures
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Middleware
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.8 $
N*   DATE        : $Date: 2015/07/21 12:38:02 $
N*   TAG         : $Name: Graphic_Middleware_V1_5 $
N*   RELEASE     : Preliminary & Confidential
N****************************************************************************/
N#ifndef GF_H
N#define GF_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define MW_GF_H_REVISION     "$Revision: 1.8 $"
N#define MW_GF_H_TAG          "$Name: Graphic_Middleware_V1_5 $"
N
N/*********************************************/
N/*---------------------------------------
N|             MATH LIBRARY USE           |
N ---------------------------------------*/
N/* Enables use of standard math library */
N/* if following define is disabled, LLDD/GA rotation and scaling are using integer instead of float */
N/* and sin/cos lookup table is used instead of math library functions */
N
N#define GA_USE_MATH_LIB
N
N#ifdef GA_USE_MATH_LIB
N/* Pi Constant Value */
N#define GA_CONST_PI 3.1415926535897932384626433
N#endif
N
N/**********************************************
N*            External variables               *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
N/*********************************************/
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N
N/**
N* @brief Transformation table structure
N*/
Ntypedef struct tag_table_st
N{
N    uint32_t    u32Address;         /*!< Table source address */
N    uint16_t    u16Width;           /*!< Image width */
N    uint16_t    u16Height;          /*!< Image height */
N} gf_table_st;
N
N
N/**
N* @brief Image description structure
N*/
Ntypedef struct tag_image_st
N{
N    uint32_t    u32Address;         /*!< Image source address */
N    uint16_t    u16Width;           /*!< Image width */
N    uint16_t    u16Height;          /*!< Image height */
N    int16_t     i16CenterX;         /*!< Image rotation center X-coord (optional) */
N    int16_t     i16CenterY;         /*!< Image rotation center Y-coord (optional) */
N    uint8_t     eFormat;            /*!< Image Format */
N    uint32_t    u32Paletteaddress;  /*!< palette address for PNG */
N} gf_image_st;
N
N
N/**
N* @brief CLUT description structure
N*/
Ntypedef struct tag_clut_st
N{
N    uint32_t    u32Address;         /*!< CLUT source address */
N    uint8_t     u8Length;           /*!< CLUT length */
N} gf_clut_st;
N
N/*********************************************/
N
N
N/**********************************************
N*            Function prototypes              *
N**********************************************/
N
N
N/***************************************************************************/
N
N#endif /* GF_H */
N
N/***************************************************************************/
N
N/************************* BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER *****************************/
L 28 "..\..\..\..\mw\inc\rotation.h" 2
N#include "rotation_matrix.h"
L 1 "..\..\..\..\lldd\inc\rotation_matrix.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver Matrix Form (Rotation Engine)
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator Rotation Engine
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.15 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef ROTATION_MATRIX_H
N#define ROTATION_MATRIX_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
N#include "ga_common.h"
L 1 "..\..\..\..\lldd\inc\ga_common.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Graphic Accelerator
N*                 Reference Low-Level Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphic Accelerator
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.14 $
N*   DATE        : $Date: 2015/07/21 12:30:20 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GA_COMMON_H
N#define GA_COMMON_H
N
N/*======================================
N             Include Files
N=======================================*/
N#include "captypes.h"
N
N#define LLDD_GA_COMMON_H_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_COMMON_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*==========================================================================
N|                       GA Configuration Parameters                         |
N ==========================================================================*/
N/*---------------------------------------
N|        GA Sub-Module inclusion         |
N ---------------------------------------*/
N/* Blitting Engine */
N#define GA_USE_BLITTING
N
N/* Transformation Engine */
N#define GA_USE_TRANSFORM
N
N/* Rotation Engine */
N#define GA_USE_ROTATION
N
N/* Drawing Engine */
N#define GA_USE_DRAWING
N
N/*---------------------------------------
N|         GA List Configuration          |
N ---------------------------------------*/
N/* Maximal Number of commands in one list */
N#define GA_CMD_MAX    2048
N
N/*---------------------------------------
N|  Enable/Disable boundary check for     |
N|         GA Command List                |
N ---------------------------------------*/
N/* Enable/Disable boundary check in drivers for command buffer: */
N/* #define GA_CMDSLIST_BOUNDARY_CHECK */
N
N
N/* 1 double word more will be reserved by calculation of needed
N   buffers for GA-API's. This is necesary to add later an END-Command to 
N   finalize the command: 
N*/   
N#define RESERVED_FOR_END_CMD    1
N
N/*======================================
N                Defs
N=======================================*/
N
N/*--------------------------------------
N|     GA General Purpose Registers      |
N --------------------------------------*/
N#define GA_GPR0   0
N#define GA_GPR1   1
N#define GA_GPR2   2
N#define GA_GPR3   3
N#define GA_GPR4   4
N#define GA_GPR5   5
N#define GA_GPR6   6
N#define GA_GPR7   7
N#define GA_GPR8   8
N#define GA_GPR9   9
N#define GA_GPR10  10
N#define GA_GPR11  11
N#define GA_GPR12  12
N#define GA_GPR13  13
N#define GA_GPR14  14
N#define GA_GPR15  15
N#define GA_GPR16  16
N#define GA_GPR17  17
N#define GA_GPR18  18
N#define GA_GPR19  19
N#define GA_GPR20  20
N#define GA_GPR21  21
N#define GA_GPR22  22
N#define GA_GPR23  23
N#define GA_GPR24  24
N#define GA_GPR25  25
N#define GA_GPR26  26
N#define GA_GPR27  27
N#define GA_GPR28  28
N#define GA_GPR29  29
N#define GA_GPR30  30
N#define GA_GPR31  31
N
N
N/*--------------------------------------
N|         GA Command Parameters         |
N --------------------------------------*/
N/* Selection of module to wait on */
Ntypedef enum tag_ga_modul_e
N{
N    GA_GDC0        = 0x0u,
N    GA_FG0         = 0x1u,
N    GA_GDC1        = 0x2u
N} ga_modul_e;
N
N/* Enables/Disables option */
Ntypedef enum tag_ga_en_e
N{
N    GA_DIS         = 0x0u,     /* Disable/off */
N    GA_EN          = 0x1u      /* Enable/on */
N} ga_en_e;
N
N/* Blending Order */
Ntypedef enum tag_blendOrd_e
N{
N    GA_ONTO_DEST   = 0x0u,     /* Onto destination */
N    GA_BEHIND_DEST = 0x1u      /* Behind destination */
N} ga_blendOrd_e;
N
N/* Color format selection */
Ntypedef enum tag_ga_colFmt_e
N{
N    GA_RGB16       = 0x0u,      /* 16-bit RGB format */
N    GA_RGBA32      = 0x1u       /* 32-bit RGBA format */
N} ga_colFmt_e;
N
N/*--------------------------------------
N|        GA Command Construction        |
N --------------------------------------*/
N/* Command Field Masks */
N#define GA_MASK1           0x1u
N#define GA_MASK2           0x3u
N#define GA_MASK3           0x7u
N#define GA_MASK4           0xfu
N#define GA_MASK5           0x1fu
N#define GA_MASK6           0x3fu
N#define GA_MASK7           0x7fu
N#define GA_MASK8           0xffu
N#define GA_MASK9           0x1ffu
N#define GA_MASK10          0x3ffu
N#define GA_MASK12          0xfffu
N#define GA_MASK14          0x3fffu
N#define GA_MASK15          0x7fffu
N#define GA_MASK16          0xffffu
N#define GA_MASK22          0x3fffffu
N#define GA_MASK24          0xffffffu
N#define GA_MASK32          0xffffffffu
N#define GA_MASK36          0xfffffffffull
N#define GA_MASK48          0xffffffffffffull
N#define GA_MASK64          0xffffffffffffffffull
N
N/* GA Unit selection */
N#define GA_SCHED           0x0u
N#define GA_BLITING         0x1u
N#define GA_DRAWING         0x2u
N#define GA_ROTATION        0x3u
N#define GA_TRANSFORM       0x4u
N
N/*** Command Codes ***/
N#define GA_CMC_LGPR        0x1u
N#define GA_CMC_CSWVSYNC    0x2u
N#define GA_CMC_CSUIC	     0x3u
N#define GA_CMC_CSGDC0CC	   0x4u
N#define GA_CMC_CSGDC1CC	   0x5u
N#define GA_CMC_END         0xffu
N
N/* Blitting Engine Command Codes */
N
N#define GA_CMC_BLTO16      0x02u
N#define GA_CMC_BLTO32      0x04u
N#define GA_CMC_BLTORLEI16  0x0au
N#define GA_CMC_BLTORLEI24  0x06u
N#define GA_CMC_BLTORLEI24A 0x0Eu
N#define GA_CMC_BLTORLEI32  0x0cu
N#define GA_CMC_BLTOP16     0x12u
N#define GA_CMC_BLTOP32     0x14u
N#define GA_CMC_BLTB16      0x03u
N#define GA_CMC_BLTB32      0x07u
N#define GA_CMC_BLTBRLEI16  0x0bu
N#define GA_CMC_BLTBRLEI24  0x05u
N#define GA_CMC_BLTBRLEI24A 0x0fu
N#define GA_CMC_BLTBRLEI32  0x0du
N#define GA_CMC_BLTBP16     0x13u
N#define GA_CMC_BLTBP32     0x17u
N
N/* Transformation Engine Command Code */
N#define GA_CMC_TRANSF      0x01u
N#define GA_CMC_TRANSFB     0x00u
N
N/* Rotation Engine Command Code */
N#define GA_CMC_ROT         0x01u
N#define GA_CMC_ROTB        0x00u
N
N/* Drawing Engine Command Codes */
N#define GA_CMC_DE_DLRGBA32 0x03u
N#define GA_CMC_DE_DLRGB16  0x04u
N#define GA_CMC_DE_DTRGBA32 0x05u
N#define GA_CMC_DE_DTRGB16  0x06u
N
N/* Command Field Offsets */
N#define GA_ENG_OFF         60
N#define GA_LEN_OFF         56
N#define GA_CMC_OFF         48
N#define GA_SPC_OFF          0
N
N/* Command Field Masks */
N#define GA_ENG_MSK         (GA_MASK3)
N#define GA_LEN_MSK         (GA_MASK4)
N#define GA_CMC_MSK         (GA_MASK8)
N#define GA_SPC_MSK         (GA_MASK48)
N
N/* Macro for command field positioning */
N#define GA_FP(val, offset, mask) (((uint64_t)(val) & (mask)) << (offset))
N
N/* GA Command Fields (Engine, Length, Command code, Cmd Specific Params.)*/
N#define GA_ENG(Engine) (GA_FP((Engine), GA_ENG_OFF, GA_ENG_MSK))
N#define GA_LEN(Len)    (GA_FP((Len)   , GA_LEN_OFF, GA_LEN_MSK))
N#define GA_CMC(Code)   (GA_FP((Code)  , GA_CMC_OFF, GA_CMC_MSK))
N#define GA_SPC(spec)   (GA_FP((spec)  , GA_SPC_OFF, GA_SPC_MSK))
N
N/* GA Command Construction Macro */
N#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    | \
N                                                GA_ENG((Engine))   | \
N                                                GA_LEN((Len))      | \
N                                                GA_CMC((CmdCode))  | \
N                                                GA_SPC((CmdSpec)))
X#define GA_CMN(Engine, Len, CmdCode, CmdSpec) ((uint64_t)0x0ull    |                                                 GA_ENG((Engine))   |                                                 GA_LEN((Len))      |                                                 GA_CMC((CmdCode))  |                                                 GA_SPC((CmdSpec)))
N
N/*=========================================================================
N|                        SCHEDULER OPERATION COMMANDS                      |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load General-Purpose Register Command (LGPR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to configure
N|             one out of the 32 General-Purpose Registers. The command
N|             specific parameter for this command is the number of the
N|             register that should be loaded and the value itself.
N|
N|  Params:    regNr   - The number of the General-Purpose Register that
N|                       should be loaded
N|
N|             uiVal   - Value that should be stored within the selected
N|                       register. If the register does not encapsulate
N|                       32 bits the value within the command has to be right
N|                       aligned.
N|
N -------------------------------------------------------------------------*/
N#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,       \
N                               GA_FP ((regNr), 32, GA_MASK5)      |   \
N                               GA_FP ((uiVal),  0,  GA_MASK32)))
X#define GA_LOAD(regNr, uiVal) (GA_CMN(GA_SCHED, 1, GA_CMC_LGPR,                                      GA_FP ((regNr), 32, GA_MASK5)      |                                  GA_FP ((uiVal),  0,  GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   END Command (CSEND)
N|
N|  Descr  :   The CSEND command must be placed at the end of every command
N|             list. It signals the Command Scheduler that all commands have
N|             been executed. When the Command Scheduler is detecting this
N|             mark, a flag in the status register signals that the command
N|             list was executed. Optionally an interrupt is generated.
N|
N|  Params:    none
N|
N -------------------------------------------------------------------------*/
N#define GA_END() (GA_CMN(GA_SCHED, 0x1u, GA_CMC_END,0x0u))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Wait VSYNC Command (CSWVSYNC)
N|
N|  Descr  :   The CSWVSYNC command can be used to synchronize parts of the
N|             command list with the vertical synchronization signal VSYNC
N|             from the GDC or the Frame Grabber.
N|
N|             When the Command Scheduler is reading the CSWVSYNC command
N|             it waits until the next vertical synchronization of the
N|             display/camera input takes place before executing the next
N|             command.
N|
N|  Params:    module   -  VSYNC select:
N|                         Use: GA_GDC0     - Wait on GDC0
N|                              GA_FG0      - Wait on FG0
N|                              GA_GDC1     - Wait on GDC1
N|                              GA_FG1      - Wait on FG1
N|
N|
N -------------------------------------------------------------------------*/
N#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,        \
N                         GA_FP ((module), 0, GA_MASK2)))
X#define GA_WAIT(module) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSWVSYNC,                                 GA_FP ((module), 0, GA_MASK2)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   User Interrupt Command (CSUIC)
N|
N|  Descr  :   The CSUIC command can be used to signal the MCU that a
N|             certain part of the Command List is already executed or
N|             will now start execution.
N|
N|  Params:    interrupt number:
N|                          Use: 0 - 23
N|                               values > 23 will be ignored
N|
N -------------------------------------------------------------------------*/
N#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,    \
N                                  GA_FP ((number), 0, GA_MASK6)))
X#define GA_USERINTERRUPT(number) (GA_CMN(GA_SCHED, 0x1u, GA_CMC_CSUIC,                                      GA_FP ((number), 0, GA_MASK6)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC0 Configuration Command (CSGDC0CC)
N|
N|  Descr  :   The CSGDC0CC command can be used to change the content of GDC0 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC0 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC0CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC0CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Command Scheduler GDC1 Configuration Command (CSGDC1CC)
N|
N|  Descr  :   The CSGDC1CC command can be used to change the content of GDC1 registers
N|
N|  Params:    
N|             register offset:
N|                          16-bits GDC1 adress register offest
N|
N|             register value:
N|                          32-bits
N|
N -------------------------------------------------------------------------*/
N#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,  \
N                                         GA_FP((regOffset), 32, GA_MASK16)      |   \
N                                         GA_FP((value),      0, GA_MASK32)))
X#define GA_GDC1CONFIG(regOffset, value) (GA_CMN(GA_SCHED,   0x1u, GA_CMC_CSGDC1CC,                                           GA_FP((regOffset), 32, GA_MASK16)      |                                            GA_FP((value),      0, GA_MASK32)))
N
N
N/*======================================
N              Structures
N=======================================*/
N/* Command List Structure */
Ntypedef struct tag_ga_list_st
N{
N    uint64_t  ullCommands[GA_CMD_MAX] ;
X    uint64_t  ullCommands[2048] ;
N    uint64_t* pu64Current;
N    uint32_t  u32UsedDoubleWords; /* used or needed double words for an  GA-API */
N    int32_t   i32FreeSpaceStat;   /* C_SUCCESS: OK no space free error,
N                                     C_FAILED:  No free space for GA-API */
N} ga_list_st ;
N
N/****************************************************************************/
N
N
N#endif /* GA_COMMON_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: ga_common.h
N**  $Revision: 1.14 $
N**  $Date: 2015/07/21 12:30:20 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** | CONS.  : 
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 27 "..\..\..\..\lldd\inc\rotation_matrix.h" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
S
N#endif  
N/*======================================
N                Defs
N=======================================*/
N
N#define LLDD_GA_ROTATE_MATRIX_H_REVISION     "$Revision: 1.15 $"
N#define LLDD_GA_ROTATE_MATRIX_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*--------------------------------------------------------------------------
N|       ------------------------------------------------------------        |
N|      | >>>>>>         ROTATION ENGINE COMMAND INDEX        <<<<<< |       |
N|       ------------------------------------------------------------        |
N|---------------------------------------------------------------------------|
N|---------------------------------------------------------------------------|
N|                                                                           |
N|                      ------------------------------                       |
N|                     |      OPERATION COMMANDS      |                      |
N|                      ------------------------------                       |
N|                                                                           |
N| - Commands:                                                               |
N|   1. ROT_ROTATE           - Rotation Command                              |
N|   2. ROT_ROTATEB          - Rotation Command with blending                |
N|                                                                           |
N|---------------------------------------------------------------------------|
N|                                                                           |
N|                    ----------------------------------                     |
N|                   |      LOAD REGISTER COMMANDS      |                    |
N|                    ----------------------------------                     |
N|                                                                           |
N| - Source Regs:                                                            |
N|   1. ROT_LOAD_SOURCEADDR  -  Load Source Address Reg.               (SAR) |
N|   2. ROT_LOAD_SRCWIDTH    -  Load Source Memory Width Reg.         (SMWR) |
N|                                                                           |
N| - Destination Regs:                                                       |
N|   3. ROT_LOAD_DESTADDR    -  Load Destination Address Reg.          (DAR) |
N|   4. ROT_LOAD_DESTMEMDIM  -  Load Destination Memory Dim. Reg.     (DMDR) |
N|                                                                           |
N| - Color Regs:                                                             |
N|   5. ROT_LOAD_COLORFMT    -  Load Color Format Register             (CFR) |
N|                                                                           |
N| - Alpha Regs:                                                             |
N|   6. ROT_LOAD_SRCALPHAVAL - Load Source Alpha Value Register       (SAVR) |
N|   7. ROT_LOAD_DSTALPHAVAL - Load Destination Alpha Value Register  (DAVR) |
N|                                                                           |
N| - Rotation Regs:                                                          |
N|   8. ROT_LOAD_A11         - Load SXR Register                      (SXR)  |
N|   9. ROT_LOAD_A12         - Load SHXR Register                     (SHXR) |
N|  10. ROT_LOAD_A21         - Load SHYR Register                     (SHYR) |
N|  11. ROT_LOAD_A22         - Load SYR Register                      (SYR)  |
N|  12. ROT_LOAD_A31         - Load W0R Register                      (W0R)  |
N|  13. ROT_LOAD_A32         - Load W1R Register                      (W1R)  |
N|  14. ROT_LOAD_A33         - Load W2R Register                      (W2R)  |
N|                                                                           |
N| - Forward-Rotation Regs:                                                  |
N|  15. ROT_LOAD_SRCADDRPOS  - Load Rotated Src. Address Pos. Reg.     (RSA) |
N|  16. ROT_LOAD_COORD1      - Load Frwd-Rot. Corner Coord. Reg. 1  (FRCCR1) |
N|  17. ROT_LOAD_COORD2      - Load Frwd-Rot. Corner Coord. Reg. 2  (FRCCR2) |
N|  18. ROT_LOAD_COORD3      - Load Frwd-Rot. Corner Coord. Reg. 3  (FRCCR3) |
N|  19. ROT_LOAD_COORD4      - Load Frwd-Rot. Corner Coord. Reg. 4  (FRCCR4) |
N|                                                                           |
N| - Clipping Window:                                                        |
N|  20. ROT_LOAD_CLIPWNDUL   - Load Clipp.Wnd. Upper-Left Corner      (CWUL) |
N|  21. ROT_LOAD_CLIPWNDLR   - Load Clipp.Wnd. Upper-Left Corner      (CWLR) |
N|                                                                           |
N --------------------------------------------------------------------------*/
N/*=========================================================================
N|                            OPERATION COMMANDS                             |
N ==========================================================================*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   ROT_ROTATE
N|
N|  Descr  :   Rotate source to destination without blending.
N|
N|  Params:    clippEn  - Clipping Control
N|                        Use: GA_EN  - Enable Clipping
N|                             GA_DIS - Disable Clipping
N|
N|             filterEn - Filter Control
N|                        Use: GA_EN  - Enable Filter
N|                             GA_DIS - Disable Filter
N|
N|
N -------------------------------------------------------------------------*/
N#define ROT_ROTATE(clippEn, filterEn) (GA_CMN(GA_ROTATION, 1, GA_CMC_ROT,   \
N                                       GA_FP ((clippEn),   1, GA_MASK1)   | \
N                                       GA_FP ((filterEn),  0, GA_MASK1)))
X#define ROT_ROTATE(clippEn, filterEn) (GA_CMN(GA_ROTATION, 1, GA_CMC_ROT,                                          GA_FP ((clippEn),   1, GA_MASK1)   |                                        GA_FP ((filterEn),  0, GA_MASK1)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   ROT_ROTATEB
N|
N|  Descr  :   Rotate source to destination with blending.
N|
N|  Params:    redChProt   - Red Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChProt - Green Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChProt  - Blue Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaProt   - Alpha Channel Protection
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|
N|             redChFad    - Red Channel Fading
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             greenChFad  - Green Channel Fading
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             blueChFad   - Blue Channel Fading
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|                         
N|             alphaFad    - Alpha Channel Fading
N|                           Use: GA_EN           - Channel Protected
N|                                GA_DIS          - Channel Not Protected
N|
N|             blndOrder   - Blending Order
N|                           Use: BLT_ONTO_DEST   - Onto destination
N|                                BLT_BEHIND_DEST - Behind the destination
N|                         
N|             ClipWndEn   - Clipping Window Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|                         
N|             FilterContr - Filter Control Option
N|                           Use: GA_EN           - Enable Option
N|                                GA_DIS          - Disable Option
N|
N|
N -------------------------------------------------------------------------*/
N#define ROT_ROTATEB(redChProt,                                            \
N                    greenChProt,                                          \
N                    blueChProt,                                           \
N                    alphaProt,                                            \
N                    redChFad,                                             \
N                    greenChFad,                                           \
N                    blueChFad,                                            \
N                    alphaFad,                                             \
N                    blndOrder,                                            \
N                    ClipWndEn,                                            \
N                    FilterContr)                                          \
N                    (GA_CMN(GA_ROTATION,   1, GA_CMC_ROTB,                \
N                     GA_FP ((redChProt),  15, GA_MASK1)        |          \
N                     GA_FP ((greenChProt),14, GA_MASK1)        |          \
N                     GA_FP ((blueChProt), 13, GA_MASK1)        |          \
N                     GA_FP ((alphaProt),  12, GA_MASK1)        |          \
N                     GA_FP ((redChFad),   11, GA_MASK1)        |          \
N                     GA_FP ((greenChFad), 10, GA_MASK1)        |          \
N                     GA_FP ((blueChFad),   9, GA_MASK1)        |          \
N                     GA_FP ((alphaFad),    8, GA_MASK1)        |          \
N                     GA_FP ((blndOrder),   3, GA_MASK1)        |          \
N                     GA_FP ((ClipWndEn),   1, GA_MASK1)        |          \
N                     GA_FP ((FilterContr), 0, GA_MASK1)))
X#define ROT_ROTATEB(redChProt,                                                                greenChProt,                                                              blueChProt,                                                               alphaProt,                                                                redChFad,                                                                 greenChFad,                                                               blueChFad,                                                                alphaFad,                                                                 blndOrder,                                                                ClipWndEn,                                                                FilterContr)                                                              (GA_CMN(GA_ROTATION,   1, GA_CMC_ROTB,                                     GA_FP ((redChProt),  15, GA_MASK1)        |                               GA_FP ((greenChProt),14, GA_MASK1)        |                               GA_FP ((blueChProt), 13, GA_MASK1)        |                               GA_FP ((alphaProt),  12, GA_MASK1)        |                               GA_FP ((redChFad),   11, GA_MASK1)        |                               GA_FP ((greenChFad), 10, GA_MASK1)        |                               GA_FP ((blueChFad),   9, GA_MASK1)        |                               GA_FP ((alphaFad),    8, GA_MASK1)        |                               GA_FP ((blndOrder),   3, GA_MASK1)        |                               GA_FP ((ClipWndEn),   1, GA_MASK1)        |                               GA_FP ((FilterContr), 0, GA_MASK1)))
N
N/*=========================================================================
N|                          LOAD REGISTER COMMANDS                           |
N ==========================================================================*/
N/*------------------------------
N|        SOURCE REGISTERS       |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Address Register (SAR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load SAR.
N|             The physical 32-bit address within the source address register
N|             is the pointer to the first dot in memory of the source image.
N|
N|  Params:    addr - Source Address
N|                    The lower 32 physical address bits that point to the
N|                    first dot of the source.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_SOURCEADDR(addr) (GA_LOAD(GA_GPR9, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Memory Width Register (SMWR)
N|
N|  Descr  :   The Load General-Purpose Register command is used to load SMWR.
N|             The source memory width register specifies the memory reserved
N|             for one line within the source image in number of dots.
N|
N|
N|  Params:    width - Source Memory Width
N|                     Memory reserved per line within the source in dots
N|                     (1 up to 4095)
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_SRCWIDTH(width) (GA_LOAD(GA_GPR10, (width)))
N
N/*------------------------------
N|     DESTINATION REGISTERS     |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Address Register (DAR)
N|
N|  Descr  :   The physical 32-bit address within the destination address
N|             register is the pointer to the first dot in the memory region,
N|             where the rotated bitmap will be placed. Depending on the
N|             source color format, which is equal to the destination color
N|             format, this address has to be word- (RGBA32) or halfword-
N|             (RGB16) aligned.
N|
N|  Params:    addr   - Destination Address
N|                      The lower 32 physical address bits that point to the
N|                      first dot of the destination.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_DESTADDR(addr) (GA_LOAD(GA_GPR4, (addr)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Memory Dimension Register (DMDR)
N|
N|  Descr  :   The destination memory dimension register specifies the memory
N|             reserved for one line within the destination image in number
N|             of dots. Note that this value does not necessarily have to be
N|             equal to the image width.
N|
N|  Params:    width  - Destination Memory Width
N|                      Memory reserved per line within the source in dots
N|                      (1 up to 4095)
N|
N|             height - Destination Memory Height
N|                      Number of lines of the destination image
N|                      (from 1 up to 4095).
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_DESTMEMDIM(width, height) (GA_LOAD(GA_GPR5,                    \
N                                            GA_FP ((height), 16, GA_MASK12)  |  \
N                                            GA_FP ((width),   0, GA_MASK12)))
X#define ROT_LOAD_DESTMEMDIM(width, height) (GA_LOAD(GA_GPR5,                                                                GA_FP ((height), 16, GA_MASK12)  |                                              GA_FP ((width),   0, GA_MASK12)))
N
N/*------------------------------
N|        COLOR REGISTERS        |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Color Format Register (CFR)
N|
N|  Descr  :   This register specifies the color format of both, source
N|             and destination. As the rotation engine does not perform color
N|             conversion.
N|
N|  Params:    dstformat - Destination color format
N|                         Use parameters:
N|                         GA_RGB16  - 16-bit RGB
N|                         GA_RGBA32 - 32-bit RGBA
N|
N|             srcformat - Source color format
N|                         Use parameters:
N|                         GA_RGB16  - 16-bit RGB
N|                         GA_RGBA32 - 32-bit RGBA
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_COLORFMT(dstformat, srcformat) (GA_LOAD(GA_GPR11,                    \
N                                                 GA_FP ((dstformat), 1, GA_MASK1)  |  \
N                                                 GA_FP ((srcformat), 0, GA_MASK1)))
X#define ROT_LOAD_COLORFMT(dstformat, srcformat) (GA_LOAD(GA_GPR11,                                                                     GA_FP ((dstformat), 1, GA_MASK1)  |                                                   GA_FP ((srcformat), 0, GA_MASK1)))
N
N/*------------------------------
N|        ALPHA REGISTERS        |
N -------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Fading Factor Register (SFFR)
N|
N|  Descr  :   The Source Fading Factor Register holds the fading factor enumerator
N|             (SFFE) of the fading factor.
N|
N|  Params:    factor - Source Fading Factor Enumerator
N|                      These bits specify the enumerator of the fading
N|                      factor FFACT.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_FADEFACT(factor) (GA_LOAD(GA_GPR26,                       \
N                                   ((factor) & GA_MASK8)))
X#define ROT_LOAD_FADEFACT(factor) (GA_LOAD(GA_GPR26,                                                          ((factor) & GA_MASK8)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Source Alpha Value Register (SAVR)
N|
N|  Descr  :   The Source Alpha Value Register keeps the alpha value for
N|             conversion of the source dots from the 16-bit RGB format to
N|             the 32-bit RGBA format for internal processing.
N|
N|  Params:    format - Source alpha value
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_SRCALPHAVAL(value) (GA_LOAD(GA_GPR27,                     \
N                                     ((value) & GA_MASK8)))
X#define ROT_LOAD_SRCALPHAVAL(value) (GA_LOAD(GA_GPR27,                                                          ((value) & GA_MASK8)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Destination Alpha Value Register (DAVR)
N|
N|  Descr  :   The Destination Alpha Value Register keeps the alpha value
N|             used during conversion of the destination dots from the
N|             16-bit RGB format to the 32-bit RGBA format.
N|
N|  Params:    format - Source alpha value
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_DSTALPHAVAL(value) (GA_LOAD(GA_GPR28,                     \
N                                     ((value) & GA_MASK8)))
X#define ROT_LOAD_DSTALPHAVAL(value) (GA_LOAD(GA_GPR28,                                                          ((value) & GA_MASK8)))
N
N/*------------------------------
N|      ROTATION REGISTERS        |
N -------------------------------*/
N               /* Rotation Matrix:
N* 
N*              [  sx   shx  0 ]
N*              [  shy  sy   0 ]
N*              [  w0   w1   w2]
N*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load SXR Register
N|
N|  Descr  :   This register holds the SX value of the rotation matrix 
N              multiplied by 65536. The signed two’s complement integer 
N              value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted SX value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A11(val) (GA_LOAD(GA_GPR12,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A11(val) (GA_LOAD(GA_GPR12,                                                          ((val) & GA_MASK22)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load SHXR Register
N|
N|  Descr  :   This register holds the SHX value of the rotation matrix 
N|             multiplied by 65536. The signed two’s complement integer 
N|             value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted SHX value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A12(val) (GA_LOAD(GA_GPR15,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A12(val) (GA_LOAD(GA_GPR15,                                                          ((val) & GA_MASK22)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load SHYR Register
N|
N|  Descr  :   This register holds the SHY value of the rotation matrix 
N|             multiplied by 65536. The signed two’s complement integer 
N|             value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted SHY value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A21(val) (GA_LOAD(GA_GPR13,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A21(val) (GA_LOAD(GA_GPR13,                                                          ((val) & GA_MASK22)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load SYR Register
N|
N|  Descr  :   This register holds the SHY value of the rotation matrix 
N|             multiplied by 65536. The signed two’s complement integer 
N|             value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted SYR value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A22(val) (GA_LOAD(GA_GPR14,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A22(val) (GA_LOAD(GA_GPR14,                                                          ((val) & GA_MASK22)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load W0R Register
N|
N|  Descr  :   This register holds the W0 value of the rotation matrix 
N|             multiplied by 65536. The signed two’s complement integer 
N|             value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted W0 value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A31(val) (GA_LOAD(GA_GPR21,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A31(val) (GA_LOAD(GA_GPR21,                                                          ((val) & GA_MASK22)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load W1R Register
N|
N|  Descr  :   This register holds the W0 value of the rotation matrix 
N|             multiplied by 65536. The signed two’s complement integer 
N|             value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted W1 value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A32(val) (GA_LOAD(GA_GPR22,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A32(val) (GA_LOAD(GA_GPR22,                                                          ((val) & GA_MASK22)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load W2R Register
N|
N|  Descr  :   This register holds the W2 value of the rotation matrix 
N|             multiplied by 65536. The signed two’s complement integer 
N|             value is in the range of -2097152 to +2097151.
N|
N|  Params:    val - The shifted and integer converted W2 value of the
N|                   rotation matrix.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_A33(val) (GA_LOAD(GA_GPR23,                               \
N                           ((val) & GA_MASK22)))
X#define ROT_LOAD_A33(val) (GA_LOAD(GA_GPR23,                                                          ((val) & GA_MASK22)))
N
N/*------------------------------
N|    FRWD-ROTATION REGISTERS    |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Rotated Source Address Position (RSA)
N|
N|  Descr  :   This value specifies the index of the rotated corner that at
N|             it’s original position maps to the source image start address.
N|
N|
N|  Params:    position - Rotated Source Address Position
N|                        Use following values:
N|                        GA_FRCCR1 - FRCCR1 maps to the source start addr.
N|                        GA_FRCCR2 - FRCCR2 maps to the source start addr.
N|                        GA_FRCCR3 - FRCCR3 maps to the source start addr.
N|                        GA_FRCCR4 - FRCCR4 maps to the source start addr.
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_SRCADDRPOS(position) (GA_LOAD(GA_GPR20,                   \
N                                       ((position) & GA_MASK2)))
X#define ROT_LOAD_SRCADDRPOS(position) (GA_LOAD(GA_GPR20,                                                          ((position) & GA_MASK2)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Forward-Rotated Corner Coordinates Register 1 (FRCCR1)
N|
N|  Descr  :   For detailed description how to select the please consult the
N|             Capricorn documantation.
N|
N|             Please note that in order To provide a higher accuracy for
N|             the Rotation Engine’s calculations, the forward-rotated
N|             coordinate’s floating point values must be multiplied by 16
N|             (shifted 4 bits to the left) before being converted to integer
N|             and passed to the Rotation Engine.
N|
N|  Params:    x - Forward-rotated x-coordinate of corner 1 times 16.
N|             y - Forward-rotated y-coordinate of corner 1 times 16
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_COORD1(x,y) (GA_LOAD(GA_GPR16,                      \
N                              GA_FP ((x), 16, GA_MASK16)      |      \
N                              GA_FP ((y),  0, GA_MASK16)))
X#define ROT_LOAD_COORD1(x,y) (GA_LOAD(GA_GPR16,                                                    GA_FP ((x), 16, GA_MASK16)      |                                    GA_FP ((y),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Forward-Rotated Corner Coordinates Register 2 (FRCCR2)
N|
N|  Descr  :   For detailed description how to select the please consult the
N|             Capricorn documantation.
N|
N|             Please note that in order To provide a higher accuracy for
N|             the Rotation Engine’s calculations, the forward-rotated
N|             coordinate’s floating point values must be multiplied by 16
N|             (shifted 4 bits to the left) before being converted to integer
N|             and passed to the Rotation Engine.
N|
N|  Params:    x - Forward-rotated x-coordinate of corner 2 times 16.
N|             y - Forward-rotated y-coordinate of corner 2 times 16
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_COORD2(x,y) (GA_LOAD(GA_GPR17,                    \
N                              GA_FP ((x), 16, GA_MASK16)     |     \
N                              GA_FP ((y),  0, GA_MASK16)))
X#define ROT_LOAD_COORD2(x,y) (GA_LOAD(GA_GPR17,                                                  GA_FP ((x), 16, GA_MASK16)     |                                   GA_FP ((y),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Forward-Rotated Corner Coordinates Register 3 (FRCCR3)
N|
N|  Descr  :   For detailed description how to select the please consult the
N|             Capricorn documantation.
N|
N|             Please note that in order To provide a higher accuracy for
N|             the Rotation Engine’s calculations, the forward-rotated
N|             coordinate’s floating point values must be multiplied by 16
N|             (shifted 4 bits to the left) before being converted to integer
N|             and passed to the Rotation Engine.
N|
N|  Params:    x - Forward-rotated x-coordinate of corner 3 times 16.
N|             y - Forward-rotated y-coordinate of corner 3 times 16
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_COORD3(x,y) (GA_LOAD(GA_GPR18,                       \
N                              GA_FP ((x), 16, GA_MASK16)      |       \
N                              GA_FP ((y),  0, GA_MASK16)))
X#define ROT_LOAD_COORD3(x,y) (GA_LOAD(GA_GPR18,                                                     GA_FP ((x), 16, GA_MASK16)      |                                     GA_FP ((y),  0, GA_MASK16)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Forward-Rotated Corner Coordinates Register 4 (FRCCR4)
N|
N|  Descr  :   For detailed description how to select the please consult the
N|             Capricorn documantation.
N|
N|             Please note that in order To provide a higher accuracy for
N|             the Rotation Engine’s calculations, the forward-rotated
N|             coordinate’s floating point values must be multiplied by 16
N|             (shifted 4 bits to the left) before being converted to integer
N|             and passed to the Rotation Engine.
N|
N|  Params:    x - Forward-rotated x-coordinate of corner 4 times 16.
N|             y - Forward-rotated y-coordinate of corner 4 times 16
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_COORD4(x,y) (GA_LOAD(GA_GPR19,                       \
N                              GA_FP ((x), 16, GA_MASK16)      |       \
N                              GA_FP ((y),  0, GA_MASK16)))
X#define ROT_LOAD_COORD4(x,y) (GA_LOAD(GA_GPR19,                                                     GA_FP ((x), 16, GA_MASK16)      |                                     GA_FP ((y),  0, GA_MASK16)))
N
N/*------------------------------
N|    CLIPPING-WND REGISTERS     |
N ------------------------------*/
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Clipping Window Upper Left Corner Coord. Reg. (CWUL)
N|
N|  Descr  :   This register defines the upper left corner coordinate of the
N|             clipping window relative to the destination start address in
N|             number of pixels.
N|
N|  Params:    x - Clipping window upper left corner x-coordinate
N|             y - Clipping window upper left corner y-coordinate
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_CLIPWNDUL(x,y) (GA_LOAD(GA_GPR1,                       \
N                                 GA_FP ((x), 16, GA_MASK12)      |      \
N                                 GA_FP ((y),  0, GA_MASK12)))
X#define ROT_LOAD_CLIPWNDUL(x,y) (GA_LOAD(GA_GPR1,                                                        GA_FP ((x), 16, GA_MASK12)      |                                       GA_FP ((y),  0, GA_MASK12)))
N
N/*--------------------------------------------------------------------------
N|
N|  Command:   Load Clipping Window Lower Right Corner Coord. Reg. (CWLR)
N|
N|  Descr  :   This register defines the upper left corner coordinate of the
N|             clipping window relative to the destination start address in
N|             number of pixels.
N|
N|  Params:    x - Clipping window lower right corner x-coordinate
N|             y - Clipping window lower right corner y-coordinate
N|
N -------------------------------------------------------------------------*/
N#define ROT_LOAD_CLIPWNDLR(x,y) (GA_LOAD(GA_GPR2,                       \
N                                 GA_FP ((x), 16, GA_MASK12)      |      \
N                                 GA_FP ((y),  0, GA_MASK12)))
X#define ROT_LOAD_CLIPWNDLR(x,y) (GA_LOAD(GA_GPR2,                                                        GA_FP ((x), 16, GA_MASK12)      |                                       GA_FP ((y),  0, GA_MASK12)))
N
N/*======================================
N                Enums
N=======================================*/
N/* Rot.Src. Address Position  */
Ntypedef enum tag_rot_SrcSel_e
N{
N    GA_FRCCR1 = 0x0u,
N    GA_FRCCR2 = 0x1u,
N    GA_FRCCR3 = 0x2u,
N    GA_FRCCR4 = 0x3u
N} rot_SrcSel_e;
N
N/*======================================
N              Structures
N=======================================*/
N/* rotation matrix Parameters (all values are mult. by 16) */
Ntypedef struct tag_rot_Mtrx_st
N{
N    uint32_t  u32A11;                /* The shifted and integer conv. sx  */
N    uint32_t  u32A12;                /* The shifted and integer conv. shx */
N    uint32_t  u32A21;                /* The shifted and integer conv. shy */
N    uint32_t  u32A22;                /* The shifted and integer conv. sy  */
N    uint32_t  u32A31;                /* The shifted and integer conv. w0  */
N    uint32_t  u32A32;                /* The shifted and integer conv. w1  */
N    uint32_t  u32A33;                /* The shifted and integer conv. w2  */
N} rot_Mtrx_st;
N
N/* Forward-Rotated Corner Coordinates (all values are mult. by 16) */
Ntypedef struct tag_rot_frccr_st
N{
N    uint16_t  u16X1;                 /* Frwd. Rotd. X-Coord (corner 1) */
N    uint16_t  u16Y1;                 /* Frwd. Rotd. Y-Coord (corner 1) */
N    uint16_t  u16X2;                 /* Frwd. Rotd. X-Coord (corner 2) */
N    uint16_t  u16Y2;                 /* Frwd. Rotd. Y-Coord (corner 2) */
N    uint16_t  u16X3;                 /* Frwd. Rotd. X-Coord (corner 3) */
N    uint16_t  u16Y3;                 /* Frwd. Rotd. Y-Coord (corner 3) */
N    uint16_t  u16X4;                 /* Frwd. Rotd. X-Coord (corner 4) */
N    uint16_t  u16Y4;                 /* Frwd. Rotd. Y-Coord (corner 4) */
N
N    uint8_t  u8ScrAddrPos;           /* Source address position */
N} rot_frccr_st;
N
N/* Memory Configuration */
Ntypedef struct tag_rot_mem_st
N{
N    /* Source Mem. Params */
N    uint16_t      u16SrcHeight;      /* Source Memory Height (Line Number) */
N    uint16_t      u16SrcWidth;       /* Source Memory Width (Dots Per Line) */
N    uint32_t      u32SrcAddr;        /* Source Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N
N    /* Destination Mem. Params */
N    uint32_t      u32DstAddr;        /* Dest. Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    /* Dest. Image Area Size */
N    uint16_t      u16DstImgWidth;    /* Destination Image Width */
N    uint16_t      u16DstImgHeight;   /* Destination Image Height */
N} rot_mem_st;
N
N/* Clipping Window Corner Coordinates */
Ntypedef struct tag_rot_clipWnd_st
N{
N    uint16_t  u16UlX;                /* Upper Left X-Coord */
N    uint16_t  u16UlY;                /* Upper Left Y-Coord */
N    uint16_t  u16LrX;                /* Lower Right X-Coord */
N    uint16_t  u16LrY;                /* Lower Right Y-Coord */
N} rot_clipWnd_st;
N
N
N/* Rotation Config. */
Ntypedef struct tag_rot_rotCfg_st
N{
N    ga_colFmt_e    eSrcColFmt;       /* Source Color Format Selection */
N    ga_colFmt_e    eDstColFmt;       /* Destination Color Format Selection */
N    ga_en_e        eClipWndEn;       /* Clipping Window Enable */
N    ga_en_e        eFilterEn;        /* Enable Filtering */
N    uint8_t        u8FadingFctr;     /* Fading factor */
N    uint8_t        u8SrcAlphaVal;    /* Source Alpha value */
N    uint8_t        u8DstAlphaVal;    /* Destination Alpha value */
N
N    /* Optional */
N    rot_clipWnd_st tClipWnd;
N} rot_rotCfg_st;
N
N/* Rotation with blending Config.  */
Ntypedef struct tag_rot_rotblendCfg_st
N{
N    ga_colFmt_e   eSrcColFmt;        /* Source Color Format Selection */
N    ga_colFmt_e   eDstColFmt;        /* Destination Color Format Selection */
N    ga_en_e       eClipWndEn;        /* Clipping Window Enable */
N    ga_en_e       eFilterEn;         /* Enable Filtering */
N    ga_en_e       eDstRedProt;       /* Destination red color protection */
N    ga_en_e       eDstGreenProt;     /* Destination green color protection */
N    ga_en_e       eDstBlueProt;      /* Destination blue color protection */
N    ga_en_e       eDstAlphaProt;     /* Destination alpha protection */
N    ga_en_e       eSrcRedFad;        /* Destination red color protection */
N    ga_en_e       eSrcGreenFad;      /* Destination green color protection */
N    ga_en_e       eSrcBlueFad;       /* Destination blue color protection */
N    ga_en_e       eSrcAlphaFad;      /* Destination alpha protection */
N    uint8_t       u8FadingFctr;      /* Fading factor */
N    ga_blendOrd_e eBldOrd;           /* Blend order */
N    uint8_t       u8SrcAlphaVal;     /* Source Alpha value */
N    uint8_t       u8DstAlphaVal;     /* Destination Alpha value */
N
N    /* Optional */
N    rot_clipWnd_st tClipWnd;
N} rot_rotblendCfg_st;
N
N
N/*======================================
N          Function definitions
N=======================================*/
N/****************************************************************************
N *
N * Function:      vRot_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                            uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag);
N
N/****************************************************************************
N *
N * Function:      vRot_SetMemSrc
N *
N * Purpose:       Sets Transf source parameters in Command List
N *
N * Inputs:        u32Addr    - Source Memory Address
N *                             (First Dot of the source)
N *
N *                u32Width   - Source Memory Width
N *                             (Memory reserved per line within the source in
N *                              dots: 1 up to 4095)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_SetMemSrc(uint32_t u32Addr, uint32_t u32Width, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetMemDest
N *
N * Purpose:       Sets the destination memory parameters in the Command List
N *
N * Inputs:        u32Addr    - Destination Memory Address
N *                             (First Dot of the destination)
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_SetMemDest(uint32_t u32Addr, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetMemDim
N *
N * Purpose:       Sets the destination memory size in the Command List
N *
N * Inputs:        u16Width   - Destination Memory Width
N *                             Number of lines of the destination image
N *                             (from 1 up to 4095).
N *
N *                u16Height  - Destination Memory Height
N *                             Memory reserved per line within the destination
N *                             in dots (from 1 up to 4095).
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_SetMemDim(uint16_t u16Width, uint16_t u16Height, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetColorFmt
N *
N * Purpose:       Sets the color format of the both source and destination.
N *
N * Inputs:        eDstColFormat - Destination Color Format Selection
N *                                (16-bit RGB/ 32-bit RGBA)
N *
N *                eSrcColFormat - SourceColor Format Selection
N *                                (16-bit RGB/ 32-bit RGBA)
N *
N *                pstCmdList    - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Please note that Rotation Engine cannot convert color
N *                format, therefore formats for both (src. and dst.) must be
N *                the same.
N *
N ***************************************************************************/
Nvoid vRot_SetColorFmt(ga_colFmt_e eDstColFormat, ga_colFmt_e eSrcColFormat, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetRotMtrx
N *
N * Purpose:       Sets the rotation matrix coefficients.
N *
N * Inputs:        pstMatrix   - Pointer to rotation matrix Coefficients
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Please note that the signed two’s complement integer values
N *                are in the range of -2097152 to +2097151.
N *
N ***************************************************************************/
Nvoid vRot_SetRotMtrx(rot_Mtrx_st* pstMatrix, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetFrwdCoord
N *
N * Purpose:       Sets the Forward Rotated Coordinates of all four corners.
N *
N * Inputs:        pstCoord    - Pointer to forward-rotated Corner Coordinates
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   Please note that if coordinates are not given in required
N *                order it will be automatically re-arranged before they are
N *                inserted in the command list (as described in FRCCReg
N *                chapter).
N *
N ***************************************************************************/
Nvoid vRot_SetFrwdCoord(rot_frccr_st* pstCoord, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetSrcAddrPos
N *
N * Purpose:       Sets the Rotated Source Address Position. This value
N *                specifies the index of the rotated corner that at it’s
N *                original position maps to the source image start address.
N *
N * Inputs:        eSrcSel    - Forward-Rotated Corner Coordinates
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_SetSrcAddrPos(rot_SrcSel_e eSrcSel, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetRotationCmd
N *
N * Purpose:       Inserts the rotation command in the Command List
N *
N * Inputs:        eClipWndEn - Enable Clipping Window
N *
N *                eFilterEn  - Enable Filtering
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_SetRotationCmd(ga_en_e eClipWndEn, ga_en_e eFilterEn, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_SetClippWnd
N *
N * Purpose:       Sets the Clipping Window Coordinates
N *
N * Inputs:        stClipWnd  - Pointer to clipping Window Coordinates
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_SetClippWnd(rot_clipWnd_st* pstClipWnd, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_RotateMatrix
N *
N * Purpose:       Inserts all required parameters for source object rotation
N *                operation
N *
N * Inputs:        pstMem      - Pointer to memory configuration parameters
N *
N *                pstParam    - Pointer to scaling Parameters
N *
N *                pstMatrix   - Pointer to transformation matrix
N *
N *                pstCoord    - Pointer to forward rotated corner coordinates
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_RotateMatrix(rot_mem_st* pstMem, rot_rotCfg_st* pstParam, rot_Mtrx_st* pstMatrix,
N                       rot_frccr_st* pstCoord, ga_list_st* pstCmdList);
N
N/****************************************************************************
N *
N * Function:      vRot_RotateBlendMatrix
N *
N * Purpose:       Inserts all required parameters for source object rotation
N *                operation with blending
N *
N * Inputs:        pstMem      - Pointer to memory configuration parameters
N *
N *                pstParam    - Pointer to scaling Parameters
N *
N *                pstMatrix   - Pointer to transformation matrix
N *
N *                pstCoord    - Pointer to forward rotated corner coordinates
N *
N *                pstCmdList - Pointer to the Command List
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vRot_RotateBlendMatrix(rot_mem_st* pstMem, rot_rotblendCfg_st* pstParam, rot_Mtrx_st* pstMatrix,
N                            rot_frccr_st* pstCoord, ga_list_st* pstCmdList);
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N/****************************************************************************/
N
N#endif /* ROATATION_MATRIX_H */
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: rotation_matrix.h
N**  $Revision: 1.15 $
N**  $Date: 2015/05/04 09:07:14 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 
N** |
N** | CONS.  :
N** |
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 29 "..\..\..\..\mw\inc\rotation.h" 2
N
N#ifdef GA_USE_MATH_LIB
N#include "math.h"
L 1 "C:\Keil_v5\ARM\ARMCC_505u2\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 185525 $ Codemist 0.03
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5050157
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 32 "..\..\..\..\mw\inc\rotation.h" 2
N#else
S#include "sin_cos.h"
N#endif /* GA_USE_MATH_LIB */
N
N/*********************************************/
N
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_GA_ROTATE_LIB_H_REVISION     "$Revision: 1.10 $"
N#define LLDD_GA_ROTATE_LIB_H_TAG          "$Name: Graphic_Middleware_V1_5 $"
N
N/*********************************************/
N
N
N/**********************************************
N*       TRIGONOMETRY FUNCTION HOOKS           *
N**********************************************/
N
N#ifdef GA_USE_MATH_LIB
N#ifdef __KEIL__
N#define ROT_SIN(angle)((RE_FLOAT64ROUND((sin(angle))*4294967296.0)/4294967296))
N#define ROT_COS(angle)((RE_FLOAT64ROUND((cos(angle))*4294967296.0)/4294967296))
N#else
S/* Standard implementation */
S#define ROT_SIN(angle)(sin((angle)))
S#define ROT_COS(angle)(cos((angle)))
N#endif
N#else
S
S/* Custom Implementation */
S/* Use Sin/Cos lookup table implementation */
S#define ROT_SIN(angle)(i32SinLookup((angle)))
S#define ROT_COS(angle)(i32CosLookup((angle)))
S
N#endif /* GA_USE_MATH_LIB */
N
N/*********************************************/
N
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
N/**
N* @brief Alignment for scale in source image
N*/
Ntypedef enum tag_rot_scaleAlign_e
N{
N    ROT_SCALE_ALIGN_00 = 0,  /*!< alignment to (0,0) */
N    ROT_SCALE_ALIGN_W0 = 1,  /*!< alignment to (width,0) */
N    ROT_SCALE_ALIGN_0H = 2,  /*!< alignment to (0,height) */
N    ROT_SCALE_ALIGN_WH = 3,  /*!< alignment to (width/height) */
N    ROT_SCALE_ALIGN_CC = 4   /*!< alignment to (center, center) */
N} rot_scaleAlign_e;
N
N/*********************************************/
N
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N/**
N* @brief rotation configuration
N*/
Ntypedef struct tag_rot_cfg_st
N{
N    rot_rotCfg_st  stRotCfg;         /* Rotation configuration */
N    int16_t        i16RotCentX;      /* Source Rotation Center X-Coord */
N    int16_t        i16RotCentY;      /* Source Rotation Center Y-Coord */
N    int16_t        i16OffsetX;       /* Dest. Offset */
N    int16_t        i16OffsetY;       /* Dest. Offset */
N} rot_cfg_st;
N
N
N/**
N* @brief rotation blend configuration
N*/
Ntypedef struct tag_rot_blendcfg_st
N{
N    rot_rotblendCfg_st  stRotBlendCfg;    /* Rotation blend configuration */
N    int16_t             i16RotCentX;      /* Source Rotation Center X-Coord */
N    int16_t             i16RotCentY;      /* Source Rotation Center Y-Coord */
N    int16_t             i16OffsetX;       /* Dest. Offset */
N    int16_t             i16OffsetY;       /* Dest. Offset */
N} rot_blendcfg_st;
N
N
N/**
N* @brief Shear/Scale configuration
N*/
Ntypedef struct tag_rot_sscalCfg_st
N{
N    ga_colFmt_e      eSrcColFmt;    /*!< Source Color Format Selection */
N    ga_colFmt_e      eDstColFmt;    /*!< Destination Color Format Selection */
N    ga_en_e          eClipWndEn;    /*!< Clipping Window Enable */
N    ga_en_e          eFilterEn;     /*!< Enable Filtering */
N    int16_t          i16OffsetX;    /*!< Dest. Offset X-Coord */
N    int16_t          i16OffsetY;    /*!< Dest. Offset Y-Coord */
N#ifdef GA_USE_MATH_LIB
N    float64_t        f64FactorX;    /*!< Shear/Scale Factor X */
N    float64_t        f64FactorY;    /*!< Shear/Scale Factor Y */
N#else
S    int32_t          i32FactorX;    /*!< Shear/Scale Factor X */
S    int32_t          i32FactorY;    /*!< Shear/Scale Factor Y */
N#endif
N    rot_scaleAlign_e eAlignment;    /*!< alignment in source image */
N    uint8_t          u8FadingFctr;  /*!< Fading factor */
N    uint8_t          u8SrcAlphaVal; /*!< Source Alpha value */
N    uint8_t          u8DstAlphaVal; /*!< Destination Alpha value */
N
N    /* Optional */
N    rot_clipWnd_st tClipWnd;
N} rot_sscalCfg_st;
N
N
N/**
N* @brief Shear/Scale configuration with blending
N*/
Ntypedef struct tag_rot_sscalblendCfg_st
N{
N    ga_colFmt_e      eSrcColFmt;    /*!< Source Color Format Selection */
N    ga_colFmt_e      eDstColFmt;    /*!< Destination Color Format Selection */
N    ga_en_e          eClipWndEn;    /*!< Clipping Window Enable */
N    ga_en_e          eFilterEn;     /*!< Enable Filtering */
N    int16_t          i16OffsetX;    /*!< Dest. Offset X-Coord */
N    int16_t          i16OffsetY;    /*!< Dest. Offset Y-Coord */
N#ifdef GA_USE_MATH_LIB
N    float64_t        f64FactorX;    /*!< Shear/Scale Factor X */
N    float64_t        f64FactorY;    /*!< Shear/Scale Factor Y */
N#else
S    int32_t          i32FactorX;    /*!< Shear/Scale Factor X */
S    int32_t          i32FactorY;    /*!< Shear/Scale Factor Y */
N#endif
N    rot_scaleAlign_e eAlignment;    /*!< alignment in source image */
N    ga_en_e          eDstRedProt;   /*!< Destination red color protection */
N    ga_en_e          eDstGreenProt; /*!< Destination green color protection */
N    ga_en_e          eDstBlueProt;  /*!< Destination blue color protection */
N    ga_en_e          eDstAlphaProt; /*!< Destination alpha protection */
N    ga_en_e          eSrcRedFad;    /*!< Destination red color protection */
N    ga_en_e          eSrcGreenFad;  /*!< Destination green color protection */
N    ga_en_e          eSrcBlueFad;   /*!< Destination blue color protection */
N    ga_en_e          eSrcAlphaFad;  /*!< Destination alpha protection */
N    uint8_t          u8FadingFctr;  /*!< Fading factor */
N    ga_blendOrd_e    eBldOrd;       /*!< Blend order */
N    uint8_t          u8SrcAlphaVal; /*!< Source Alpha value */
N    uint8_t          u8DstAlphaVal; /*!< Destination Alpha value */
N
N    /* Optional */
N    rot_clipWnd_st tClipWnd;
N} rot_sscalblendCfg_st;
N
N
N/**
N* @brief Perspective configuration
N*/
Ntypedef struct tag_rot_perspectiveCfg_st
N{
N    ga_colFmt_e    eSrcColFmt;      /*!< Source Color Format Selection */
N    ga_colFmt_e    eDstColFmt;      /*!< Destination Color Format Selection */
N    ga_en_e        eClipWndEn;      /*!< Clipping Window Enable */
N    ga_en_e        eFilterEn;       /*!< Enable Filtering */
N    int16_t        i16OffsetX;      /*!< Dest. Offset X-Coord */
N    int16_t        i16OffsetY;      /*!< Dest. Offset Y-Coord */
N    uint32_t       u32RotPointX;    /*!< Rotation point X */
N    uint32_t       u32RotPointY;    /*!< Rotation point Y */
N#ifdef GA_USE_MATH_LIB
N    float64_t      f64AngleX;       /*!< Perspective Angle X */
N    float64_t      f64AngleY;       /*!< Perspective Angle Y */
N    float64_t      f64AngleZ;       /*!< Perspective Angle Z */
N    float64_t      f64ScaleX;       /*!< Scale Factor X */
N    float64_t      f64ScaleY;       /*!< Scale Factor Y */
N#else
S    int32_t        i32AngleX;       /*!< Perspective Angle X */
S    int32_t        i32AngleY;       /*!< Perspective Angle Y */
S    int32_t        i32AngleZ;       /*!< Perspective Angle Z */
S    int32_t        i32ScaleX;       /*!< Scale Factor X */
S    int32_t        i32ScaleY;       /*!< Scale Factor Y */
N#endif
N    uint8_t        u8FadingFctr;    /*!< Fading factor */
N    uint8_t        u8SrcAlphaVal;   /*!< Source Alpha value */
N    uint8_t        u8DstAlphaVal;   /*!< Destination Alpha value */
N
N    /* Optional */
N    rot_clipWnd_st tClipWnd;
N} rot_perspectiveCfg_st;
N
N
N/**
N* @brief Perspective configuration with blending
N*/
Ntypedef struct tag_rot_perspectiveblendCfg_st
N{
N    ga_colFmt_e    eSrcColFmt;      /*!< Source Color Format Selection */
N    ga_colFmt_e    eDstColFmt;      /*!< Destination Color Format Selection */
N    ga_en_e        eClipWndEn;      /*!< Clipping Window Enable */
N    ga_en_e        eFilterEn;       /*!< Enable Filtering */
N    int16_t        i16OffsetX;      /*!< Dest. Offset X-Coord */
N    int16_t        i16OffsetY;      /*!< Dest. Offset Y-Coord */
N    uint32_t       u32RotPointX;    /*!< Rotation point X */
N    uint32_t       u32RotPointY;    /*!< Rotation point Y */
N#ifdef GA_USE_MATH_LIB
N    float64_t      f64AngleX;       /*!< Perspective Angle X */
N    float64_t      f64AngleY;       /*!< Perspective Angle Y */
N    float64_t      f64AngleZ;       /*!< Perspective Angle Z */
N    float64_t      f64Scale;        /*!< Scale Factor */
N    float64_t      f64ScaleX;       /*!< Scale Factor X */
N    float64_t      f64ScaleY;       /*!< Scale Factor Y */
N#else
S    int32_t        i32AngleX;       /*!< Perspective Angle X */
S    int32_t        i32AngleY;       /*!< Perspective Angle Y */
S    int32_t        i32AngleZ;       /*!< Perspective Angle Z */
S    int32_t        i32ScaleX;       /*!< Scale Factor X */
S    int32_t        i32ScaleY;       /*!< Scale Factor Y */
N#endif
N    ga_en_e        eDstRedProt;     /*!< Destination red color protection */
N    ga_en_e        eDstGreenProt;   /*!< Destination green color protection */
N    ga_en_e        eDstBlueProt;    /*!< Destination blue color protection */
N    ga_en_e        eDstAlphaProt;   /*!< Destination alpha protection */
N    ga_en_e        eSrcRedFad;      /*!< Destination red color protection */
N    ga_en_e        eSrcGreenFad;    /*!< Destination green color protection */
N    ga_en_e        eSrcBlueFad;     /*!< Destination blue color protection */
N    ga_en_e        eSrcAlphaFad;    /*!< Destination alpha protection */
N    uint8_t        u8FadingFctr;    /*!< Fading factor */
N    ga_blendOrd_e  eBldOrd;         /*!< Blend order */
N    uint8_t        u8SrcAlphaVal;   /*!< Source Alpha value */
N    uint8_t        u8DstAlphaVal;   /*!< Destination Alpha value */
N
N    /* Optional */
N    rot_clipWnd_st tClipWnd;
N} rot_perspectiveblendCfg_st;
N
N
N/**
N* @brief Rotation of part of image
N*/
Ntypedef struct tag_rot_mem_part_st
N{
N    /* Source Mem. Params */
N    uint16_t      u16SrcHeight;      /*!< Source Memory Height (Line Number) */
N    uint16_t      u16SrcWidth;       /*!< Source Memory Width (Dots Per Line) */
N    uint32_t      u32SrcAddr;        /*!< Source Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    uint16_t      u16DotCnt;         /*!< Dot Number per line to be blitted */
N
N    /* Destination Mem. Params */
N    uint32_t      u32DstAddr;        /*!< Dest. Memory Addr. First Src. Dot
N                                       (Each function specifies its own
N                                        memory alignment rules) */
N    /* Dest. Image Area Size */
N    uint16_t      u16DstImgWidth;    /*!< Destination Image Width */
N    uint16_t      u16DstImgHeight;   /*!< Destination Image Height */
N} rot_mem_part_st;
N
N
N/**
N* @brief Matrix parameter
N*/
Ntypedef struct tag_GA_MATRIX_t
N{
N    double sx;       /*!< Parameter sx */
N    double shx;      /*!< Parameter shx */
N    double tx;       /*!< Parameter tx */
N    double shy;      /*!< Parameter shy */
N    double sy;       /*!< Parameter sy */
N    double ty;       /*!< Parameter ty */
N    double w0;       /*!< Parameter w0 */
N    double w1;       /*!< Parameter w1 */
N    double w2;       /*!< Parameter w2 */
N} GA_MATRIX_t;
N
N
N/**
N* @brief Coordinate point
N*/
Ntypedef struct tag_GA_COORD_t
N{
N    double x;       /*!< Coordinate x */
N    double y;       /*!< Coordinate y */
N    double z;       /*!< Coordinate z */
N} GA_COORD_t;
N
N
N/**
N* @brief Screenobject
N*/
Ntypedef struct tag_GA_SCREENOBJ_t
N{
N    GA_COORD_t p1;       /*!< Point p1 */
N    GA_COORD_t p2;       /*!< Point p2 */
N    GA_COORD_t p3;       /*!< Point p3 */
N    GA_COORD_t p4;       /*!< Point p4 */
N    GA_COORD_t c;        /*!< Point c */
N} GA_SCREENOBJ_t;
N
N/*********************************************/
N
N
N/**********************************************
N*            Function prototypes              *
N**********************************************/
N
N/**
N* @brief Implementation of round off function for KEIL
N*
N* @note none
N*
N* @param[in] f64Value - The floating point value to be rounded off
N*
N* @return The rounded off value
N*/
N#if defined (__KEIL__)
X#if 1L
Nfloat64_t round(float64_t f64Value);
N#endif
N
N
N/**
N* @brief Implementation of function vRotLib_GetVersion
N*
N* Retrieve pointers to module and header revision and tag string
N*
N* @note none
N*
N* @param[in,out] pau8ModuleRevision - pointer to module revision string
N* @param[in,out] pau8ModuleTag      - pointer to module tag string
N* @param[in,out] pau8HeaderRevision - pointer to header revision string
N* @param[in,out] pau8HeaderTag      - pointer to header tag string
N*
N* @return void
N*/
Nvoid vRotLib_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                        uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag);
N
N
N#ifdef GA_USE_MATH_LIB
N/**
N* @brief Implementation of function vRotLib_CalculateTransformationMatrix_Rotate
N*
N* Calculates rotation matrix on hand of angle
N*
N* @note none
N*
N* @param[in] pstMatrix - Pointer to rotation matrix
N* @param[in] f64Angle  - angle in degree 
N*
N* @return void
N*/
Nvoid vRotLib_CalculateTransformationMatrix_Rotate(rot_Mtrx_st* pstMatrix, float64_t f64Angle);
N#else
S/**
S* @brief Implementation of function vRotLib_CalculateTransformationMatrix_Rotate
S*
S* Calculates rotation matrix on hand of angle
S*
S* @note none
S*
S* @param[in] pstMatrix - Pointer to rotation matrix
S* @param[in] i16Angle  - angle in degree 
S*
S* @return void
S*/
Svoid vRotLib_CalculateTransformationMatrix_Rotate(rot_Mtrx_st* pstMatrix, int16_t i16Angle);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB
N/**
N* @brief Implementation of function vRotLib_CalculateTransformationMatrix_Shear
N*
N* Calculates rotation matrix for shear operation
N*
N* @note none
N*
N* @param[in] pstMatrix  - Pointer to rotation matrix
N* @param[in] f64FactorX - Factor X for Shear 
N* @param[in] f64FactorY - Factor Y for Shear 
N*
N* @return void
N*/
Nvoid vRotLib_CalculateTransformationMatrix_Shear(rot_Mtrx_st* pstMatrix, float64_t f64FactorX, float64_t f64FactorY);
N#else
S/**
S* @brief Implementation of function vRotLib_CalculateTransformationMatrix_Shear
S*
S* Calculates rotation matrix for shear operation
S*
S* @note none
S*
S* @param[in] pstMatrix  - Pointer to rotation matrix
S* @param[in] i32FactorX - Factor X for Shear 
S* @param[in] i32FactorY - Factor Y for Shear 
S*
S* @return void
S*/
Svoid vRotLib_CalculateTransformationMatrix_Shear(rot_Mtrx_st* pstMatrix, int32_t i32FactorX, int32_t i32FactorY);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB
N/**
N* @brief Implementation of function vRotLib_CalculateTransformationMatrix_Scale
N*
N* Calculates rotation matrix for scale operation
N*
N* @note none
N*
N* @param[in] pstMatrix  - Pointer to rotation matrix
N* @param[in] f64FactorX - Factor X for scaling 
N* @param[in] f64FactorY - Factor Y for scaling 
N*
N* @return void
N*/
Nvoid vRotLib_CalculateTransformationMatrix_Scale(rot_Mtrx_st* pstMatrix, float64_t f64FactorX, float64_t f64FactorY);
N#else
S/**
S* @brief Implementation of function vRotLib_CalculateTransformationMatrix_Scale
S*
S* Calculates rotation matrix for scale operation
S*
S* @note none
S*
S* @param[in] pstMatrix  - Pointer to rotation matrix
S* @param[in] i32FactorX - Factor X for scaling 
S* @param[in] i32FactorY - Factor Y for scaling 
S*
S* @return void
S*/
Svoid vRotLib_CalculateTransformationMatrix_Scale(rot_Mtrx_st* pstMatrix, int32_t i32FactorX, int32_t i32FactorY);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB 
N/**
N* @brief Implementation of function vRotLib_Rotate
N*
N* Inserts all required parameters for source object rotation
N*
N* @note Please note that this function will perform rotation angle
N*       conversion from degrees to radians.
N*
N* @param[in] pstMem   - Pointer to memory configuration parameters
N* @param[in] pstParam - Pointer to rotation Parameters
N*                       (for more details see struct. desc.)
N* @param[in] f64Angle - Rotation angle (degrees)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_Rotate(rot_mem_st* pstMem, rot_cfg_st* pstParam, float64_t f64Angle,
N                    ga_list_st* pstCmdList);
N#else
S/**
S* @brief Implementation of function vRotLib_Rotate
S*
S* Inserts all required parameters for source object rotation
S*
S* @note Please note that this function will perform rotation angle
S*       conversion from degrees to radians.
S*
S* @param[in] pstMem   - Pointer to memory configuration parameters
S* @param[in] pstParam - Pointer to rotation Parameters
S*                       (for more details see struct. desc.)
S* @param[in] i16Angle - 10times integer rotation angle
S*
S* @param[in,out] pstCmdList - Pointer to the Command List
S*
S* @return void
S*/
Svoid vRotLib_Rotate(rot_mem_st* pstMem, rot_cfg_st* pstParam, int16_t   i16Angle,
S                    ga_list_st* pstCmdList);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB 
N/**
N* @brief Implementation of function vRotLib_Rotate_Part
N*
N* Inserts all required parameters for part source object rotation
N*
N* @note Please note that this function will perform rotation angle
N*       conversion from degrees to radians.
N*
N* @param[in] pstMem   - Pointer to memory configuration parameters
N* @param[in] pstParam - Pointer to rotation Parameters
N*                       (for more details see struct. desc.)
N* @param[in] f64Angle - Rotation angle (degrees)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_Rotate_Part(rot_mem_part_st* pstMem, rot_cfg_st* pstParam, float64_t f64Angle,
N                         ga_list_st* pstCmdList);
N#else
S/**
S* @brief Implementation of function vRotLib_Rotate_Part
S*
S* Inserts all required parameters for part source object rotation
S*
S* @note Please note that this function will perform rotation angle
S*       conversion from degrees to radians.
S*
S* @param[in] pstMem   - Pointer to memory configuration parameters
S* @param[in] pstParam - Pointer to rotation Parameters
S*                       (for more details see struct. desc.)
S* @param[in] i16Angle - 10times integer rotation angle
S*
S* @param[in,out] pstCmdList - Pointer to the Command List
S*
S* @return void
S*/
Svoid vRotLib_Rotate_Part(rot_mem_part_st* pstMem, rot_cfg_st* pstParam, int16_t   i16Angle,
S                         ga_list_st* pstCmdList);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB 
N/**
N* @brief Implementation of function vRotLib_RotateBlend
N*
N* Inserts all required parameters for source object rotation
N*
N* @note Please note that this function will perform rotation angle
N*       conversion from degrees to radians.
N*
N* @param[in] pstMem   - Pointer to memory configuration parameters
N* @param[in] pstParam - Pointer to rotation Parameters
N*                       (for more details see struct. desc.)
N* @param[in] f64Angle - Rotation angle (degrees)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_RotateBlend(rot_mem_st* pstMem, rot_blendcfg_st* pstParam, float64_t f64Angle,
N                         ga_list_st* pstCmdList);
N#else
S/**
S* @brief Implementation of function vRotLib_RotateBlend
S*
S* Inserts all required parameters for source object rotation
S*
S* @note Please note that this function will perform rotation angle
S*       conversion from degrees to radians.
S*
S* @param[in] pstMem   - Pointer to memory configuration parameters
S* @param[in] pstParam - Pointer to rotation Parameters
S*                       (for more details see struct. desc.)
S* @param[in] i16Angle - 10times integer rotation angle
S*
S* @param[in,out] pstCmdList - Pointer to the Command List
S*
S* @return void
S*/
Svoid vRotLib_RotateBlend(rot_mem_st* pstMem, rot_blendcfg_st* pstParam, int16_t   i16Angle,
S                         ga_list_st* pstCmdList);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB
N/**
N* @brief Implementation of function vRotLib_RotateBlend_Part
N*
N* Inserts all required parameters for part source object rotation
N*
N* @note Please note that this function will perform rotation angle
N*       conversion from degrees to radians.
N*
N* @param[in] pstMem   - Pointer to memory configuration parameters
N* @param[in] pstParam - Pointer to rotation Parameters
N*                       (for more details see struct. desc.)
N* @param[in] f64Angle - Rotation angle (degrees)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_RotateBlend_Part(rot_mem_part_st* pstMem, rot_blendcfg_st* pstParam, float64_t f64Angle,
N                              ga_list_st* pstCmdList);
N#else
S/**
S* @brief Implementation of function vRotLib_RotateBlend_Part
S*
S* Inserts all required parameters for part source object rotation
S*
S* @note Please note that this function will perform rotation angle
S*       conversion from degrees to radians.
S*
S* @param[in] pstMem   - Pointer to memory configuration parameters
S* @param[in] pstParam - Pointer to rotation Parameters
S*                       (for more details see struct. desc.)
S* @param[in] i16Angle - 10times integer rotation angle
S*
S* @param[in,out] pstCmdList - Pointer to the Command List
S*
S* @return void
S*/
Svoid vRotLib_RotateBlend_Part(rot_mem_part_st* pstMem, rot_blendcfg_st* pstParam, int16_t   i16Angle,
S                              ga_list_st* pstCmdList);
N#endif
N
N
N#ifdef GA_USE_MATH_LIB 
N/**
N* @brief Implementation of function vRotLib_Shear
N*
N* Inserts all required parameters for source object shearing operation
N*
N* @note none
N*
N* @param[in] pstMem     - Memory configuration parameters
N* @param[in] pstParam   - Shearing Parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_Shear(rot_mem_st* pstMem, rot_sscalCfg_st* pstParam,
N                   ga_list_st* pstCmdList);
N
N
N/**
N* @brief Implementation of function vRotLib_ShearBlend
N*
N* Inserts all required parameters for source object shearing operation
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to shearing Parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_ShearBlend(rot_mem_st* pstMem, rot_sscalblendCfg_st* pstParam,
N                        ga_list_st* pstCmdList);
N
N#endif /* GA_USE_MATH_LIB */
N
N
N/**
N* @brief Implementation of function vRotLib_Scale
N*
N* Inserts all required parameters for source object scaling operation
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to scaling parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_Scale(rot_mem_st* pstMem, rot_sscalCfg_st* pstParam,
N                   ga_list_st* pstCmdList);
N
N
N/**
N* @brief Implementation of function vRotLib_ScaleBlend
N*
N* Inserts all required parameters for source object scaling operation
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to scaling parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_ScaleBlend(rot_mem_st* pstMem, rot_sscalblendCfg_st* pstParam,
N                        ga_list_st* pstCmdList);
N
N
N#ifdef GA_USE_MATH_LIB
N/**
N* @brief Implementation of function vRotLib_Perspective
N*
N* Inserts all required parameters for source object perspective operation
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to perspective parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_Perspective(rot_mem_st* pstMem, rot_perspectiveCfg_st* pstParam,
N                         ga_list_st* pstCmdList);
N
N
N/**
N* @brief Implementation of function vRotLib_PerspectiveBlend
N*
N* Inserts all required parameters for source object perspective operation
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to perspective parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_PerspectiveBlend(rot_mem_st* pstMem, rot_perspectiveblendCfg_st* pstParam,
N                              ga_list_st* pstCmdList);
N
N
N/**
N* @brief Implementation of function vRotLib_PerspectiveOGL
N*
N* Inserts all required parameters for source object perspective operation in OpenGL style
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to perspective parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_PerspectiveOGL(rot_mem_st * pstMem, rot_perspectiveCfg_st * pstParam, ga_list_st * pstCmdList);
N
N
N/**
N* @brief Implementation of function vRotLib_PerspectiveOGL
N*
N* Inserts all required parameters for source object perspective operation in OpenGL style
N*
N* @note none
N*
N* @param[in] pstMem     - Pointer to memory configuration parameters
N* @param[in] pstParam   - Pointer to perspective parameters
N*                         (for more details see struct. desc.)
N*
N* @param[in,out] pstCmdList - Pointer to the Command List
N*
N* @return void
N*/
Nvoid vRotLib_PerspectiveBlendOGL(rot_mem_st * pstMem, rot_perspectiveblendCfg_st * pstParam, ga_list_st * pstCmdList);
N
N#endif
N
N
N/****************************************************************************/
N
N
N#endif /* ROTATION_LIB_H */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
L 26 "..\..\..\..\mw\src\rotation.c" 2
N#include "gf.h"
N/*********************************************/
N
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N#define LLDD_GA_ROTATE_LIB_C_REVISION     "$Revision: 1.14 $"
N#define LLDD_GA_ROTATE_LIB_C_TAG          "$Name: Graphic_Middleware_V1_5 $"
N
N/*********************************************/
N
N#define WxR_VALUE_ONE  (0x10000U)  /* WxR register set to 1 (shifted by 16 bits)*/
N#define RE_MIN(a, b) ((a) < (b) ? (a) : (b))
N
N/*********************************************/
N
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/ 
Nstatic uint8_t au8LLDD_GA_ROTATE_LIB_C_REVISION[] = LLDD_GA_ROTATE_LIB_C_REVISION;
Xstatic uint8_t au8LLDD_GA_ROTATE_LIB_C_REVISION[] = "$Revision: 1.14 $";
Nstatic uint8_t au8LLDD_GA_ROTATE_LIB_C_TAG[]      = LLDD_GA_ROTATE_LIB_C_TAG;
Xstatic uint8_t au8LLDD_GA_ROTATE_LIB_C_TAG[]      = "$Name: Graphic_Middleware_V1_5 $";
Nstatic uint8_t au8LLDD_GA_ROTATE_LIB_H_REVISION[] = LLDD_GA_ROTATE_LIB_H_REVISION;
Xstatic uint8_t au8LLDD_GA_ROTATE_LIB_H_REVISION[] = "$Revision: 1.10 $";
Nstatic uint8_t au8LLDD_GA_ROTATE_LIB_H_TAG[]      = LLDD_GA_ROTATE_LIB_H_TAG;
Xstatic uint8_t au8LLDD_GA_ROTATE_LIB_H_TAG[]      = "$Name: Graphic_Middleware_V1_5 $";
N
N/*********************************************/
N
N
N/**********************************************
N*              Global variables               *
N**********************************************/
Nuint32_t  au32Coordinate[4][2];
N
Nfloat32_t f32SubResPPos = 16.0;
Nuint32_t  u32SubResPPos = 16U;
Nfloat32_t f32SubResCPos = 16.0;
Nuint32_t  u32SubResCPos = 16U;
N
N/*********************************************/
N
Nfloat64_t obj[4][4];
N
N/*********************************************/
N
N
N/**********************************************
N*             Function prototypes             *
N**********************************************/
Nstatic ga_en_e vRotLib_CalculateCorrectClipWindow(rot_clipWnd_st* stClipWnd, ga_en_e eClipWndEn, rot_mem_st * pstMem, int* offset);
Nstatic void vSaveGlFwRotCornerCoord(rot_frccr_st *stCoord);
Nstatic GA_COORD_t RE_DEG2RAD(GA_COORD_t c);
Nstatic GA_MATRIX_t RE_ROTMATRIX (GA_COORD_t rot);
Nstatic GA_SCREENOBJ_t RE_CREATESCREENOBJECT(uint32_t u32Width, uint32_t u32Height, float64_t f64RotPoint_x, float64_t f64RotPoint_y);
Nstatic GA_COORD_t RE_VECTORMATRIXMULT (GA_COORD_t A, GA_MATRIX_t B);
Nstatic float64_t RE_MAX2(float64_t f64X, float64_t f64Y);
Nstatic GA_SCREENOBJ_t RE_3DTO2D(GA_SCREENOBJ_t S, float64_t f64Depth_shift);
Nstatic GA_COORD_t RE_MINSCREENOBJECTTYPE(GA_SCREENOBJ_t s);
Nstatic GA_SCREENOBJ_t RE_TRANSLATESCREENOBJECT(GA_SCREENOBJ_t a, GA_COORD_t b);
Nstatic GA_SCREENOBJ_t RE_SCALESCREENOBJECT_X(GA_SCREENOBJ_t S, float64_t f64Scale);
Nstatic GA_SCREENOBJ_t RE_SCALESCREENOBJECT_Y(GA_SCREENOBJ_t S, float64_t f64Scale);
Nstatic GA_SCREENOBJ_t RE_FORWARDROT(GA_COORD_t rot, float64_t f64Scale, uint32_t u32Width, uint32_t u32Height, float64_t f64RotPoint_x, float64_t f64RotPoint_y);
Nstatic int RE_SORTCORNERS (GA_SCREENOBJ_t* CC);
Nstatic GA_MATRIX_t RE_SCALEMATRIX(GA_MATRIX_t M, float64_t f64Scale);
Nstatic float64_t RE_DOUBLEABS(float64_t f64X);
Nstatic float64_t RE_MAXMATRIXELEMENT(GA_MATRIX_t M);
Nstatic GA_MATRIX_t RE_BACKWARDMATRIX(GA_SCREENOBJ_t FRCC, uint32_t u32Width, uint32_t u32Height);
Nstatic float64_t RE_FLOAT64ROUND(float64_t x);
Nstatic float64_t RE_FLOAT64TRUNC(float64_t x);
Nstatic void RE_TRANSLATEOBJECT(int32_t * offset, GA_SCREENOBJ_t * FRCC, float64_t * original);
Nstatic uint32_t RE_FLOAT64TOUINT32(float64_t x);
N#ifdef GA_USE_MATH_LIB
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(rot_mem_st* pstMem, 
N                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
N                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
N                                                                 rot_frccr_st* pstCoord, float64_t f64Angle);
N#else
Sstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(rot_mem_st* pstMem, 
S                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
S                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
S                                                                 rot_frccr_st* pstCoord, int16_t i16Angle);
N#endif
N#ifdef GA_USE_MATH_LIB
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(rot_mem_part_st* pstMem, 
N                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
N                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
N                                                                 rot_frccr_st* pstCoord, float64_t f64Angle);
N#else
Sstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(rot_mem_part_st* pstMem, 
S                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
S                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
S                                                                 rot_frccr_st* pstCoord, int16_t i16Angle);
N#endif
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_Shear(rot_mem_st* pstMem, 
N                                                            int16_t i16OffsetX, int16_t i16OffsetY, 
N                                                            float64_t f64FactorX, float64_t f64FactorY, 
N                                                            rot_frccr_st* pstCoord);
N#ifdef GA_USE_MATH_LIB
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(rot_mem_st* pstMem,
N                                                            int16_t i16OffsetX, int16_t i16OffsetY,
N                                                            float64_t f64FactorX, float64_t f64FactorY,
N                                                            rot_scaleAlign_e eAlignment, rot_frccr_st* pstCoord);
N#else
Sstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(rot_mem_st* pstMem,
S                                                            int16_t i16OffsetX, int16_t i16OffsetY,
S                                                            int32_t i32FactorX, int32_t i32FactorY,
S                                                            rot_scaleAlign_e eAlignment, rot_frccr_st* pstCoord);
N#endif
Nstatic void vRotLib_CheckForNegativeCoordinates(rot_mem_st* pstMem, rot_rotCfg_st* pstParam, rot_frccr_st* pstCoord);
Nstatic void vRotLib_CheckForNegativeCoordinatesBlend(rot_mem_st* pstMem, rot_rotblendCfg_st* pstParam, rot_frccr_st* pstCoord);
N
N/*********************************************/
N
N
N/**********************************************
N*             Function definition             *
N**********************************************/
N
Nvoid vRotLib_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                        uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag)
N{
N     *pau8ModuleRevision = &au8LLDD_GA_ROTATE_LIB_C_REVISION[0];
N     *pau8ModuleTag      = &au8LLDD_GA_ROTATE_LIB_C_TAG[0];
N     *pau8HeaderRevision = &au8LLDD_GA_ROTATE_LIB_H_REVISION[0];
N     *pau8HeaderTag      = &au8LLDD_GA_ROTATE_LIB_H_TAG[0];
N}
N
N
N/****************************************************************************/
N
N/* Direct conversion from negative floats to unsigned int will cause undefined behaviour. Refer to C99 Â§6.3.1.4 */
Nstatic uint32_t RE_FLOAT64TOUINT32(float64_t x)
N{
N	return ((uint32_t)((int32_t)(x)));
N}
N
N/****************************************************************************/
N/* calculate rounded float64_t */
Nstatic float64_t RE_FLOAT64ROUND(float64_t x)
N{
N    if (x>0.0)
N    {
N        return ((float64_t)((long long)(x + 0.5)));
N    }
N    else
N    {
N        return ((float64_t)((long long)(x - 0.5)));
N    }
N}
N
N/****************************************************************************/
N
Nstatic void vSaveGlFwRotCornerCoord(rot_frccr_st *stCoord)
N{
N    au32Coordinate[0][0] = stCoord->u16X1;
N    au32Coordinate[0][1] = stCoord->u16Y1;
N    au32Coordinate[1][0] = stCoord->u16X2;
N    au32Coordinate[1][1] = stCoord->u16Y2;
N    au32Coordinate[2][0] = stCoord->u16X3;
N    au32Coordinate[2][1] = stCoord->u16Y3;
N    au32Coordinate[3][0] = stCoord->u16X4;
N    au32Coordinate[3][1] = stCoord->u16Y4;
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_CalculateTransformationMatrix_Rotate(rot_Mtrx_st* pstMatrix, float64_t f64Angle)
N#else
Svoid vRotLib_CalculateTransformationMatrix_Rotate(rot_Mtrx_st* pstMatrix, int16_t i16Angle)
N#endif
N{
N#ifdef GA_USE_MATH_LIB
N    float64_t f64AngRad;
N    float64_t f64Sin,f64Cos;
N#else
S    int32_t i32Sin, i32Cos;
N#endif
N
N#ifdef GA_USE_MATH_LIB
N    /* Angle Conversion to radians */
N    f64AngRad = (2.0 * GA_CONST_PI * f64Angle)/360.0 ;
X    f64AngRad = (2.0 * 3.1415926535897932384626433 * f64Angle)/360.0 ;
N
N    f64Sin = ROT_SIN(f64AngRad);
X    f64Sin = ((RE_FLOAT64ROUND((sin(f64AngRad))*4294967296.0)/4294967296));
N    f64Cos = ROT_COS(f64AngRad);
X    f64Cos = ((RE_FLOAT64ROUND((cos(f64AngRad))*4294967296.0)/4294967296));
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1865    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1866    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1867    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N    pstMatrix -> u32A11 = (uint32_t)((int64_t)( f64Cos * 65536.0) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N    pstMatrix -> u32A12 = (uint32_t)((int64_t)(-f64Sin * 65536.0) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N    pstMatrix -> u32A21 = (uint32_t)((int64_t)( f64Sin * 65536.0) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N    pstMatrix -> u32A22 = (uint32_t)((int64_t)( f64Cos * 65536.0) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#else
S
S    /* Calculate only once Sine and Cosine */
S    i32Sin = ROT_SIN(i16Angle);
S    i32Cos = ROT_COS(i16Angle);
S   
S#if defined(__GHS__) || defined(__ghs__)
S  #pragma ghs nowarning 1865    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1866    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1867    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
S#endif /* defined(__GHS__) || defined(__ghs__) */
S    /* Transformation Matrix Config. */
S    pstMatrix -> u32A11 = (uint32_t)(( i32Cos) + 0xFFFFFFFFU + 0x1U);
S    pstMatrix -> u32A12 = (uint32_t)((-i32Sin) + 0xFFFFFFFFU + 0x1U);
S    pstMatrix -> u32A21 = (uint32_t)(( i32Sin) + 0xFFFFFFFFU + 0x1U);
S    pstMatrix -> u32A22 = (uint32_t)(( i32Cos) + 0xFFFFFFFFU + 0x1U);
S#if defined(__GHS__) || defined(__ghs__)
S  #pragma ghs endnowarning
S#endif /* defined(__GHS__) || defined(__ghs__) */
S
N#endif
N
N    /* Fill W0=0, W1=0, W2=1: */
N    pstMatrix -> u32A31 = (uint32_t)(0);
N    pstMatrix -> u32A32 = (uint32_t)(0);
N    pstMatrix -> u32A33 = (uint32_t)(WxR_VALUE_ONE);
X    pstMatrix -> u32A33 = (uint32_t)((0x10000U));
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_CalculateTransformationMatrix_Shear(rot_Mtrx_st* pstMatrix, float64_t  f64FactorX, float64_t  f64FactorY)
N#else
Svoid vRotLib_CalculateTransformationMatrix_Shear(rot_Mtrx_st* pstMatrix, int32_t i32FactorX, int32_t i32FactorY)
N#endif
N{
N    /* Transformation Matrix Setup */
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1863    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N#ifdef GA_USE_MATH_LIB
N    pstMatrix -> u32A11 = (uint32_t)((int64_t)((65536.0/(1.0-(f64FactorX * f64FactorY)))) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N    pstMatrix -> u32A12 = (uint32_t)((int64_t)(((-f64FactorY * 65536.0) / (1.0-(f64FactorX * f64FactorY)))) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N    pstMatrix -> u32A21 = (uint32_t)((int64_t)(((-f64FactorX*65536.0) / (1.0-(f64FactorX * f64FactorY)))) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N    pstMatrix -> u32A22 = (uint32_t)((int64_t)((65536.0/(1.0-(f64FactorX * f64FactorY)))) + 0xFFFFFFFFFFFFFFFFUL + 0x1UL);
N#else
S    pstMatrix -> u32A11 = (uint32_t)((65536U * (65536U/(1U-(i32FactorX * i32FactorY))) ) + 0xFFFFFFFFU + 0x1U);
S    pstMatrix -> u32A12 = (uint32_t)((65536U * ((-i32FactorY * 65536U) / (1U-(i32FactorX * i32FactorY))) ) + 0xFFFFFFFFU + 0x1U);
S    pstMatrix -> u32A21 = (uint32_t)((65536U * ((-i32FactorX*65536U) / (1U-(i32FactorX * i32FactorY))) ) + 0xFFFFFFFFU + 0x1U);
S    pstMatrix -> u32A22 = (uint32_t)((65536U * (65536U/(1-(i32FactorX * i32FactorY))) ) + 0xFFFFFFFFU + 0x1U);
N#endif
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    /* Fill W0=0, W1=0, W2=1: */
N    pstMatrix -> u32A31 = (uint32_t)(0);
N    pstMatrix -> u32A32 = (uint32_t)(0);
N    pstMatrix -> u32A33 = (uint32_t)(WxR_VALUE_ONE);
X    pstMatrix -> u32A33 = (uint32_t)((0x10000U));
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_CalculateTransformationMatrix_Scale(rot_Mtrx_st* pstMatrix, float64_t  f64FactorX, float64_t  f64FactorY)
N#else
Svoid vRotLib_CalculateTransformationMatrix_Scale(rot_Mtrx_st* pstMatrix, int32_t i32FactorX, int32_t i32FactorY)
N#endif
N{
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1864    /* MISRA 2004 Rule 10.1 */
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N#ifdef GA_USE_MATH_LIB
N    /* Transformation Matrix Setup */
N    pstMatrix -> u32A11 = RE_FLOAT64TOUINT32((65536.0 / f64FactorX));
N    pstMatrix -> u32A12 = 0U;
N    pstMatrix -> u32A21 = 0U;
N    pstMatrix -> u32A22 = RE_FLOAT64TOUINT32((65536.0 / f64FactorY));
N#else
S    /* Transformation Matrix Setup */
S    pstMatrix -> u32A11 = (uint64_t)(65536U * (65536U / i32FactorX));
S    pstMatrix -> u32A12 = 0U;
S    pstMatrix -> u32A21 = 0U;
S    pstMatrix -> u32A22 = (uint64_t)(65536U * (65536U / i32FactorY));
N#endif
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    /* Fill W0=0, W1=0, W2=1: */
N    pstMatrix -> u32A31 = (uint32_t)(0);
N    pstMatrix -> u32A32 = (uint32_t)(0);
N    pstMatrix -> u32A33 = (uint32_t)(WxR_VALUE_ONE);
X    pstMatrix -> u32A33 = (uint32_t)((0x10000U));
N    
N}
N
N/****************************************************************************/
Nstatic ga_en_e vRotLib_CalculateCorrectClipWindow(rot_clipWnd_st* stClipWnd, ga_en_e eClipWndEn, rot_mem_st * pstMem, int* offset)
N{
N    ga_en_e eDraw = GA_EN;
N    /* correct clip window */
N    if(eClipWndEn == GA_EN)
N    {
N        if(offset[0] >= 0)
N        {
N            /* If offset is positive */
N            if(offset[0] >= stClipWnd->u16UlX && offset[0] <= stClipWnd->u16LrX)
N            {
N                /* When is there is a partial overlap of clip window */
N                stClipWnd->u16UlX = 0;
N                stClipWnd->u16LrX = stClipWnd->u16LrX - offset[0];
N            }
N            else
N            {
N                /* Clip window is either completely inside the destination area or completely outside the destination area */
N                stClipWnd->u16UlX = stClipWnd->u16UlX - offset[0];
N                stClipWnd->u16LrX = stClipWnd->u16LrX - offset[0];           
N            }
N        }
N        else
N        {
N            /* If offset is negative */
N            stClipWnd->u16UlX = (uint16_t)RE_DOUBLEABS(offset[0]) + stClipWnd->u16UlX;
N            stClipWnd->u16LrX = (uint16_t)(RE_MIN(pstMem->u16DstImgWidth - 1, (uint32_t)(RE_DOUBLEABS(offset[0])) + stClipWnd->u16LrX));
X            stClipWnd->u16LrX = (uint16_t)(((pstMem->u16DstImgWidth - 1) < ((uint32_t)(RE_DOUBLEABS(offset[0])) + stClipWnd->u16LrX) ? (pstMem->u16DstImgWidth - 1) : ((uint32_t)(RE_DOUBLEABS(offset[0])) + stClipWnd->u16LrX)));
N        }
N
N        if(offset[1] >= 0)
N        {
N            /* If offset is positive */
N            if(offset[1] >= stClipWnd->u16UlY && offset[1]  <= stClipWnd->u16LrY)
N            {
N                /* When is there is a partial overlap of clip window */
N                stClipWnd->u16UlY = 0;
N                stClipWnd->u16LrY = stClipWnd->u16LrY - offset[1];
N            }
N            else
N            {
N                /* Clip window is either completely inside the destination area or completely outside the destination area */
N                stClipWnd->u16UlY = stClipWnd->u16UlY - offset[1];
N                stClipWnd->u16LrY = stClipWnd->u16LrY - offset[1];
N            }
N        }
N        else
N        {
N            /* If offset is negative */
N            stClipWnd->u16UlY = (uint16_t)RE_DOUBLEABS(offset[1]) + stClipWnd->u16UlY;
N            stClipWnd->u16LrY = (uint16_t)(RE_MIN(pstMem->u16DstImgHeight - 1, (uint32_t)(RE_DOUBLEABS(offset[1])) + stClipWnd->u16LrY));
X            stClipWnd->u16LrY = (uint16_t)(((pstMem->u16DstImgHeight - 1) < ((uint32_t)(RE_DOUBLEABS(offset[1])) + stClipWnd->u16LrY) ? (pstMem->u16DstImgHeight - 1) : ((uint32_t)(RE_DOUBLEABS(offset[1])) + stClipWnd->u16LrY)));
N        }
N
N        eDraw = GA_EN;
N        if(stClipWnd->u16UlX > 0x8000 || stClipWnd->u16UlY > 0x8000)
N        {
N            /* when there is no overlap of clip window with the destination area, disable drawing i.e Don't make a call to LLDD */
N
N            stClipWnd->u16UlX = 0;
N            stClipWnd->u16UlY = 0;
N            stClipWnd->u16LrX = 0;
N            stClipWnd->u16LrY = 0;
N            eDraw = GA_DIS;
N        }
N    }
N    else
N    {
N        eDraw = GA_EN;
N        if(offset[0] < 0)
N        {
N            stClipWnd->u16UlX = (uint16_t)RE_DOUBLEABS(offset[0]);
N            stClipWnd->u16LrX = pstMem->u16DstImgWidth - 1;
N        }
N        else
N        {
N            stClipWnd->u16UlX = 0;
N            stClipWnd->u16LrX = pstMem->u16DstImgWidth - (uint16_t)RE_DOUBLEABS(offset[0]) - 1;
N        }
N
N        if(offset[1] < 0)
N        {
N            stClipWnd->u16UlY = (uint16_t)RE_DOUBLEABS(offset[1]);
N            stClipWnd->u16LrY = pstMem->u16DstImgHeight - 1;
N        }
N        else
N        {
N            stClipWnd->u16UlY = 0;
N            stClipWnd->u16LrY = pstMem->u16DstImgHeight - (uint16_t)RE_DOUBLEABS(offset[1]) - 1;
N        }
N    }
N    return eDraw;
N}
N
N
N/****************************************************************************/
N
Nga_en_e vRotLib_CheckForOverlap(rot_frccr_st * stCoord, rot_clipWnd_st * stClipWnd, ga_en_e eClipWndEn)
N{
N    ga_en_e eResult;
N    uint16_t u16XMax, u16YMax;
N    eResult = GA_EN;
N
N    if(eClipWndEn == GA_EN)
N    {
N        u16XMax = stCoord->u16X4;
N        u16YMax = stCoord->u16Y3;
N       
N        u16XMax = u16XMax >> 4;
N        u16YMax = u16YMax >> 4;
N        
N		/* Check if the FRCC overlaps with the destination region by atleast 1 pixel and also check make sure that Y coordinates of FRCC are not equal */
N        if(((u16YMax - stClipWnd->u16UlY) >= 1) && ((u16XMax - stClipWnd->u16UlX) >= 1) &&
N			 ( ((stCoord->u16Y1 >> 4) ^  (stCoord->u16Y2 >> 4)) | ((stCoord->u16Y2 >> 4) ^  (stCoord->u16Y3 >> 4)) |
N			    ((stCoord->u16Y3 >> 4) ^  (stCoord->u16Y3 >> 4)) | ((stCoord->u16Y4 >> 4) ^  (stCoord->u16Y1 >> 4)) ))
N        {
N            eResult = GA_EN;
N        }
N        else
N        {
N            eResult = GA_DIS;
N        }
N    }
N    return eResult;  
N    
N}
N
N/****************************************************************************/
N
Nstatic GA_COORD_t RE_DEG2RAD(GA_COORD_t c)
N{
N    c.x = (c.x*(float64_t)3.141592654)/(float64_t)180.0;
N    c.y = (c.y*(float64_t)3.141592654)/(float64_t)180.0;
N    c.z = (c.z*(float64_t)3.141592654)/(float64_t)180.0;
N
N    return(c);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_MATRIX_t RE_ROTMATRIX (GA_COORD_t rot)
N{
N    GA_MATRIX_t R;
N    float64_t cx, sx, cy, sy, cz, sz;
N
N    cx = (float64_t)cos(rot.x);
N    sx = (float64_t)sin(rot.x);
N    cy = (float64_t)cos(rot.y);
N    sy = (float64_t)sin(rot.y);
N    cz = (float64_t)cos(rot.z);
N    sz = (float64_t)sin(rot.z);
N
N    R.sx  = cy*cz;
N    R.shx = -cy*sz;
N    R.tx  = sy;
N    R.shy = sx*sy*cz  + cx*sz;
N    R.sy  = -sx*sy*sz + cx*cz;
N    R.ty  = -sx*cy;
N    R.w0  = -cx*sy*cz + sx*sz;
N    R.w1  = cx*sy*sz + sx*cz;
N    R.w2  = cx*cy;
N
N    return(R);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_SCREENOBJ_t RE_CREATESCREENOBJECT(uint32_t u32Width, uint32_t u32Height, float64_t f64RotPoint_x, float64_t f64RotPoint_y)
N{
N    GA_SCREENOBJ_t s;
N
N    /* lower left */
N    s.p1.x = - f64RotPoint_x;
N    s.p1.y = - f64RotPoint_y;
N    s.p1.z = 0.0;
N
N    /* upper left */
N    s.p2.x = - f64RotPoint_x;
N    s.p2.y = (float64_t)u32Height - f64RotPoint_y;
N    s.p2.z = 0.0;
N
N    /* upper right */
N    s.p3.x = (float64_t)u32Width  - f64RotPoint_x;
N    s.p3.y = (float64_t)u32Height - f64RotPoint_y;
N    s.p3.z = 0.0;
N
N    /* lower right */
N    s.p4.x =   (float64_t)u32Width - f64RotPoint_x;
N    s.p4.y = - f64RotPoint_y;
N    s.p4.z = 0.0;
N
N    s.c.x = 0.0;
N    s.c.y = 0.0;
N    s.c.z = 0.0;
N
N    return(s);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_COORD_t RE_VECTORMATRIXMULT (GA_COORD_t A, GA_MATRIX_t B)
N{
N    GA_COORD_t C;
N
N    C.x = A.x*B.sx  + A.y*B.shy + A.z*B.w0;
N    C.y = A.x*B.shx + A.y*B.sy  + A.z*B.w1;
N    C.z = A.x*B.tx  + A.y*B.ty  + A.z*B.w2;
N
N    return(C);
N}
N
N
N/****************************************************************************/
N
Nstatic float64_t RE_MAX2(float64_t f64X, float64_t f64Y)
N{
N    float64_t f64Value;
N
N    if (f64X>f64Y)
N    {
N        f64Value = f64X;
N    }
N    else
N    {
N        f64Value = f64Y;
N    }
N
N    return f64Value;
N}
N
N
N/****************************************************************************/
N
Nstatic GA_SCREENOBJ_t RE_3DTO2D(GA_SCREENOBJ_t S, float64_t f64Depth_shift)
N{
N    float64_t z;
N
N    z = S.p1.z + f64Depth_shift;
N    S.p1.x = S.p1.x/z;
N    S.p1.y = S.p1.y/z;
N    S.p1.z = 0.0;
N
N    z = S.p2.z + f64Depth_shift;
N    S.p2.x = S.p2.x/z;
N    S.p2.y = S.p2.y/z;
N    S.p2.z = 0.0;
N
N    z = S.p3.z + f64Depth_shift;
N    S.p3.x = S.p3.x/z;
N    S.p3.y = S.p3.y/z;
N    S.p3.z = 0.0;
N
N    z  =S.p4.z + f64Depth_shift;
N    S.p4.x = S.p4.x/z;
N    S.p4.y = S.p4.y/z;
N    S.p4.z = 0.0;
N
N    return(S);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_COORD_t RE_MINSCREENOBJECTTYPE(GA_SCREENOBJ_t s)
N{
N    GA_COORD_t dummy;
N
N    dummy.x = s.p1.x;
N    dummy.y = s.p1.y;
N    dummy.z = s.p1.z;
N
N    if (dummy.x > s.p2.x) {dummy.x = s.p2.x;}
N    if (dummy.x > s.p3.x) {dummy.x = s.p3.x;}
N    if (dummy.x > s.p4.x) {dummy.x = s.p4.x;}
N
N    if (dummy.y > s.p2.y) {dummy.y = s.p2.y;}
N    if (dummy.y > s.p3.y) {dummy.y = s.p3.y;}
N    if (dummy.y > s.p4.y) {dummy.y = s.p4.y;}
N
N    if (dummy.z > s.p2.z) {dummy.z = s.p2.z;}
N    if (dummy.z > s.p3.z) {dummy.z = s.p3.z;}
N    if (dummy.z > s.p4.z) {dummy.z = s.p4.z;}
N
N    return(dummy);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_SCREENOBJ_t RE_TRANSLATESCREENOBJECT(GA_SCREENOBJ_t a, GA_COORD_t b)
N{
N    a.p1.x = a.p1.x - b.x;
N    a.p1.y = a.p1.y - b.y;
N    a.p1.z = a.p1.z - b.z;
N
N    a.p2.x = a.p2.x - b.x;
N    a.p2.y = a.p2.y - b.y;
N    a.p2.z = a.p2.z - b.z;
N
N    a.p3.x = a.p3.x - b.x;
N    a.p3.y = a.p3.y - b.y;
N    a.p3.z = a.p3.z - b.z;
N
N    a.p4.x = a.p4.x - b.x;
N    a.p4.y = a.p4.y - b.y;
N    a.p4.z = a.p4.z - b.z;
N
N    a.c.x = a.c.x - b.x;
N    a.c.y = a.c.y - b.y;
N    a.c.z = a.c.z - b.z;
N
N    return(a);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_SCREENOBJ_t RE_SCALESCREENOBJECT_X(GA_SCREENOBJ_t S, float64_t f64Scale)
N{
N    S.p1.x = S.p1.x * f64Scale;
N    S.p2.x = S.p2.x * f64Scale;
N    S.p3.x = S.p3.x * f64Scale;
N    S.p4.x = S.p4.x * f64Scale;
N    S.c.x  = S.c.x  * f64Scale;
N
N    return(S);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_SCREENOBJ_t RE_SCALESCREENOBJECT_Y(GA_SCREENOBJ_t S, float64_t f64Scale)
N{
N    S.p1.y = S.p1.y * f64Scale;
N    S.p2.y = S.p2.y * f64Scale;
N    S.p3.y = S.p3.y * f64Scale;
N    S.p4.y = S.p4.y * f64Scale;
N    S.c.y  = S.c.y  * f64Scale;
N
N    return(S);
N}
N
N
N/****************************************************************************/
N
Nstatic GA_SCREENOBJ_t RE_FORWARDROT(GA_COORD_t rot, float64_t f64Scale, uint32_t u32Width, uint32_t u32Height, float64_t f64RotPoint_x, float64_t f64RotPoint_y)
N{
N    GA_MATRIX_t R;
N    GA_SCREENOBJ_t S;
N    GA_COORD_t min;
N
N    R = RE_ROTMATRIX(RE_DEG2RAD(rot));
N    S = RE_CREATESCREENOBJECT(u32Width, u32Height, f64RotPoint_x, f64RotPoint_y);
N
N    S.p1 = RE_VECTORMATRIXMULT(S.p1, R);
N    S.p2 = RE_VECTORMATRIXMULT(S.p2, R);
N    S.p3 = RE_VECTORMATRIXMULT(S.p3, R);
N    S.p4 = RE_VECTORMATRIXMULT(S.p4, R);
N
N    S = RE_3DTO2D(S,RE_MAX2((float64_t)u32Width, (float64_t)u32Height));
N    min = RE_MINSCREENOBJECTTYPE(S);
N    S = RE_TRANSLATESCREENOBJECT(S, min);
N    S = RE_SCALESCREENOBJECT_X(S, f64Scale);
N    S = RE_SCALESCREENOBJECT_Y(S, f64Scale);
N
N    return(S);
N}
N
N
N/****************************************************************************/
Nstatic int RE_SORTCORNERS(GA_SCREENOBJ_t* CC)
N{
N    int32_t p1, p2, p3, p4;
N    float64_t cx1;
N    float64_t cy1;
N    float64_t cx2;
N    float64_t cy2;
N    float64_t cx3;
N    float64_t cy3;
N    float64_t cx4;
N    float64_t cy4;
N    float64_t ox1;
N    float64_t oy1;
N    float64_t ox2;
N    float64_t oy2;
N    float64_t ox3;
N    float64_t oy3;
N    float64_t ox4;
N    float64_t oy4;
N    float64_t alpha1, alpha2, alpha3;
N    GA_SCREENOBJ_t pCC;
N    int iReturnCode = -1;
N
N    pCC.p1.x = (int32_t)((*CC).p1.x);
N    pCC.p2.x = (int32_t)((*CC).p2.x);
N    pCC.p3.x = (int32_t)((*CC).p3.x);
N    pCC.p4.x = (int32_t)((*CC).p4.x);
N    pCC.p1.y = (int32_t)((*CC).p1.y);
N    pCC.p2.y = (int32_t)((*CC).p2.y);
N    pCC.p3.y = (int32_t)((*CC).p3.y);
N    pCC.p4.y = (int32_t)((*CC).p4.y);
N
N    pCC.p1.z = 0.0;
N    pCC.p2.z = 0.0;
N    pCC.p3.z = 0.0;
N    pCC.p4.z = 0.0;
N
N    (*CC).p1.x = ((*CC).p1.x);
N    (*CC).p2.x = ((*CC).p2.x);
N    (*CC).p3.x = ((*CC).p3.x);
N    (*CC).p4.x = ((*CC).p4.x);
N    (*CC).p1.y = ((*CC).p1.y);
N    (*CC).p2.y = ((*CC).p2.y);
N    (*CC).p3.y = ((*CC).p3.y);
N    (*CC).p4.y = ((*CC).p4.y);
N
N    p1 = (((int32_t)(pCC.p1.y))<<16) + ((int32_t)(pCC.p1.x));
N    p2 = (((int32_t)(pCC.p2.y))<<16) + ((int32_t)(pCC.p2.x));
N    p3 = (((int32_t)(pCC.p3.y))<<16) + ((int32_t)(pCC.p3.x));
N    p4 = (((int32_t)(pCC.p4.y))<<16) + ((int32_t)(pCC.p4.x));
N
N    cx1 = (pCC.p1.x);
N    cy1 = (pCC.p1.y);
N    cx2 = (pCC.p2.x);
N    cy2 = (pCC.p2.y);
N    cx3 = (pCC.p3.x);
N    cy3 = (pCC.p3.y);
N    cx4 = (pCC.p4.x);
N    cy4 = (pCC.p4.y);
N
N    ox1 = ((*CC).p1.x);
N    oy1 = ((*CC).p1.y);
N    ox2 = ((*CC).p2.x);
N    oy2 = ((*CC).p2.y);
N    ox3 = ((*CC).p3.x);
N    oy3 = ((*CC).p3.y);
N    ox4 = ((*CC).p4.x);
N    oy4 = ((*CC).p4.y);
N
N    /* corner 1 has the smallest coordinates */
N    if ((p1<p2) && (p1<p3) && (p1<p4))
N    {
N        (*CC).p1.x = RE_FLOAT64TOUINT32(ox1);
N        (*CC).p1.y = RE_FLOAT64TOUINT32(oy1);
N        /* calculate the angle of all vectors from corner 1 to the other corners */
N        alpha1 = ((cx2-cx1) / sqrt((cx2-cx1)*(cx2-cx1) + (cy2-cy1)*(cy2-cy1)));
N        alpha2 = ((cx3-cx1) / sqrt((cx3-cx1)*(cx3-cx1) + (cy3-cy1)*(cy3-cy1)));
N        alpha3 = ((cx4-cx1) / sqrt((cx4-cx1)*(cx4-cx1) + (cy4-cy1)*(cy4-cy1)));
N
N        /* sort remaining corners dependant on angle */
N        if ((alpha1<alpha2) && (alpha1<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox2);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy2);
N            if (alpha2<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy3);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy4);
N                iReturnCode = 1;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy4);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy3);
N                iReturnCode = 1;
N            }
N        }
N        else if ((alpha2<alpha1) && (alpha2<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox3);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy3);
N            if (alpha1<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy2);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy4);
N                iReturnCode = 1;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy4);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy2);
N                iReturnCode = 1;
N            }
N        }
N        else if ((alpha3<alpha1) && (alpha3<alpha2))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox4);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy4);
N            if (alpha1<alpha2)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy2);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy3);
N                iReturnCode = 1;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy3);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy2);
N                iReturnCode = 1;
N            }
N        }
N        else
N        {
N            iReturnCode = -1;
N        }
N    }
N    /* corner 2 has the smallest coordinates*/
N    else if ((p2<p1) && (p2<p3) && (p2<p4))
N    {
N        (*CC).p1.x = RE_FLOAT64TOUINT32(ox2);
N        (*CC).p1.y = RE_FLOAT64TOUINT32(oy2);
N        /* calculate the angle of all vectors from corner 2 to the other corners */
N        alpha1 = ((cx1-cx2) / sqrt((cx1-cx2)*(cx1-cx2) + (cy1-cy2)*(cy1-cy2)));
N        alpha2 = ((cx3-cx2) / sqrt((cx3-cx2)*(cx3-cx2) + (cy3-cy2)*(cy3-cy2)));
N        alpha3 = ((cx4-cx2) / sqrt((cx4-cx2)*(cx4-cx2) + (cy4-cy2)*(cy4-cy2)));
N        /* sort remaining corners dependant on angle */
N        if ((alpha1<alpha2) && (alpha1<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox1);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy1);
N            if (alpha2<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy3);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy4);
N                iReturnCode = 2;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy4);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy3);
N                iReturnCode = 2;
N            }
N        }
N        else if ((alpha2<alpha1) && (alpha2<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox3);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy3);
N            if (alpha1<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy1);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy4);
N                iReturnCode = 3;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy4);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy1);
N                iReturnCode = 4;
N            }
N        }
N        else if ((alpha3<alpha1) && (alpha3<alpha2))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox4);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy4);
N            if (alpha1<alpha2)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy1);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy3);
N                iReturnCode = 3;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy3);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy1);
N                iReturnCode = 4;
N            }
N        }
N        else
N        {
N            iReturnCode = -1;
N        }
N    }
N    /* corner 3 has the smallest coordinates */
N    else if ((p3<p1) && (p3<p2) && (p3<p4))
N    {
N        (*CC).p1.x = RE_FLOAT64TOUINT32(ox3);
N        (*CC).p1.y = RE_FLOAT64TOUINT32(oy3);
N        /* calculate the angle of all vectors from corner 3 to the other corners */
N        alpha1 = ((cx1-cx3) / sqrt((cx1-cx3)*(cx1-cx3) + (cy1-cy3)*(cy1-cy3)));
N        alpha2 = ((cx2-cx3) / sqrt((cx2-cx3)*(cx2-cx3) + (cy2-cy3)*(cy2-cy3)));
N        alpha3 = ((cx4-cx3) / sqrt((cx4-cx3)*(cx4-cx3) + (cy4-cy3)*(cy4-cy3)));
N        /* sort remaining corners dependant on angle */
N        if ((alpha1<alpha2) && (alpha1<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox1);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy1);
N            if (alpha2<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy2);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy4);
N                iReturnCode = 2;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy4);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy2);
N                iReturnCode = 2;
N            }
N        }
N        else if ((alpha2<alpha1) && (alpha2<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox2);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy2);
N            if (alpha1<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy1);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy4);
N                iReturnCode = 3;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox4);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy4);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy1);
N                iReturnCode = 4;
N            }
N        }
N        else if ((alpha3<alpha1) && (alpha3<alpha2))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox4);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy4);
N            if (alpha1<alpha2)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy1);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy2);
N                iReturnCode = 3;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy2);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy1);
N                iReturnCode = 4;
N            }
N        }
N        else
N        {
N            iReturnCode = -1;
N        }
N    }
N    /* corner 4 has the smallest coordinates */
N    else if ((p4<p1) && (p4<p2) && (p4<p3))
N    {
N        (*CC).p1.x = RE_FLOAT64TOUINT32(ox4);
N        (*CC).p1.y = RE_FLOAT64TOUINT32(oy4);
N        /* calculate the angle of all vectors from corner 4 to the other corners */
N        alpha1 = ((cx1-cx4) / sqrt((cx1-cx4)*(cx1-cx4) + (cy1-cy4)*(cy1-cy4)));
N        alpha2 = ((cx2-cx4) / sqrt((cx2-cx4)*(cx2-cx4) + (cy2-cy4)*(cy2-cy4)));
N        alpha3 = ((cx3-cx4) / sqrt((cx3-cx4)*(cx3-cx4) + (cy3-cy4)*(cy3-cy4)));
N        /* sort remaining corners dependant on angle */
N        if ((alpha1<alpha2) && (alpha1<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox1);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy1);
N            if (alpha2<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy2);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy3);
N                iReturnCode = 2;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy3);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy2);
N                iReturnCode = 2;
N            }
N        }
N        else if ((alpha2<alpha1) && (alpha2<alpha3))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox2);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy2);
N            if (alpha1<alpha3)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy1);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy3);
N                iReturnCode = 3;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox3);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy3);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy1);
N                iReturnCode = 4;
N            }
N        }
N        else if ((alpha3<alpha1) && (alpha3<alpha2))
N        {
N            (*CC).p2.x = RE_FLOAT64TOUINT32(ox3);
N            (*CC).p2.y = RE_FLOAT64TOUINT32(oy3);
N            if (alpha1<alpha2)
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy1);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy2);
N                iReturnCode = 3;
N            }
N            else
N            {
N                (*CC).p3.x = RE_FLOAT64TOUINT32(ox2);
N                (*CC).p3.y = RE_FLOAT64TOUINT32(oy2);
N                (*CC).p4.x = RE_FLOAT64TOUINT32(ox1);
N                (*CC).p4.y = RE_FLOAT64TOUINT32(oy1);
N                iReturnCode = 4;
N            }
N        }
N        else
N        {
N            iReturnCode = -1;
N        }
N    }
N    else
N    {
N        iReturnCode = -1;
N    }
N
N    return iReturnCode;
N}
N
N
N/****************************************************************************/
N
Nstatic GA_MATRIX_t RE_SCALEMATRIX(GA_MATRIX_t M, float64_t f64Scale)
N{
N    M.sx  = M.sx  * f64Scale;
N    M.shx = M.shx * f64Scale;
N    M.tx  = M.tx  * f64Scale;
N    M.shy = M.shy * f64Scale;
N    M.sy  = M.sy  * f64Scale;
N    M.ty  = M.ty  * f64Scale;
N    M.w0  = M.w0  * f64Scale;
N    M.w1  = M.w1  * f64Scale;
N    M.w2  = M.w2  * f64Scale;
N
N    return(M);
N}
N
N
N/****************************************************************************/
N
Nstatic float64_t RE_DOUBLEABS(float64_t f64X)
N{
N    float64_t f64Value;
N
N    if (f64X > 0.0)
N    {
N        f64Value = f64X;
N    }
N    else
N    {
N        f64Value = -f64X;
N    }
N
N    return f64Value;
N}
N
N
N/****************************************************************************/
Nstatic float64_t RE_MAXMATRIXELEMENT(GA_MATRIX_t M)
N{
N    float64_t f64X;
N
N    f64X = RE_DOUBLEABS(M.sx);
N
N    if (RE_DOUBLEABS(M.shx) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.shx);
N    }
N    if (RE_DOUBLEABS(M.tx) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.tx);
N    }
N    if (RE_DOUBLEABS(M.shy) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.shy);
N    }
N    if (RE_DOUBLEABS(M.sy) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.sy);
N    }
N    if (RE_DOUBLEABS(M.ty) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.ty);
N    }
N    if (RE_DOUBLEABS(M.w0) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.w0);
N    }
N    if (RE_DOUBLEABS(M.w1) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.w1);
N    }
N    if (RE_DOUBLEABS(M.w2) > f64X)
N    {
N        f64X = RE_DOUBLEABS(M.w2);
N    }
N
N    return(f64X);
N}
N
N
N/****************************************************************************/
N
N#if defined (__KEIL__)
X#if 1L
Nfloat64_t round(float64_t f64Value)
N{
N    return (f64Value >= 0.0) ? floor(f64Value + 0.5) : ceil(f64Value - 0.5);
N}
N#endif
N
N
N/****************************************************************************/
N
Nstatic GA_MATRIX_t RE_BACKWARDMATRIX(GA_SCREENOBJ_t FRCC, uint32_t u32Width, uint32_t u32Height)
N{
N    GA_MATRIX_t im1;
N    float64_t f64Width  = (float64_t)u32Width;
N    float64_t f64Height = (float64_t)u32Height;
N
N    im1.sx=(((FRCC.p4.x-FRCC.p3.x)*FRCC.p1.y+FRCC.p3.x*FRCC.p4.y+(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y-FRCC.p4.y*FRCC.p1.x)*((FRCC.p4.x-FRCC.p3.x)*FRCC.p2.y+FRCC.p3.x*FRCC.p4.y+(FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y-FRCC.p2.x*FRCC.p4.y)*f64Width*(FRCC.p1.y-FRCC.p2.y)) /
N           ((-FRCC.p2.x*(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y+FRCC.p4.y*FRCC.p3.x*FRCC.p3.x*FRCC.p4.x+((FRCC.p2.x*FRCC.p2.x-FRCC.p4.x*FRCC.p4.x)*FRCC.p3.y-2*FRCC.p4.y*FRCC.p4.x*FRCC.p2.x)*FRCC.p3.x-2*FRCC.p2.x*((FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y-0.5*FRCC.p2.x*FRCC.p4.y)*FRCC.p4.x)*FRCC.p1.y*FRCC.p1.y +
N           (FRCC.p1.x*(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y*FRCC.p2.y-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p3.x)*FRCC.p2.y-FRCC.p3.x*FRCC.p3.x*FRCC.p4.y*FRCC.p4.y*FRCC.p1.x+2*FRCC.p2.x*((FRCC.p4.x-FRCC.p2.x)*FRCC.p3.y+FRCC.p4.y*FRCC.p1.x)*FRCC.p4.y*FRCC.p3.x -
N           ((FRCC.p1.x-2*FRCC.p2.x)*FRCC.p4.x+FRCC.p2.x*FRCC.p1.x)*(FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y+2*FRCC.p1.x*FRCC.p2.x*FRCC.p4.y*(FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y-FRCC.p2.x*FRCC.p2.x*FRCC.p4.y*FRCC.p4.y*FRCC.p1.x)*FRCC.p1.y+(-2*FRCC.p4.y*(FRCC.p1.x-0.5*FRCC.p4.x)*FRCC.p3.x*FRCC.p3.x +
N           (-(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y+2*FRCC.p4.y*FRCC.p1.x*FRCC.p1.x)*FRCC.p3.x-FRCC.p4.x*FRCC.p1.x*FRCC.p1.x*FRCC.p4.y)*FRCC.p2.y*FRCC.p2.y+(2*(FRCC.p1.x-0.5*FRCC.p2.x)*FRCC.p4.y*FRCC.p4.y*FRCC.p3.x*FRCC.p3.x-2*((FRCC.p4.x-FRCC.p2.x)*FRCC.p3.y+FRCC.p4.y*FRCC.p1.x)*FRCC.p4.y*FRCC.p1.x*FRCC.p3.x +
N           FRCC.p2.x*(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y-2*FRCC.p1.x*FRCC.p1.x*FRCC.p4.y*(FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y+FRCC.p1.x*FRCC.p1.x*FRCC.p4.y*FRCC.p4.y*FRCC.p2.x)*FRCC.p2.y+FRCC.p4.y*FRCC.p3.y*(FRCC.p1.x-FRCC.p2.x)*(FRCC.p1.x-FRCC.p2.x)*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y));
N    im1.shx=-((FRCC.p1.x-FRCC.p2.x)*((FRCC.p4.y-FRCC.p2.y)*FRCC.p3.x+(FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y+FRCC.p4.x*FRCC.p2.y-FRCC.p2.x*FRCC.p4.y)*((FRCC.p4.y-FRCC.p1.y)*FRCC.p3.x+(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y+FRCC.p4.x*FRCC.p1.y-FRCC.p4.y*FRCC.p1.x)*f64Width) /
N             ((FRCC.p4.y*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p1.y-FRCC.p2.y)*FRCC.p4.x+((2*FRCC.p2.y-FRCC.p1.y)*FRCC.p1.x-FRCC.p2.x*FRCC.p2.y)*FRCC.p4.y*FRCC.p4.y+2*(FRCC.p1.y*FRCC.p2.x*FRCC.p2.y-FRCC.p1.x*FRCC.p2.y*FRCC.p2.y)*FRCC.p4.y+FRCC.p1.y*FRCC.p2.y*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y))*FRCC.p3.x*FRCC.p3.x +
N             ((-(FRCC.p1.y-FRCC.p2.y)*(FRCC.p1.y-FRCC.p2.y)*FRCC.p4.x*FRCC.p4.x+2*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y)*FRCC.p4.x+(FRCC.p1.x-FRCC.p2.x)*(FRCC.p1.x-FRCC.p2.x)*FRCC.p4.y*FRCC.p4.y+2*(FRCC.p2.x*FRCC.p1.x*FRCC.p2.y-FRCC.p1.y*FRCC.p2.x*FRCC.p2.x)*FRCC.p4.y+FRCC.p1.y*FRCC.p1.y*FRCC.p2.x*FRCC.p2.x-FRCC.p2.y*FRCC.p2.y*FRCC.p1.x*FRCC.p1.x)*FRCC.p3.y +
N             2*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y))*FRCC.p3.x+((FRCC.p1.x*FRCC.p1.y-2*FRCC.p2.x*(FRCC.p1.y-0.5*FRCC.p2.y))*FRCC.p4.x*FRCC.p4.x+(-(FRCC.p1.x-FRCC.p2.x)*(FRCC.p1.x-FRCC.p2.x)*FRCC.p4.y +
N             2*FRCC.p1.y*FRCC.p2.x*FRCC.p2.x-2*FRCC.p2.x*FRCC.p1.x*FRCC.p2.y)*FRCC.p4.x+FRCC.p1.x*FRCC.p2.x*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y))*FRCC.p3.y*FRCC.p3.y-2*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y)*FRCC.p3.y +
N             (FRCC.p2.x*FRCC.p4.y-FRCC.p4.x*FRCC.p2.y)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y));
N    im1.tx=(((FRCC.p3.y-FRCC.p4.y)*FRCC.p1.x+(FRCC.p4.x-FRCC.p3.x)*FRCC.p1.y+FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*f64Width*((FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x+(FRCC.p4.x-FRCC.p3.x)*FRCC.p2.y+FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.y*FRCC.p1.x-FRCC.p2.x*FRCC.p1.y)) /
N           ((FRCC.p2.y*(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x+((2*FRCC.p4.y-FRCC.p3.y)*FRCC.p3.x-FRCC.p4.y*FRCC.p4.x)*FRCC.p2.y*FRCC.p2.y+2*(FRCC.p4.y*FRCC.p4.x*FRCC.p3.y-FRCC.p4.y*FRCC.p4.y*FRCC.p3.x)*FRCC.p2.y+FRCC.p4.y*FRCC.p3.y*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y))*FRCC.p1.x*FRCC.p1.x +
N           ((-(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x*FRCC.p2.x-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.y-FRCC.p4.y)*FRCC.p2.x+(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y*FRCC.p2.y+2*(FRCC.p4.y*FRCC.p4.x*FRCC.p3.x-FRCC.p4.x*FRCC.p4.x*FRCC.p3.y)*FRCC.p2.y-FRCC.p3.x*FRCC.p3.x*FRCC.p4.y*FRCC.p4.y +
N           FRCC.p4.x*FRCC.p4.x*FRCC.p3.y*FRCC.p3.y)*FRCC.p1.y+2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x))*FRCC.p1.x+((FRCC.p3.y*FRCC.p3.x-2*(FRCC.p3.y-0.5*FRCC.p4.y)*FRCC.p4.x)*FRCC.p2.x*FRCC.p2.x +
N           (-(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y-2*FRCC.p4.y*FRCC.p4.x*FRCC.p3.x+2*FRCC.p4.x*FRCC.p4.x*FRCC.p3.y)*FRCC.p2.x+FRCC.p4.x*FRCC.p3.x*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y))*FRCC.p1.y*FRCC.p1.y-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x)*FRCC.p1.y +
N           (FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.x*FRCC.p4.y-FRCC.p4.x*FRCC.p2.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x));
N    im1.shy=-(((FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x+(FRCC.p4.x-FRCC.p3.x)*FRCC.p2.y+FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*((FRCC.p3.y-FRCC.p1.y)*FRCC.p2.x+(FRCC.p1.x-FRCC.p3.x)*FRCC.p2.y-FRCC.p3.y*FRCC.p1.x+FRCC.p3.x*FRCC.p1.y)*f64Height*(FRCC.p1.y-FRCC.p4.y)) /
N             ((FRCC.p3.y*(FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*FRCC.p3.x+((2*FRCC.p4.x-FRCC.p1.x)*FRCC.p1.y-FRCC.p4.y*FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y+2*(FRCC.p1.y*FRCC.p1.x*FRCC.p4.y-FRCC.p4.x*FRCC.p1.y*FRCC.p1.y)*FRCC.p3.y+FRCC.p1.y*FRCC.p1.y*FRCC.p4.y*FRCC.p4.x-FRCC.p1.y*FRCC.p4.y*FRCC.p4.y*FRCC.p1.x)*FRCC.p2.x*FRCC.p2.x+
N             ((-(FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*FRCC.p3.x*FRCC.p3.x-2*(FRCC.p1.y-FRCC.p3.y)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*FRCC.p3.x+(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y+2*(FRCC.p4.x*FRCC.p1.y*FRCC.p1.x-FRCC.p4.y*FRCC.p1.x*FRCC.p1.x)*FRCC.p3.y-FRCC.p4.x*FRCC.p4.x*FRCC.p1.y*FRCC.p1.y +
N             FRCC.p4.y*FRCC.p4.y*FRCC.p1.x*FRCC.p1.x)*FRCC.p2.y+2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p1.y-FRCC.p3.y)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y))*FRCC.p2.x+((FRCC.p1.x*FRCC.p1.y-2*FRCC.p4.y*(FRCC.p1.x-0.5*FRCC.p4.x))*FRCC.p3.x*FRCC.p3.x +
N             (-(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y-2*FRCC.p4.x*FRCC.p1.y*FRCC.p1.x+2*FRCC.p4.y*FRCC.p1.x*FRCC.p1.x)*FRCC.p3.x-FRCC.p4.x*FRCC.p1.x*FRCC.p1.x*FRCC.p4.y+FRCC.p4.x*FRCC.p4.x*FRCC.p1.y*FRCC.p1.x)*FRCC.p2.y*FRCC.p2.y-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p1.x-FRCC.p3.x)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*FRCC.p2.y +
N             (FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*(FRCC.p3.y*FRCC.p1.x-FRCC.p3.x*FRCC.p1.y));
N    im1.sy=((FRCC.p1.x-FRCC.p4.x)*((FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x+(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x-FRCC.p3.x*(FRCC.p2.y-FRCC.p4.y))*f64Height*((FRCC.p2.y-FRCC.p3.y)*FRCC.p1.x+(FRCC.p3.y-FRCC.p1.y)*FRCC.p2.x+FRCC.p3.x*(FRCC.p1.y-FRCC.p2.y))) /
N           ((-FRCC.p4.y*(FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x+FRCC.p2.y*(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x-((FRCC.p3.y-2*FRCC.p4.y)*FRCC.p2.y+FRCC.p4.y*FRCC.p3.y)*FRCC.p3.x*(FRCC.p2.y-FRCC.p4.y))*FRCC.p1.x*FRCC.p1.x+(FRCC.p1.y*(FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x*FRCC.p4.x +
N           2*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p4.x-FRCC.p1.y*(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x*FRCC.p2.x-2*FRCC.p3.x*FRCC.p4.y*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p2.x +
N           FRCC.p3.x*FRCC.p3.x*(FRCC.p2.y-FRCC.p4.y)*((FRCC.p1.y-2*FRCC.p4.y)*FRCC.p2.y+FRCC.p1.y*FRCC.p4.y))*FRCC.p1.x+(-(FRCC.p1.y-FRCC.p3.y)*((FRCC.p1.y+FRCC.p3.y)*FRCC.p2.y-2*FRCC.p1.y*FRCC.p3.y)*FRCC.p2.x-FRCC.p3.x*FRCC.p3.y*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p1.y-FRCC.p2.y))*FRCC.p4.x*FRCC.p4.x +
N           (((2*FRCC.p1.y-FRCC.p4.y)*FRCC.p3.y*FRCC.p3.y-2*FRCC.p1.y*FRCC.p1.y*FRCC.p3.y+FRCC.p1.y*FRCC.p1.y*FRCC.p4.y)*FRCC.p2.x*FRCC.p2.x+2*FRCC.p1.y*FRCC.p3.x*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p2.x+FRCC.p4.y*FRCC.p3.x*FRCC.p3.x*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p1.y-FRCC.p2.y))*FRCC.p4.x+FRCC.p2.x*FRCC.p3.x*(FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x));
N    im1.ty=-(((FRCC.p2.y-FRCC.p3.y)*FRCC.p1.x+(FRCC.p3.x-FRCC.p2.x)*FRCC.p1.y+FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x)*(FRCC.p4.y*FRCC.p1.x-FRCC.p4.x*FRCC.p1.y)*((FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x+(FRCC.p3.x-FRCC.p2.x)*FRCC.p4.y+FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x)*f64Height) /
N            ((-FRCC.p4.y*(FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x+(FRCC.p2.x*FRCC.p2.y-2*(FRCC.p2.y-0.5*FRCC.p3.y)*FRCC.p3.x)*FRCC.p4.y*FRCC.p4.y+2*(FRCC.p2.y*FRCC.p2.y*FRCC.p3.x-FRCC.p3.y*FRCC.p2.y*FRCC.p2.x)*FRCC.p4.y+FRCC.p2.y*FRCC.p3.y*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x))*FRCC.p1.x*FRCC.p1.x +
N            (((FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x*FRCC.p4.x+2*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x)*FRCC.p4.x-(FRCC.p2.x-FRCC.p3.x)*(FRCC.p2.x-FRCC.p3.x)*FRCC.p4.y*FRCC.p4.y+2*(FRCC.p2.x*FRCC.p2.x*FRCC.p3.y-FRCC.p3.x*FRCC.p2.y*FRCC.p2.x)*FRCC.p4.y-FRCC.p2.x*FRCC.p2.x*FRCC.p3.y*FRCC.p3.y +
N            FRCC.p2.y*FRCC.p2.y*FRCC.p3.x*FRCC.p3.x)*FRCC.p1.y+2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x))*FRCC.p1.x+(((2*FRCC.p3.y-FRCC.p2.y)*FRCC.p2.x-FRCC.p3.y*FRCC.p3.x)*FRCC.p4.x*FRCC.p4.x+((FRCC.p2.x-FRCC.p3.x)*(FRCC.p2.x-FRCC.p3.x)*FRCC.p4.y +
N            2*FRCC.p3.x*FRCC.p2.y*FRCC.p2.x-2*FRCC.p2.x*FRCC.p2.x*FRCC.p3.y)*FRCC.p4.x+FRCC.p2.x*FRCC.p3.x*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x))*FRCC.p1.y*FRCC.p1.y-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x)*FRCC.p1.y+(FRCC.p3.x*FRCC.p4.y -
N            FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.x*FRCC.p4.y-FRCC.p4.x*FRCC.p2.y)*(FRCC.p2.x*FRCC.p3.y-FRCC.p2.y*FRCC.p3.x));
N    im1.w0=(((FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y+(FRCC.p2.x-FRCC.p4.x)*(FRCC.p2.x-2*FRCC.p3.x+FRCC.p4.x)*FRCC.p3.y-(FRCC.p2.x-FRCC.p3.x)*(FRCC.p2.x-FRCC.p3.x)*FRCC.p4.y)*FRCC.p1.y*FRCC.p1.y+(-(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y*FRCC.p2.y-2*(FRCC.p3.y-FRCC.p4.y)*(FRCC.p2.x-FRCC.p4.x) *
N           (FRCC.p1.x-FRCC.p3.x)*FRCC.p2.y+2*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p1.x-0.5*FRCC.p2.x-0.5*FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y-2*FRCC.p4.y*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p3.x)*FRCC.p3.y+(FRCC.p2.x-FRCC.p3.x)*(FRCC.p2.x-FRCC.p3.x)*FRCC.p4.y*FRCC.p4.y)*FRCC.p1.y +
N           ((FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y-(FRCC.p1.x-FRCC.p3.x)*FRCC.p4.y*(FRCC.p1.x-2*FRCC.p4.x+FRCC.p3.x))*FRCC.p2.y*FRCC.p2.y+(-(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y+2*FRCC.p4.y*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p3.x)*FRCC.p3.y +
N           FRCC.p4.y*FRCC.p4.y*(FRCC.p1.x-FRCC.p3.x)*(FRCC.p1.x-2*FRCC.p2.x+FRCC.p3.x))*FRCC.p2.y+FRCC.p3.y*FRCC.p4.y*(FRCC.p1.x-FRCC.p2.x)*(FRCC.p1.x-FRCC.p2.x)*(FRCC.p3.y-FRCC.p4.y))/((-FRCC.p2.x*(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y+((FRCC.p3.x-2*FRCC.p4.x)*FRCC.p2.x+FRCC.p3.x*FRCC.p4.x)*(FRCC.p2.x-FRCC.p4.x)*FRCC.p3.y+FRCC.p4.x*FRCC.p4.y*(FRCC.p2.x-FRCC.p3.x)*(FRCC.p2.x-FRCC.p3.x))*FRCC.p1.y*FRCC.p1.y+(FRCC.p1.x*(FRCC.p3.x-FRCC.p4.x)*(FRCC.p3.x-FRCC.p4.x)*FRCC.p2.y*FRCC.p2.y-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y)*(FRCC.p2.x-FRCC.p4.x) *
N           (FRCC.p1.x-FRCC.p3.x)*FRCC.p2.y-(FRCC.p2.x-FRCC.p4.x)*((FRCC.p2.x+FRCC.p4.x)*FRCC.p1.x-2*FRCC.p2.x*FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y+2*FRCC.p2.x*FRCC.p4.y*(FRCC.p2.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p3.x)*FRCC.p3.y-FRCC.p4.y*FRCC.p4.y*FRCC.p1.x*(FRCC.p2.x-FRCC.p3.x)*(FRCC.p2.x-FRCC.p3.x))*FRCC.p1.y +
N           (-FRCC.p3.x*(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y+2*FRCC.p4.y*((FRCC.p3.x-0.5*FRCC.p4.x)*FRCC.p1.x-0.5*FRCC.p3.x*FRCC.p4.x)*(FRCC.p1.x-FRCC.p3.x))*FRCC.p2.y*FRCC.p2.y+(FRCC.p2.x*(FRCC.p1.x-FRCC.p4.x)*(FRCC.p1.x-FRCC.p4.x)*FRCC.p3.y*FRCC.p3.y-2*FRCC.p1.x*FRCC.p4.y*(FRCC.p2.x-FRCC.p4.x) *
N           (FRCC.p1.x-FRCC.p3.x)*FRCC.p3.y+FRCC.p4.y*FRCC.p4.y*((FRCC.p2.x-2*FRCC.p3.x)*FRCC.p1.x+FRCC.p2.x*FRCC.p3.x)*(FRCC.p1.x-FRCC.p3.x))*FRCC.p2.y+FRCC.p4.y*FRCC.p3.y*(FRCC.p1.x-FRCC.p2.x)*(FRCC.p1.x-FRCC.p2.x)*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y));
N    im1.w1=((-(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x-(FRCC.p2.y-FRCC.p4.y)*(FRCC.p2.y-2*FRCC.p3.y+FRCC.p4.y)*FRCC.p3.x+FRCC.p4.x*(FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y))*FRCC.p1.x*FRCC.p1.x+((FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x*FRCC.p2.x+2*(FRCC.p3.x-FRCC.p4.x) *
N           (FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p2.x-2*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-0.5*FRCC.p2.y-0.5*FRCC.p4.y)*FRCC.p3.x*FRCC.p3.x+2*FRCC.p4.x*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p3.x -
N           (FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x*FRCC.p4.x)*FRCC.p1.x+(-(FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*FRCC.p3.x+FRCC.p4.x*(FRCC.p1.y-FRCC.p3.y)*(FRCC.p1.y-2*FRCC.p4.y+FRCC.p3.y))*FRCC.p2.x*FRCC.p2.x+((FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*FRCC.p3.x*FRCC.p3.x-2*FRCC.p4.x*(FRCC.p2.y-FRCC.p4.y) *
N           (FRCC.p1.y-FRCC.p3.y)*FRCC.p3.x-FRCC.p4.x*FRCC.p4.x*(FRCC.p1.y-FRCC.p3.y)*(FRCC.p1.y-2*FRCC.p2.y+FRCC.p3.y))*FRCC.p2.x-FRCC.p3.x*FRCC.p4.x*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p3.x-FRCC.p4.x))/((FRCC.p2.y*(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x-((FRCC.p3.y-2*FRCC.p4.y)*FRCC.p2.y+FRCC.p4.y*FRCC.p3.y)*(FRCC.p2.y-FRCC.p4.y)*FRCC.p3.x-FRCC.p4.y*(FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y)*FRCC.p4.x)*FRCC.p1.x*FRCC.p1.x+(-FRCC.p1.y*(FRCC.p3.y-FRCC.p4.y)*(FRCC.p3.y-FRCC.p4.y)*FRCC.p2.x*FRCC.p2.x-2*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y) *
N           (FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p2.x+((FRCC.p2.y+FRCC.p4.y)*FRCC.p1.y-2*FRCC.p2.y*FRCC.p4.y)*(FRCC.p2.y-FRCC.p4.y)*FRCC.p3.x*FRCC.p3.x-2*FRCC.p2.y*FRCC.p4.x*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p3.x+FRCC.p1.y*FRCC.p4.x*FRCC.p4.x *
N           (FRCC.p2.y-FRCC.p3.y)*(FRCC.p2.y-FRCC.p3.y))*FRCC.p1.x+(FRCC.p3.y*(FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*FRCC.p3.x-2*((FRCC.p3.y-0.5*FRCC.p4.y)*FRCC.p1.y-0.5*FRCC.p4.y*FRCC.p3.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p4.x)*FRCC.p2.x*FRCC.p2.x+(-FRCC.p2.y*(FRCC.p1.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p4.y)*FRCC.p3.x*FRCC.p3.x +
N           2*FRCC.p1.y*FRCC.p4.x*(FRCC.p2.y-FRCC.p4.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p3.x-((FRCC.p2.y-2*FRCC.p3.y)*FRCC.p1.y+FRCC.p3.y*FRCC.p2.y)*(FRCC.p1.y-FRCC.p3.y)*FRCC.p4.x*FRCC.p4.x)*FRCC.p2.x+FRCC.p3.x*FRCC.p4.x*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p1.y-FRCC.p2.y)*(FRCC.p3.x*FRCC.p4.y-FRCC.p4.x*FRCC.p3.y));
N    im1.w2=1.0;
N
N    im1.sx  = im1.sx  - im1.tx*im1.w0;
N    im1.shx = im1.shx - im1.tx*im1.w1;
N    im1.tx  = 0.0;
N
N    im1.shy = im1.shy - im1.ty*im1.w0;
N    im1.sy  = im1.sy  - im1.ty*im1.w1;
N    im1.ty  = 0.0;
N
N    im1 = RE_SCALEMATRIX(im1, 2097151.0/RE_MAXMATRIXELEMENT(im1));
N
N    im1.sx  = round(im1.sx);
N    im1.shx = round(im1.shx);
N    im1.shy = round(im1.shy);
N    im1.sy  = round(im1.sy);
N    im1.w0  = round(im1.w0);
N    im1.w1  = round(im1.w1);
N    im1.w2  = round(im1.w2);
N
N    return(im1);
N}
N
N
N/****************************************************************************/
N
N/* calculate truncated double */
Nstatic float64_t RE_FLOAT64TRUNC(float64_t x)
N{
N    return ((float64_t)((long long)(x)));
N}
N
N
N/****************************************************************************/
N
Nstatic void RE_TRANSLATEOBJECT(int32_t * offset, GA_SCREENOBJ_t * FRCC, float64_t * original)
N{
N    float64_t minX;
N    float64_t minY;
N    uint32_t  i;
N
N    minX = original[4*0 + 0];
N    for (i=1; i<4; i++)
N    {
N        if (original[4*i + 0] < minX)
N        {
N            minX = original[4*i + 0];
N        }
N    }
N
N    minY = original[4*0 + 1];
N    for (i=1; i<4; i++)
N    {
N        if (original[4*i + 1] < minY)
N        {
N            minY = original[4*i + 1];
N        }
N    }
N
N    offset[0] = (int32_t)RE_FLOAT64TRUNC(RE_FLOAT64ROUND(minX*4294967296.0)/4294967296);
N    offset[1] = (int32_t)RE_FLOAT64TRUNC(RE_FLOAT64ROUND(minY*4294967296.0)/4294967296);
N
N    FRCC->p1.x = original[0]  - offset[0];
N    FRCC->p1.y = original[1]  - offset[1];
N    FRCC->p2.x = original[4]  - offset[0];
N    FRCC->p2.y = original[5]  - offset[1];
N    FRCC->p3.x = original[8]  - offset[0];
N    FRCC->p3.y = original[9]  - offset[1];
N    FRCC->p4.x = original[12] - offset[0];
N    FRCC->p4.y = original[13] - offset[1];
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(rot_mem_st* pstMem, 
N                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
N                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
N                                                                 rot_frccr_st* pstCoord, float64_t f64Angle)
N#else
Sstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(rot_mem_st* pstMem, 
S                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
S                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
S                                                                 rot_frccr_st* pstCoord, int16_t i16Angle)
N#endif
N{
N#ifdef GA_USE_MATH_LIB
N    float64_t f64AngRad;
N    float64_t f64Sin,f64Cos;
N#else
S    int32_t   i32Sin, i32Cos;
N#endif  
N    rot_frccr_st stCoordlocal;
N    uint16_t     u16PixelOffset;
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    u16PixelOffset = 1;
N    if( (pstMem->u16SrcHeight == 1) && (pstMem->u16SrcWidth == 1) )
N    {
N        u16PixelOffset = 0;
N    }
N
N#ifdef GA_USE_MATH_LIB
N
N    /* Angle Conversion to radians */
N    f64AngRad = (2.0 * GA_CONST_PI * f64Angle)/360.0 ;
X    f64AngRad = (2.0 * 3.1415926535897932384626433 * f64Angle)/360.0 ;
N    
N    /* Calculate only once Sine and Cosine */
N    f64Sin = ROT_SIN(f64AngRad);
X    f64Sin = ((RE_FLOAT64ROUND((sin(f64AngRad))*4294967296.0)/4294967296));
N    f64Cos = ROT_COS(f64AngRad);
X    f64Cos = ((RE_FLOAT64ROUND((cos(f64AngRad))*4294967296.0)/4294967296));
N
N    /* Forward Rotated Coordinates Calculation */
N    /* From Source Img. point (0, 0) */
N    stCoordlocal.u16X1 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y1 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N    /* From Source Img. point (0, Image_Height-PixelOffset) */
N    stCoordlocal.u16X2 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY)* f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y2 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N    /* From Source Img. point (Image_Width-PixelOffset, Image_Height-PixelOffset) */
N    stCoordlocal.u16X3 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset)  - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y3 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N    /* From Source Img. point (Image_Width-PixelOffset, 0) */
N    stCoordlocal.u16X4 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y4 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N#else
S   
S    /* Calculate only once Sine and Cosine */
S    i32Sin = ROT_SIN(i16Angle);
S    i32Cos = ROT_COS(i16Angle);
S   
S    /* Forward Rotated Coordinates Calculation */
S    /* From Source Img. point (0, 0) */
S    stCoordlocal.u16X1 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S    
S    stCoordlocal.u16Y1 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S    
S    /* From Source Img. point (0, Image_Height-PixelOffset) */
S    stCoordlocal.u16X2 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY)* i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S
S    stCoordlocal.u16Y2 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S
S    /* From Source Img. point (Image_Width-PixelOffset, Image_Height-PixelOffset) */
S    stCoordlocal.u16X3 = (uint32_t)(((((16U * (pstMem->u16SrcWidth-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY) * i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S
S    stCoordlocal.u16Y3 = (uint32_t)(((((16U * (pstMem->u16SrcWidth-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S
S    /* From Source Img. point (Image_Width-PixelOffset, 0) */
S    stCoordlocal.u16X4 = (uint32_t)(((((16U * (pstMem->u16SrcWidth-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S
S    stCoordlocal.u16Y4 = (uint32_t)(((((16U * (pstMem->u16SrcWidth-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S
N#endif /* GA_USE_MATH_LIB */
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    /* save calculated coordinates for later usage in a glocal array: */
N    vSaveGlFwRotCornerCoord(&stCoordlocal);
N
N    /* Coordinate Sorting */
N#ifdef GA_USE_MATH_LIB    
N    if(f64Angle < 90.0)
N#else
S    if(i16Angle < 900U)
N#endif
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X1;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y1;
N        pstCoord -> u16X2 = stCoordlocal.u16X2;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y2;
N        pstCoord -> u16X3 = stCoordlocal.u16X3;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y3;
N        pstCoord -> u16X4 = stCoordlocal.u16X4;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y4;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR1;
N    }
N#ifdef GA_USE_MATH_LIB        
N    else if(f64Angle < 180.0)
N#else
S    else if(i16Angle < 1800U)
N#endif
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X2;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y2;
N        pstCoord -> u16X2 = stCoordlocal.u16X3;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y3;
N        pstCoord -> u16X3 = stCoordlocal.u16X4;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y4;
N        pstCoord -> u16X4 = stCoordlocal.u16X1;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y1;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR4;
N    }
N#ifdef GA_USE_MATH_LIB     
N    else if (f64Angle < 270.0)
N#else
S    else if (i16Angle < 2700U)
N#endif
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X3;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y3;
N        pstCoord -> u16X2 = stCoordlocal.u16X4;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y4;
N        pstCoord -> u16X3 = stCoordlocal.u16X1;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y1;
N        pstCoord -> u16X4 = stCoordlocal.u16X2;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y2;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR3;
N    }
N    else
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X4;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y4;
N        pstCoord -> u16X2 = stCoordlocal.u16X1;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y1;
N        pstCoord -> u16X3 = stCoordlocal.u16X2;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y2;
N        pstCoord -> u16X4 = stCoordlocal.u16X3;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y3;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR2;
N    }
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(rot_mem_part_st* pstMem, 
N                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
N                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
N                                                                 rot_frccr_st* pstCoord, float64_t f64Angle)
N#else
Sstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(rot_mem_part_st* pstMem, 
S                                                                 int16_t i16RotCentX, int16_t i16RotCentY, 
S                                                                 int16_t i16OffsetX, int16_t i16OffsetY, 
S                                                                 rot_frccr_st* pstCoord, int16_t i16Angle)
N#endif
N
N{
N#ifdef GA_USE_MATH_LIB
N    float64_t f64AngRad;
N    float64_t f64Sin,f64Cos;
N#else
S    int32_t   i32Sin, i32Cos;
N#endif  
N    rot_frccr_st stCoordlocal;
N    uint16_t     u16PixelOffset;
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    u16PixelOffset = 1;
N    if( (pstMem->u16SrcHeight == 1) && (pstMem->u16DotCnt == 1) )
N    {
N        u16PixelOffset = 0;
N    }
N
N#ifdef GA_USE_MATH_LIB
N
N    /* Angle Conversion to radians */
N    f64AngRad = (2 * GA_CONST_PI * f64Angle)/360.0 ;
X    f64AngRad = (2 * 3.1415926535897932384626433 * f64Angle)/360.0 ;
N
N    /* Calculate only once Sine and Cosine */
N    f64Sin = ROT_SIN(f64AngRad);
X    f64Sin = ((RE_FLOAT64ROUND((sin(f64AngRad))*4294967296.0)/4294967296));
N    f64Cos = ROT_COS(f64AngRad);
X    f64Cos = ((RE_FLOAT64ROUND((cos(f64AngRad))*4294967296.0)/4294967296));
N
N    /* Forward Rotated Coordinates Calculation */
N    /* From Source Img. point (0, 0) */
N    stCoordlocal.u16X1 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N    
N    stCoordlocal.u16Y1 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N    
N    /* From Source Img. point (0, Image_Height-PixelOffset) */
N    stCoordlocal.u16X2 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY)* f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y2 = RE_FLOAT64TOUINT32((((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N    /* From Source Img. point (DotCnt-PixelOffset, Image_Height-PixelOffset) */
N    stCoordlocal.u16X3 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16DotCnt-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y3 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16DotCnt-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N    /* From Source Img. point (DotCnt-1, 0) */
N    stCoordlocal.u16X4 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16DotCnt-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Cos)
N                                   - ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Sin))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetX));
N
N    stCoordlocal.u16Y4 = RE_FLOAT64TOUINT32((((16.0 * (float64_t)(pstMem->u16DotCnt-u16PixelOffset) - (float64_t)f32SubResCPos * (float64_t)i16RotCentX) * f64Sin)
N                                   + ((16.0 * 0.0 - (float64_t)f32SubResCPos * (float64_t)i16RotCentY) * f64Cos))
N                                   + ((float64_t)f32SubResPPos * (float64_t)i16OffsetY));
N
N#else
S   
S    /* Calculate only once Sine and Cosine */
S    i32Sin = ROT_SIN(i16Angle);
S    i32Cos = ROT_COS(i16Angle);
S   
S    /* Forward Rotated Coordinates Calculation */
S    /* From Source Img. point (0, 0) */
S    stCoordlocal.u16X1 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S    
S    stCoordlocal.u16Y1 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S    
S    /* From Source Img. point (0, Image_Height-PixelOffset) */
S    stCoordlocal.u16X2 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY)* i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S
S    stCoordlocal.u16Y2 = (uint32_t)(((((16U * 0U - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S
S    /* From Source Img. point (DotCnt-PixelOffset, Image_Height-PixelOffset) */
S    stCoordlocal.u16X3 = (uint32_t)(((((16U * (pstMem->u16DotCnt-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY) * i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S
S    stCoordlocal.u16Y3 = (uint32_t)(((((16U * (pstMem->u16DotCnt-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * (pstMem->u16SrcHeight-u16PixelOffset) - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S
S    /* From Source Img. point (DotCnt-PixelOffset, 0) */
S    stCoordlocal.u16X4 = (uint32_t)(((((16U * (pstMem->u16DotCnt-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Cos)
S                                    - ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Sin))
S                                    + (u32SubResPPos * i16OffsetX * 65536U)) / 65536U);
S
S    stCoordlocal.u16Y4 = (uint32_t)(((((16U * (pstMem->u16DotCnt-u16PixelOffset) - u32SubResCPos * i16RotCentX) * i32Sin)
S                                    + ((16U * 0U - u32SubResCPos * i16RotCentY) * i32Cos))
S                                    + (u32SubResPPos * i16OffsetY * 65536U)) / 65536U);
S    
N#endif
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    /* save calculated coordinates for later usage in a glocal array: */
N    vSaveGlFwRotCornerCoord(&stCoordlocal);
N
N    /* Coordinate Sorting */
N#ifdef GA_USE_MATH_LIB
N    if(f64Angle < 90.0)
N#else
S    if(i16Angle < 900U)
N#endif
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X1;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y1;
N        pstCoord -> u16X2 = stCoordlocal.u16X2;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y2;
N        pstCoord -> u16X3 = stCoordlocal.u16X3;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y3;
N        pstCoord -> u16X4 = stCoordlocal.u16X4;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y4;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR1;
N    }
N#ifdef GA_USE_MATH_LIB    
N    else if(f64Angle < 180.0)
N#else
S    else if(i16Angle < 1800U)
N#endif
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X2;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y2;
N        pstCoord -> u16X2 = stCoordlocal.u16X3;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y3;
N        pstCoord -> u16X3 = stCoordlocal.u16X4;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y4;
N        pstCoord -> u16X4 = stCoordlocal.u16X1;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y1;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR4;
N    }
N#ifdef GA_USE_MATH_LIB    
N    else if (f64Angle < 270.0)
N#else
S    else if (i16Angle < 2700U)
N#endif
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X3;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y3;
N        pstCoord -> u16X2 = stCoordlocal.u16X4;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y4;
N        pstCoord -> u16X3 = stCoordlocal.u16X1;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y1;
N        pstCoord -> u16X4 = stCoordlocal.u16X2;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y2;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR3;
N    }
N    else
N    {
N        pstCoord -> u16X1 = stCoordlocal.u16X4;
N        pstCoord -> u16Y1 = stCoordlocal.u16Y4;
N        pstCoord -> u16X2 = stCoordlocal.u16X1;
N        pstCoord -> u16Y2 = stCoordlocal.u16Y1;
N        pstCoord -> u16X3 = stCoordlocal.u16X2;
N        pstCoord -> u16Y3 = stCoordlocal.u16Y2;
N        pstCoord -> u16X4 = stCoordlocal.u16X3;
N        pstCoord -> u16Y4 = stCoordlocal.u16Y3;
N
N        pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR2;
N    }
N}
N
N
N/****************************************************************************/
N
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_Shear(rot_mem_st* pstMem, 
N                                                            int16_t i16OffsetX, int16_t i16OffsetY, 
N                                                            float64_t f64FactorX, float64_t f64FactorY, 
N                                                            rot_frccr_st* pstCoord)
N{
N    rot_frccr_st   stCoordlocal;
N    GA_SCREENOBJ_t sortedFRCC;
N    uint16_t       u16PixelOffset;
N
N    u16PixelOffset = 1;
N    if( (pstMem->u16SrcWidth == 1) && (pstMem->u16SrcHeight == 1) )
N    {
N        u16PixelOffset = 0;
N    }
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N    /* Forward Rotated Coordinates Calculation */
N    stCoordlocal.u16X1 = RE_FLOAT64TOUINT32((float64_t)f32SubResPPos * (float64_t)i16OffsetX);
N    stCoordlocal.u16Y1 = RE_FLOAT64TOUINT32((float64_t)f32SubResPPos * (float64_t)i16OffsetY);
N
N    stCoordlocal.u16X2 = RE_FLOAT64TOUINT32((float64_t)stCoordlocal.u16X1 + (16.0 * (f64FactorX * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset))));
N    stCoordlocal.u16Y2 = stCoordlocal.u16Y1 + 16U * (pstMem->u16SrcHeight-u16PixelOffset);
N
N    stCoordlocal.u16X3 = stCoordlocal.u16X2 + 16U * (pstMem->u16SrcWidth-u16PixelOffset);
N    stCoordlocal.u16Y3 = RE_FLOAT64TOUINT32((float64_t)stCoordlocal.u16Y2 + (16.0 * (f64FactorY * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset))));
N
N    stCoordlocal.u16X4 = stCoordlocal.u16X1 + 16U * (pstMem->u16SrcWidth-u16PixelOffset);
N    stCoordlocal.u16Y4 = RE_FLOAT64TOUINT32((float64_t)stCoordlocal.u16Y1 + (16.0 * (f64FactorY * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset))));
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N    
N    /* save calculated coordinates for later usage in a glocal array: */
N    vSaveGlFwRotCornerCoord(&stCoordlocal);
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1847    /* MISRA 2004 Rule 10.3 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N    /* Coordinate Sorting */
N    sortedFRCC.p1.x = (float64_t)(int16_t)(stCoordlocal.u16X1 + 0xFFFFU + 0x1U);
N    sortedFRCC.p1.y = (float64_t)(int16_t)(stCoordlocal.u16Y1 + 0xFFFFU + 0x1U);
N    sortedFRCC.p2.x = (float64_t)(int16_t)(stCoordlocal.u16X2 + 0xFFFFU + 0x1U);
N    sortedFRCC.p2.y = (float64_t)(int16_t)(stCoordlocal.u16Y2 + 0xFFFFU + 0x1U);
N    sortedFRCC.p3.x = (float64_t)(int16_t)(stCoordlocal.u16X3 + 0xFFFFU + 0x1U);
N    sortedFRCC.p3.y = (float64_t)(int16_t)(stCoordlocal.u16Y3 + 0xFFFFU + 0x1U);
N    sortedFRCC.p4.x = (float64_t)(int16_t)(stCoordlocal.u16X4 + 0xFFFFU + 0x1U);
N    sortedFRCC.p4.y = (float64_t)(int16_t)(stCoordlocal.u16Y4 + 0xFFFFU + 0x1U);
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N	/* sort corners as required by RE and get start corner */
N    pstCoord -> u8ScrAddrPos  = (uint8_t)RE_SORTCORNERS(&sortedFRCC) - 1;
N
N    pstCoord->u16X1 = (uint16_t)sortedFRCC.p1.x;
N    pstCoord->u16Y1 = (uint16_t)sortedFRCC.p1.y;
N    pstCoord->u16X2 = (uint16_t)sortedFRCC.p2.x;
N    pstCoord->u16Y2 = (uint16_t)sortedFRCC.p2.y;
N	pstCoord->u16X3 = (uint16_t)sortedFRCC.p3.x;
N	pstCoord->u16Y3 = (uint16_t)sortedFRCC.p3.y;
N    pstCoord->u16X4 = (uint16_t)sortedFRCC.p4.x;
N    pstCoord->u16Y4 = (uint16_t)sortedFRCC.p4.y;
N    
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(rot_mem_st* pstMem,
N                                                            int16_t i16OffsetX, int16_t i16OffsetY,
N                                                            float64_t f64FactorX, float64_t f64FactorY,
N                                                            rot_scaleAlign_e eAlignment, rot_frccr_st* pstCoord)
N#else
Sstatic void vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(rot_mem_st* pstMem,
S                                                            int16_t i16OffsetX, int16_t i16OffsetY,
S                                                            int32_t i32FactorX, int32_t i32FactorY,
S                                                            rot_scaleAlign_e eAlignment, rot_frccr_st* pstCoord)
N#endif
N{
N    rot_frccr_st stCoordlocal;
N    uint32_t     u32DiffX, u32DiffY;
N    uint16_t     u16CorrectionX, u16CorrectionY;
N    uint16_t     u16PixelOffset;
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N    u16PixelOffset = 1;
N    if( (pstMem->u16SrcHeight == 1) && (pstMem->u16SrcWidth == 1) )
N    {
N        u16PixelOffset = 0;
N    }
N
N#ifdef GA_USE_MATH_LIB
N
N    /* Forward Rotated Coordinates Calculation */
N    stCoordlocal.u16X1 = RE_FLOAT64TOUINT32((float64_t)f32SubResPPos * (float64_t)i16OffsetX);
N    stCoordlocal.u16Y1 = RE_FLOAT64TOUINT32((float64_t)f32SubResPPos * (float64_t)i16OffsetY);
N
N    stCoordlocal.u16X2 = stCoordlocal.u16X1;
N    stCoordlocal.u16Y2 = RE_FLOAT64TOUINT32((float64_t)stCoordlocal.u16Y1 + (16.0 * (float64_t)(pstMem->u16SrcHeight-u16PixelOffset) * f64FactorY));
N
N    stCoordlocal.u16X3 = RE_FLOAT64TOUINT32((float64_t)stCoordlocal.u16X2 + (16.0 * f64FactorX * (float64_t)(pstMem->u16SrcWidth-u16PixelOffset)));
N    stCoordlocal.u16Y3 = stCoordlocal.u16Y2;
N
N    stCoordlocal.u16X4 = stCoordlocal.u16X3;
N    stCoordlocal.u16Y4 = stCoordlocal.u16Y1;
N
N    /* 1 pixel value is needed to later get the correct size of the image */
N    u16CorrectionX     = 16.0*u16PixelOffset*f64FactorX;
N    u16CorrectionY     = 16.0*u16PixelOffset*f64FactorY;
N
N#else
S
S    /* Forward Rotated Coordinates Calculation */
S    stCoordlocal.u16X1 = u32SubResPPos * i16OffsetX;
S    stCoordlocal.u16Y1 = u32SubResPPos * i16OffsetY;
S
S    stCoordlocal.u16X2 = stCoordlocal.u16X1;
S    stCoordlocal.u16Y2 = (stCoordlocal.u16Y1 + ((16U * (pstMem->u16SrcHeight-u16PixelOffset) * i32FactorY) / 65536U));
S
S    stCoordlocal.u16X3 = (stCoordlocal.u16X2 + ((16U * i32FactorX * (pstMem->u16SrcWidth-u16PixelOffset)) / 65536U));
S    stCoordlocal.u16Y3 = stCoordlocal.u16Y2;
S
S    stCoordlocal.u16X4 = stCoordlocal.u16X3;
S    stCoordlocal.u16Y4 = stCoordlocal.u16Y1;
S
S    /* 1 pixel value is needed to later get the correct size of the image */
S    u16CorrectionX     = 16.0*u16PixelOffset*i32FactorX/65536;
S    u16CorrectionY     = 16.0*u16PixelOffset*i32FactorY/65536;
S
N#endif
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#ifdef GA_USE_MATH_LIB
N    if (!((f64FactorX > 1.0) || (f64FactorY > 1.0)))
N#else
S    if (!((i32FactorX > 65536U) || (i32FactorY > 65536U)))
N#endif
N    {
N        switch (eAlignment)
N        {
N            case ROT_SCALE_ALIGN_W0:
N                u32DiffX = 16U * pstMem->u16SrcWidth - (stCoordlocal.u16X3 - stCoordlocal.u16X1 + u16CorrectionX);
N                stCoordlocal.u16X1 = stCoordlocal.u16X1 + u32DiffX;
N                stCoordlocal.u16X2 = stCoordlocal.u16X2 + u32DiffX;
N                stCoordlocal.u16X3 = stCoordlocal.u16X3 + u32DiffX;
N                stCoordlocal.u16X4 = stCoordlocal.u16X4 + u32DiffX;
N                break;
N            case ROT_SCALE_ALIGN_0H:
N                u32DiffY = 16U * pstMem->u16SrcHeight - (stCoordlocal.u16Y3 - stCoordlocal.u16Y1 + u16CorrectionY);
N                stCoordlocal.u16Y1 = stCoordlocal.u16Y1 + u32DiffY;
N                stCoordlocal.u16Y2 = stCoordlocal.u16Y2 + u32DiffY;
N                stCoordlocal.u16Y3 = stCoordlocal.u16Y3 + u32DiffY;
N                stCoordlocal.u16Y4 = stCoordlocal.u16Y4 + u32DiffY;
N                break;
N            case ROT_SCALE_ALIGN_WH:
N                u32DiffX = 16U * pstMem->u16SrcWidth  - (stCoordlocal.u16X3 - stCoordlocal.u16X1 + u16CorrectionX);
N                u32DiffY = 16U * pstMem->u16SrcHeight - (stCoordlocal.u16Y3 - stCoordlocal.u16Y1 + u16CorrectionY);
N                stCoordlocal.u16X1 = stCoordlocal.u16X1 + u32DiffX;
N                stCoordlocal.u16Y1 = stCoordlocal.u16Y1 + u32DiffY;
N                stCoordlocal.u16X2 = stCoordlocal.u16X2 + u32DiffX;
N                stCoordlocal.u16Y2 = stCoordlocal.u16Y2 + u32DiffY;
N                stCoordlocal.u16X3 = stCoordlocal.u16X3 + u32DiffX;
N                stCoordlocal.u16Y3 = stCoordlocal.u16Y3 + u32DiffY;
N                stCoordlocal.u16X4 = stCoordlocal.u16X4 + u32DiffX;
N                stCoordlocal.u16Y4 = stCoordlocal.u16Y4 + u32DiffY;
N                break;
N            case ROT_SCALE_ALIGN_CC:
N                u32DiffX = (((16U * pstMem->u16SrcWidth)  - (int16_t)((int16_t)(stCoordlocal.u16X3) - (int16_t)(stCoordlocal.u16X1) + (int16_t)(u16CorrectionX) )) >> 1U);
N                u32DiffY = (((16U * pstMem->u16SrcHeight) - (int16_t)((int16_t)(stCoordlocal.u16Y3) - (int16_t)(stCoordlocal.u16Y1) + (int16_t)(u16CorrectionY) )) >> 1U);
N                stCoordlocal.u16X1 = stCoordlocal.u16X1 + u32DiffX;
N                stCoordlocal.u16Y1 = stCoordlocal.u16Y1 + u32DiffY;
N                stCoordlocal.u16X2 = stCoordlocal.u16X2 + u32DiffX;
N                stCoordlocal.u16Y2 = stCoordlocal.u16Y2 + u32DiffY;
N                stCoordlocal.u16X3 = stCoordlocal.u16X3 + u32DiffX;
N                stCoordlocal.u16Y3 = stCoordlocal.u16Y3 + u32DiffY;
N                stCoordlocal.u16X4 = stCoordlocal.u16X4 + u32DiffX;
N                stCoordlocal.u16Y4 = stCoordlocal.u16Y4 + u32DiffY;
N                break;
N            default: /* upper left */
N                ;
N        }
N    }
N
N    /* save calculated coordinates for later usage in a glocal array: */
N    vSaveGlFwRotCornerCoord(&stCoordlocal);
N    
N    /* Forward Rotated Coordinates */
N    pstCoord -> u16X1 = stCoordlocal.u16X1;
N    pstCoord -> u16Y1 = stCoordlocal.u16Y1;
N    pstCoord -> u16X2 = stCoordlocal.u16X2;
N    pstCoord -> u16Y2 = stCoordlocal.u16Y2;
N    pstCoord -> u16X3 = stCoordlocal.u16X3;
N    pstCoord -> u16Y3 = stCoordlocal.u16Y3;
N    pstCoord -> u16X4 = stCoordlocal.u16X4;
N    pstCoord -> u16Y4 = stCoordlocal.u16Y4;
N
N    pstCoord -> u8ScrAddrPos = (uint8_t) GA_FRCCR1;
N}
N
N
N/****************************************************************************/
N
Nstatic void vRotLib_CheckForNegativeCoordinates(rot_mem_st* pstMem, rot_rotCfg_st* pstParam, rot_frccr_st* pstCoord)
N{
N    uint16_t  u16CoordinateX, u16CoordinateY;
N    uint16_t  u16UpX, u16UpY;
N    int16_t   i16CoordinateX, i16CoordinateY, i16Coordinate2, i16Coordinate3, i16Coordinate4;
N
N    /* check if one coordinate in x-direction is negative */
N    u16CoordinateX = 0U;
N    if ((pstCoord->u16X1 > 0x8000U) || (pstCoord->u16X2 > 0x8000U) || (pstCoord->u16X3 > 0x8000U) || (pstCoord->u16X4 > 0x8000U))
N    {
N        /* get most negative coordinate */
N        i16CoordinateX = pstCoord->u16X1 + 0xFFFFU + 0x1U;
N        i16Coordinate2 = pstCoord->u16X2 + 0xFFFFU + 0x1U;
N        i16Coordinate3 = pstCoord->u16X3 + 0xFFFFU + 0x1U;
N        i16Coordinate4 = pstCoord->u16X4 + 0xFFFFU + 0x1U;
N        if (i16CoordinateX > i16Coordinate2) {i16CoordinateX = i16Coordinate2;}
N        if (i16CoordinateX > i16Coordinate3) {i16CoordinateX = i16Coordinate3;}
N        if (i16CoordinateX > i16Coordinate4) {i16CoordinateX = i16Coordinate4;}
N        u16CoordinateX = i16CoordinateX + 0xFFFFU + 0x1U;
N
N        /* update x coordinates */
N        u16CoordinateX = 0xFFFFU - u16CoordinateX + 1U;
N        u16UpX = 16U*((u16CoordinateX>>4U) + 1U);
N        pstCoord->u16X1 = pstCoord->u16X1 + u16UpX;
N        pstCoord->u16X2 = pstCoord->u16X2 + u16UpX;
N        pstCoord->u16X3 = pstCoord->u16X3 + u16UpX;
N        pstCoord->u16X4 = pstCoord->u16X4 + u16UpX;
N    }
N
N    /* check if one coordinate in y-direction is negative */
N    u16CoordinateY = 0U;
N    if ((pstCoord->u16Y1 > 0x8000U) || (pstCoord->u16Y2 > 0x8000U) || (pstCoord->u16Y3 > 0x8000U) || (pstCoord->u16Y4 > 0x8000U))
N    {
N        /* get most negative coordinate */
N        i16CoordinateY = pstCoord->u16Y1 + 0xFFFFU + 0x1U;
N        i16Coordinate2 = pstCoord->u16Y2 + 0xFFFFU + 0x1U;
N        i16Coordinate3 = pstCoord->u16Y3 + 0xFFFFU + 0x1U;
N        i16Coordinate4 = pstCoord->u16Y4 + 0xFFFFU + 0x1U;
N        if (i16CoordinateY > i16Coordinate2) {i16CoordinateY = i16Coordinate2;}
N        if (i16CoordinateY > i16Coordinate3) {i16CoordinateY = i16Coordinate3;}
N        if (i16CoordinateY > i16Coordinate4) {i16CoordinateY = i16Coordinate4;}
N        u16CoordinateY = i16CoordinateY + 0xFFFFU + 0x1U;
N
N        /* update y coordinates */
N        u16CoordinateY = 0xFFFFU - u16CoordinateY + 1U;
N        u16UpY = 16U*((u16CoordinateY>>4U) + 1U);
N        pstCoord->u16Y1 = pstCoord->u16Y1 + u16UpY;
N        pstCoord->u16Y2 = pstCoord->u16Y2 + u16UpY;
N        pstCoord->u16Y3 = pstCoord->u16Y3 + u16UpY;
N        pstCoord->u16Y4 = pstCoord->u16Y4 + u16UpY;
N
N        /* update Dst-image height */
N        pstMem->u16DstImgHeight = pstMem->u16DstImgHeight + (u16CoordinateY >> 4U);
N    }
N
N    /* if negative coordinates are available */
N    if ((u16CoordinateX != 0U) || (u16CoordinateY != 0U))
N    {
N        /* extract pixel */
N        if (u16CoordinateX != 0U)
N        {
N            u16CoordinateX = (u16CoordinateX >> 4U) + 1U;
N        }
N        if (u16CoordinateY != 0U)
N        {
N            u16CoordinateY = (u16CoordinateY >> 4U) + 1U;
N        }
N
N        /* update Dst-image startaddress */
N        if (pstParam->eDstColFmt == GA_RGB16)
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr - 2U*u16CoordinateY*pstMem->u16DstImgWidth - 2U*u16CoordinateX;
N        }
N        else
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr - 4U*u16CoordinateY*pstMem->u16DstImgWidth - 4U*u16CoordinateX;
N        }
N
N        /* update clipwindow */
N        if (pstParam->eClipWndEn == GA_EN)
N        {
N            pstParam->tClipWnd.u16UlX = pstParam->tClipWnd.u16UlX + u16CoordinateX;
N            pstParam->tClipWnd.u16UlY = pstParam->tClipWnd.u16UlY + u16CoordinateY;
N            pstParam->tClipWnd.u16LrX = (uint16_t)RE_MIN((pstParam->tClipWnd.u16LrX + u16CoordinateX), (pstMem->u16DstImgWidth-1U));
X            pstParam->tClipWnd.u16LrX = (uint16_t)(((pstParam->tClipWnd . u16LrX + u16CoordinateX)) < ((pstMem->u16DstImgWidth-1U)) ? ((pstParam->tClipWnd . u16LrX + u16CoordinateX)) : ((pstMem->u16DstImgWidth-1U)));
N            pstParam->tClipWnd.u16LrY = (uint16_t)RE_MIN((pstParam->tClipWnd.u16LrY + u16CoordinateY), (pstMem->u16DstImgHeight-1U));
X            pstParam->tClipWnd.u16LrY = (uint16_t)(((pstParam->tClipWnd . u16LrY + u16CoordinateY)) < ((pstMem->u16DstImgHeight-1U)) ? ((pstParam->tClipWnd . u16LrY + u16CoordinateY)) : ((pstMem->u16DstImgHeight-1U)));
N        }
N        else
N        {
N            pstParam->eClipWndEn = GA_EN;
N            pstParam->tClipWnd.u16UlX = u16CoordinateX;
N            pstParam->tClipWnd.u16UlY = u16CoordinateY;
N            pstParam->tClipWnd.u16LrX = (pstMem->u16DstImgWidth-1U);
N            pstParam->tClipWnd.u16LrY = (pstMem->u16DstImgHeight-1U);
N        }
N    }
N
N    /* set clipwindow if image is overlapping upper border */
N    if (((pstCoord->u16Y1>>4U) >= pstMem->u16DstImgHeight) ||
N        ((pstCoord->u16Y2>>4U) >= pstMem->u16DstImgHeight) ||
N        ((pstCoord->u16Y3>>4U) >= pstMem->u16DstImgHeight) ||
N        ((pstCoord->u16Y4>>4U) >= pstMem->u16DstImgHeight))
N    {
N        if (pstParam->eClipWndEn != GA_EN)
N        {
N            pstParam->eClipWndEn = GA_EN;
N            pstParam->tClipWnd.u16UlX = u16CoordinateX;
N            pstParam->tClipWnd.u16UlY = u16CoordinateY;
N            pstParam->tClipWnd.u16LrX = (pstMem->u16DstImgWidth-1U)  + u16CoordinateX;
N            pstParam->tClipWnd.u16LrY = (pstMem->u16DstImgHeight-1U) + u16CoordinateY;
N        }
N    }
N}
N
N
N/****************************************************************************/
N
Nstatic void vRotLib_CheckForNegativeCoordinatesBlend(rot_mem_st* pstMem, rot_rotblendCfg_st* pstParam, rot_frccr_st* pstCoord)
N{
N    uint16_t  u16CoordinateX, u16CoordinateY;
N    uint16_t  u16UpX, u16UpY;
N    int16_t   i16CoordinateX, i16CoordinateY, i16Coordinate2, i16Coordinate3, i16Coordinate4;
N
N    /* check if one coordinate in x-direction is negative */
N    u16CoordinateX = 0U;
N    if ((pstCoord->u16X1 > 0x8000U) || (pstCoord->u16X2 > 0x8000U) || (pstCoord->u16X3 > 0x8000U) || (pstCoord->u16X4 > 0x8000U))
N    {
N        /* get most negative coordinate */
N        i16CoordinateX = pstCoord->u16X1 + 0xFFFFU + 0x1U;
N        i16Coordinate2 = pstCoord->u16X2 + 0xFFFFU + 0x1U;
N        i16Coordinate3 = pstCoord->u16X3 + 0xFFFFU + 0x1U;
N        i16Coordinate4 = pstCoord->u16X4 + 0xFFFFU + 0x1U;
N        if (i16CoordinateX > i16Coordinate2) {i16CoordinateX = i16Coordinate2;}
N        if (i16CoordinateX > i16Coordinate3) {i16CoordinateX = i16Coordinate3;}
N        if (i16CoordinateX > i16Coordinate4) {i16CoordinateX = i16Coordinate4;}
N        u16CoordinateX = i16CoordinateX + 0xFFFFU + 0x1U;
N
N        /* update x coordinates */
N        u16CoordinateX = 0xFFFFU - u16CoordinateX + 1U;
N        u16UpX = 16U*((u16CoordinateX>>4U) + 1U);
N        pstCoord->u16X1 = pstCoord->u16X1 + u16UpX;
N        pstCoord->u16X2 = pstCoord->u16X2 + u16UpX;
N        pstCoord->u16X3 = pstCoord->u16X3 + u16UpX;
N        pstCoord->u16X4 = pstCoord->u16X4 + u16UpX;
N    }
N
N    /* check if one coordinate in y-direction is negative */
N    u16CoordinateY = 0U;
N    if ((pstCoord->u16Y1 > 0x8000U) || (pstCoord->u16Y2 > 0x8000U) || (pstCoord->u16Y3 > 0x8000U) || (pstCoord->u16Y4 > 0x8000U))
N    {
N        /* get most negative coordinate */
N        i16CoordinateY = pstCoord->u16Y1 + 0xFFFFU + 0x1U;
N        i16Coordinate2 = pstCoord->u16Y2 + 0xFFFFU + 0x1U;
N        i16Coordinate3 = pstCoord->u16Y3 + 0xFFFFU + 0x1U;
N        i16Coordinate4 = pstCoord->u16Y4 + 0xFFFFU + 0x1U;
N        if (i16CoordinateY > i16Coordinate2) {i16CoordinateY = i16Coordinate2;}
N        if (i16CoordinateY > i16Coordinate3) {i16CoordinateY = i16Coordinate3;}
N        if (i16CoordinateY > i16Coordinate4) {i16CoordinateY = i16Coordinate4;}
N        u16CoordinateY = i16CoordinateY + 0xFFFFU + 0x1U;
N
N        /* update y coordinates */
N        u16CoordinateY = 0xFFFFU - u16CoordinateY + 1U;
N        u16UpY = 16U*((u16CoordinateY>>4U) + 1U);
N        pstCoord->u16Y1 = pstCoord->u16Y1 + u16UpY;
N        pstCoord->u16Y2 = pstCoord->u16Y2 + u16UpY;
N        pstCoord->u16Y3 = pstCoord->u16Y3 + u16UpY;
N        pstCoord->u16Y4 = pstCoord->u16Y4 + u16UpY;
N
N        /* update Dst-image height */
N        pstMem->u16DstImgHeight = pstMem->u16DstImgHeight + (u16CoordinateY >> 4U);
N    }
N
N    /* if negative coordinates are available */
N    if ((u16CoordinateX != 0U) || (u16CoordinateY != 0U))
N    {
N        /* extract pixel */
N        if (u16CoordinateX != 0U)
N        {
N            u16CoordinateX = (u16CoordinateX >> 4U) + 1U;
N        }
N        if (u16CoordinateY != 0U)
N        {
N            u16CoordinateY = (u16CoordinateY >> 4U) + 1U;
N        }
N
N        /* update Dst-image startaddress */
N        if (pstParam->eDstColFmt == GA_RGB16)
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr - 2U*u16CoordinateY*pstMem->u16DstImgWidth - 2U*u16CoordinateX;
N        }
N        else
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr - 4U*u16CoordinateY*pstMem->u16DstImgWidth - 4U*u16CoordinateX;
N        }
N
N        /* update clipwindow */
N        if (pstParam->eClipWndEn == GA_EN)
N        {
N            pstParam->tClipWnd.u16UlX = pstParam->tClipWnd.u16UlX + u16CoordinateX;
N            pstParam->tClipWnd.u16UlY = pstParam->tClipWnd.u16UlY + u16CoordinateY;
N            pstParam->tClipWnd.u16LrX = pstParam->tClipWnd.u16LrX + u16CoordinateX;
N            pstParam->tClipWnd.u16LrY = pstParam->tClipWnd.u16LrY + u16CoordinateY;
N        }
N        else
N        {
N            pstParam->eClipWndEn = GA_EN;
N            pstParam->tClipWnd.u16UlX = u16CoordinateX;
N            pstParam->tClipWnd.u16UlY = u16CoordinateY;
N            pstParam->tClipWnd.u16LrX = (pstMem->u16DstImgWidth-1U)  + u16CoordinateX;
N            pstParam->tClipWnd.u16LrY = (pstMem->u16DstImgHeight-1U) + u16CoordinateY;
N        }
N    }
N
N    /* set clipwindow if image is overlapping upper border */
N    if (((pstCoord->u16Y1>>4U) >= pstMem->u16DstImgHeight) ||
N        ((pstCoord->u16Y2>>4U) >= pstMem->u16DstImgHeight) ||
N        ((pstCoord->u16Y3>>4U) >= pstMem->u16DstImgHeight) ||
N        ((pstCoord->u16Y4>>4U) >= pstMem->u16DstImgHeight))
N    {
N        if (pstParam->eClipWndEn != GA_EN)
N        {
N            pstParam->eClipWndEn = GA_EN;
N            pstParam->tClipWnd.u16UlX = u16CoordinateX;
N            pstParam->tClipWnd.u16UlY = u16CoordinateY;
N            pstParam->tClipWnd.u16LrX = (pstMem->u16DstImgWidth-1U)  + u16CoordinateX;
N            pstParam->tClipWnd.u16LrY = (pstMem->u16DstImgHeight-1U) + u16CoordinateY;
N        }
N    }
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_Rotate(rot_mem_st* pstMem, rot_cfg_st* pstParam, float64_t f64Angle, ga_list_st* pstCmdList)
N#else
Svoid vRotLib_Rotate(rot_mem_st* pstMem, rot_cfg_st* pstParam, int16_t   i16Angle, ga_list_st* pstCmdList)
N#endif
N{
N    rot_Mtrx_st    stMatrix;
N    rot_frccr_st   stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, f64Angle);
N#else
S    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, i16Angle);
N#endif
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(pstMem, pstParam->i16RotCentX, pstParam->i16RotCentY, 
N                                                                pstParam->i16OffsetX, pstParam->i16OffsetY, &stCoord, f64Angle);
N#else
S    vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(pstMem, pstParam->i16RotCentX, pstParam->i16RotCentY, 
S                                                                pstParam->i16OffsetX, pstParam->i16OffsetY, &stCoord, i16Angle);
N#endif
N
N    vRotLib_CheckForNegativeCoordinates(pstMem, &pstParam->stRotCfg, &stCoord);
N
N    if(pstParam->stRotCfg.eClipWndEn == GA_DIS)
N    {
N        /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N        coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N        all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N        this block of  coded might affect the performance */
N        
N        pstParam->stRotCfg.eClipWndEn = GA_EN;
N        pstParam->stRotCfg.tClipWnd.u16UlX = 0;
N        pstParam->stRotCfg.tClipWnd.u16UlY = 0;
N        pstParam->stRotCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N        pstParam->stRotCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N    }
N    if(vRotLib_CheckForOverlap(&stCoord, &pstParam->stRotCfg.tClipWnd, pstParam->stRotCfg.eClipWndEn) == GA_EN)
N    {
N        vRot_RotateMatrix(pstMem, &pstParam->stRotCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_Rotate_Part(rot_mem_part_st* pstMem, rot_cfg_st* pstParam, float64_t f64Angle, ga_list_st* pstCmdList)
N#else
Svoid vRotLib_Rotate_Part(rot_mem_part_st* pstMem, rot_cfg_st* pstParam, int16_t   i16Angle, ga_list_st* pstCmdList)
N#endif
N{
N    rot_mem_st    stMem_local;
N    rot_Mtrx_st   stMatrix;
N    rot_frccr_st  stCoord;
N
N    #ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, f64Angle);
N#else
S    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, i16Angle);
N#endif
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(pstMem, 
N                                                                pstParam->i16RotCentX, pstParam->i16RotCentY, 
N                                                                pstParam->i16OffsetX,  pstParam->i16OffsetY, 
N                                                                &stCoord, f64Angle);
N#else
S    vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(pstMem, 
S                                                                pstParam->i16RotCentX, pstParam->i16RotCentY, 
S                                                                pstParam->i16OffsetX,  pstParam->i16OffsetY, 
S                                                                &stCoord, i16Angle);
N#endif
N    stMem_local.u16SrcHeight    = pstMem->u16SrcHeight;
N    stMem_local.u16SrcWidth     = pstMem->u16SrcWidth;
N    stMem_local.u32SrcAddr      = pstMem->u32SrcAddr;
N    stMem_local.u32DstAddr      = pstMem->u32DstAddr;
N    stMem_local.u16DstImgWidth  = pstMem->u16DstImgWidth;
N    stMem_local.u16DstImgHeight = pstMem->u16DstImgHeight;
N
N    vRotLib_CheckForNegativeCoordinates(&stMem_local, &pstParam->stRotCfg, &stCoord);
N    if(pstParam->stRotCfg.eClipWndEn == GA_DIS)
N    {
N        /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N        coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N        all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N        this block of  coded might affect the performance */
N        
N        pstParam->stRotCfg.eClipWndEn = GA_EN;
N        pstParam->stRotCfg.tClipWnd.u16UlX = 0;
N        pstParam->stRotCfg.tClipWnd.u16UlY = 0;
N        pstParam->stRotCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N        pstParam->stRotCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N    }
N    
N    if(vRotLib_CheckForOverlap(&stCoord, &pstParam->stRotCfg.tClipWnd, pstParam->stRotCfg.eClipWndEn) == GA_EN)
N    {
N        vRot_RotateMatrix(&stMem_local, &pstParam->stRotCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_RotateBlend(rot_mem_st* pstMem, rot_blendcfg_st* pstParam, float64_t f64Angle, ga_list_st* pstCmdList)
N#else
Svoid vRotLib_RotateBlend(rot_mem_st* pstMem, rot_blendcfg_st* pstParam, int16_t   i16Angle, ga_list_st* pstCmdList)
N#endif
N{
N    rot_Mtrx_st   stMatrix;
N    rot_frccr_st  stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, f64Angle);
N#else
S    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, i16Angle);
N#endif
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(pstMem, pstParam->i16RotCentX, pstParam->i16RotCentY, 
N                                                                pstParam->i16OffsetX, pstParam->i16OffsetY, &stCoord, f64Angle);
N#else
S    vRotLib_CalculateForwardRotatedCornerCoordinates_RotateFull(pstMem, pstParam->i16RotCentX, pstParam->i16RotCentY, 
S                                                                pstParam->i16OffsetX, pstParam->i16OffsetY, &stCoord, i16Angle);
N#endif
N
N    vRotLib_CheckForNegativeCoordinatesBlend(pstMem, &pstParam->stRotBlendCfg, &stCoord);
N
N    if(pstParam->stRotBlendCfg.eClipWndEn == GA_DIS)
N    {
N        /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N        coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N        all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N        this block of  coded might affect the performance */
N        
N        pstParam->stRotBlendCfg.eClipWndEn = GA_EN;
N        pstParam->stRotBlendCfg.tClipWnd.u16UlX = 0;
N        pstParam->stRotBlendCfg.tClipWnd.u16UlY = 0;
N        pstParam->stRotBlendCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N        pstParam->stRotBlendCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N    }
N    
N    if(vRotLib_CheckForOverlap(&stCoord, &pstParam->stRotBlendCfg.tClipWnd, pstParam->stRotBlendCfg.eClipWndEn) == GA_EN)
N    {
N        vRot_RotateBlendMatrix(pstMem, &pstParam->stRotBlendCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB 
Nvoid vRotLib_RotateBlend_Part(rot_mem_part_st* pstMem, rot_blendcfg_st* pstParam, float64_t f64Angle, ga_list_st* pstCmdList)
N#else
Svoid vRotLib_RotateBlend_Part(rot_mem_part_st* pstMem, rot_blendcfg_st* pstParam, int16_t   i16Angle, ga_list_st* pstCmdList)
N#endif
N{
N    rot_mem_st    stMem_local;
N    rot_Mtrx_st   stMatrix;
N    rot_frccr_st  stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, f64Angle);
N#else
S    vRotLib_CalculateTransformationMatrix_Rotate(&stMatrix, i16Angle);
N#endif
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(pstMem, 
N                                                                pstParam->i16RotCentX, pstParam->i16RotCentY, 
N                                                                pstParam->i16OffsetX,  pstParam->i16OffsetY, 
N                                                                &stCoord, f64Angle);
N#else
S    vRotLib_CalculateForwardRotatedCornerCoordinates_RotatePart(pstMem, 
S                                                                pstParam->i16RotCentX, pstParam->i16RotCentY, 
S                                                                pstParam->i16OffsetX,  pstParam->i16OffsetY, 
S                                                                &stCoord, i16Angle);
N#endif
N    stMem_local.u16SrcHeight    = pstMem->u16SrcHeight;
N    stMem_local.u16SrcWidth     = pstMem->u16SrcWidth;
N    stMem_local.u32SrcAddr      = pstMem->u32SrcAddr;
N    stMem_local.u32DstAddr      = pstMem->u32DstAddr;
N    stMem_local.u16DstImgWidth  = pstMem->u16DstImgWidth;
N    stMem_local.u16DstImgHeight = pstMem->u16DstImgHeight;
N
N    vRotLib_CheckForNegativeCoordinatesBlend(&stMem_local, &pstParam->stRotBlendCfg, &stCoord);
N
N    if(pstParam->stRotBlendCfg.eClipWndEn == GA_DIS)
N    {
N        /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N        coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N        all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N        this block of  coded might affect the performance */
N        
N        pstParam->stRotBlendCfg.eClipWndEn = GA_EN;
N        pstParam->stRotBlendCfg.tClipWnd.u16UlX = 0;
N        pstParam->stRotBlendCfg.tClipWnd.u16UlY = 0;
N        pstParam->stRotBlendCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N        pstParam->stRotBlendCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N    }
N    if(vRotLib_CheckForOverlap(&stCoord, &pstParam->stRotBlendCfg.tClipWnd, pstParam->stRotBlendCfg.eClipWndEn) == GA_EN)
N    {
N        vRot_RotateBlendMatrix(&stMem_local, &pstParam->stRotBlendCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vRotLib_Shear(rot_mem_st* pstMem, rot_sscalCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    rot_cfg_st    stParam_local;
N    rot_Mtrx_st   stMatrix;
N    rot_frccr_st  stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Shear(&stMatrix, pstParam->f64FactorX, pstParam->f64FactorY);
N    vRotLib_CalculateForwardRotatedCornerCoordinates_Shear(pstMem, 
N                                                           pstParam->i16OffsetX, pstParam->i16OffsetY, 
N                                                           pstParam->f64FactorX, pstParam->f64FactorY, 
N                                                           &stCoord);
N#else
S    vRotLib_CalculateTransformationMatrix_Shear(&stMatrix, pstParam->i32FactorX, pstParam->i32FactorY);
S    vRotLib_CalculateForwardRotatedCornerCoordinates_Shear(pstMem, 
S                                                           pstParam->i16OffsetX, pstParam->i16OffsetY, 
S                                                           pstParam->i32FactorX, pstParam->i32FactorY, 
S                                                           &stCoord);
N#endif
N
N    stParam_local.stRotCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N    stParam_local.stRotCfg.eDstColFmt    = pstParam->eDstColFmt;
N    stParam_local.stRotCfg.eClipWndEn    = pstParam->eClipWndEn;
N    stParam_local.stRotCfg.eFilterEn     = pstParam->eFilterEn;
N    stParam_local.i16RotCentX            = 0U;
N    stParam_local.i16RotCentY            = 0U;
N    stParam_local.i16OffsetX             = pstParam->i16OffsetX;
N    stParam_local.i16OffsetY             = pstParam->i16OffsetY;
N    stParam_local.stRotCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N    stParam_local.stRotCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N    stParam_local.stRotCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N    stParam_local.stRotCfg.tClipWnd      = pstParam->tClipWnd;
N
N    vRotLib_CheckForNegativeCoordinates(pstMem, &stParam_local.stRotCfg, &stCoord);
N
N    if(stParam_local.stRotCfg.eClipWndEn == GA_DIS)
N    {
N        /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N        coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N        all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N        this block of  coded might affect the performance */
N        
N        stParam_local.stRotCfg.eClipWndEn = GA_EN;
N        stParam_local.stRotCfg.tClipWnd.u16UlX = 0;
N        stParam_local.stRotCfg.tClipWnd.u16UlY = 0;
N        stParam_local.stRotCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N        stParam_local.stRotCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N    }
N    if(vRotLib_CheckForOverlap(&stCoord, &stParam_local.stRotCfg.tClipWnd, stParam_local.stRotCfg.eClipWndEn) == GA_EN)
N    {
N        vRot_RotateMatrix(pstMem, &stParam_local.stRotCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vRotLib_ShearBlend(rot_mem_st* pstMem, rot_sscalblendCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    rot_blendcfg_st  stParam_local;
N    rot_Mtrx_st      stMatrix;
N    rot_frccr_st     stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Shear(&stMatrix, pstParam->f64FactorX, pstParam->f64FactorY);
N    vRotLib_CalculateForwardRotatedCornerCoordinates_Shear(pstMem, 
N                                                           pstParam->i16OffsetX, pstParam->i16OffsetY, 
N                                                           pstParam->f64FactorX, pstParam->f64FactorY, 
N                                                           &stCoord);
N#else
S    vRotLib_CalculateTransformationMatrix_Shear(&stMatrix, pstParam->i32FactorX, pstParam->i32FactorY);
S    vRotLib_CalculateForwardRotatedCornerCoordinates_Shear(pstMem, 
S                                                           pstParam->i16OffsetX, pstParam->i16OffsetY, 
S                                                           pstParam->i32FactorX, pstParam->i32FactorY, 
S                                                           &stCoord);
N#endif
N
N    stParam_local.stRotBlendCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N    stParam_local.stRotBlendCfg.eDstColFmt    = pstParam->eDstColFmt;
N    stParam_local.stRotBlendCfg.eClipWndEn    = pstParam->eClipWndEn;
N    stParam_local.stRotBlendCfg.eFilterEn     = pstParam->eFilterEn;
N    stParam_local.i16RotCentX                 = 0U;
N    stParam_local.i16RotCentY                 = 0U;
N    stParam_local.i16OffsetX                  = pstParam->i16OffsetX;
N    stParam_local.i16OffsetY                  = pstParam->i16OffsetY;
N    stParam_local.stRotBlendCfg.eDstRedProt   = pstParam->eDstRedProt;
N    stParam_local.stRotBlendCfg.eDstGreenProt = pstParam->eDstGreenProt;
N    stParam_local.stRotBlendCfg.eDstBlueProt  = pstParam->eDstBlueProt;
N    stParam_local.stRotBlendCfg.eDstAlphaProt = pstParam->eDstAlphaProt;
N    stParam_local.stRotBlendCfg.eSrcRedFad    = pstParam->eSrcRedFad;
N    stParam_local.stRotBlendCfg.eSrcGreenFad  = pstParam->eSrcGreenFad;
N    stParam_local.stRotBlendCfg.eSrcBlueFad   = pstParam->eSrcBlueFad;
N    stParam_local.stRotBlendCfg.eSrcAlphaFad  = pstParam->eSrcAlphaFad;
N    stParam_local.stRotBlendCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N    stParam_local.stRotBlendCfg.eBldOrd       = pstParam->eBldOrd;
N    stParam_local.stRotBlendCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N    stParam_local.stRotBlendCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N    stParam_local.stRotBlendCfg.tClipWnd      = pstParam->tClipWnd;
N
N    vRotLib_CheckForNegativeCoordinatesBlend(pstMem, &stParam_local.stRotBlendCfg, &stCoord);
N
N    if(stParam_local.stRotBlendCfg.eClipWndEn == GA_DIS)
N    {
N        /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N        coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N        all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N        this block of  coded might affect the performance */
N        
N        stParam_local.stRotBlendCfg.eClipWndEn = GA_EN;
N        stParam_local.stRotBlendCfg.tClipWnd.u16UlX = 0;
N        stParam_local.stRotBlendCfg.tClipWnd.u16UlY = 0;
N        stParam_local.stRotBlendCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N        stParam_local.stRotBlendCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N    }
N    if(vRotLib_CheckForOverlap(&stCoord, &stParam_local.stRotBlendCfg.tClipWnd, stParam_local.stRotBlendCfg.eClipWndEn) == GA_EN)
N    {
N        vRot_RotateBlendMatrix(pstMem, &stParam_local.stRotBlendCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vRotLib_Scale(rot_mem_st* pstMem, rot_sscalCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    rot_cfg_st    stParam_local;
N    rot_Mtrx_st   stMatrix;
N    rot_frccr_st  stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Scale(&stMatrix, pstParam->f64FactorX, pstParam->f64FactorY);
N#else
S    vRotLib_CalculateTransformationMatrix_Scale(&stMatrix, pstParam->i32FactorX, pstParam->i32FactorY);
N#endif
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(pstMem,
N                                                           pstParam->i16OffsetX, pstParam->i16OffsetY,
N                                                           pstParam->f64FactorX, pstParam->f64FactorY,
N                                                           pstParam->eAlignment, &stCoord);
N#else
S    vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(pstMem,
S                                                           pstParam->i16OffsetX, pstParam->i16OffsetY,
S                                                           pstParam->i32FactorX, pstParam->i32FactorY,
S                                                           pstParam->eAlignment, &stCoord);
N#endif
N
N    stParam_local.stRotCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N    stParam_local.stRotCfg.eDstColFmt    = pstParam->eDstColFmt;
N    stParam_local.stRotCfg.eClipWndEn    = pstParam->eClipWndEn;
N    stParam_local.stRotCfg.eFilterEn     = pstParam->eFilterEn;
N    stParam_local.i16RotCentX            = 0U;
N    stParam_local.i16RotCentY            = 0U;
N    stParam_local.i16OffsetX             = pstParam->i16OffsetX;
N    stParam_local.i16OffsetY             = pstParam->i16OffsetY;
N    stParam_local.stRotCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N    stParam_local.stRotCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N    stParam_local.stRotCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N    stParam_local.stRotCfg.tClipWnd      = pstParam->tClipWnd;
N
N    vRotLib_CheckForNegativeCoordinates(pstMem, &stParam_local.stRotCfg, &stCoord);
N
N    if((RE_DOUBLEABS((stCoord.u16X1>>4) - (stCoord.u16X4>>4)) > 0) && (RE_DOUBLEABS((stCoord.u16Y1>>4) - (stCoord.u16Y3>>4)) > 0))
N    {
N        if(stParam_local.stRotCfg.eClipWndEn == GA_DIS)
N        {
N            /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N            coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N            all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N            this block of  coded might affect the performance */
N            
N            stParam_local.stRotCfg.eClipWndEn = GA_EN;
N            stParam_local.stRotCfg.tClipWnd.u16UlX = 0;
N            stParam_local.stRotCfg.tClipWnd.u16UlY = 0;
N            stParam_local.stRotCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N            stParam_local.stRotCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N        }
N        if(vRotLib_CheckForOverlap(&stCoord, &stParam_local.stRotCfg.tClipWnd, stParam_local.stRotCfg.eClipWndEn) == GA_EN)
N        {
N            vRot_RotateMatrix(pstMem, &stParam_local.stRotCfg, &stMatrix, &stCoord, pstCmdList);
N        }
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vRotLib_ScaleBlend(rot_mem_st* pstMem, rot_sscalblendCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N
N    rot_blendcfg_st  stParam_local;
N    rot_Mtrx_st      stMatrix;
N    rot_frccr_st     stCoord;
N
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateTransformationMatrix_Scale(&stMatrix, pstParam->f64FactorX, pstParam->f64FactorY);
N#else
S    vRotLib_CalculateTransformationMatrix_Scale(&stMatrix, pstParam->i32FactorX, pstParam->i32FactorY);
N#endif
N#ifdef GA_USE_MATH_LIB
N    vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(pstMem,
N                                                           pstParam->i16OffsetX, pstParam->i16OffsetY,
N                                                           pstParam->f64FactorX, pstParam->f64FactorY,
N                                                           pstParam->eAlignment, &stCoord);
N#else
S    vRotLib_CalculateForwardRotatedCornerCoordinates_Scale(pstMem,
S                                                           pstParam->i16OffsetX, pstParam->i16OffsetY,
S                                                           pstParam->i32FactorX, pstParam->i32FactorY,
S                                                           pstParam->eAlignment, &stCoord);
N#endif
N
N    stParam_local.stRotBlendCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N    stParam_local.stRotBlendCfg.eDstColFmt    = pstParam->eDstColFmt;
N    stParam_local.stRotBlendCfg.eClipWndEn    = pstParam->eClipWndEn;
N    stParam_local.stRotBlendCfg.eFilterEn     = pstParam->eFilterEn;
N    stParam_local.i16RotCentX                 = 0U;
N    stParam_local.i16RotCentY                 = 0U;
N    stParam_local.i16OffsetX                  = pstParam->i16OffsetX;
N    stParam_local.i16OffsetY                  = pstParam->i16OffsetY;
N    stParam_local.stRotBlendCfg.eDstRedProt   = pstParam->eDstRedProt;
N    stParam_local.stRotBlendCfg.eDstGreenProt = pstParam->eDstGreenProt;
N    stParam_local.stRotBlendCfg.eDstBlueProt  = pstParam->eDstBlueProt;
N    stParam_local.stRotBlendCfg.eDstAlphaProt = pstParam->eDstAlphaProt;
N    stParam_local.stRotBlendCfg.eSrcRedFad    = pstParam->eSrcRedFad;
N    stParam_local.stRotBlendCfg.eSrcGreenFad  = pstParam->eSrcGreenFad;
N    stParam_local.stRotBlendCfg.eSrcBlueFad   = pstParam->eSrcBlueFad;
N    stParam_local.stRotBlendCfg.eSrcAlphaFad  = pstParam->eSrcAlphaFad;
N    stParam_local.stRotBlendCfg.eBldOrd       = pstParam->eBldOrd;
N    stParam_local.stRotBlendCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N    stParam_local.stRotBlendCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N    stParam_local.stRotBlendCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N    stParam_local.stRotBlendCfg.tClipWnd      = pstParam->tClipWnd;
N
N    vRotLib_CheckForNegativeCoordinatesBlend(pstMem, &stParam_local.stRotBlendCfg, &stCoord);
N
N    if((RE_DOUBLEABS((stCoord.u16X1>>4) - (stCoord.u16X4>>4)) > 0) && (RE_DOUBLEABS((stCoord.u16Y1>>4) - (stCoord.u16Y3>>4)) > 0))
N    {
N        if(stParam_local.stRotBlendCfg.eClipWndEn == GA_DIS)
N        {
N            /* RE expects atleast 2 pixels to overlap with the draw region. When the clip window is disabled, and the 
N            coordinates are also positive, it might so happen that all the 4 (Y coords >> 4) are 0. i.e they Y coord of 
N            all 4 points lie on Y = 0;. In such cases RE hangs. Since this is an extreme and it does not occur so often,
N            this block of  coded might affect the performance */
N            
N            stParam_local.stRotBlendCfg.eClipWndEn = GA_EN;
N            stParam_local.stRotBlendCfg.tClipWnd.u16UlX = 0;
N            stParam_local.stRotBlendCfg.tClipWnd.u16UlY = 0;
N            stParam_local.stRotBlendCfg.tClipWnd.u16LrX = pstMem->u16DstImgWidth - 1U;
N            stParam_local.stRotBlendCfg.tClipWnd.u16LrY = pstMem->u16DstImgHeight - 1U;
N        }
N        if(vRotLib_CheckForOverlap(&stCoord, &stParam_local.stRotBlendCfg.tClipWnd, stParam_local.stRotBlendCfg.eClipWndEn) == GA_EN)
N        {
N            vRot_RotateBlendMatrix(pstMem, &stParam_local.stRotBlendCfg, &stMatrix, &stCoord, pstCmdList);
N        }
N    }
N}
N
N
N/****************************************************************************/
N
N#ifdef GA_USE_MATH_LIB
Nvoid vRotLib_Perspective(rot_mem_st* pstMem, rot_perspectiveCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    rot_cfg_st     stParam_local;
N    GA_COORD_t     rot;
N    GA_MATRIX_t    iR;
N    GA_SCREENOBJ_t FRCC;
N    GA_SCREENOBJ_t sortedFRCC;
N    rot_Mtrx_st    stMatrix;
N    rot_frccr_st   stCoord;
N    float64_t      f64OffsetX, f64OffsetY;
N    uint16_t       u16SubResDivX, u16SubResDivY;
N    uint16_t       u16MinX, u16MinY;
N
N    rot.x = -pstParam->f64AngleX;
N    rot.y = -pstParam->f64AngleY;
N    rot.z = -pstParam->f64AngleZ;
N
N    /* forward rotate corners */
N    FRCC = RE_FORWARDROT(rot, 1U, (uint32_t)pstMem->u16SrcWidth, (uint32_t)pstMem->u16SrcHeight, (float64_t)pstParam->u32RotPointX/(17.0 - (float64_t)f32SubResCPos), (float64_t)pstParam->u32RotPointY/(17.0 - (float64_t)f32SubResCPos));
N    FRCC = RE_SCALESCREENOBJECT_X(FRCC, pstMem->u16SrcWidth*pstParam->f64ScaleX);
N    FRCC = RE_SCALESCREENOBJECT_Y(FRCC, pstMem->u16SrcHeight*pstParam->f64ScaleY);
N
N    sortedFRCC.p1.x = 16.0*FRCC.p1.x;
N    sortedFRCC.p1.y = 16.0*FRCC.p1.y;
N    sortedFRCC.p2.x = 16.0*FRCC.p2.x;
N    sortedFRCC.p2.y = 16.0*FRCC.p2.y;
N    sortedFRCC.p3.x = 16.0*FRCC.p3.x;
N    sortedFRCC.p3.y = 16.0*FRCC.p3.y;
N    sortedFRCC.p4.x = 16.0*FRCC.p4.x;
N    sortedFRCC.p4.y = 16.0*FRCC.p4.y;
N
N    /* sort corners as required by RE and get start corner */
N    stCoord.u8ScrAddrPos = (uint8_t)RE_SORTCORNERS(&sortedFRCC) - 1U;
N
N    if (stCoord.u8ScrAddrPos != 254U)
N    {
N        /* calculate offset */
N        f64OffsetX = 16.0*(((float64_t)pstParam->i16OffsetX / (17.0 -(float64_t)f32SubResPPos)) - (FRCC.c.x - ((float64_t)pstParam->u32RotPointX / (17.0 - (float64_t)f32SubResCPos))));
N        f64OffsetY = 16.0*(((float64_t)pstParam->i16OffsetY / (17.0 -(float64_t)f32SubResPPos)) - (FRCC.c.y - ((float64_t)pstParam->u32RotPointY / (17.0 - (float64_t)f32SubResCPos))));
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N        /* correct offset */
N        stCoord.u16X1 = 0xFFFFU & ((uint32_t)(sortedFRCC.p1.x + f64OffsetX));
N        stCoord.u16Y1 = 0xFFFFU & ((uint32_t)(sortedFRCC.p1.y + f64OffsetY));
N        stCoord.u16X2 = 0xFFFFU & ((uint32_t)(sortedFRCC.p2.x + f64OffsetX));
N        stCoord.u16Y2 = 0xFFFFU & ((uint32_t)(sortedFRCC.p2.y + f64OffsetY));
N        stCoord.u16X3 = 0xFFFFU & ((uint32_t)(sortedFRCC.p3.x + f64OffsetX));
N        stCoord.u16Y3 = 0xFFFFU & ((uint32_t)(sortedFRCC.p3.y + f64OffsetY));
N        stCoord.u16X4 = 0xFFFFU & ((uint32_t)(sortedFRCC.p4.x + f64OffsetX));
N        stCoord.u16Y4 = 0xFFFFU & ((uint32_t)(sortedFRCC.p4.y + f64OffsetY));
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N        /* create matrix as required by RE */
N        iR = RE_BACKWARDMATRIX(FRCC, (uint32_t)pstMem->u16SrcWidth, (uint32_t)pstMem->u16SrcHeight);
N
N        /* assign matrix */
N        stMatrix.u32A11 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sx  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A12 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shy + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A21 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shx + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A22 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sy  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A31 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w0  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A32 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w1  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A33 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w2  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N
N        stParam_local.stRotCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N        stParam_local.stRotCfg.eDstColFmt    = pstParam->eDstColFmt;
N        stParam_local.stRotCfg.eClipWndEn    = pstParam->eClipWndEn;
N        stParam_local.stRotCfg.eFilterEn     = pstParam->eFilterEn;
N        stParam_local.i16RotCentX            = 0U;
N        stParam_local.i16RotCentY            = 0U;
N        stParam_local.i16OffsetX             = pstParam->i16OffsetX;
N        stParam_local.i16OffsetY             = pstParam->i16OffsetY;
N        stParam_local.stRotCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N        stParam_local.stRotCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N        stParam_local.stRotCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N        stParam_local.stRotCfg.tClipWnd      = pstParam->tClipWnd;
N
N        vRotLib_CheckForNegativeCoordinates(pstMem, &stParam_local.stRotCfg, &stCoord);
N
N        /* get MinX and MinY of coordinates */
N        u16MinX = stCoord.u16X1;
N        if (stCoord.u16X2 < u16MinX) {u16MinX = stCoord.u16X2;}
N        if (stCoord.u16X3 < u16MinX) {u16MinX = stCoord.u16X3;}
N        if (stCoord.u16X4 < u16MinX) {u16MinX = stCoord.u16X4;}
N        u16MinY = stCoord.u16Y1;
N        if (stCoord.u16Y2 < u16MinY) {u16MinY = stCoord.u16Y2;}
N        if (stCoord.u16Y3 < u16MinY) {u16MinY = stCoord.u16Y3;}
N        if (stCoord.u16Y4 < u16MinY) {u16MinY = stCoord.u16Y4;}
N
N        u16SubResDivX  = u16MinX >> 4U;
N        u16SubResDivY  = u16MinY >> 4U;
N
N        /* correct offset of coordinates */
N        stCoord.u16X1 = stCoord.u16X1 - 16U*u16SubResDivX;
N        stCoord.u16Y1 = stCoord.u16Y1 - 16U*u16SubResDivY;
N        stCoord.u16X2 = stCoord.u16X2 - 16U*u16SubResDivX;
N        stCoord.u16Y2 = stCoord.u16Y2 - 16U*u16SubResDivY;
N        stCoord.u16X3 = stCoord.u16X3 - 16U*u16SubResDivX;
N        stCoord.u16Y3 = stCoord.u16Y3 - 16U*u16SubResDivY;
N        stCoord.u16X4 = stCoord.u16X4 - 16U*u16SubResDivX;
N        stCoord.u16Y4 = stCoord.u16Y4 - 16U*u16SubResDivY;
N
N        /* correct startaddress */
N        if (pstParam->eDstColFmt == GA_RGB16)
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 2U*pstMem->u16DstImgWidth*u16SubResDivY + 2U*u16SubResDivX;
N        }
N        else
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 4U*pstMem->u16DstImgWidth*u16SubResDivY + 4U*u16SubResDivX;
N        }
N
N        /* correct clip window */
N        if (pstParam->eClipWndEn == GA_EN)
N        {
N            pstParam->tClipWnd.u16UlX = pstParam->tClipWnd.u16UlX - u16SubResDivX;
N            pstParam->tClipWnd.u16UlY = pstParam->tClipWnd.u16UlY - u16SubResDivY;
N            pstParam->tClipWnd.u16LrX = pstParam->tClipWnd.u16LrX - u16SubResDivX;
N            pstParam->tClipWnd.u16LrY = pstParam->tClipWnd.u16LrY - u16SubResDivY;
N            stParam_local.stRotCfg.tClipWnd = pstParam->tClipWnd;
N        }
N
N        vRot_RotateMatrix(pstMem, &stParam_local.stRotCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vRotLib_PerspectiveBlend(rot_mem_st* pstMem, rot_perspectiveblendCfg_st* pstParam, ga_list_st* pstCmdList)
N{
N    rot_blendcfg_st  stParam_local;
N    GA_COORD_t       rot;
N    GA_MATRIX_t      iR;
N    GA_SCREENOBJ_t   FRCC;
N    GA_SCREENOBJ_t   sortedFRCC;
N    rot_Mtrx_st      stMatrix;
N    rot_frccr_st     stCoord;
N    float64_t        f64OffsetX, f64OffsetY;
N    uint16_t         u16SubResDivX, u16SubResDivY;
N    uint16_t         u16MinX, u16MinY;
N
N    rot.x = -pstParam->f64AngleX;
N    rot.y = -pstParam->f64AngleY;
N    rot.z = -pstParam->f64AngleZ;
N
N    /* forward rotate corners */
N    FRCC = RE_FORWARDROT(rot, 1U, (uint32_t)pstMem->u16SrcWidth, (uint32_t)pstMem->u16SrcHeight, (float64_t)pstParam->u32RotPointX/(17.0 - (float64_t)f32SubResCPos), (float64_t)pstParam->u32RotPointY/(17.0 - (float64_t)f32SubResCPos));
N    FRCC = RE_SCALESCREENOBJECT_X(FRCC, pstMem->u16SrcWidth*pstParam->f64ScaleX);
N    FRCC = RE_SCALESCREENOBJECT_Y(FRCC, pstMem->u16SrcHeight*pstParam->f64ScaleY);
N
N    sortedFRCC.p1.x = 16.0*FRCC.p1.x;
N    sortedFRCC.p1.y = 16.0*FRCC.p1.y;
N    sortedFRCC.p2.x = 16.0*FRCC.p2.x;
N    sortedFRCC.p2.y = 16.0*FRCC.p2.y;
N    sortedFRCC.p3.x = 16.0*FRCC.p3.x;
N    sortedFRCC.p3.y = 16.0*FRCC.p3.y;
N    sortedFRCC.p4.x = 16.0*FRCC.p4.x;
N    sortedFRCC.p4.y = 16.0*FRCC.p4.y;
N
N    /* sort corners as required by RE and get start corner */
N    stCoord.u8ScrAddrPos = (uint8_t)RE_SORTCORNERS(&sortedFRCC) - 1U;
N
N    if (stCoord.u8ScrAddrPos != 254U)
N    {
N        /* calculate offset */
N        f64OffsetX = 16.0*(((float64_t)pstParam->i16OffsetX / (17.0 -(float64_t)f32SubResPPos)) - (FRCC.c.x - ((float64_t)pstParam->u32RotPointX / (17.0 - (float64_t)f32SubResCPos))));
N        f64OffsetY = 16.0*(((float64_t)pstParam->i16OffsetY / (17.0 -(float64_t)f32SubResPPos)) - (FRCC.c.y - ((float64_t)pstParam->u32RotPointY / (17.0 - (float64_t)f32SubResCPos))));
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N        /* correct offset */
N        stCoord.u16X1 = 0xFFFFU & ((uint32_t)(sortedFRCC.p1.x + f64OffsetX));
N        stCoord.u16Y1 = 0xFFFFU & ((uint32_t)(sortedFRCC.p1.y + f64OffsetY));
N        stCoord.u16X2 = 0xFFFFU & ((uint32_t)(sortedFRCC.p2.x + f64OffsetX));
N        stCoord.u16Y2 = 0xFFFFU & ((uint32_t)(sortedFRCC.p2.y + f64OffsetY));
N        stCoord.u16X3 = 0xFFFFU & ((uint32_t)(sortedFRCC.p3.x + f64OffsetX));
N        stCoord.u16Y3 = 0xFFFFU & ((uint32_t)(sortedFRCC.p3.y + f64OffsetY));
N        stCoord.u16X4 = 0xFFFFU & ((uint32_t)(sortedFRCC.p4.x + f64OffsetX));
N        stCoord.u16Y4 = 0xFFFFU & ((uint32_t)(sortedFRCC.p4.y + f64OffsetY));
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N        /* create matrix as required by RE */
N        iR=RE_BACKWARDMATRIX(FRCC, (uint32_t)pstMem->u16SrcWidth, (uint32_t)pstMem->u16SrcHeight);
N
N        stMatrix.u32A11 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sx  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A12 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shy + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A21 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shx + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A22 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sy  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A31 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w0  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A32 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w1  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A33 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w2  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N
N        stParam_local.stRotBlendCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N        stParam_local.stRotBlendCfg.eDstColFmt    = pstParam->eDstColFmt;
N        stParam_local.stRotBlendCfg.eClipWndEn    = pstParam->eClipWndEn;
N        stParam_local.stRotBlendCfg.eFilterEn     = pstParam->eFilterEn;
N        stParam_local.i16RotCentX                 = 0U;
N        stParam_local.i16RotCentY                 = 0U;
N        stParam_local.i16OffsetX                  = pstParam->i16OffsetX;
N        stParam_local.i16OffsetY                  = pstParam->i16OffsetY;
N        stParam_local.stRotBlendCfg.eDstRedProt   = pstParam->eDstRedProt;
N        stParam_local.stRotBlendCfg.eDstGreenProt = pstParam->eDstGreenProt;
N        stParam_local.stRotBlendCfg.eDstBlueProt  = pstParam->eDstBlueProt;
N        stParam_local.stRotBlendCfg.eDstAlphaProt = pstParam->eDstAlphaProt;
N        stParam_local.stRotBlendCfg.eSrcRedFad    = pstParam->eSrcRedFad;
N        stParam_local.stRotBlendCfg.eSrcGreenFad  = pstParam->eSrcGreenFad;
N        stParam_local.stRotBlendCfg.eSrcBlueFad   = pstParam->eSrcBlueFad;
N        stParam_local.stRotBlendCfg.eSrcAlphaFad  = pstParam->eSrcAlphaFad;
N        stParam_local.stRotBlendCfg.eBldOrd       = pstParam->eBldOrd;
N        stParam_local.stRotBlendCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N        stParam_local.stRotBlendCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N        stParam_local.stRotBlendCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N        stParam_local.stRotBlendCfg.tClipWnd      = pstParam->tClipWnd;
N
N        vRotLib_CheckForNegativeCoordinatesBlend(pstMem, &stParam_local.stRotBlendCfg, &stCoord);
N
N        /* get MinX and MinY of coordinates */
N        u16MinX = stCoord.u16X1;
N        if (stCoord.u16X2 < u16MinX) {u16MinX = stCoord.u16X2;}
N        if (stCoord.u16X3 < u16MinX) {u16MinX = stCoord.u16X3;}
N        if (stCoord.u16X4 < u16MinX) {u16MinX = stCoord.u16X4;}
N        u16MinY = stCoord.u16Y1;
N        if (stCoord.u16Y2 < u16MinY) {u16MinY = stCoord.u16Y2;}
N        if (stCoord.u16Y3 < u16MinY) {u16MinY = stCoord.u16Y3;}
N        if (stCoord.u16Y4 < u16MinY) {u16MinY = stCoord.u16Y4;}
N
N        u16SubResDivX  = u16MinX >> 4U;
N        u16SubResDivY  = u16MinY >> 4U;
N
N        /* correct offset of coordinates */
N        stCoord.u16X1 = stCoord.u16X1 - 16U*u16SubResDivX;
N        stCoord.u16Y1 = stCoord.u16Y1 - 16U*u16SubResDivY;
N        stCoord.u16X2 = stCoord.u16X2 - 16U*u16SubResDivX;
N        stCoord.u16Y2 = stCoord.u16Y2 - 16U*u16SubResDivY;
N        stCoord.u16X3 = stCoord.u16X3 - 16U*u16SubResDivX;
N        stCoord.u16Y3 = stCoord.u16Y3 - 16U*u16SubResDivY;
N        stCoord.u16X4 = stCoord.u16X4 - 16U*u16SubResDivX;
N        stCoord.u16Y4 = stCoord.u16Y4 - 16U*u16SubResDivY;
N
N        /* correct startaddress */
N        if (pstParam->eDstColFmt == GA_RGB16)
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 2U*pstMem->u16DstImgWidth*u16SubResDivY + 2U*u16SubResDivX;
N        }
N        else
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 4U*pstMem->u16DstImgWidth*u16SubResDivY + 4U*u16SubResDivX;
N        }
N
N        /* correct clip window */
N        if (pstParam->eClipWndEn == GA_EN)
N        {
N            pstParam->tClipWnd.u16UlX = pstParam->tClipWnd.u16UlX - u16SubResDivX;
N            pstParam->tClipWnd.u16UlY = pstParam->tClipWnd.u16UlY - u16SubResDivY;
N            pstParam->tClipWnd.u16LrX = pstParam->tClipWnd.u16LrX - u16SubResDivX;
N            pstParam->tClipWnd.u16LrY = pstParam->tClipWnd.u16LrY - u16SubResDivY;
N            stParam_local.stRotBlendCfg.tClipWnd = pstParam->tClipWnd;
N        }
N
N        vRot_RotateBlendMatrix(pstMem, &stParam_local.stRotBlendCfg, &stMatrix, &stCoord, pstCmdList);
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vRotLib_PerspectiveOGL(rot_mem_st * pstMem, rot_perspectiveCfg_st * pstParam, ga_list_st * pstCmdList)
N{
N    int32_t        offset[2];
N    rot_cfg_st     stParam_local;
N    rot_Mtrx_st    stMatrix;
N    rot_frccr_st   stCoord;
N    uint16_t       u16SubResDivX, u16SubResDivY;
N    uint16_t       u16MinX, u16MinY;
N    GA_MATRIX_t    iR;
N    GA_SCREENOBJ_t sortedFRCC, FRCC;
N    ga_en_e        eDraw;
N
N    RE_TRANSLATEOBJECT((int32_t*)offset, &FRCC, (float64_t*)obj);
N
N    /* create matrix as required by RE */
N    iR = RE_BACKWARDMATRIX(FRCC, (uint32_t)pstMem->u16SrcWidth, (uint32_t)pstMem->u16SrcHeight);
N
N    sortedFRCC.p1.x = 16.0*FRCC.p1.x;
N    sortedFRCC.p1.y = 16.0*FRCC.p1.y;
N    sortedFRCC.p2.x = 16.0*FRCC.p2.x;
N    sortedFRCC.p2.y = 16.0*FRCC.p2.y;
N    sortedFRCC.p3.x = 16.0*FRCC.p3.x;
N    sortedFRCC.p3.y = 16.0*FRCC.p3.y;
N    sortedFRCC.p4.x = 16.0*FRCC.p4.x;
N    sortedFRCC.p4.y = 16.0*FRCC.p4.y;
N                           
N    /* sort corners as required by RE and get start corner */
N    stCoord.u8ScrAddrPos = (uint8_t)RE_SORTCORNERS(&sortedFRCC) - 1U;
N
N    if (stCoord.u8ScrAddrPos != 254U)
N    {
N        /* assign matrix */
N        stMatrix.u32A11 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sx  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A12 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shy + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A21 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shx + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A22 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sy  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A31 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w0  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A32 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w1  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A33 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w2  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N        /* correct offset */
N        stCoord.u16X1 = 0xFFFFU & ((uint32_t)sortedFRCC.p1.x);
N        stCoord.u16Y1 = 0xFFFFU & ((uint32_t)sortedFRCC.p1.y);
N        stCoord.u16X2 = 0xFFFFU & ((uint32_t)sortedFRCC.p2.x);
N        stCoord.u16Y2 = 0xFFFFU & ((uint32_t)sortedFRCC.p2.y);
N        stCoord.u16X3 = 0xFFFFU & ((uint32_t)sortedFRCC.p3.x);
N        stCoord.u16Y3 = 0xFFFFU & ((uint32_t)sortedFRCC.p3.y);
N        stCoord.u16X4 = 0xFFFFU & ((uint32_t)sortedFRCC.p4.x);
N        stCoord.u16Y4 = 0xFFFFU & ((uint32_t)sortedFRCC.p4.y);
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N        stParam_local.stRotCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N        stParam_local.stRotCfg.eDstColFmt    = pstParam->eDstColFmt;
N        stParam_local.stRotCfg.eClipWndEn    = pstParam->eClipWndEn;
N        stParam_local.stRotCfg.eFilterEn     = pstParam->eFilterEn;
N        stParam_local.i16RotCentX            = 0U;
N        stParam_local.i16RotCentY            = 0U;
N        stParam_local.i16OffsetX             = 0U;
N        stParam_local.i16OffsetY             = 0U;
N        stParam_local.stRotCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N        stParam_local.stRotCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N        stParam_local.stRotCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N        stParam_local.stRotCfg.tClipWnd      = pstParam->tClipWnd;
N        
N        vRotLib_CheckForNegativeCoordinates(pstMem, &stParam_local.stRotCfg, &stCoord);
N
N        /* get MinX and MinY of coordinates */
N        u16MinX = stCoord.u16X1;
N        if (stCoord.u16X2 < u16MinX) {u16MinX = stCoord.u16X2;}
N        if (stCoord.u16X3 < u16MinX) {u16MinX = stCoord.u16X3;}
N        if (stCoord.u16X4 < u16MinX) {u16MinX = stCoord.u16X4;}
N        u16MinY = stCoord.u16Y1;
N        if (stCoord.u16Y2 < u16MinY) {u16MinY = stCoord.u16Y2;}
N        if (stCoord.u16Y3 < u16MinY) {u16MinY = stCoord.u16Y3;}
N        if (stCoord.u16Y4 < u16MinY) {u16MinY = stCoord.u16Y4;}
N
N        u16SubResDivX  = u16MinX >> 4U;
N        u16SubResDivY  = u16MinY >> 4U;
N
N        /* correct offset of coordinates */
N        stCoord.u16X1 = stCoord.u16X1 - 16U*u16SubResDivX;
N        stCoord.u16Y1 = stCoord.u16Y1 - 16U*u16SubResDivY;
N        stCoord.u16X2 = stCoord.u16X2 - 16U*u16SubResDivX;
N        stCoord.u16Y2 = stCoord.u16Y2 - 16U*u16SubResDivY;
N        stCoord.u16X3 = stCoord.u16X3 - 16U*u16SubResDivX;
N        stCoord.u16Y3 = stCoord.u16Y3 - 16U*u16SubResDivY;
N        stCoord.u16X4 = stCoord.u16X4 - 16U*u16SubResDivX;
N        stCoord.u16Y4 = stCoord.u16Y4 - 16U*u16SubResDivY;
N
N        /* correct startaddress */
N        if (pstParam->eDstColFmt == GA_RGB16)
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 2U*pstMem->u16DstImgWidth*offset[1] + 2U*offset[0];
N        }
N        else
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 4U*pstMem->u16DstImgWidth*offset[1] + 4U*offset[0];
N        }
N
N        
N        /* Update the clip window parameters if it was modified in the CheckForNegative() */
N        pstParam->tClipWnd = stParam_local.stRotCfg.tClipWnd;
N        pstParam->eClipWndEn = stParam_local.stRotCfg.eClipWndEn;
N            
N        /* correct clip window */
N        eDraw = vRotLib_CalculateCorrectClipWindow(&pstParam->tClipWnd, pstParam->eClipWndEn, pstMem, &offset[0]);
N        /* Draw only if there is an overlapping clip window and destination area */
N        if(eDraw == GA_EN)
N        {   
N            if(vRotLib_CheckForOverlap(&stCoord, &pstParam->tClipWnd, eDraw) == GA_EN)
N            {
N                /* check pstParam->tClipWnd */
N                pstParam->eClipWndEn = eDraw;
N                stParam_local.stRotCfg.tClipWnd = pstParam->tClipWnd;
N                stParam_local.stRotCfg.eClipWndEn = pstParam->eClipWndEn;
N
N                vRot_RotateMatrix(pstMem, &stParam_local.stRotCfg, &stMatrix, &stCoord, pstCmdList);
N            }
N        }
N    }
N}
N
N/****************************************************************************/
N
Nvoid vRotLib_PerspectiveBlendOGL(rot_mem_st * pstMem, rot_perspectiveblendCfg_st * pstParam, ga_list_st * pstCmdList)
N{
N    int32_t         offset[2];
N    rot_blendcfg_st stParam_local;
N    rot_Mtrx_st     stMatrix;
N    rot_frccr_st    stCoord;
N    uint16_t        u16SubResDivX, u16SubResDivY;
N    uint16_t        u16MinX, u16MinY;
N    GA_MATRIX_t     iR;
N    GA_SCREENOBJ_t  sortedFRCC, FRCC;
N    ga_en_e         eDraw;
N
N    RE_TRANSLATEOBJECT((int32_t*)offset, &FRCC, (float64_t*)obj);
N
N    /* create matrix as required by RE */
N    iR = RE_BACKWARDMATRIX(FRCC, (uint32_t)pstMem->u16SrcWidth, (uint32_t)pstMem->u16SrcHeight);
N
N    sortedFRCC.p1.x = 16.0*FRCC.p1.x;
N    sortedFRCC.p1.y = 16.0*FRCC.p1.y;
N    sortedFRCC.p2.x = 16.0*FRCC.p2.x;
N    sortedFRCC.p2.y = 16.0*FRCC.p2.y;
N    sortedFRCC.p3.x = 16.0*FRCC.p3.x;
N    sortedFRCC.p3.y = 16.0*FRCC.p3.y;
N    sortedFRCC.p4.x = 16.0*FRCC.p4.x;
N    sortedFRCC.p4.y = 16.0*FRCC.p4.y;
N                           
N    /* sort corners as required by RE and get start corner */
N    stCoord.u8ScrAddrPos = (uint8_t)RE_SORTCORNERS(&sortedFRCC) - 1U;
N
N    if (stCoord.u8ScrAddrPos != 254U)
N    {
N        /* assign matrix */
N        stMatrix.u32A11 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sx  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A12 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shy + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A21 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.shx + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A22 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.sy  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A31 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w0  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A32 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w1  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N        stMatrix.u32A33 = 0x3FFFFFU & ((uint32_t)((int64_t)iR.w2  + 0xFFFFFFFFFFFFFFFFUL + 0x1UL));
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1848    /* MISRA 2004 Rule 10.4 */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N        /* correct offset */
N        stCoord.u16X1 = 0xFFFFU & ((uint32_t)sortedFRCC.p1.x);
N        stCoord.u16Y1 = 0xFFFFU & ((uint32_t)sortedFRCC.p1.y);
N        stCoord.u16X2 = 0xFFFFU & ((uint32_t)sortedFRCC.p2.x);
N        stCoord.u16Y2 = 0xFFFFU & ((uint32_t)sortedFRCC.p2.y);
N        stCoord.u16X3 = 0xFFFFU & ((uint32_t)sortedFRCC.p3.x);
N        stCoord.u16Y3 = 0xFFFFU & ((uint32_t)sortedFRCC.p3.y);
N        stCoord.u16X4 = 0xFFFFU & ((uint32_t)sortedFRCC.p4.x);
N        stCoord.u16Y4 = 0xFFFFU & ((uint32_t)sortedFRCC.p4.y);
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N        stParam_local.stRotBlendCfg.eSrcColFmt    = pstParam->eSrcColFmt;
N        stParam_local.stRotBlendCfg.eDstColFmt    = pstParam->eDstColFmt;
N        stParam_local.stRotBlendCfg.eClipWndEn    = pstParam->eClipWndEn;
N        stParam_local.stRotBlendCfg.eFilterEn     = pstParam->eFilterEn;
N        stParam_local.i16RotCentX                 = 0U;
N        stParam_local.i16RotCentY                 = 0U;
N        stParam_local.i16OffsetX                  = 0U;
N        stParam_local.i16OffsetY                  = 0U;
N        stParam_local.stRotBlendCfg.eDstRedProt   = pstParam->eDstRedProt;
N        stParam_local.stRotBlendCfg.eDstGreenProt = pstParam->eDstGreenProt;
N        stParam_local.stRotBlendCfg.eDstBlueProt  = pstParam->eDstBlueProt;
N        stParam_local.stRotBlendCfg.eDstAlphaProt = pstParam->eDstAlphaProt;
N        stParam_local.stRotBlendCfg.eSrcRedFad    = pstParam->eSrcRedFad;
N        stParam_local.stRotBlendCfg.eSrcGreenFad  = pstParam->eSrcGreenFad;
N        stParam_local.stRotBlendCfg.eSrcBlueFad   = pstParam->eSrcBlueFad;
N        stParam_local.stRotBlendCfg.eSrcAlphaFad  = pstParam->eSrcAlphaFad;
N        stParam_local.stRotBlendCfg.eBldOrd       = pstParam->eBldOrd;
N        stParam_local.stRotBlendCfg.u8FadingFctr  = pstParam->u8FadingFctr;
N        stParam_local.stRotBlendCfg.u8SrcAlphaVal = pstParam->u8SrcAlphaVal;
N        stParam_local.stRotBlendCfg.u8DstAlphaVal = pstParam->u8DstAlphaVal;
N        stParam_local.stRotBlendCfg.tClipWnd      = pstParam->tClipWnd;
N        
N        vRotLib_CheckForNegativeCoordinatesBlend(pstMem, &stParam_local.stRotBlendCfg, &stCoord);
N
N        /* get MinX and MinY of coordinates */
N        u16MinX = stCoord.u16X1;
N        if (stCoord.u16X2 < u16MinX) {u16MinX = stCoord.u16X2;}
N        if (stCoord.u16X3 < u16MinX) {u16MinX = stCoord.u16X3;}
N        if (stCoord.u16X4 < u16MinX) {u16MinX = stCoord.u16X4;}
N        u16MinY = stCoord.u16Y1;
N        if (stCoord.u16Y2 < u16MinY) {u16MinY = stCoord.u16Y2;}
N        if (stCoord.u16Y3 < u16MinY) {u16MinY = stCoord.u16Y3;}
N        if (stCoord.u16Y4 < u16MinY) {u16MinY = stCoord.u16Y4;}
N
N        u16SubResDivX  = u16MinX >> 4U;
N        u16SubResDivY  = u16MinY >> 4U;
N
N        /* correct offset of coordinates */
N        stCoord.u16X1 = stCoord.u16X1 - 16U*u16SubResDivX;
N        stCoord.u16Y1 = stCoord.u16Y1 - 16U*u16SubResDivY;
N        stCoord.u16X2 = stCoord.u16X2 - 16U*u16SubResDivX;
N        stCoord.u16Y2 = stCoord.u16Y2 - 16U*u16SubResDivY;
N        stCoord.u16X3 = stCoord.u16X3 - 16U*u16SubResDivX;
N        stCoord.u16Y3 = stCoord.u16Y3 - 16U*u16SubResDivY;
N        stCoord.u16X4 = stCoord.u16X4 - 16U*u16SubResDivX;
N        stCoord.u16Y4 = stCoord.u16Y4 - 16U*u16SubResDivY;
N
N        /* correct startaddress */
N        if (pstParam->eDstColFmt == GA_RGB16)
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 2U*pstMem->u16DstImgWidth*offset[1] + 2U*offset[0];
N        }
N        else
N        {
N            pstMem->u32DstAddr = pstMem->u32DstAddr + 4U*pstMem->u16DstImgWidth*offset[1] + 4U*offset[0];
N        }
N
N        /* Update the clip window parameters, if it was modified in the CheckForNegative() */
N        pstParam->tClipWnd = stParam_local.stRotBlendCfg.tClipWnd;
N        pstParam->eClipWndEn = stParam_local.stRotBlendCfg.eClipWndEn;
N            
N        /* correct clip window */
N        eDraw = vRotLib_CalculateCorrectClipWindow(&pstParam->tClipWnd, pstParam->eClipWndEn, pstMem, &offset[0]);
N        /* Draw only if there is an overlapping clip window and destination area */
N        if(eDraw == GA_EN)
N        {
N            if(vRotLib_CheckForOverlap(&stCoord, &pstParam->tClipWnd, eDraw) == GA_EN)
N            {
N                pstParam->eClipWndEn = eDraw;
N                stParam_local.stRotBlendCfg.tClipWnd = pstParam->tClipWnd;
N                stParam_local.stRotBlendCfg.eClipWndEn = pstParam->eClipWndEn;
N
N                vRot_RotateBlendMatrix(pstMem, &stParam_local.stRotBlendCfg, &stMatrix, &stCoord, pstCmdList);
N            }
N        }
N    }
N}
N
N#endif
N
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the ï¿½Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (ï¿½Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customerï¿½s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
