; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\ga.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\ga.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\ga.crf ..\..\..\..\lldd\src\ga.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vGA_GetVersion PROC
;;;85     
;;;86     void vGA_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
000000  e92d40f0          PUSH     {r4-r7,lr}
;;;87                         uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
;;;88                         uint8_t** pau8CommonRevision, uint8_t** pau8CommonTag,
;;;89                         uint8_t** pau8IORevision, uint8_t** pau8IOTag)
;;;90     {
000004  e1cd41d4          LDRD     r4,r5,[sp,#0x14]
000008  e1cd61dc          LDRD     r6,r7,[sp,#0x1c]
;;;91          *pau8ModuleRevision = &au8LLDD_GA_C_REVISION[0];
00000c  e59fc954          LDR      r12,|L1.2408|
000010  e580c000          STR      r12,[r0,#0]
;;;92          *pau8ModuleTag      = &au8LLDD_GA_C_TAG[0];
000014  e59fc950          LDR      r12,|L1.2412|
000018  e581c000          STR      r12,[r1,#0]
;;;93          *pau8HeaderRevision = &au8LLDD_GA_H_REVISION[0];
00001c  e59fc94c          LDR      r12,|L1.2416|
000020  e582c000          STR      r12,[r2,#0]
;;;94          *pau8HeaderTag      = &au8LLDD_GA_H_TAG[0];
000024  e59fc948          LDR      r12,|L1.2420|
000028  e583c000          STR      r12,[r3,#0]
;;;95          *pau8CommonRevision = &au8LLDD_GA_COMMON_H_REVISION[0];
00002c  e59fc944          LDR      r12,|L1.2424|
000030  e584c000          STR      r12,[r4,#0]
;;;96          *pau8CommonTag      = &au8LLDD_GA_COMMON_H_TAG[0];
000034  e59fc940          LDR      r12,|L1.2428|
000038  e585c000          STR      r12,[r5,#0]
;;;97          *pau8IORevision     = &au8LLDD_GA_IO_H_REVISION[0];
00003c  e59fc93c          LDR      r12,|L1.2432|
000040  e586c000          STR      r12,[r6,#0]
;;;98          *pau8IOTag          = &au8LLDD_GA_IO_H_TAG[0];
000044  e59fc938          LDR      r12,|L1.2436|
000048  e587c000          STR      r12,[r7,#0]
;;;99     }
00004c  e8bd80f0          POP      {r4-r7,pc}
;;;100    
                          ENDP

                  vGA_ResetMaxUsedBuffSize PROC
;;;101    /* ....................................................................... */
;;;102    void vGA_ResetMaxUsedBuffSize(void)
000050  e3a00000          MOV      r0,#0
;;;103    {
;;;104         u32MaxUsedBuffSize = 0U;
000054  e59f192c          LDR      r1,|L1.2440|
000058  e5810000          STR      r0,[r1,#0]  ; u32MaxUsedBuffSize
;;;105    }
00005c  e12fff1e          BX       lr
;;;106    /* ....................................................................... */
                          ENDP

                  u32GA_GetMaxUsedBuffSize PROC
;;;107    uint32_t u32GA_GetMaxUsedBuffSize(void)
000060  e59f0920          LDR      r0,|L1.2440|
;;;108    {
;;;109         return u32MaxUsedBuffSize;
000064  e5900000          LDR      r0,[r0,#0]  ; u32MaxUsedBuffSize
;;;110    }
000068  e12fff1e          BX       lr
;;;111    /* ....................................................................... */
                          ENDP

                  i32GA_GetLastCmdBuffStatus PROC
;;;112    int32_t i32GA_GetLastCmdBuffStatus(ga_list_st* pstCmdList)
00006c  e1a01000          MOV      r1,r0
;;;113    {
;;;114         return pstCmdList->i32FreeSpaceStat;
000070  e3040008          MOV      r0,#0x4008
000074  e7900001          LDR      r0,[r0,r1]
;;;115    }
000078  e12fff1e          BX       lr
;;;116    /* ....................................................................... */
                          ENDP

                  u32GA_GetLastCmdSize PROC
;;;117    uint32_t u32GA_GetLastCmdSize(ga_list_st* pstCmdList)
00007c  e1a01000          MOV      r1,r0
;;;118    {
;;;119         return pstCmdList->u32UsedDoubleWords;
000080  e3040004          MOV      r0,#0x4004
000084  e7900001          LDR      r0,[r0,r1]
;;;120    }
000088  e12fff1e          BX       lr
;;;121    /* ....................................................................... */
                          ENDP

                  i32GA_CheckList PROC
;;;122    int32_t i32GA_CheckList(ga_list_st* pstCmdList, uint32_t u32NeededDW)
00008c  e92d4010          PUSH     {r4,lr}
;;;123    {
000090  e1a02000          MOV      r2,r0
;;;124        int32_t i32Result;
;;;125       /* check if there are enough double words free */
;;;126       if ((pstCmdList->pu64Current + u32NeededDW-1) < &pstCmdList->ullCommands[GA_CMD_MAX])
000094  e3043000          MOVW     r3,#0x4000
000098  e7933002          LDR      r3,[r3,r2]
00009c  e0833181          ADD      r3,r3,r1,LSL #3
0000a0  e2433008          SUB      r3,r3,#8
0000a4  e2824901          ADD      r4,r2,#0x4000
0000a8  e1530004          CMP      r3,r4
0000ac  2a000001          BCS      |L1.184|
;;;127       {
;;;128           i32Result = C_SUCCESS;
0000b0  e3a00000          MOV      r0,#0
0000b4  ea000000          B        |L1.188|
                  |L1.184|
;;;129       }
;;;130       else
;;;131       {
;;;132           i32Result = C_FAILED;
0000b8  e3e00000          MVN      r0,#0
                  |L1.188|
;;;133       }
;;;134       return (i32Result);
;;;135    }
0000bc  e8bd8010          POP      {r4,pc}
;;;136    /* ....................................................................... */
                          ENDP

                  vGA_ResetList PROC
;;;137    void vGA_ResetList(ga_list_st* pstCmdList)
0000c0  e3041000          MOVW     r1,#0x4000
;;;138    {
;;;139    
;;;140        pstCmdList->pu64Current = &(pstCmdList->ullCommands[0]);
0000c4  e7810000          STR      r0,[r1,r0]
;;;141        pstCmdList->i32FreeSpaceStat   = C_SUCCESS;
0000c8  e3a01000          MOV      r1,#0
0000cc  e3042008          MOV      r2,#0x4008
0000d0  e7821000          STR      r1,[r2,r0]
;;;142        pstCmdList->u32UsedDoubleWords = 0U;
0000d4  e3042004          MOV      r2,#0x4004
0000d8  e7821000          STR      r1,[r2,r0]
;;;143    
;;;144    }
0000dc  e12fff1e          BX       lr
;;;145    
                          ENDP

                  vGA_Enable PROC
;;;146    /* ....................................................................... */
;;;147    void vGA_Enable(ga_en_e eEn)
0000e0  e59f18a4          LDR      r1,|L1.2444|
;;;148    {
;;;149        vSetGASCR_GAEN((uint8_t)eEn);
0000e4  e1d110b0          LDRH     r1,[r1,#0]
0000e8  e7c11090          BFI      r1,r0,#1,#1
0000ec  e59f2898          LDR      r2,|L1.2444|
0000f0  e1c210b0          STRH     r1,[r2,#0]
;;;150    }
0000f4  e12fff1e          BX       lr
;;;151    
                          ENDP

                  vGA_ReadAheadEnable PROC
;;;152    /* ....................................................................... */
;;;153    void vGA_ReadAheadEnable(ga_en_e eEn)
0000f8  e3500001          CMP      r0,#1
;;;154    {
;;;155        /* NOTE:
;;;156         * Disable ReadBuffer Read Ahead feature
;;;157         *   0: Read Ahead feature is enabled
;;;158         *   1: Read Ahead feature is disabled */
;;;159        if (GA_EN == eEn)
0000fc  1a000005          BNE      |L1.280|
;;;160        {
;;;161            vSetGASCR_DISRA((uint8_t)GA_DIS);
000100  e59f1884          LDR      r1,|L1.2444|
000104  e1d110b0          LDRH     r1,[r1,#0]
000108  e3c11c01          BIC      r1,r1,#0x100
00010c  e59f2878          LDR      r2,|L1.2444|
000110  e1c210b0          STRH     r1,[r2,#0]
000114  ea000005          B        |L1.304|
                  |L1.280|
;;;162        }
;;;163        else
;;;164        {
;;;165            vSetGASCR_DISRA((uint8_t)GA_EN);
000118  e59f186c          LDR      r1,|L1.2444|
00011c  e1d110b0          LDRH     r1,[r1,#0]
000120  e3c11c01          BIC      r1,r1,#0x100
000124  e2811c01          ADD      r1,r1,#0x100
000128  e59f285c          LDR      r2,|L1.2444|
00012c  e1c210b0          STRH     r1,[r2,#0]
                  |L1.304|
;;;166        }
;;;167    }
000130  e12fff1e          BX       lr
;;;168    
                          ENDP

                  vGA_CloseList PROC
;;;169    /* ....................................................................... */
;;;170    void vGA_CloseList(ga_list_st* pstCmdList)
000134  e92d4010          PUSH     {r4,lr}
;;;171    {
;;;172        uint32_t u32UsedBuffSize;
;;;173        uint64_t* pullCurr = (uint64_t*) pstCmdList->pu64Current;
000138  e3043000          MOVW     r3,#0x4000
00013c  e7932000          LDR      r2,[r3,r0]
000140  e3a04000          MOV      r4,#0
000144  e59f3844          LDR      r3,|L1.2448|
;;;174    
;;;175    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;176    
;;;177        uint32_t u32NeededDW = 1;
;;;178    
;;;179        /* check if there is enough space in command list: */
;;;180        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;181        {
;;;182          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;183          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;184          return;
;;;185        }
;;;186        else 
;;;187        {
;;;188          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;189        }
;;;190    #endif
;;;191    
;;;192    
;;;193        pullCurr[0] = GA_END();
000148  e5823004          STR      r3,[r2,#4]
00014c  e5824000          STR      r4,[r2,#0]
;;;194    
;;;195        pstCmdList->pu64Current = &pullCurr[1];
000150  e2823008          ADD      r3,r2,#8
000154  e3044000          MOVW     r4,#0x4000
000158  e7843000          STR      r3,[r4,r0]
;;;196    
;;;197        
;;;198        u32UsedBuffSize = pstCmdList->pu64Current - pstCmdList->ullCommands;
00015c  e3043000          MOVW     r3,#0x4000
000160  e7933000          LDR      r3,[r3,r0]
000164  e0433000          SUB      r3,r3,r0
000168  e1a011c3          ASR      r1,r3,#3
;;;199        if (u32UsedBuffSize > u32MaxUsedBuffSize) 
00016c  e59f3814          LDR      r3,|L1.2440|
000170  e5933000          LDR      r3,[r3,#0]  ; u32MaxUsedBuffSize
000174  e1510003          CMP      r1,r3
000178  9a000001          BLS      |L1.388|
;;;200        {
;;;201          u32MaxUsedBuffSize = u32UsedBuffSize; 
00017c  e59f3804          LDR      r3,|L1.2440|
000180  e5831000          STR      r1,[r3,#0]  ; u32MaxUsedBuffSize
                  |L1.388|
;;;202        }
;;;203        pstCmdList->u32UsedDoubleWords = 1;
000184  e3a03001          MOV      r3,#1
000188  e3044004          MOV      r4,#0x4004
00018c  e7843000          STR      r3,[r4,r0]
;;;204    }
000190  e8bd8010          POP      {r4,pc}
;;;205    
                          ENDP

                  vGA_SyncList PROC
;;;206    /* ....................................................................... */
;;;207    void vGA_SyncList(ga_modul_e eModule, ga_list_st* pstCmdList)
000194  e92d40f0          PUSH     {r4-r7,lr}
;;;208    {
;;;209        uint64_t* pullCurr = (uint64_t*) pstCmdList->pu64Current;
000198  e3043000          MOVW     r3,#0x4000
00019c  e7932001          LDR      r2,[r3,r1]
;;;210    
;;;211    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;212    
;;;213        uint32_t u32NeededDW = 1;
;;;214       
;;;215        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;216    
;;;217        /* check if there is enough space in command list: */
;;;218        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;219        {
;;;220          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;221          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;222          return;
;;;223        }
;;;224        else 
;;;225        {
;;;226          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;227        }
;;;228    #endif
;;;229    
;;;230        pullCurr[0] = GA_WAIT(eModule);
0001a0  e3a04000          MOV      r4,#0
0001a4  e2006003          AND      r6,r0,#3
0001a8  e0043004          AND      r3,r4,r4
0001ac  e1a05006          MOV      r5,r6
0001b0  e6ff6073          UXTH     r6,r3
0001b4  e59f37d8          LDR      r3,|L1.2452|
0001b8  e1844005          ORR      r4,r4,r5
0001bc  e1833006          ORR      r3,r3,r6
0001c0  e5823004          STR      r3,[r2,#4]
0001c4  e5824000          STR      r4,[r2,#0]
;;;231    
;;;232        pstCmdList->pu64Current = &pullCurr[1];
0001c8  e2823008          ADD      r3,r2,#8
0001cc  e3044000          MOVW     r4,#0x4000
0001d0  e7843001          STR      r3,[r4,r1]
;;;233        pstCmdList->u32UsedDoubleWords = 1;
0001d4  e3a03001          MOV      r3,#1
0001d8  e3044004          MOV      r4,#0x4004
0001dc  e7843001          STR      r3,[r4,r1]
;;;234    }
0001e0  e8bd80f0          POP      {r4-r7,pc}
;;;235    
                          ENDP

                  vGA_SetUserInt PROC
;;;236    /* ....................................................................... */
;;;237    void vGA_SetUserInt(uint8_t u8Number, ga_list_st* pstCmdList)
0001e4  e92d40f0          PUSH     {r4-r7,lr}
;;;238    {
;;;239        uint64_t* pullCurr = (uint64_t*) pstCmdList->pu64Current;
0001e8  e3043000          MOVW     r3,#0x4000
0001ec  e7932001          LDR      r2,[r3,r1]
;;;240    
;;;241    #ifdef  GA_CMDSLIST_BOUNDARY_CHECK
;;;242    
;;;243        uint32_t u32NeededDW = 1;
;;;244       
;;;245        u32NeededDW += RESERVED_FOR_END_CMD; /* 1 Double word more for later END command */
;;;246    
;;;247        /* check if there is enough space in command list: */
;;;248        if ( i32GA_CheckList(pstCmdList, u32NeededDW) == C_FAILED)
;;;249        {
;;;250          pstCmdList->i32FreeSpaceStat = C_FAILED;
;;;251          pstCmdList->u32UsedDoubleWords = u32NeededDW;
;;;252          return;
;;;253        }
;;;254        else 
;;;255        {
;;;256          pstCmdList->i32FreeSpaceStat = C_SUCCESS;
;;;257        }
;;;258    #endif
;;;259    
;;;260        pullCurr[0] = GA_USERINTERRUPT(u8Number);
0001f0  e3a04000          MOV      r4,#0
0001f4  e200603f          AND      r6,r0,#0x3f
0001f8  e0043004          AND      r3,r4,r4
0001fc  e1a05006          MOV      r5,r6
000200  e6ff6073          UXTH     r6,r3
000204  e59f378c          LDR      r3,|L1.2456|
000208  e1844005          ORR      r4,r4,r5
00020c  e1833006          ORR      r3,r3,r6
000210  e5823004          STR      r3,[r2,#4]
000214  e5824000          STR      r4,[r2,#0]
;;;261    
;;;262        pstCmdList->pu64Current = &pullCurr[1];
000218  e2823008          ADD      r3,r2,#8
00021c  e3044000          MOVW     r4,#0x4000
000220  e7843001          STR      r3,[r4,r1]
;;;263        pstCmdList->u32UsedDoubleWords = 1;
000224  e3a03001          MOV      r3,#1
000228  e3044004          MOV      r4,#0x4004
00022c  e7843001          STR      r3,[r4,r1]
;;;264    }
000230  e8bd80f0          POP      {r4-r7,pc}
;;;265    /* ....................................................................... */
                          ENDP

                  i32GA_Reset PROC
;;;266    int32_t i32GA_Reset(void)
000234  e92d4010          PUSH     {r4,lr}
;;;267    {
;;;268        int32_t  i32Ret = C_FAILED;
000238  e3e00000          MVN      r0,#0
;;;269        int32_t  i32TimeOut = GA_TIMEOUT;
00023c  e3021710          MOV      r1,#0x2710
;;;270        uint32_t u32Res;
;;;271    
;;;272        vSetGASCR_GARESET();
000240  e59f3744          LDR      r3,|L1.2444|
000244  e1d330b0          LDRH     r3,[r3,#0]
000248  e3c33001          BIC      r3,r3,#1
00024c  e2833001          ADD      r3,r3,#1
000250  e59f4734          LDR      r4,|L1.2444|
000254  e1c430b0          STRH     r3,[r4,#0]
;;;273        u32Res =  (uint32_t)biGetGASCR_GARESET();
000258  e0043000          AND      r3,r4,r0
00025c  e1d330b0          LDRH     r3,[r3,#0]
000260  e2032001          AND      r2,r3,#1
;;;274    
;;;275        while((i32TimeOut > 0) && (u32Res == 1))
000264  ea000000          B        |L1.620|
                  |L1.616|
;;;276        {
;;;277            i32TimeOut--;
000268  e2411001          SUB      r1,r1,#1
                  |L1.620|
00026c  e3510000          CMP      r1,#0                 ;275
000270  da000001          BLE      |L1.636|
000274  e3520001          CMP      r2,#1                 ;275
000278  0afffffa          BEQ      |L1.616|
                  |L1.636|
;;;278        }
;;;279    
;;;280        if(i32TimeOut > 0)
00027c  e3510000          CMP      r1,#0
000280  da000000          BLE      |L1.648|
;;;281        {
;;;282            i32Ret = C_SUCCESS;
000284  e3a00000          MOV      r0,#0
                  |L1.648|
;;;283        }
;;;284    
;;;285        return i32Ret;
;;;286    }
000288  e8bd8010          POP      {r4,pc}
;;;287    
                          ENDP

                  vGA_SetCmdListAddr PROC
;;;288    /* ....................................................................... */
;;;289    void vGA_SetCmdListAddr(uint32_t u32Addr)
00028c  e59f16f8          LDR      r1,|L1.2444|
;;;290    {
;;;291        vSetGACLAR(u32Addr);
000290  e5810004          STR      r0,[r1,#4]
;;;292    }
000294  e12fff1e          BX       lr
;;;293    
                          ENDP

                  u8GA_GetStatus PROC
;;;294    /* ....................................................................... */
;;;295    uint8_t u8GA_GetStatus(void)
000298  e59f06ec          LDR      r0,|L1.2444|
;;;296    {
;;;297        return ((uint8_t) u8GetGASR());
00029c  e5d00008          LDRB     r0,[r0,#8]
;;;298    }
0002a0  e12fff1e          BX       lr
;;;299    
                          ENDP

                  boGA_CmdListFinished PROC
;;;300    /* ....................................................................... */
;;;301    bool_t boGA_CmdListFinished(void)
0002a4  e59f16e0          LDR      r1,|L1.2444|
;;;302    {
;;;303        bool_t boRes;
;;;304        boRes = ( 0x01 == biGetGASR_CSLEF() )? C_TRUE : C_FALSE;
0002a8  e5d11008          LDRB     r1,[r1,#8]
0002ac  e7e001d1          UBFX     r0,r1,#3,#1
;;;305        return (boRes);
;;;306    }
0002b0  e12fff1e          BX       lr
;;;307    
                          ENDP

                  boGA_CmdListError PROC
;;;308    /* ....................................................................... */
;;;309    bool_t boGA_CmdListError(void)
0002b4  e59f16d0          LDR      r1,|L1.2444|
;;;310    {
;;;311        bool_t boRes;
;;;312        boRes = ( 0x01 == biGetGASR_CSCEF() )? C_TRUE : C_FALSE;
0002b8  e5d11008          LDRB     r1,[r1,#8]
0002bc  e7e00151          UBFX     r0,r1,#2,#1
;;;313        return (boRes);
;;;314    }
0002c0  e12fff1e          BX       lr
;;;315    
                          ENDP

                  boGA_CmdReg_IsBusy PROC
;;;316    /* ....................................................................... */
;;;317    bool_t boGA_CmdReg_IsBusy(void)
0002c4  e59f16c0          LDR      r1,|L1.2444|
;;;318    {
;;;319        bool_t boRes;
;;;320        boRes = ( 0x01 == biGetGASR_BUSY() )? C_TRUE : C_FALSE;
0002c8  e5d11008          LDRB     r1,[r1,#8]
0002cc  e2010001          AND      r0,r1,#1
;;;321        return (boRes);
;;;322    }
0002d0  e12fff1e          BX       lr
;;;323    
                          ENDP

                  u32GA_GetIrqCause PROC
;;;324    /* ....................................................................... */
;;;325    uint32_t u32GA_GetIrqCause(void)
0002d4  e59f16b0          LDR      r1,|L1.2444|
;;;326    {
;;;327        uint32_t u32Result;
;;;328        
;;;329        u32Result = u32GetGAICR();
0002d8  e591000c          LDR      r0,[r1,#0xc]
;;;330        
;;;331        return u32Result;
;;;332    }
0002dc  e12fff1e          BX       lr
;;;333    
                          ENDP

                  vGA_ClearIrqCause PROC
;;;334    /* ....................................................................... */
;;;335    void vGA_ClearIrqCause(uint32_t u32CauseMask)
0002e0  e3c01002          BIC      r1,r0,#2
;;;336    {
;;;337        /* set bit 1 to o, since these bit is Read Only: */
;;;338        vSetGAICR(u32CauseMask & GA_IRQ_CLR_ALL);
0002e4  e59f26a0          LDR      r2,|L1.2444|
0002e8  e582100c          STR      r1,[r2,#0xc]
;;;339    }
0002ec  e12fff1e          BX       lr
;;;340    
                          ENDP

                  vGA_SetIrqMask PROC
;;;341    /* ....................................................................... */
;;;342    void vGA_SetIrqMask(uint32_t u32Mask)
0002f0  e3c01002          BIC      r1,r0,#2
;;;343    {
;;;344      /* set bit 1 to o, since these bit is Read Only: */
;;;345        vSetGAIMR(u32Mask & GA_IRQ_CLR_ALL);
0002f4  e59f2690          LDR      r2,|L1.2444|
0002f8  e5821010          STR      r1,[r2,#0x10]
;;;346    }
0002fc  e12fff1e          BX       lr
;;;347    
                          ENDP

                  vGA_EnableUserIrq PROC
;;;348    /* ....................................................................... */
;;;349    void vGA_EnableUserIrq(uint8_t u8Number, ga_en_e eEn)
000300  e92d4030          PUSH     {r4,r5,lr}
;;;350    {
000304  e1a02001          MOV      r2,r1
;;;351        uint32_t  u32GAIMR_CSLUIM;
;;;352        uint32_t  u32NewVal; 
;;;353    
;;;354        /* invalid parameter: */
;;;355        if (u8Number <= 23) 
000308  e3500017          CMP      r0,#0x17
00030c  ca000011          BGT      |L1.856|
;;;356        {
;;;357            u32GAIMR_CSLUIM = biGetGAIMR_CSLUIM();  
000310  e59f4674          LDR      r4,|L1.2444|
000314  e5944010          LDR      r4,[r4,#0x10]
000318  e1a01424          LSR      r1,r4,#8
;;;358    
;;;359            u32NewVal = (eEn== GA_EN)? 1<<u8Number : 0;
00031c  e3520001          CMP      r2,#1
000320  1a000002          BNE      |L1.816|
000324  e3a04001          MOV      r4,#1
000328  e1a04014          LSL      r4,r4,r0
00032c  ea000000          B        |L1.820|
                  |L1.816|
000330  e3a04000          MOV      r4,#0
                  |L1.820|
000334  e1a03004          MOV      r3,r4
;;;360        
;;;361            /* clear bit: */
;;;362            u32GAIMR_CSLUIM &= ~(1<<u8Number);
000338  e3a04001          MOV      r4,#1
00033c  e1c11014          BIC      r1,r1,r4,LSL r0
;;;363        
;;;364            /* modify bit: */
;;;365            u32GAIMR_CSLUIM |= u32NewVal;
000340  e1811003          ORR      r1,r1,r3
;;;366        
;;;367            vSetGAIMR_CSLUIM(u32GAIMR_CSLUIM);
000344  e59f4640          LDR      r4,|L1.2444|
000348  e5944010          LDR      r4,[r4,#0x10]
00034c  e7df4411          BFI      r4,r1,#8,#24
000350  e59f5634          LDR      r5,|L1.2444|
000354  e5854010          STR      r4,[r5,#0x10]
                  |L1.856|
;;;368        }
;;;369        
;;;370        return;
;;;371    }
000358  e8bd8030          POP      {r4,r5,pc}
;;;372    
                          ENDP

                  vGA_CmdReg_EnableIrqCmdEnd PROC
;;;373    /* ....................................................................... */
;;;374    void vGA_CmdReg_EnableIrqCmdEnd(ga_en_e eEn)
00035c  e59f1628          LDR      r1,|L1.2444|
;;;375    {
;;;376        vSetGAIMR_GACENDIM((uint8_t) eEn);
000360  e5911010          LDR      r1,[r1,#0x10]
000364  e7c01010          BFI      r1,r0,#0,#1
000368  e59f261c          LDR      r2,|L1.2444|
00036c  e5821010          STR      r1,[r2,#0x10]
;;;377    }
000370  e12fff1e          BX       lr
;;;378    
                          ENDP

                  vGA_CmdReg_ClearIrqCmdEnd PROC
;;;379    /* ....................................................................... */
;;;380    void vGA_CmdReg_ClearIrqCmdEnd(void)
000374  e59f0610          LDR      r0,|L1.2444|
;;;381    {
;;;382        vClrGAICR_GACENDI();
000378  e590000c          LDR      r0,[r0,#0xc]
00037c  e3c00001          BIC      r0,r0,#1
000380  e2800001          ADD      r0,r0,#1
000384  e59f1600          LDR      r1,|L1.2444|
000388  e581000c          STR      r0,[r1,#0xc]
;;;383    }
00038c  e12fff1e          BX       lr
;;;384    
                          ENDP

                  vGA_EnableIrqCSCEI PROC
;;;385    /* ....................................................................... */
;;;386    void vGA_EnableIrqCSCEI(ga_en_e eEn)
000390  e59f15f4          LDR      r1,|L1.2444|
;;;387    {
;;;388        vSetGAIMR_CSCEIM((uint8_t) eEn);
000394  e5911010          LDR      r1,[r1,#0x10]
000398  e7c21110          BFI      r1,r0,#2,#1
00039c  e59f25e8          LDR      r2,|L1.2444|
0003a0  e5821010          STR      r1,[r2,#0x10]
;;;389    }
0003a4  e12fff1e          BX       lr
;;;390    
                          ENDP

                  vGA_ClearIrqCSCEI PROC
;;;391    /* ....................................................................... */
;;;392    void vGA_ClearIrqCSCEI(void)
0003a8  e59f05dc          LDR      r0,|L1.2444|
;;;393    {
;;;394        vClrGAICR_CSCEI();
0003ac  e590000c          LDR      r0,[r0,#0xc]
0003b0  e3c00004          BIC      r0,r0,#4
0003b4  e2800004          ADD      r0,r0,#4
0003b8  e59f15cc          LDR      r1,|L1.2444|
0003bc  e581000c          STR      r0,[r1,#0xc]
;;;395    }
0003c0  e12fff1e          BX       lr
;;;396    
                          ENDP

                  vGA_EnableIrqCSLEI PROC
;;;397    /* ....................................................................... */
;;;398    void vGA_EnableIrqCSLEI(ga_en_e eEn)
0003c4  e59f15c0          LDR      r1,|L1.2444|
;;;399    {
;;;400        vSetGAIMR_CSLEIM((uint8_t) eEn);
0003c8  e5911010          LDR      r1,[r1,#0x10]
0003cc  e7c31190          BFI      r1,r0,#3,#1
0003d0  e59f25b4          LDR      r2,|L1.2444|
0003d4  e5821010          STR      r1,[r2,#0x10]
;;;401    }
0003d8  e12fff1e          BX       lr
;;;402    
                          ENDP

                  vGA_ClearIrqCSLEI PROC
;;;403    /* ....................................................................... */
;;;404    void vGA_ClearIrqCSLEI(void)
0003dc  e59f05a8          LDR      r0,|L1.2444|
;;;405    {
;;;406        vClrGAICR_CSLEI();
0003e0  e590000c          LDR      r0,[r0,#0xc]
0003e4  e3c00008          BIC      r0,r0,#8
0003e8  e2800008          ADD      r0,r0,#8
0003ec  e59f1598          LDR      r1,|L1.2444|
0003f0  e581000c          STR      r0,[r1,#0xc]
;;;407    }
0003f4  e12fff1e          BX       lr
;;;408    
                          ENDP

                  vGA_SetGADelay PROC
;;;409    /* ....................................................................... */
;;;410    void vGA_SetGADelay(uint16_t u16Delay)
0003f8  e59f158c          LDR      r1,|L1.2444|
;;;411    {
;;;412        vSetGADR((uint32_t) u16Delay);
0003fc  e1c101b4          STRH     r0,[r1,#0x14]
;;;413    }
000400  e12fff1e          BX       lr
;;;414    
                          ENDP

                  vGA_EnableIrqGAWBWI PROC
;;;420    /* ....................................................................... */
;;;421    void vGA_EnableIrqGAWBWI(ga_en_e eEn)
000404  e59f1580          LDR      r1,|L1.2444|
;;;422    {
;;;423        vSetGAIMR_GAWBWIM((uint8_t) eEn);
000408  e5911010          LDR      r1,[r1,#0x10]
00040c  e7c41210          BFI      r1,r0,#4,#1
000410  e59f2574          LDR      r2,|L1.2444|
000414  e5821010          STR      r1,[r2,#0x10]
;;;424    }
000418  e12fff1e          BX       lr
;;;425    
                          ENDP

                  vGA_ClearIrqGAWBWI PROC
;;;426    /* ....................................................................... */
;;;427    void vGA_ClearIrqGAWBWI(void)
00041c  e59f0568          LDR      r0,|L1.2444|
;;;428    {
;;;429        vClrGAICR_GAWBWI();
000420  e590000c          LDR      r0,[r0,#0xc]
000424  e3c00010          BIC      r0,r0,#0x10
000428  e2800010          ADD      r0,r0,#0x10
00042c  e59f1558          LDR      r1,|L1.2444|
000430  e581000c          STR      r0,[r1,#0xc]
;;;430    }
000434  e12fff1e          BX       lr
;;;431    
                          ENDP

                  vGA_EnableIrqGAWBRI PROC
;;;432    /* ....................................................................... */
;;;433    void vGA_EnableIrqGAWBRI(ga_en_e eEn)
000438  e59f154c          LDR      r1,|L1.2444|
;;;434    {
;;;435        vSetGAIMR_GAWBRIM((uint8_t) eEn);
00043c  e5911010          LDR      r1,[r1,#0x10]
000440  e7c51290          BFI      r1,r0,#5,#1
000444  e59f2540          LDR      r2,|L1.2444|
000448  e5821010          STR      r1,[r2,#0x10]
;;;436    }
00044c  e12fff1e          BX       lr
;;;437    /* ....................................................................... */
                          ENDP

                  vGA_ClearIrqGAWBRI PROC
;;;438    void vGA_ClearIrqGAWBRI(void)
000450  e59f0534          LDR      r0,|L1.2444|
;;;439    {
;;;440        vClrGAICR_GAWBRI();
000454  e590000c          LDR      r0,[r0,#0xc]
000458  e3c00020          BIC      r0,r0,#0x20
00045c  e2800020          ADD      r0,r0,#0x20
000460  e59f1524          LDR      r1,|L1.2444|
000464  e581000c          STR      r0,[r1,#0xc]
;;;441    }
000468  e12fff1e          BX       lr
;;;442    
                          ENDP

                  vGA_EnableIrqGACBI PROC
;;;443    /* ....................................................................... */
;;;444    void vGA_EnableIrqGACBI(ga_en_e eEn)
00046c  e59f1518          LDR      r1,|L1.2444|
;;;445    {
;;;446        vSetGAIMR_GACBIM((uint8_t) eEn);
000470  e5911010          LDR      r1,[r1,#0x10]
000474  e7c61310          BFI      r1,r0,#6,#1
000478  e59f250c          LDR      r2,|L1.2444|
00047c  e5821010          STR      r1,[r2,#0x10]
;;;447    }
000480  e12fff1e          BX       lr
;;;448    
                          ENDP

                  vGA_ClearIrqGACBI PROC
;;;449    /* ....................................................................... */
;;;450    void vGA_ClearIrqGACBI(void)
000484  e59f0500          LDR      r0,|L1.2444|
;;;451    {
;;;452        vClrGAICR_GACBI();
000488  e590000c          LDR      r0,[r0,#0xc]
00048c  e3c00040          BIC      r0,r0,#0x40
000490  e2800040          ADD      r0,r0,#0x40
000494  e59f14f0          LDR      r1,|L1.2444|
000498  e581000c          STR      r0,[r1,#0xc]
;;;453    }
00049c  e12fff1e          BX       lr
;;;454    
                          ENDP

                  vGA_EnableIrqGARBI PROC
;;;455    /* ....................................................................... */
;;;456    void vGA_EnableIrqGARBI(ga_en_e eEn)
0004a0  e59f14e4          LDR      r1,|L1.2444|
;;;457    {
;;;458        vSetGAIMR_GARBIM((uint8_t) eEn);
0004a4  e5911010          LDR      r1,[r1,#0x10]
0004a8  e7c71390          BFI      r1,r0,#7,#1
0004ac  e59f24d8          LDR      r2,|L1.2444|
0004b0  e5821010          STR      r1,[r2,#0x10]
;;;459    }
0004b4  e12fff1e          BX       lr
;;;460    
                          ENDP

                  vGA_ClearIrqGARBI PROC
;;;461    /* ....................................................................... */
;;;462    void vGA_ClearIrqGARBI(void)
0004b8  e59f04cc          LDR      r0,|L1.2444|
;;;463    {
;;;464        vClrGAICR_GARBI();
0004bc  e590000c          LDR      r0,[r0,#0xc]
0004c0  e3c00080          BIC      r0,r0,#0x80
0004c4  e2800080          ADD      r0,r0,#0x80
0004c8  e59f14bc          LDR      r1,|L1.2444|
0004cc  e581000c          STR      r0,[r1,#0xc]
;;;465    }
0004d0  e12fff1e          BX       lr
;;;466    
                          ENDP

                  vGA_ClearUserIrq PROC
;;;467    /* ....................................................................... */
;;;468    void vGA_ClearUserIrq(uint8_t u8CmdListIntr)
0004d4  e3a01001          MOV      r1,#1
;;;469    
;;;470    {
;;;471        vClrGAICR_CSLUI(u8CmdListIntr);
0004d8  e1a01011          LSL      r1,r1,r0
0004dc  e59f24a8          LDR      r2,|L1.2444|
0004e0  e592200c          LDR      r2,[r2,#0xc]
0004e4  e7df2411          BFI      r2,r1,#8,#24
0004e8  e59f149c          LDR      r1,|L1.2444|
0004ec  e581200c          STR      r2,[r1,#0xc]
;;;472    }
0004f0  e12fff1e          BX       lr
;;;473    
                          ENDP

                  boGA_GetBusErrAddr PROC
;;;474    /* ....................................................................... */
;;;475    bool_t boGA_GetBusErrAddr(ga_bus_type_e eBusType, uint32_t* pu32BusErrAddr)
0004f4  e92d4010          PUSH     {r4,lr}
;;;476    {
0004f8  e1a03000          MOV      r3,r0
0004fc  e1a02001          MOV      r2,r1
;;;477        bool_t boRes = C_TRUE;
000500  e3a00001          MOV      r0,#1
;;;478        uint32_t u32BusErrAddr;
;;;479        
;;;480        if(0x00 != pu32BusErrAddr)
000504  e3520000          CMP      r2,#0
000508  0a000020          BEQ      |L1.1424|
;;;481        {
;;;482            switch( eBusType )
00050c  e3530000          CMP      r3,#0
000510  0a000006          BEQ      |L1.1328|
000514  e3530001          CMP      r3,#1
000518  0a000009          BEQ      |L1.1348|
00051c  e3530002          CMP      r3,#2
000520  0a00000c          BEQ      |L1.1368|
000524  e3530003          CMP      r3,#3
000528  1a000014          BNE      |L1.1408|
00052c  ea00000e          B        |L1.1388|
                  |L1.1328|
;;;483            {
;;;484                case GA_READ_BUF_BUS:
000530  e320f000          NOP      
;;;485                    /* GA Read Buffer Bus: */
;;;486                    u32BusErrAddr = (uint32_t) u32GetGARBBEAR();
000534  e59f4450          LDR      r4,|L1.2444|
000538  e5941020          LDR      r1,[r4,#0x20]
;;;487                    *pu32BusErrAddr = u32BusErrAddr;
00053c  e5821000          STR      r1,[r2,#0]
;;;488                    break;
000540  ea000011          B        |L1.1420|
                  |L1.1348|
;;;489                 
;;;490                case GA_CACHE_BUF_BUS:
000544  e320f000          NOP      
;;;491                    /* GA Cache Buffer Bus: */
;;;492                    u32BusErrAddr = (uint32_t) u32GetGACBBEAR();
000548  e59f443c          LDR      r4,|L1.2444|
00054c  e5941028          LDR      r1,[r4,#0x28]
;;;493                    *pu32BusErrAddr = u32BusErrAddr;
000550  e5821000          STR      r1,[r2,#0]
;;;494                    break;
000554  ea00000c          B        |L1.1420|
                  |L1.1368|
;;;495    
;;;496                case GA_WRITE_BUF_READ_BUS:
000558  e320f000          NOP      
;;;497                    /* GA Write Buffer Read Bus: */
;;;498                    u32BusErrAddr = (uint32_t) u32GetGAWBRBEAR();
00055c  e59f4428          LDR      r4,|L1.2444|
000560  e5941030          LDR      r1,[r4,#0x30]
;;;499                    *pu32BusErrAddr = u32BusErrAddr;
000564  e5821000          STR      r1,[r2,#0]
;;;500                    break;
000568  ea000007          B        |L1.1420|
                  |L1.1388|
;;;501    
;;;502                case GA_WRITE_BUF_WRITE_BUS:
00056c  e320f000          NOP      
;;;503                    /* GA Write Buffer Write Bus: */
;;;504                    u32BusErrAddr = (uint32_t) u32GetGAWBWBEAR();
000570  e59f4414          LDR      r4,|L1.2444|
000574  e5941038          LDR      r1,[r4,#0x38]
;;;505                    *pu32BusErrAddr = u32BusErrAddr;
000578  e5821000          STR      r1,[r2,#0]
;;;506                    break;
00057c  ea000002          B        |L1.1420|
                  |L1.1408|
;;;507    
;;;508                default:
000580  e320f000          NOP      
;;;509                    /* Invalid Bus Type */
;;;510                    boRes = C_FALSE;
000584  e3a00000          MOV      r0,#0
;;;511                    break;
000588  e320f000          NOP      
                  |L1.1420|
00058c  ea000000          B        |L1.1428|
                  |L1.1424|
;;;512            }      
;;;513        }
;;;514        else
;;;515        {
;;;516            boRes = C_FALSE;
000590  e3a00000          MOV      r0,#0
                  |L1.1428|
;;;517        }
;;;518        return  boRes;
;;;519    }
000594  e8bd8010          POP      {r4,pc}
;;;520    
                          ENDP

                  boGA_GetBusErrCtrlStatus PROC
;;;521    /* ....................................................................... */
;;;522    bool_t boGA_GetBusErrCtrlStatus(ga_bus_type_e eBusType, ga_bus_err_ctrl_st* pstCtrlStatus)
000598  e1a02000          MOV      r2,r0
;;;523    {
;;;524        bool_t boRes = C_TRUE;
00059c  e3a00001          MOV      r0,#1
;;;525        
;;;526        if(0x00 != pstCtrlStatus)
0005a0  e3510000          CMP      r1,#0
0005a4  0a000084          BEQ      |L1.1980|
;;;527        {
;;;528            switch( eBusType )
0005a8  e3520000          CMP      r2,#0
0005ac  0a000006          BEQ      |L1.1484|
0005b0  e3520001          CMP      r2,#1
0005b4  0a000022          BEQ      |L1.1604|
0005b8  e3520002          CMP      r2,#2
0005bc  0a00003e          BEQ      |L1.1724|
0005c0  e3520003          CMP      r2,#3
0005c4  1a000078          BNE      |L1.1964|
0005c8  ea000059          B        |L1.1844|
                  |L1.1484|
;;;529            {
;;;530                case GA_READ_BUF_BUS:
0005cc  e320f000          NOP      
;;;531                    /* GA Read Buffer Bus: */
;;;532                    pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGARBBECR_WR();
0005d0  e59f33b4          LDR      r3,|L1.2444|
0005d4  e5933024          LDR      r3,[r3,#0x24]
0005d8  e2033001          AND      r3,r3,#1
0005dc  e5c13000          STRB     r3,[r1,#0]
;;;533                    pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGARBBECR_BTYPE();
0005e0  e59f33a4          LDR      r3,|L1.2444|
0005e4  e5933024          LDR      r3,[r3,#0x24]
0005e8  e7e030d3          UBFX     r3,r3,#1,#1
0005ec  e5c13001          STRB     r3,[r1,#1]
;;;534                    pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGARBBECR_BSIZE();
0005f0  e59f3394          LDR      r3,|L1.2444|
0005f4  e5933024          LDR      r3,[r3,#0x24]
0005f8  e7e23153          UBFX     r3,r3,#2,#3
0005fc  e5c13002          STRB     r3,[r1,#2]
;;;535                    pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGARBBECR_RTYPE();
000600  e59f3384          LDR      r3,|L1.2444|
000604  e5933024          LDR      r3,[r3,#0x24]
000608  e7e132d3          UBFX     r3,r3,#5,#2
00060c  e5c13003          STRB     r3,[r1,#3]
;;;536                    pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGARBBECR_BEN();
000610  e59f3374          LDR      r3,|L1.2444|
000614  e5933024          LDR      r3,[r3,#0x24]
000618  e1a03423          LSR      r3,r3,#8
00061c  e5c13004          STRB     r3,[r1,#4]
;;;537                    pstCtrlStatus->u8ID          = (uint8_t) biGetGARBBECR_ID();
000620  e59f3364          LDR      r3,|L1.2444|
000624  e5933024          LDR      r3,[r3,#0x24]
000628  e7e33853          UBFX     r3,r3,#16,#4
00062c  e5c13005          STRB     r3,[r1,#5]
;;;538                    pstCtrlStatus->u8BurstLength = (uint8_t) biGetGARBBECR_LEN();
000630  e59f3354          LDR      r3,|L1.2444|
000634  e5933024          LDR      r3,[r3,#0x24]
000638  e7e33a53          UBFX     r3,r3,#20,#4
00063c  e5c13006          STRB     r3,[r1,#6]
;;;539                    break;
000640  ea00005c          B        |L1.1976|
                  |L1.1604|
;;;540    
;;;541                case GA_CACHE_BUF_BUS:
000644  e320f000          NOP      
;;;542                    /* GA Cache Buffer Bus: */
;;;543                    pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGACBBECR_WR();
000648  e59f333c          LDR      r3,|L1.2444|
00064c  e593302c          LDR      r3,[r3,#0x2c]
000650  e2033001          AND      r3,r3,#1
000654  e5c13000          STRB     r3,[r1,#0]
;;;544                    pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGACBBECR_BTYPE();
000658  e59f332c          LDR      r3,|L1.2444|
00065c  e593302c          LDR      r3,[r3,#0x2c]
000660  e7e030d3          UBFX     r3,r3,#1,#1
000664  e5c13001          STRB     r3,[r1,#1]
;;;545                    pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGACBBECR_BSIZE();
000668  e59f331c          LDR      r3,|L1.2444|
00066c  e593302c          LDR      r3,[r3,#0x2c]
000670  e7e23153          UBFX     r3,r3,#2,#3
000674  e5c13002          STRB     r3,[r1,#2]
;;;546                    pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGACBBECR_RTYPE();
000678  e59f330c          LDR      r3,|L1.2444|
00067c  e593302c          LDR      r3,[r3,#0x2c]
000680  e7e132d3          UBFX     r3,r3,#5,#2
000684  e5c13003          STRB     r3,[r1,#3]
;;;547                    pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGACBBECR_BEN();
000688  e59f32fc          LDR      r3,|L1.2444|
00068c  e593302c          LDR      r3,[r3,#0x2c]
000690  e1a03423          LSR      r3,r3,#8
000694  e5c13004          STRB     r3,[r1,#4]
;;;548                    pstCtrlStatus->u8ID          = (uint8_t) biGetGACBBECR_ID();
000698  e59f32ec          LDR      r3,|L1.2444|
00069c  e593302c          LDR      r3,[r3,#0x2c]
0006a0  e7e33853          UBFX     r3,r3,#16,#4
0006a4  e5c13005          STRB     r3,[r1,#5]
;;;549                    pstCtrlStatus->u8BurstLength = (uint8_t) biGetGACBBECR_LEN();
0006a8  e59f32dc          LDR      r3,|L1.2444|
0006ac  e593302c          LDR      r3,[r3,#0x2c]
0006b0  e7e33a53          UBFX     r3,r3,#20,#4
0006b4  e5c13006          STRB     r3,[r1,#6]
;;;550                    break;
0006b8  ea00003e          B        |L1.1976|
                  |L1.1724|
;;;551    
;;;552                case GA_WRITE_BUF_READ_BUS:
0006bc  e320f000          NOP      
;;;553                    /* GA Write Buffer Read Bus: */
;;;554                    pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGAWBRBECR_WR();
0006c0  e59f32c4          LDR      r3,|L1.2444|
0006c4  e5933034          LDR      r3,[r3,#0x34]
0006c8  e2033001          AND      r3,r3,#1
0006cc  e5c13000          STRB     r3,[r1,#0]
;;;555                    pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGAWBRBECR_BTYPE();
0006d0  e59f32b4          LDR      r3,|L1.2444|
0006d4  e5933034          LDR      r3,[r3,#0x34]
0006d8  e7e030d3          UBFX     r3,r3,#1,#1
0006dc  e5c13001          STRB     r3,[r1,#1]
;;;556                    pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGAWBRBECR_BSIZE();
0006e0  e59f32a4          LDR      r3,|L1.2444|
0006e4  e5933034          LDR      r3,[r3,#0x34]
0006e8  e7e23153          UBFX     r3,r3,#2,#3
0006ec  e5c13002          STRB     r3,[r1,#2]
;;;557                    pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGAWBRBECR_RTYPE();
0006f0  e59f3294          LDR      r3,|L1.2444|
0006f4  e5933034          LDR      r3,[r3,#0x34]
0006f8  e7e132d3          UBFX     r3,r3,#5,#2
0006fc  e5c13003          STRB     r3,[r1,#3]
;;;558                    pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGAWBRBECR_BEN();
000700  e59f3284          LDR      r3,|L1.2444|
000704  e5933034          LDR      r3,[r3,#0x34]
000708  e1a03423          LSR      r3,r3,#8
00070c  e5c13004          STRB     r3,[r1,#4]
;;;559                    pstCtrlStatus->u8ID          = (uint8_t) biGetGAWBRBECR_ID();
000710  e59f3274          LDR      r3,|L1.2444|
000714  e5933034          LDR      r3,[r3,#0x34]
000718  e7e33853          UBFX     r3,r3,#16,#4
00071c  e5c13005          STRB     r3,[r1,#5]
;;;560                    pstCtrlStatus->u8BurstLength = (uint8_t) biGetGAWBRBECR_LEN();
000720  e59f3264          LDR      r3,|L1.2444|
000724  e5933034          LDR      r3,[r3,#0x34]
000728  e7e33a53          UBFX     r3,r3,#20,#4
00072c  e5c13006          STRB     r3,[r1,#6]
;;;561                    break;
000730  ea000020          B        |L1.1976|
                  |L1.1844|
;;;562    
;;;563                case GA_WRITE_BUF_WRITE_BUS:
000734  e320f000          NOP      
;;;564                    /* GA Write Buffer Write Bus: */
;;;565                    pstCtrlStatus->eDirection    = (ga_buserr_dir_e) biGetGAWBWBECR_WR();
000738  e59f324c          LDR      r3,|L1.2444|
00073c  e593303c          LDR      r3,[r3,#0x3c]
000740  e2033001          AND      r3,r3,#1
000744  e5c13000          STRB     r3,[r1,#0]
;;;566                    pstCtrlStatus->eBurstType    = (ga_buserr_bursttype) biGetGAWBWBECR_BTYPE();
000748  e59f323c          LDR      r3,|L1.2444|
00074c  e593303c          LDR      r3,[r3,#0x3c]
000750  e7e030d3          UBFX     r3,r3,#1,#1
000754  e5c13001          STRB     r3,[r1,#1]
;;;567                    pstCtrlStatus->eBurstSize    = (ga_buserr_burstsize) biGetGAWBWBECR_BSIZE();
000758  e59f322c          LDR      r3,|L1.2444|
00075c  e593303c          LDR      r3,[r3,#0x3c]
000760  e7e23153          UBFX     r3,r3,#2,#3
000764  e5c13002          STRB     r3,[r1,#2]
;;;568                    pstCtrlStatus->eRespType     = (ga_buserr_resptype) biGetGAWBWBECR_RTYPE();
000768  e59f321c          LDR      r3,|L1.2444|
00076c  e593303c          LDR      r3,[r3,#0x3c]
000770  e7e132d3          UBFX     r3,r3,#5,#2
000774  e5c13003          STRB     r3,[r1,#3]
;;;569                    pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGAWBWBECR_BEN();
000778  e59f320c          LDR      r3,|L1.2444|
00077c  e593303c          LDR      r3,[r3,#0x3c]
000780  e1a03423          LSR      r3,r3,#8
000784  e5c13004          STRB     r3,[r1,#4]
;;;570                    pstCtrlStatus->u8ID          = (uint8_t) biGetGAWBWBECR_ID();
000788  e59f31fc          LDR      r3,|L1.2444|
00078c  e593303c          LDR      r3,[r3,#0x3c]
000790  e7e33853          UBFX     r3,r3,#16,#4
000794  e5c13005          STRB     r3,[r1,#5]
;;;571                    pstCtrlStatus->u8BurstLength = (uint8_t) biGetGAWBWBECR_LEN();
000798  e59f31ec          LDR      r3,|L1.2444|
00079c  e593303c          LDR      r3,[r3,#0x3c]
0007a0  e7e33a53          UBFX     r3,r3,#20,#4
0007a4  e5c13006          STRB     r3,[r1,#6]
;;;572                    break;
0007a8  ea000002          B        |L1.1976|
                  |L1.1964|
;;;573    
;;;574                default:
0007ac  e320f000          NOP      
;;;575                    /* Invalid Bus Type */
;;;576                    boRes = C_FALSE;
0007b0  e3a00000          MOV      r0,#0
;;;577                    break;
0007b4  e320f000          NOP      
                  |L1.1976|
0007b8  ea000000          B        |L1.1984|
                  |L1.1980|
;;;578            }      
;;;579        }
;;;580        else
;;;581        {
;;;582            boRes = C_FALSE;
0007bc  e3a00000          MOV      r0,#0
                  |L1.1984|
;;;583        }
;;;584        return  boRes;
;;;585    }
0007c0  e12fff1e          BX       lr
;;;586    
                          ENDP

                  boGA_SetMemoryProtRegionAddr PROC
;;;587    /* ....................................................................... */
;;;588    bool_t boGA_SetMemoryProtRegionAddr(ga_memory_region_e eRegion, uint32_t u32LowAddress, uint32_t u32HighAddress)
0007c4  e92d4030          PUSH     {r4,r5,lr}
;;;589    {
0007c8  e1a03000          MOV      r3,r0
;;;590        bool_t boRes = C_TRUE;
0007cc  e3a00001          MOV      r0,#1
0007d0  e1a04001          MOV      r4,r1
;;;591        
;;;592         /* Th memory regions are defined with a granularity of 4KB:
;;;593            check addresses: */    
;;;594        if ( (0x00 ==(u32LowAddress & GA_PROT_REGION_MASK)) && (0xFFF ==(u32HighAddress & GA_PROT_REGION_MASK)) )
0007d4  e7df461f          BFC      r4,#12,#20
0007d8  e3540000          CMP      r4,#0
0007dc  1a000017          BNE      |L1.2112|
0007e0  e1a04002          MOV      r4,r2
0007e4  e7df461f          BFC      r4,#12,#20
0007e8  e3005fff          MOV      r5,#0xfff
0007ec  e1540005          CMP      r4,r5
0007f0  1a000012          BNE      |L1.2112|
;;;595        {
;;;596            switch( eRegion )
0007f4  e3530000          CMP      r3,#0
0007f8  0a000002          BEQ      |L1.2056|
0007fc  e3530001          CMP      r3,#1
000800  1a00000a          BNE      |L1.2096|
000804  ea000004          B        |L1.2076|
                  |L1.2056|
;;;597            {
;;;598                case GA_MEMORY_PROT_REGION_0:
000808  e320f000          NOP      
;;;599                    /* GA Read Buffer Bus: */
;;;600                    vSetGAMPR0LR(u32LowAddress);
00080c  e59f4178          LDR      r4,|L1.2444|
000810  e5841040          STR      r1,[r4,#0x40]
;;;601                    vSetGAMPR0HR(u32HighAddress);
000814  e5842044          STR      r2,[r4,#0x44]
;;;602                    break;
000818  ea000007          B        |L1.2108|
                  |L1.2076|
;;;603                 
;;;604                case GA_MEMORY_PROT_REGION_1:
00081c  e320f000          NOP      
;;;605                    /* GA Read Buffer Bus: */
;;;606                    vSetGAMPR1LR(u32LowAddress);
000820  e59f4164          LDR      r4,|L1.2444|
000824  e5841048          STR      r1,[r4,#0x48]
;;;607                    vSetGAMPR1HR(u32HighAddress);
000828  e584204c          STR      r2,[r4,#0x4c]
;;;608                    break;
00082c  ea000002          B        |L1.2108|
                  |L1.2096|
;;;609    
;;;610                default:
000830  e320f000          NOP      
;;;611                    /* Invalid Bus Type */
;;;612                    boRes = C_FALSE;
000834  e3a00000          MOV      r0,#0
;;;613                    break;
000838  e320f000          NOP      
                  |L1.2108|
00083c  ea000000          B        |L1.2116|
                  |L1.2112|
;;;614            }
;;;615        }
;;;616        else
;;;617        {
;;;618            boRes = C_FALSE;
000840  e3a00000          MOV      r0,#0
                  |L1.2116|
;;;619        }
;;;620        return  boRes;
;;;621    }
000844  e8bd8030          POP      {r4,r5,pc}
;;;622    
                          ENDP

                  vGA_EnableMemoryProtecConfigIrq PROC
;;;623    /* ....................................................................... */
;;;624    void vGA_EnableMemoryProtecConfigIrq(ga_en_e eEn)
000848  e59f113c          LDR      r1,|L1.2444|
;;;625    {
;;;626        vSetGAMPIMR_GAMPCIM((uint8_t) eEn);
00084c  e5d11054          LDRB     r1,[r1,#0x54]
000850  e7c11090          BFI      r1,r0,#1,#1
000854  e59f2130          LDR      r2,|L1.2444|
000858  e5c21054          STRB     r1,[r2,#0x54]
;;;627    }
00085c  e12fff1e          BX       lr
;;;628    
                          ENDP

                  vGA_EnableMemoryProtecAccessIrq PROC
;;;629    /* ....................................................................... */
;;;630    void vGA_EnableMemoryProtecAccessIrq(ga_en_e eEn)
000860  e59f1124          LDR      r1,|L1.2444|
;;;631    {
;;;632        vSetGAMPIMR_GAMPIM((uint8_t) eEn);
000864  e5d11054          LDRB     r1,[r1,#0x54]
000868  e7c01010          BFI      r1,r0,#0,#1
00086c  e59f2118          LDR      r2,|L1.2444|
000870  e5c21054          STRB     r1,[r2,#0x54]
;;;633    }
000874  e12fff1e          BX       lr
;;;634    
                          ENDP

                  vGA_ClearMemoryProtecConfigIrq PROC
;;;635    /* ....................................................................... */
;;;636    void vGA_ClearMemoryProtecConfigIrq(void)
000878  e59f010c          LDR      r0,|L1.2444|
;;;637    {
;;;638        vClrGAMPICR_GAMPCI();
00087c  e5d00050          LDRB     r0,[r0,#0x50]
000880  e3c00002          BIC      r0,r0,#2
000884  e2800002          ADD      r0,r0,#2
000888  e59f10fc          LDR      r1,|L1.2444|
00088c  e5c10050          STRB     r0,[r1,#0x50]
;;;639    }
000890  e12fff1e          BX       lr
;;;640    
                          ENDP

                  vGA_ClearMemoryProtecAccessIrq PROC
;;;641    /* ....................................................................... */
;;;642    void vGA_ClearMemoryProtecAccessIrq(void)
000894  e59f00f0          LDR      r0,|L1.2444|
;;;643    {
;;;644        vClrGAMPICR_GAMPI();
000898  e5d00050          LDRB     r0,[r0,#0x50]
00089c  e3c00001          BIC      r0,r0,#1
0008a0  e2800001          ADD      r0,r0,#1
0008a4  e59f10e0          LDR      r1,|L1.2444|
0008a8  e5c10050          STRB     r0,[r1,#0x50]
;;;645    }
0008ac  e12fff1e          BX       lr
;;;646    
                          ENDP

                  u32GA_GetMemoryProtecErr_CaptAddr PROC
;;;648    /* ....................................................................... */
;;;649    uint32_t u32GA_GetMemoryProtecErr_CaptAddr(void)
0008b0  e59f10d4          LDR      r1,|L1.2444|
;;;650    {
;;;651        uint32_t u32Addr;
;;;652        
;;;653        u32Addr = u32GetGAMPACR();
0008b4  e5910058          LDR      r0,[r1,#0x58]
;;;654        
;;;655        return (u32Addr);
;;;656    }
0008b8  e12fff1e          BX       lr
;;;657    
                          ENDP

                  boGA_SetGeneralPurposeRegister PROC
;;;659    /* ....................................................................... */
;;;660    bool_t boGA_SetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t u32RegValue)
0008bc  e92d4010          PUSH     {r4,lr}
;;;661    {
0008c0  e1a02000          MOV      r2,r0
;;;662        bool_t   boRes = C_TRUE;
0008c4  e3a00001          MOV      r0,#1
;;;663        uint32_t u32Res;
;;;664        
;;;665        u32Res = (uint32_t)biGetGASR_BUSY();
0008c8  e59f40bc          LDR      r4,|L1.2444|
0008cc  e5d44008          LDRB     r4,[r4,#8]
0008d0  e2043001          AND      r3,r4,#1
;;;666        /* check parameters and if GA is not busy: */
;;;667        if ( (u8RegNo > 31) || (0x00U != u32Res ) )
0008d4  e352001f          CMP      r2,#0x1f
0008d8  ca000001          BGT      |L1.2276|
0008dc  e3530000          CMP      r3,#0
0008e0  0a000001          BEQ      |L1.2284|
                  |L1.2276|
;;;668        {
;;;669            boRes = C_FALSE;
0008e4  e3a00000          MOV      r0,#0
0008e8  ea000002          B        |L1.2296|
                  |L1.2284|
;;;670        }
;;;671        else
;;;672        {
;;;673            vSetGAGPR(u8RegNo, u32RegValue);
0008ec  e1a04102          LSL      r4,r2,#2
0008f0  e24445fd          SUB      r4,r4,#0x3f400000
0008f4  e5841080          STR      r1,[r4,#0x80]
                  |L1.2296|
;;;674        }
;;;675        return (boRes);
;;;676    }
0008f8  e8bd8010          POP      {r4,pc}
;;;677    
                          ENDP

                  boGA_GetGeneralPurposeRegister PROC
;;;679    /* ....................................................................... */
;;;680    bool_t boGA_GetGeneralPurposeRegister (uint8_t u8RegNo, uint32_t* pu32RegValue)
0008fc  e92d4010          PUSH     {r4,lr}
;;;681    {
000900  e1a02000          MOV      r2,r0
;;;682        bool_t    boRes = C_TRUE;
000904  e3a00001          MOV      r0,#1
;;;683        uint32_t  u32Value;
;;;684        
;;;685        /* check parameters: */
;;;686        if ( (u8RegNo > 31) || (0x00U == pu32RegValue) )
000908  e352001f          CMP      r2,#0x1f
00090c  ca000001          BGT      |L1.2328|
000910  e3510000          CMP      r1,#0
000914  1a000001          BNE      |L1.2336|
                  |L1.2328|
;;;687        {
;;;688            boRes = C_FALSE;
000918  e3a00000          MOV      r0,#0
00091c  ea000003          B        |L1.2352|
                  |L1.2336|
;;;689        }
;;;690        else
;;;691        {
;;;692            u32Value = u32GetGAGPR(u8RegNo);
000920  e1a04102          LSL      r4,r2,#2
000924  e24445fd          SUB      r4,r4,#0x3f400000
000928  e5943080          LDR      r3,[r4,#0x80]
;;;693            *pu32RegValue = u32Value;
00092c  e5813000          STR      r3,[r1,#0]
                  |L1.2352|
;;;694        }
;;;695        return (boRes);
;;;696    }
000930  e8bd8010          POP      {r4,pc}
;;;697    
                          ENDP

                  boGA_SetCommandRegisterLowHigh PROC
;;;699    /* ....................................................................... */
;;;700    bool_t boGA_SetCommandRegisterLowHigh (uint32_t u32LowValue,  uint32_t u32HighValue)
000934  e1a02000          MOV      r2,r0
;;;701    {
;;;702        bool_t boRes = C_TRUE;
000938  e3a00001          MOV      r0,#1
;;;703        
;;;704        /* check if GA is not busy: */
;;;705        if (0x00U != biGetGASR_BUSY() )
00093c  e59f3048          LDR      r3,|L1.2444|
000940  e5d33008          LDRB     r3,[r3,#8]
000944  e2033001          AND      r3,r3,#1
000948  e3530000          CMP      r3,#0
00094c  0a000001          BEQ      |L1.2392|
;;;706        {
;;;707            boRes = C_FALSE;
000950  e3a00000          MOV      r0,#0
000954  ea000002          B        |L1.2404|
                  |L1.2392|
;;;708        }
;;;709        else
;;;710        {
;;;711            /* it is important to write first the low register!: */
;;;712            vSetGACMDL(u32LowValue);
000958  e59f302c          LDR      r3,|L1.2444|
00095c  e5832100          STR      r2,[r3,#0x100]
;;;713            
;;;714            /* then write high register!: */
;;;715            vSetGACMDH(u32HighValue);
000960  e5831104          STR      r1,[r3,#0x104]
                  |L1.2404|
;;;716    
;;;717        }
;;;718        return (boRes);
;;;719    }
000964  e12fff1e          BX       lr
;;;720    
                          ENDP

                  |L1.2408|
                          DCD      au8LLDD_GA_C_REVISION
                  |L1.2412|
                          DCD      au8LLDD_GA_C_TAG
                  |L1.2416|
                          DCD      au8LLDD_GA_H_REVISION
                  |L1.2420|
                          DCD      au8LLDD_GA_H_TAG
                  |L1.2424|
                          DCD      au8LLDD_GA_COMMON_H_REVISION
                  |L1.2428|
                          DCD      au8LLDD_GA_COMMON_H_TAG
                  |L1.2432|
                          DCD      au8LLDD_GA_IO_H_REVISION
                  |L1.2436|
                          DCD      au8LLDD_GA_IO_H_TAG
                  |L1.2440|
                          DCD      u32MaxUsedBuffSize
                  |L1.2444|
                          DCD      0xc0c00000
                  |L1.2448|
                          DCD      0x01ff0000
                  |L1.2452|
                          DCD      0x01020000
                  |L1.2456|
                          DCD      0x01030000

                          AREA ||.data||, DATA, ALIGN=2

                  au8LLDD_GA_C_REVISION
000000  24526576          DCB      0x24,0x52,0x65,0x76
000004  6973696f          DCB      0x69,0x73,0x69,0x6f
000008  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00000c  2e323020          DCB      0x2e,0x32,0x30,0x20
000010  2400              DCB      0x24,0x00
                  au8LLDD_GA_C_TAG
000012  244e              DCB      0x24,0x4e
000014  616d653a          DCB      0x61,0x6d,0x65,0x3a
000018  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00001c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000020  375f4746          DCB      0x37,0x5f,0x47,0x46
000024  58202400          DCB      0x58,0x20,0x24,0x00
                  au8LLDD_GA_H_REVISION
000028  24526576          DCB      0x24,0x52,0x65,0x76
00002c  6973696f          DCB      0x69,0x73,0x69,0x6f
000030  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000034  2e313920          DCB      0x2e,0x31,0x39,0x20
000038  2400              DCB      0x24,0x00
                  au8LLDD_GA_H_TAG
00003a  244e              DCB      0x24,0x4e
00003c  616d653a          DCB      0x61,0x6d,0x65,0x3a
000040  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000044  445f315f          DCB      0x44,0x5f,0x31,0x5f
000048  375f4746          DCB      0x37,0x5f,0x47,0x46
00004c  58202400          DCB      0x58,0x20,0x24,0x00
                  au8LLDD_GA_COMMON_H_REVISION
000050  24526576          DCB      0x24,0x52,0x65,0x76
000054  6973696f          DCB      0x69,0x73,0x69,0x6f
000058  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00005c  2e313420          DCB      0x2e,0x31,0x34,0x20
000060  2400              DCB      0x24,0x00
                  au8LLDD_GA_COMMON_H_TAG
000062  244e              DCB      0x24,0x4e
000064  616d653a          DCB      0x61,0x6d,0x65,0x3a
000068  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00006c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000070  375f4746          DCB      0x37,0x5f,0x47,0x46
000074  58202400          DCB      0x58,0x20,0x24,0x00
                  au8LLDD_GA_IO_H_REVISION
000078  24526576          DCB      0x24,0x52,0x65,0x76
00007c  6973696f          DCB      0x69,0x73,0x69,0x6f
000080  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000084  2e313220          DCB      0x2e,0x31,0x32,0x20
000088  2400              DCB      0x24,0x00
                  au8LLDD_GA_IO_H_TAG
00008a  244e              DCB      0x24,0x4e
00008c  616d653a          DCB      0x61,0x6d,0x65,0x3a
000090  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000094  445f315f          DCB      0x44,0x5f,0x31,0x5f
000098  375f4746          DCB      0x37,0x5f,0x47,0x46
00009c  58202400          DCB      0x58,0x20,0x24,0x00
                  u32MaxUsedBuffSize
                          DCD      0x00000000
