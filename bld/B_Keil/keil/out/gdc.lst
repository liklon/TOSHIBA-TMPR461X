L 1 "..\..\..\..\lldd\src\gdc.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Reference GDC Low Level Device Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphics Display Controller (GDC)
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.19 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "gdc_io.h"                         /* GDC registers, bits and access macros defintion */
L 1 "..\..\..\..\lldd\hdr\gdc_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : GDC 
N/  Date of creation (y-m-d:time): 2013-06-14+02:00  :  15:35:28.447+02:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.12 $ 
N/  Excel Sheet ver.             : vv1.9
N/  Excel Sheet date             : 2013-Apr-11
N/  Excel Sheet author           : ZUL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION : GDC low level driver io-header file
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : GDC
N*   LIBRARIES   : None
N*****************************************************************************
N*   VERSION     : $Revision: 1.12 $ 
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N
N
N#ifndef GDC_IO_H
N#define GDC_IO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"                      /* Core specific primitive type definitions */
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 39 "..\..\..\..\lldd\hdr\gdc_io.h" 2
N
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 230    /* Rule 6.4 [R] : nonstandard type for a bit field */
S  #pragma ghs nowarning 1840   /* Rule 5.7 [A] : identifier reused from declaration of entity-kind "entity" */
N#endif
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N
N#define LLDD_GDC_IO_H_REVISION     "$Revision: 1.12 $"
N#define LLDD_GDC_IO_H_TAG          "$Name: LLDD_1_7_GFX $"     
N
N#ifndef HW_EMULATION_GDC
N#define GDC1_REGADR_OFFSET    0x1000U
N#else
S#define GDC1_REGADR_OFFSET    0x08U
N#endif
N
N/**********************************************
N*             extern defined varaibles
N**********************************************/
N
N /* Following variables will be used to keep register data before writing in shadow registers:
N  * they should be defined as global, otherwise the usage of macros in gdx_io.h by another 
N  * applications will not work:*/
N
Nextern  volatile uint64_t u64GDCDCR_REG__Var[2];
Nextern  volatile uint64_t u64GDCCAVRA_REG__Var[2];
Nextern  volatile uint64_t u64GDCSCVRA_REG__Var[2];
Nextern  volatile uint64_t u64GDCSCVRB_REG__Var[2];
Nextern  volatile uint64_t u64GDCSCVRC_REG__Var[2];
Nextern  volatile uint64_t u64GDCSCVRD_REG__Var[2];
Nextern  volatile uint64_t u64APCCR_REG__Var[2];
Nextern  volatile uint64_t u64APCCWR_REG__Var[2];
Nextern  volatile uint64_t u64APCCSR_REG__Var[2];
N
N
Nextern  volatile uint32_t u32GDCLARA0_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARA1_REG__Var[2];
Nextern  volatile uint32_t u32GDCWARA_REG__Var[2];
Nextern  volatile uint32_t u32GDCBGCR_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARB0_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARB1_REG__Var[2];
Nextern  volatile uint32_t u32GDCWARB_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARC0_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARC1_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARD0_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARD1_REG__Var[2];
Nextern  volatile uint32_t u32GDCMWRA_REG__Var[2];
Nextern  volatile uint32_t u32GDCMWRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCMWRC_REG__Var[2];
Nextern  volatile uint32_t u32GDCMWRD_REG__Var[2];
Nextern  volatile uint32_t u32GDCMWRE_REG__Var[2];
Nextern  volatile uint32_t u32GDCLSRA_REG__Var[2];
Nextern  volatile uint32_t u32GDCLSRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCLSRC_REG__Var[2];
Nextern  volatile uint32_t u32GDCLSRD_REG__Var[2];
Nextern  volatile uint32_t u32GDCLSRE_REG__Var[2];
Nextern  volatile uint32_t u32GDCLDRA_REG__Var[2];
Nextern  volatile uint32_t u32GDCLDRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCLDRC_REG__Var[2];
Nextern  volatile uint32_t u32GDCLDRD_REG__Var[2];
Nextern  volatile uint32_t u32GDCLDRE_REG__Var[2];
Nextern  volatile uint32_t u32GDCWSRA_REG__Var[2];
Nextern  volatile uint32_t u32GDCWSRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCWIMRA_REG__Var[2];
Nextern  volatile uint32_t u32GDCWIMRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCCAVRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCHSR_REG__Var[2];
Nextern  volatile uint32_t u32GDCVSR_REG__Var[2];
N
Nextern  volatile uint32_t u32GDCCBAR0_REG__Var[2];
Nextern  volatile uint32_t u32GDCCBAR1_REG__Var[2];
Nextern  volatile uint32_t u32GDCCBAR2_REG__Var[2];
Nextern  volatile uint32_t u32GDCPTCR_REG__Var[2];
Nextern  volatile uint32_t u32GDCGPCRA_REG__Var[2];
Nextern  volatile uint32_t u32GDCGPCRB_REG__Var[2];
Nextern  volatile uint32_t u32GDCGPCRC_REG__Var[2];
Nextern  volatile uint32_t u32GDCPSMR_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARE0_REG__Var[2];
Nextern  volatile uint32_t u32GDCLARE1_REG__Var[2];
Nextern  volatile uint32_t u32GDCWARC_REG__Var[2];
Nextern  volatile uint32_t u32GDCWARD_REG__Var[2];
Nextern  volatile uint32_t u32GDCWARE_REG__Var[2];
Nextern  volatile uint32_t u32GDCWSRC_REG__Var[2];
Nextern  volatile uint32_t u32GDCWSRD_REG__Var[2];
Nextern  volatile uint32_t u32GDCWSRE_REG__Var[2];
Nextern  volatile uint32_t u32GDCWIMRC_REG__Var[2];
Nextern  volatile uint32_t u32GDCWIMRD_REG__Var[2];
Nextern  volatile uint32_t u32GDCWIMRE_REG__Var[2];
Nextern  volatile uint32_t u32GDCDSR_REG__Var[2];
Nextern  volatile uint32_t u32GDCDIMR_REG__Var[2];
Nextern  volatile uint32_t u32GDCPROTR_REG__Var[2];
Nextern  volatile uint32_t u32APCPROTR_REG__Var[2];
N
Nextern volatile uint32_t u32GDCPxGAR_REG__Var[2][12];
Nextern volatile uint32_t u32GDCPxGBR_REG__Var[2][12];
N
N#ifdef HW_EMULATION_GDC
S
Sextern  volatile  uint64_t  GDCDCR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCCAVRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCSCVRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCSCVRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCSCVRC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCSCVRD_REG_EMUL[2];
Sextern  volatile  uint64_t  APCCR_REG_EMUL[2];
Sextern  volatile  uint64_t  APCCWR_REG_EMUL[2];
Sextern  volatile  uint64_t  APCCSR_REG_EMUL[2];
S
Sextern  volatile  uint64_t  GDCLARA0_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARA1_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWARA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCBGCR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARB0_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARB1_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWARB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARC0_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARC1_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARD0_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARD1_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCMWRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCMWRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCMWRC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCMWRD_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCMWRE_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLSRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLSRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLSRC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLSRD_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLSRE_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLDRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLDRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLDRC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLDRD_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLDRE_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWSRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWSRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWIMRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWIMRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCCAVRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCHSR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCVSR_REG_EMUL[2];
S
Sextern  volatile  uint64_t  GDCCBAR0_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCCBAR1_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCCBAR2_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCPTCR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCGPCRA_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCGPCRB_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCGPCRC_REG_EMUL[2];
S
Sextern  volatile  uint64_t  GDCP0GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP1GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP2GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP3GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP4GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP5GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP6GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP7GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP8GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP9GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP10GAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP11GAR_REG_EMUL[2];
S
Sextern  volatile  uint64_t  GDCP0GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP1GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP2GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP3GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP4GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP5GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP6GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP7GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP8GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP9GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP10GBR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCP11GBR_REG_EMUL[2];
S
Sextern  volatile  uint64_t  GDCPSMR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARE0_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCLARE1_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWARC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWARD_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWARE_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWSRC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWSRD_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWSRE_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWIMRC_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWIMRD_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCWIMRE_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCDSR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCDIMR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCPROTR_REG_EMUL[2];
Sextern  volatile  uint64_t  APCPROTR_REG_EMUL[2];
S
S/* NOTE:  These registers are no shadow registes: */
Sextern  volatile  uint64_t  GDCINTR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCGBEAR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCGBECR_REG_EMUL[2];
Sextern  volatile  uint64_t  APCPVR_REG_EMUL[2];
Sextern  volatile  uint64_t  GDCCCLUTR_REG_EMUL[2][256];
Sextern  volatile  uint64_t  GDCCCLUTG_REG_EMUL[2][256];
Sextern  volatile  uint64_t  GDCCCLUTB_REG_EMUL[2][256];
Sextern  volatile  uint64_t  GDCGCAR_REG_EMUL[2];
N#endif
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCDCR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02000                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC 
N#define GDCDCR_REG__       0xC0C02000U
N#else
S#define GDCDCR_REG__ ((uint32_t) GDCDCR_REG_EMUL)
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   PHDISP	:1; 	 /* 0..0  bit(s) R/W */
N  uint64_t   PHSYNC	:1; 	 /* 1..1  bit(s) R/W */
N  uint64_t   PVSYNC	:1; 	 /* 2..2  bit(s) R/W */
N  uint64_t   CSYNC	:1; 	 /* 3..3  bit(s) R/W */
N  uint64_t   EXTSYNC	:1; 	 /* 4..4  bit(s) R/W */
N  uint64_t   RSRVD5	:1; 	 /* 5..5  bit(s) R/W */
N  uint64_t   RSRVD6	:1; 	 /* 6..6  bit(s) R/W */
N  uint64_t   VORD	:1; 	 /* 7..7  bit(s) R/W */
N  uint64_t   ARTH	:2; 	 /* 8..9  bit(s) R/W */
N  uint64_t   ARTHCD	:1; 	 /* 10..10  bit(s) R/W */
N  uint64_t   	:1; 	 /* 11..11  bit(s) R */
N  uint64_t   PDC	:1; 	 /* 12..12  bit(s) R/W */
N  uint64_t   IDC	:1; 	 /* 13..13  bit(s) R/W */
N  uint64_t   ADBS	:1; 	 /* 14..14  bit(s) R/W */
N  uint64_t   FBACT	:1; 	 /* 15..15  bit(s) R */
N  uint64_t   HDISP	:1; 	 /* 16..16  bit(s) R */
N  uint64_t   HSYNC	:1; 	 /* 17..17  bit(s) R */
N  uint64_t   VSYNC	:1; 	 /* 18..18  bit(s) R */
N  uint64_t   GBER	:1; 	 /* 19..19  bit(s) R/W1C */
N  uint64_t   A16	:1; 	 /* 20..20  bit(s) R/W */
N  uint64_t   B16	:1; 	 /* 21..21  bit(s) R/W */
N  uint64_t   C16	:1; 	 /* 22..22  bit(s) R/W */
N  uint64_t   D16	:1; 	 /* 23..23  bit(s) R/W */
N  uint64_t   AEN	:1; 	 /* 24..24  bit(s) R/W */
N  uint64_t   WAEN	:1; 	 /* 25..25  bit(s) R/W */
N  uint64_t   BEN	:1; 	 /* 26..26  bit(s) R/W */
N  uint64_t   WBEN	:1; 	 /* 27..27  bit(s) R/W */
N  uint64_t   CEN	:1; 	 /* 28..28  bit(s) R/W */
N  uint64_t   WCEN	:1; 	 /* 29..29  bit(s) R/W */
N  uint64_t   DEN	:1; 	 /* 30..30  bit(s) R/W */
N  uint64_t   WDEN	:1; 	 /* 31..31  bit(s) R/W */
N  uint64_t   EEN	:1; 	 /* 32..32  bit(s) R/W */
N  uint64_t   WEEN	:1; 	 /* 33..33  bit(s) R/W */
N  uint64_t   	:2; 	 /* 34..35  bit(s) R */
N  uint64_t   E16	:1; 	 /* 36..36  bit(s) R/W */
N  uint64_t   	:3; 	 /* 37..39  bit(s) R */
N  uint64_t   CCEN	:1; 	 /* 40..40  bit(s) R/W */
N  uint64_t   SCCEN	:1; 	 /* 41..41  bit(s) R/W */
N  uint64_t   SCCM	:1; 	 /* 42..42  bit(s) R/W */
N  uint64_t   	:1; 	 /* 43..43  bit(s) R */
N  uint64_t   DITHEN	:2; 	 /* 44..45  bit(s) R/W */
N  uint64_t   	:6; 	 /* 46..51  bit(s) R */
N  uint64_t   ARGBEN	:1; 	 /* 52..52  bit(s) R/W */
N  uint64_t   LAD	:1; 	 /* 53..53  bit(s) R/W */
N  uint64_t   UPDREG	:2; 	 /* 54..55  bit(s) R/W */
N  uint64_t   GAPEN	:1; 	 /* 56..56  bit(s) R/W */
N  uint64_t   GAPCOL	:1; 	 /* 57..57  bit(s) R/W1C */
N  uint64_t   GAPACC	:1; 	 /* 58..58  bit(s) R */
N  uint64_t   RSRVD59    :1;      /* 59..59  bit(s) R/W */
N  uint64_t   	:1; 	 /* 60..60  bit(s) R */
N  uint64_t   PNLIFON	:1; 	 /* 61..61  bit(s) R */
N  uint64_t   DISPIFON	:1; 	 /* 62..62  bit(s) R */ 
N  uint64_t   GDCON	:1; 	 /* 63..63  bit(s) R/W */                    
N} GDCDCR_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCDCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCDCR_word_view_st;
N            
N/* LONGWORD View */
Ntypedef uint64_t u64GDCDCR_longword_view;
N             
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCDCR(ctrlr)     ((volatile GDCDCR_bit_view_st *)\
S(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCDCR(ctrlr)     ((volatile GDCDCR_bit_view_st *)(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCDCR(ctrlr)     ((volatile GDCDCR_halfword_view_st *)\
S(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCDCR(ctrlr)     ((volatile GDCDCR_halfword_view_st *)(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32GDCDCR(ctrlr)   ((volatile GDCDCR_word_view_st *) \
S(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCDCR(ctrlr)   ((volatile GDCDCR_word_view_st *) (GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to LONG_WORD  */
S#define pu64GDCDCR(ctrlr)    ((volatile u64GDCDCR_longword_view *)\
S(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCDCR(ctrlr)    ((volatile u64GDCDCR_longword_view *)(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
N#else
N/* Pointer to BIT-struct of shadow register */
N#define pst_bitGDCDCR_Direct(ctrlr)     ((volatile GDCDCR_bit_view_st *)\
N(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCDCR_Direct(ctrlr)     ((volatile GDCDCR_bit_view_st *)(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCDCR(ctrlr)     ((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCDCR(ctrlr)     ((volatile GDCDCR_halfword_view_st *) &u64GDCDCR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCDCR(ctrlr)   ((volatile GDCDCR_word_view_st *) &u64GDCDCR_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64GDCDCR(ctrlr)    ((volatile u64GDCDCR_longword_view *) &u64GDCDCR_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD to shadow register */
N#define pu64GDCDCR_Direct(ctrlr)    ((volatile u64GDCDCR_longword_view *)\
N(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCDCR_Direct(ctrlr)    ((volatile u64GDCDCR_longword_view *)(GDCDCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N#endif
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCDCR_PHDISP(ctrlr) (pst_bitGDCDCR(ctrlr) -> PHDISP)
N#define vSetGDCDCR_PHDISP(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> PHDISP=(ParValue))
N#define biGetGDCDCR_PHSYNC(ctrlr) (pst_bitGDCDCR(ctrlr) -> PHSYNC)
N#define vSetGDCDCR_PHSYNC(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> PHSYNC=(ParValue))
N#define biGetGDCDCR_PVSYNC(ctrlr) (pst_bitGDCDCR(ctrlr) -> PVSYNC)
N#define vSetGDCDCR_PVSYNC(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> PVSYNC=(ParValue))
N#define biGetGDCDCR_CSYNC(ctrlr) (pst_bitGDCDCR(ctrlr) -> CSYNC)
N#define vSetGDCDCR_CSYNC(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> CSYNC=(ParValue))
N#define biGetGDCDCR_EXTSYNC(ctrlr) (pst_bitGDCDCR(ctrlr) -> EXTSYNC)
N#define vSetGDCDCR_EXTSYNC(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> EXTSYNC=(ParValue))
N#define biGetGDCDCR_RSRVD5(ctrlr) (pst_bitGDCDCR(ctrlr) -> RSRVD5)
N#define vSetGDCDCR_RSRVD5(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> RSRVD5=(ParValue))
N#define biGetGDCDCR_RSRVD6(ctrlr) (pst_bitGDCDCR(ctrlr) -> RSRVD6)
N#define vSetGDCDCR_RSRVD6(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> RSRVD6=(ParValue))
N#define biGetGDCDCR_VORD(ctrlr) (pst_bitGDCDCR(ctrlr) -> VORD)
N#define vSetGDCDCR_VORD(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> VORD=(ParValue))
N#define biGetGDCDCR_ARTH(ctrlr) (pst_bitGDCDCR(ctrlr) -> ARTH)
N#define vSetGDCDCR_ARTH(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> ARTH=(ParValue))
N#define biGetGDCDCR_ARTHCD(ctrlr) (pst_bitGDCDCR(ctrlr) -> ARTHCD)
N#define vSetGDCDCR_ARTHCD(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> ARTHCD=(ParValue))
N#define biGetGDCDCR_PDC(ctrlr) (pst_bitGDCDCR(ctrlr) -> PDC)
N#define vSetGDCDCR_PDC(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> PDC=(ParValue))
N#define biGetGDCDCR_IDC(ctrlr) (pst_bitGDCDCR(ctrlr) -> IDC)
N#define vSetGDCDCR_IDC(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> IDC=(ParValue))
N#define biGetGDCDCR_ADBS(ctrlr) (pst_bitGDCDCR(ctrlr) -> ADBS)
N#define vSetGDCDCR_ADBS(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> ADBS=(ParValue))            
N
N/**********************************************************************
N ** "Read Only" signals should be read directly fom shadow register  **
N **********************************************************************/
N#define biGetGDCDCR_FBACT(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> FBACT)
N#define biGetGDCDCR_HDISP(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> HDISP)
N#define biGetGDCDCR_HSYNC(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> HSYNC)
N#define biGetGDCDCR_VSYNC(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> VSYNC)
N/**********************************************************************/
N
N#define biGetGDCDCR_GBER(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> GBER)
N#define vClrGDCDCR_GBER(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> GBER = (1))
N
N#define biGetGDCDCR_A16(ctrlr) (pst_bitGDCDCR(ctrlr) -> A16)
N#define vSetGDCDCR_A16(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> A16=(ParValue))
N#define biGetGDCDCR_B16(ctrlr) (pst_bitGDCDCR(ctrlr) -> B16)
N#define vSetGDCDCR_B16(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> B16=(ParValue))
N#define biGetGDCDCR_C16(ctrlr) (pst_bitGDCDCR(ctrlr) -> C16)
N#define vSetGDCDCR_C16(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> C16=(ParValue))
N#define biGetGDCDCR_D16(ctrlr) (pst_bitGDCDCR(ctrlr) -> D16)
N#define vSetGDCDCR_D16(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> D16=(ParValue))
N#define biGetGDCDCR_AEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> AEN)
N#define vSetGDCDCR_AEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> AEN=(ParValue))
N#define biGetGDCDCR_WAEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> WAEN)
N#define vSetGDCDCR_WAEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> WAEN=(ParValue))
N#define biGetGDCDCR_BEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> BEN)
N#define vSetGDCDCR_BEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> BEN=(ParValue))
N#define biGetGDCDCR_WBEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> WBEN)
N#define vSetGDCDCR_WBEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> WBEN=(ParValue))
N#define biGetGDCDCR_CEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> CEN)
N#define vSetGDCDCR_CEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> CEN=(ParValue))
N#define biGetGDCDCR_WCEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> WCEN)
N#define vSetGDCDCR_WCEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> WCEN=(ParValue))
N#define biGetGDCDCR_DEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> DEN)
N#define vSetGDCDCR_DEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> DEN=(ParValue))
N#define biGetGDCDCR_WDEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> WDEN)
N#define vSetGDCDCR_WDEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> WDEN=(ParValue))
N#define biGetGDCDCR_EEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> EEN)
N#define vSetGDCDCR_EEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> EEN=(ParValue))
N#define biGetGDCDCR_WEEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> WEEN)
N#define vSetGDCDCR_WEEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> WEEN=(ParValue))
N#define biGetGDCDCR_E16(ctrlr) (pst_bitGDCDCR(ctrlr) -> E16)
N#define vSetGDCDCR_E16(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> E16=(ParValue))
N#define biGetGDCDCR_CCEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> CCEN)
N#define vSetGDCDCR_CCEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> CCEN=(ParValue))
N#define biGetGDCDCR_SCCEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> SCCEN)
N#define vSetGDCDCR_SCCEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> SCCEN=(ParValue))
N#define biGetGDCDCR_SCCM(ctrlr) (pst_bitGDCDCR(ctrlr) -> SCCM)
N#define vSetGDCDCR_SCCM(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> SCCM=(ParValue))
N#define biGetGDCDCR_DITHEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> DITHEN)
N#define vSetGDCDCR_DITHEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> DITHEN=(ParValue))
N#define biGetGDCDCR_ARGBEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> ARGBEN)
N#define vSetGDCDCR_ARGBEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> ARGBEN=(ParValue))
N#define biGetGDCDCR_LAD(ctrlr) (pst_bitGDCDCR(ctrlr) -> LAD)
N#define vSetGDCDCR_LAD(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> LAD=(ParValue))
N
N/**********************************************************************
N ** NOTE:
N *      "UPDREG" has an immediate influenc to HW, so 
N *      a) to get these bits, it should be read from HW shadow register
N *      b) to set these bits, it should NOT be set direct to shadow register, because
N *         the exisiting data in shadow register can be overwritten before VSNC was raised
N **********************************************************************/
N#define biGetGDCDCR_UPDREG_Direct(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> UPDREG)
N#define vSetGDCDCR_UPDREG(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> UPDREG=(ParValue))
N/***********************************************************************/
N#define biGetGDCDCR_GAPEN(ctrlr) (pst_bitGDCDCR(ctrlr) -> GAPEN)
N#define vSetGDCDCR_GAPEN(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> GAPEN=(ParValue))
N
N#define biGetGDCDCR_GAPCOL(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> GAPCOL)
N#define vClrGDCDCR_GAPCOL(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> GAPCOL = (1))
N
N/* "Read Only" signals will be read from shadow register: */
N#define biGetGDCDCR_GAPACC(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> GAPACC)
N
N/*"Read Only" signals will be read from shadow register: */
N#define biGetGDCDCR_PNLIFON(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> PNLIFON)
N#define biGetGDCDCR_DISPIFON(ctrlr) (pst_bitGDCDCR_Direct(ctrlr) -> DISPIFON)
N
N#define biGetGDCDCR_GDCON(ctrlr) (pst_bitGDCDCR(ctrlr) -> GDCON)
N#define vSetGDCDCR_GDCON(ctrlr,ParValue)  (pst_bitGDCDCR(ctrlr) -> GDCON=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetGDCDCRLL(ctrlr,ParValue) (pst_u16GDCDCR(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCDCRLL(ctrlr) (pst_u16GDCDCR(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCDCRLH(ctrlr,ParValue) (pst_u16GDCDCR(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCDCRLH(ctrlr) (pst_u16GDCDCR(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCDCRHL(ctrlr,ParValue) (pst_u16GDCDCR(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCDCRHL(ctrlr) (pst_u16GDCDCR(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCDCRHH(ctrlr,ParValue) (pst_u16GDCDCR(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCDCRHH(ctrlr) (pst_u16GDCDCR(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCDCRL(ctrlr,ParValue) (pst_u32GDCDCR(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCDCRL(ctrlr) (pst_u32GDCDCR(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCDCRH(ctrlr,ParValue) (pst_u32GDCDCR(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCDCRH(ctrlr) (pst_u32GDCDCR(ctrlr) -> u32H)
N            
N/* Long  Word access */ 
N#define vSetGDCDCR(ctrlr,ParValue)  (*pu64GDCDCR(ctrlr) = (ParValue))
N#define u64GetGDCDCR(ctrlr)  (*pu64GDCDCR(ctrlr) )
N
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARA0                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARA0_REG__       0xC0C02010U
N#else
S#define GDCLARA0_REG__ ((uint32_t) GDCLARA0_REG_EMUL)
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARA0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARA0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARA0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARA0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARA0(ctrlr)     ((volatile GDCLARA0_bit_view_st *)\
S(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARA0(ctrlr)     ((volatile GDCLARA0_bit_view_st *)(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARA0(ctrlr)     ((volatile GDCLARA0_byte_view_st *)\
S(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARA0(ctrlr)     ((volatile GDCLARA0_byte_view_st *)(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARA0(ctrlr)     ((volatile GDCLARA0_halfword_view_st *)\
S(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARA0(ctrlr)     ((volatile GDCLARA0_halfword_view_st *)(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARA0(ctrlr)     ((volatile u32GDCLARA0_word_view *)\
S(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARA0(ctrlr)     ((volatile u32GDCLARA0_word_view *)(GDCLARA0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARA0(ctrlr)     ((volatile GDCLARA0_bit_view_st *) &u32GDCLARA0_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARA0(ctrlr)     ((volatile GDCLARA0_byte_view_st *) &u32GDCLARA0_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARA0(ctrlr)     ((volatile GDCLARA0_halfword_view_st *) &u32GDCLARA0_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARA0(ctrlr)     ((volatile u32GDCLARA0_word_view *) &u32GDCLARA0_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARA0_SSCROLL(ctrlr) (pst_bitGDCLARA0(ctrlr) -> SSCROLL)
N#define vSetGDCLARA0_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARA0(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARA0_SAR(ctrlr) (pst_bitGDCLARA0(ctrlr) -> SAR)
N#define vSetGDCLARA0_SAR(ctrlr,ParValue)  (pst_bitGDCLARA0(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARA0LL(ctrlr,ParValue) (pst_u8GDCLARA0(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARA0LL(ctrlr) (pst_u8GDCLARA0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARA0LH(ctrlr,ParValue) (pst_u8GDCLARA0(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARA0LH(ctrlr) (pst_u8GDCLARA0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARA0HL(ctrlr,ParValue) (pst_u8GDCLARA0(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARA0HL(ctrlr) (pst_u8GDCLARA0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARA0HH(ctrlr,ParValue) (pst_u8GDCLARA0(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARA0HH(ctrlr) (pst_u8GDCLARA0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARA0L(ctrlr,ParValue) (pst_u16GDCLARA0(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARA0L(ctrlr) (pst_u16GDCLARA0(ctrlr) -> u16L)
N#define vSetGDCLARA0H(ctrlr,ParValue) (pst_u16GDCLARA0(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARA0H(ctrlr) (pst_u16GDCLARA0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARA0(ctrlr,ParValue)  (*pu32GDCLARA0(ctrlr) = (ParValue))
N#define u32GetGDCLARA0(ctrlr)  (*pu32GDCLARA0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARA1                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02018                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARA1_REG__       0xC0C02018U
N#else
S#define GDCLARA1_REG__ ((uint32_t) GDCLARA1_REG_EMUL)
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARA1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARA1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARA1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARA1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARA1(ctrlr)     ((volatile GDCLARA1_bit_view_st *)\
S(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARA1(ctrlr)     ((volatile GDCLARA1_bit_view_st *)(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARA1(ctrlr)     ((volatile GDCLARA1_byte_view_st *)\
S(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARA1(ctrlr)     ((volatile GDCLARA1_byte_view_st *)(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARA1(ctrlr)     ((volatile GDCLARA1_halfword_view_st *)\
S(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARA1(ctrlr)     ((volatile GDCLARA1_halfword_view_st *)(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARA1(ctrlr)     ((volatile u32GDCLARA1_word_view *)\
S(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARA1(ctrlr)     ((volatile u32GDCLARA1_word_view *)(GDCLARA1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARA1(ctrlr)     ((volatile GDCLARA1_bit_view_st *) &u32GDCLARA1_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARA1(ctrlr)     ((volatile GDCLARA1_byte_view_st *) &u32GDCLARA1_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARA1(ctrlr)     ((volatile GDCLARA1_halfword_view_st *) &u32GDCLARA1_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARA1(ctrlr)     ((volatile u32GDCLARA1_word_view *) &u32GDCLARA1_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARA1_SSCROLL(ctrlr) (pst_bitGDCLARA1(ctrlr) -> SSCROLL)
N#define vSetGDCLARA1_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARA1(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARA1_SAR(ctrlr) (pst_bitGDCLARA1(ctrlr) -> SAR)
N#define vSetGDCLARA1_SAR(ctrlr,ParValue)  (pst_bitGDCLARA1(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARA1LL(ctrlr,ParValue) (pst_u8GDCLARA1(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARA1LL(ctrlr) (pst_u8GDCLARA1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARA1LH(ctrlr,ParValue) (pst_u8GDCLARA1(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARA1LH(ctrlr) (pst_u8GDCLARA1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARA1HL(ctrlr,ParValue) (pst_u8GDCLARA1(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARA1HL(ctrlr) (pst_u8GDCLARA1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARA1HH(ctrlr,ParValue) (pst_u8GDCLARA1(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARA1HH(ctrlr) (pst_u8GDCLARA1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARA1L(ctrlr,ParValue) (pst_u16GDCLARA1(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARA1L(ctrlr) (pst_u16GDCLARA1(ctrlr) -> u16L)
N#define vSetGDCLARA1H(ctrlr,ParValue) (pst_u16GDCLARA1(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARA1H(ctrlr) (pst_u16GDCLARA1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARA1(ctrlr,ParValue)  (*pu32GDCLARA1(ctrlr) = (ParValue))
N#define u32GetGDCLARA1(ctrlr)  (*pu32GDCLARA1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWARA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02020                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWARA_REG__       0xC0C02020U
N#else
S#define GDCWARA_REG__ ((uint32_t) GDCWARA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   WAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCWARA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWARA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWARA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWARA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWARA(ctrlr)     ((volatile GDCWARA_bit_view_st *)\
S(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWARA(ctrlr)     ((volatile GDCWARA_bit_view_st *)(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWARA(ctrlr)     ((volatile GDCWARA_byte_view_st *)\
S(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWARA(ctrlr)     ((volatile GDCWARA_byte_view_st *)(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWARA(ctrlr)     ((volatile GDCWARA_halfword_view_st *)\
S(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWARA(ctrlr)     ((volatile GDCWARA_halfword_view_st *)(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWARA(ctrlr)     ((volatile u32GDCWARA_word_view *)\
S(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWARA(ctrlr)     ((volatile u32GDCWARA_word_view *)(GDCWARA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWARA(ctrlr)     ((volatile GDCWARA_bit_view_st *) &u32GDCWARA_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWARA(ctrlr)     ((volatile GDCWARA_byte_view_st *) &u32GDCWARA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWARA(ctrlr)     ((volatile GDCWARA_halfword_view_st *) &u32GDCWARA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWARA(ctrlr)     ((volatile u32GDCWARA_word_view *) &u32GDCWARA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWARA_WAR(ctrlr) (pst_bitGDCWARA(ctrlr) -> WAR)
N#define vSetGDCWARA_WAR(ctrlr,ParValue)  (pst_bitGDCWARA(ctrlr) -> WAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWARALL(ctrlr,ParValue) (pst_u8GDCWARA(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWARALL(ctrlr) (pst_u8GDCWARA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWARALH(ctrlr,ParValue) (pst_u8GDCWARA(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWARALH(ctrlr) (pst_u8GDCWARA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWARAHL(ctrlr,ParValue) (pst_u8GDCWARA(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWARAHL(ctrlr) (pst_u8GDCWARA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWARAHH(ctrlr,ParValue) (pst_u8GDCWARA(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWARAHH(ctrlr) (pst_u8GDCWARA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWARAL(ctrlr,ParValue) (pst_u16GDCWARA(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWARAL(ctrlr) (pst_u16GDCWARA(ctrlr) -> u16L)
N#define vSetGDCWARAH(ctrlr,ParValue) (pst_u16GDCWARA(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWARAH(ctrlr) (pst_u16GDCWARA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWARA(ctrlr,ParValue)  (*pu32GDCWARA(ctrlr) = (ParValue))
N#define u32GetGDCWARA(ctrlr)  (*pu32GDCWARA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCBGCR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02028                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCBGCR_REG__       0xC0C02028U
N#else
S#define GDCBGCR_REG__ ((uint32_t) GDCBGCR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:8; 	 /* 0..7  bit(s) R */
N  uint32_t   BGBLUE	:8; 	 /* 8..15  bit(s) R/W */
N  uint32_t   BGGREEN	:8; 	 /* 16..23  bit(s) R/W */
N  uint32_t   BGRED	:8; 	 /* 24..31  bit(s) R/W */                    
N} GDCBGCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCBGCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCBGCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCBGCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCBGCR(ctrlr)     ((volatile GDCBGCR_bit_view_st *)\
S(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCBGCR(ctrlr)     ((volatile GDCBGCR_bit_view_st *)(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCBGCR(ctrlr)     ((volatile GDCBGCR_byte_view_st *)\
S(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCBGCR(ctrlr)     ((volatile GDCBGCR_byte_view_st *)(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCBGCR(ctrlr)     ((volatile GDCBGCR_halfword_view_st *)\
S(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCBGCR(ctrlr)     ((volatile GDCBGCR_halfword_view_st *)(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCBGCR(ctrlr)     ((volatile u32GDCBGCR_word_view *)\
S(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCBGCR(ctrlr)     ((volatile u32GDCBGCR_word_view *)(GDCBGCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCBGCR(ctrlr)     ((volatile GDCBGCR_bit_view_st *) &u32GDCBGCR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCBGCR(ctrlr)     ((volatile GDCBGCR_byte_view_st *) &u32GDCBGCR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCBGCR(ctrlr)     ((volatile GDCBGCR_halfword_view_st *) &u32GDCBGCR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCBGCR(ctrlr)     ((volatile u32GDCBGCR_word_view *) &u32GDCBGCR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCBGCR_BGBLUE(ctrlr) (pst_bitGDCBGCR(ctrlr) -> BGBLUE)
N#define vSetGDCBGCR_BGBLUE(ctrlr,ParValue)  (pst_bitGDCBGCR(ctrlr) -> BGBLUE=(ParValue))
N#define biGetGDCBGCR_BGGREEN(ctrlr) (pst_bitGDCBGCR(ctrlr) -> BGGREEN)
N#define vSetGDCBGCR_BGGREEN(ctrlr,ParValue)  (pst_bitGDCBGCR(ctrlr) -> BGGREEN=(ParValue))
N#define biGetGDCBGCR_BGRED(ctrlr) (pst_bitGDCBGCR(ctrlr) -> BGRED)
N#define vSetGDCBGCR_BGRED(ctrlr,ParValue)  (pst_bitGDCBGCR(ctrlr) -> BGRED=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCBGCRLL(ctrlr,ParValue) (pst_u8GDCBGCR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCBGCRLL(ctrlr) (pst_u8GDCBGCR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCBGCRLH(ctrlr,ParValue) (pst_u8GDCBGCR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCBGCRLH(ctrlr) (pst_u8GDCBGCR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCBGCRHL(ctrlr,ParValue) (pst_u8GDCBGCR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCBGCRHL(ctrlr) (pst_u8GDCBGCR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCBGCRHH(ctrlr,ParValue) (pst_u8GDCBGCR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCBGCRHH(ctrlr) (pst_u8GDCBGCR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCBGCRL(ctrlr,ParValue) (pst_u16GDCBGCR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCBGCRL(ctrlr) (pst_u16GDCBGCR(ctrlr) -> u16L)
N#define vSetGDCBGCRH(ctrlr,ParValue) (pst_u16GDCBGCR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCBGCRH(ctrlr) (pst_u16GDCBGCR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCBGCR(ctrlr,ParValue)  (*pu32GDCBGCR(ctrlr) = (ParValue))
N#define u32GetGDCBGCR(ctrlr)  (*pu32GDCBGCR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARB0                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02030                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARB0_REG__       0xC0C02030U
N#else
S#define GDCLARB0_REG__ ((uint32_t) GDCLARB0_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARB0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARB0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARB0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARB0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARB0(ctrlr)     ((volatile GDCLARB0_bit_view_st *)\
S(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARB0(ctrlr)     ((volatile GDCLARB0_bit_view_st *)(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARB0(ctrlr)     ((volatile GDCLARB0_byte_view_st *)\
S(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARB0(ctrlr)     ((volatile GDCLARB0_byte_view_st *)(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARB0(ctrlr)     ((volatile GDCLARB0_halfword_view_st *)\
S(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARB0(ctrlr)     ((volatile GDCLARB0_halfword_view_st *)(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARB0(ctrlr)     ((volatile u32GDCLARB0_word_view *)\
S(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARB0(ctrlr)     ((volatile u32GDCLARB0_word_view *)(GDCLARB0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARB0(ctrlr)     ((volatile GDCLARB0_bit_view_st *) &u32GDCLARB0_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARB0(ctrlr)     ((volatile GDCLARB0_byte_view_st *) &u32GDCLARB0_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARB0(ctrlr)     ((volatile GDCLARB0_halfword_view_st *) &u32GDCLARB0_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARB0(ctrlr)     ((volatile u32GDCLARB0_word_view *) &u32GDCLARB0_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARB0_SSCROLL(ctrlr) (pst_bitGDCLARB0(ctrlr) -> SSCROLL)
N#define vSetGDCLARB0_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARB0(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARB0_SAR(ctrlr) (pst_bitGDCLARB0(ctrlr) -> SAR)
N#define vSetGDCLARB0_SAR(ctrlr,ParValue)  (pst_bitGDCLARB0(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARB0LL(ctrlr,ParValue) (pst_u8GDCLARB0(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARB0LL(ctrlr) (pst_u8GDCLARB0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARB0LH(ctrlr,ParValue) (pst_u8GDCLARB0(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARB0LH(ctrlr) (pst_u8GDCLARB0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARB0HL(ctrlr,ParValue) (pst_u8GDCLARB0(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARB0HL(ctrlr) (pst_u8GDCLARB0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARB0HH(ctrlr,ParValue) (pst_u8GDCLARB0(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARB0HH(ctrlr) (pst_u8GDCLARB0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARB0L(ctrlr,ParValue) (pst_u16GDCLARB0(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARB0L(ctrlr) (pst_u16GDCLARB0(ctrlr) -> u16L)
N#define vSetGDCLARB0H(ctrlr,ParValue) (pst_u16GDCLARB0(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARB0H(ctrlr) (pst_u16GDCLARB0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARB0(ctrlr,ParValue)  (*pu32GDCLARB0(ctrlr) = (ParValue))
N#define u32GetGDCLARB0(ctrlr)  (*pu32GDCLARB0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARB1                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02038                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARB1_REG__       0xC0C02038U
N#else
S#define GDCLARB1_REG__ ((uint32_t) GDCLARB1_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARB1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARB1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARB1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARB1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARB1(ctrlr)     ((volatile GDCLARB1_bit_view_st *)\
S(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARB1(ctrlr)     ((volatile GDCLARB1_bit_view_st *)(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARB1(ctrlr)     ((volatile GDCLARB1_byte_view_st *)\
S(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARB1(ctrlr)     ((volatile GDCLARB1_byte_view_st *)(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARB1(ctrlr)     ((volatile GDCLARB1_halfword_view_st *)\
S(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARB1(ctrlr)     ((volatile GDCLARB1_halfword_view_st *)(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARB1(ctrlr)     ((volatile u32GDCLARB1_word_view *)\
S(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARB1(ctrlr)     ((volatile u32GDCLARB1_word_view *)(GDCLARB1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARB1(ctrlr)     ((volatile GDCLARB1_bit_view_st *) &u32GDCLARB1_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARB1(ctrlr)     ((volatile GDCLARB1_byte_view_st *) &u32GDCLARB1_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARB1(ctrlr)     ((volatile GDCLARB1_halfword_view_st *) &u32GDCLARB1_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARB1(ctrlr)     ((volatile u32GDCLARB1_word_view *) &u32GDCLARB1_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARB1_SSCROLL(ctrlr) (pst_bitGDCLARB1(ctrlr) -> SSCROLL)
N#define vSetGDCLARB1_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARB1(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARB1_SAR(ctrlr) (pst_bitGDCLARB1(ctrlr) -> SAR)
N#define vSetGDCLARB1_SAR(ctrlr,ParValue)  (pst_bitGDCLARB1(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARB1LL(ctrlr,ParValue) (pst_u8GDCLARB1(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARB1LL(ctrlr) (pst_u8GDCLARB1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARB1LH(ctrlr,ParValue) (pst_u8GDCLARB1(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARB1LH(ctrlr) (pst_u8GDCLARB1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARB1HL(ctrlr,ParValue) (pst_u8GDCLARB1(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARB1HL(ctrlr) (pst_u8GDCLARB1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARB1HH(ctrlr,ParValue) (pst_u8GDCLARB1(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARB1HH(ctrlr) (pst_u8GDCLARB1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARB1L(ctrlr,ParValue) (pst_u16GDCLARB1(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARB1L(ctrlr) (pst_u16GDCLARB1(ctrlr) -> u16L)
N#define vSetGDCLARB1H(ctrlr,ParValue) (pst_u16GDCLARB1(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARB1H(ctrlr) (pst_u16GDCLARB1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARB1(ctrlr,ParValue)  (*pu32GDCLARB1(ctrlr) = (ParValue))
N#define u32GetGDCLARB1(ctrlr)  (*pu32GDCLARB1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWARB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02040                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWARB_REG__       0xC0C02040U
N#else
S#define GDCWARB_REG__ ((uint32_t) GDCWARB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   WAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCWARB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWARB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWARB_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWARB_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWARB(ctrlr)     ((volatile GDCWARB_bit_view_st *)\
S(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWARB(ctrlr)     ((volatile GDCWARB_bit_view_st *)(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWARB(ctrlr)     ((volatile GDCWARB_byte_view_st *)\
S(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWARB(ctrlr)     ((volatile GDCWARB_byte_view_st *)(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWARB(ctrlr)     ((volatile GDCWARB_halfword_view_st *)\
S(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWARB(ctrlr)     ((volatile GDCWARB_halfword_view_st *)(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWARB(ctrlr)     ((volatile u32GDCWARB_word_view *)\
S(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWARB(ctrlr)     ((volatile u32GDCWARB_word_view *)(GDCWARB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWARB(ctrlr)     ((volatile GDCWARB_bit_view_st *) &u32GDCWARB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWARB(ctrlr)     ((volatile GDCWARB_byte_view_st *) &u32GDCWARB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWARB(ctrlr)     ((volatile GDCWARB_halfword_view_st *) &u32GDCWARB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWARB(ctrlr)     ((volatile u32GDCWARB_word_view *) &u32GDCWARB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWARB_WAR(ctrlr) (pst_bitGDCWARB(ctrlr) -> WAR)
N#define vSetGDCWARB_WAR(ctrlr,ParValue)  (pst_bitGDCWARB(ctrlr) -> WAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWARBLL(ctrlr,ParValue) (pst_u8GDCWARB(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWARBLL(ctrlr) (pst_u8GDCWARB(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWARBLH(ctrlr,ParValue) (pst_u8GDCWARB(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWARBLH(ctrlr) (pst_u8GDCWARB(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWARBHL(ctrlr,ParValue) (pst_u8GDCWARB(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWARBHL(ctrlr) (pst_u8GDCWARB(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWARBHH(ctrlr,ParValue) (pst_u8GDCWARB(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWARBHH(ctrlr) (pst_u8GDCWARB(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWARBL(ctrlr,ParValue) (pst_u16GDCWARB(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWARBL(ctrlr) (pst_u16GDCWARB(ctrlr) -> u16L)
N#define vSetGDCWARBH(ctrlr,ParValue) (pst_u16GDCWARB(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWARBH(ctrlr) (pst_u16GDCWARB(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWARB(ctrlr,ParValue)  (*pu32GDCWARB(ctrlr) = (ParValue))
N#define u32GetGDCWARB(ctrlr)  (*pu32GDCWARB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARC0                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02048                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARC0_REG__       0xC0C02048U
N#else
S#define GDCLARC0_REG__ ((uint32_t) GDCLARC0_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARC0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARC0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARC0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARC0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARC0(ctrlr)     ((volatile GDCLARC0_bit_view_st *)\
S(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARC0(ctrlr)     ((volatile GDCLARC0_bit_view_st *)(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARC0(ctrlr)     ((volatile GDCLARC0_byte_view_st *)\
S(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARC0(ctrlr)     ((volatile GDCLARC0_byte_view_st *)(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARC0(ctrlr)     ((volatile GDCLARC0_halfword_view_st *)\
S(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARC0(ctrlr)     ((volatile GDCLARC0_halfword_view_st *)(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARC0(ctrlr)     ((volatile u32GDCLARC0_word_view *)\
S(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARC0(ctrlr)     ((volatile u32GDCLARC0_word_view *)(GDCLARC0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARC0(ctrlr)     ((volatile GDCLARC0_bit_view_st *) &u32GDCLARC0_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARC0(ctrlr)     ((volatile GDCLARC0_byte_view_st *)\ &u32GDCLARC0_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARC0(ctrlr)     ((volatile GDCLARC0_halfword_view_st *) &u32GDCLARC0_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARC0(ctrlr)     ((volatile u32GDCLARC0_word_view *) &u32GDCLARC0_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARC0_SSCROLL(ctrlr) (pst_bitGDCLARC0(ctrlr) -> SSCROLL)
N#define vSetGDCLARC0_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARC0(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARC0_SAR(ctrlr) (pst_bitGDCLARC0(ctrlr) -> SAR)
N#define vSetGDCLARC0_SAR(ctrlr,ParValue)  (pst_bitGDCLARC0(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARC0LL(ctrlr,ParValue) (pst_u8GDCLARC0(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARC0LL(ctrlr) (pst_u8GDCLARC0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARC0LH(ctrlr,ParValue) (pst_u8GDCLARC0(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARC0LH(ctrlr) (pst_u8GDCLARC0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARC0HL(ctrlr,ParValue) (pst_u8GDCLARC0(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARC0HL(ctrlr) (pst_u8GDCLARC0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARC0HH(ctrlr,ParValue) (pst_u8GDCLARC0(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARC0HH(ctrlr) (pst_u8GDCLARC0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARC0L(ctrlr,ParValue) (pst_u16GDCLARC0(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARC0L(ctrlr) (pst_u16GDCLARC0(ctrlr) -> u16L)
N#define vSetGDCLARC0H(ctrlr,ParValue) (pst_u16GDCLARC0(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARC0H(ctrlr) (pst_u16GDCLARC0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARC0(ctrlr,ParValue)  (*pu32GDCLARC0(ctrlr) = (ParValue))
N#define u32GetGDCLARC0(ctrlr)  (*pu32GDCLARC0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARC1                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02050                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARC1_REG__       0xC0C02050U
N#else
S#define GDCLARC1_REG__ ((uint32_t) GDCLARC1_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARC1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARC1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARC1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARC1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARC1(ctrlr)     ((volatile GDCLARC1_bit_view_st *)\
S(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARC1(ctrlr)     ((volatile GDCLARC1_bit_view_st *)(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARC1(ctrlr)     ((volatile GDCLARC1_byte_view_st *)\
S(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARC1(ctrlr)     ((volatile GDCLARC1_byte_view_st *)(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARC1(ctrlr)     ((volatile GDCLARC1_halfword_view_st *)\
S(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARC1(ctrlr)     ((volatile GDCLARC1_halfword_view_st *)(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARC1(ctrlr)     ((volatile u32GDCLARC1_word_view *)\
S(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARC1(ctrlr)     ((volatile u32GDCLARC1_word_view *)(GDCLARC1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARC1(ctrlr)     ((volatile GDCLARC1_bit_view_st *) &u32GDCLARC1_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARC1(ctrlr)     ((volatile GDCLARC1_byte_view_st *) &u32GDCLARC1_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARC1(ctrlr)     ((volatile GDCLARC1_halfword_view_st *) &u32GDCLARC1_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARC1(ctrlr)     ((volatile u32GDCLARC1_word_view *) &u32GDCLARC1_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARC1_SSCROLL(ctrlr) (pst_bitGDCLARC1(ctrlr) -> SSCROLL)
N#define vSetGDCLARC1_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARC1(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARC1_SAR(ctrlr) (pst_bitGDCLARC1(ctrlr) -> SAR)
N#define vSetGDCLARC1_SAR(ctrlr,ParValue)  (pst_bitGDCLARC1(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARC1LL(ctrlr,ParValue) (pst_u8GDCLARC1(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARC1LL(ctrlr) (pst_u8GDCLARC1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARC1LH(ctrlr,ParValue) (pst_u8GDCLARC1(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARC1LH(ctrlr) (pst_u8GDCLARC1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARC1HL(ctrlr,ParValue) (pst_u8GDCLARC1(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARC1HL(ctrlr) (pst_u8GDCLARC1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARC1HH(ctrlr,ParValue) (pst_u8GDCLARC1(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARC1HH(ctrlr) (pst_u8GDCLARC1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARC1L(ctrlr,ParValue) (pst_u16GDCLARC1(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARC1L(ctrlr) (pst_u16GDCLARC1(ctrlr) -> u16L)
N#define vSetGDCLARC1H(ctrlr,ParValue) (pst_u16GDCLARC1(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARC1H(ctrlr) (pst_u16GDCLARC1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARC1(ctrlr,ParValue)  (*pu32GDCLARC1(ctrlr) = (ParValue))
N#define u32GetGDCLARC1(ctrlr)  (*pu32GDCLARC1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARD0                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02058                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARD0_REG__       0xC0C02058U
N#else
S#define GDCLARD0_REG__ ((uint32_t) GDCLARD0_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARD0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARD0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARD0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARD0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARD0(ctrlr)     ((volatile GDCLARD0_bit_view_st *)\
S(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARD0(ctrlr)     ((volatile GDCLARD0_bit_view_st *)(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARD0(ctrlr)     ((volatile GDCLARD0_byte_view_st *)\
S(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARD0(ctrlr)     ((volatile GDCLARD0_byte_view_st *)(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARD0(ctrlr)     ((volatile GDCLARD0_halfword_view_st *)\
S(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARD0(ctrlr)     ((volatile GDCLARD0_halfword_view_st *)(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARD0(ctrlr)     ((volatile u32GDCLARD0_word_view *)\
S(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARD0(ctrlr)     ((volatile u32GDCLARD0_word_view *)(GDCLARD0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARD0(ctrlr)     ((volatile GDCLARD0_bit_view_st *) &u32GDCLARD0_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARD0(ctrlr)     ((volatile GDCLARD0_byte_view_st *) &u32GDCLARD0_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARD0(ctrlr)     ((volatile GDCLARD0_halfword_view_st *) &u32GDCLARD0_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARD0(ctrlr)     ((volatile u32GDCLARD0_word_view *) &u32GDCLARD0_REG__Var[(ctrlr)])
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARD0_SSCROLL(ctrlr) (pst_bitGDCLARD0(ctrlr) -> SSCROLL)
N#define vSetGDCLARD0_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARD0(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARD0_SAR(ctrlr) (pst_bitGDCLARD0(ctrlr) -> SAR)
N#define vSetGDCLARD0_SAR(ctrlr,ParValue)  (pst_bitGDCLARD0(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARD0LL(ctrlr,ParValue) (pst_u8GDCLARD0(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARD0LL(ctrlr) (pst_u8GDCLARD0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARD0LH(ctrlr,ParValue) (pst_u8GDCLARD0(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARD0LH(ctrlr) (pst_u8GDCLARD0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARD0HL(ctrlr,ParValue) (pst_u8GDCLARD0(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARD0HL(ctrlr) (pst_u8GDCLARD0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARD0HH(ctrlr,ParValue) (pst_u8GDCLARD0(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARD0HH(ctrlr) (pst_u8GDCLARD0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARD0L(ctrlr,ParValue) (pst_u16GDCLARD0(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARD0L(ctrlr) (pst_u16GDCLARD0(ctrlr) -> u16L)
N#define vSetGDCLARD0H(ctrlr,ParValue) (pst_u16GDCLARD0(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARD0H(ctrlr) (pst_u16GDCLARD0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARD0(ctrlr,ParValue)  (*pu32GDCLARD0(ctrlr) = (ParValue))
N#define u32GetGDCLARD0(ctrlr)  (*pu32GDCLARD0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARD1                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02060                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARD1_REG__       0xC0C02060U
N#else
S#define GDCLARD1_REG__ ((uint32_t) GDCLARD1_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARD1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARD1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARD1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARD1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARD1(ctrlr)     ((volatile GDCLARD1_bit_view_st *)\
S(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARD1(ctrlr)     ((volatile GDCLARD1_bit_view_st *)(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARD1(ctrlr)     ((volatile GDCLARD1_byte_view_st *)\
S(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARD1(ctrlr)     ((volatile GDCLARD1_byte_view_st *)(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARD1(ctrlr)     ((volatile GDCLARD1_halfword_view_st *)\
S(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARD1(ctrlr)     ((volatile GDCLARD1_halfword_view_st *)(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARD1(ctrlr)     ((volatile u32GDCLARD1_word_view *)\
S(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARD1(ctrlr)     ((volatile u32GDCLARD1_word_view *)(GDCLARD1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARD1(ctrlr)     ((volatile GDCLARD1_bit_view_st *) &u32GDCLARD1_REG__Var[(ctrlr)])
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARD1(ctrlr)     ((volatile GDCLARD1_byte_view_st *) &u32GDCLARD1_REG__Var[(ctrlr)])
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARD1(ctrlr)     ((volatile GDCLARD1_halfword_view_st *) &u32GDCLARD1_REG__Var[(ctrlr)])
N            
N/* Pointer to WORD  */ 
N#define pu32GDCLARD1(ctrlr)     ((volatile u32GDCLARD1_word_view *) &u32GDCLARD1_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARD1_SSCROLL(ctrlr) (pst_bitGDCLARD1(ctrlr) -> SSCROLL)
N#define vSetGDCLARD1_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARD1(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARD1_SAR(ctrlr) (pst_bitGDCLARD1(ctrlr) -> SAR)
N#define vSetGDCLARD1_SAR(ctrlr,ParValue)  (pst_bitGDCLARD1(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARD1LL(ctrlr,ParValue) (pst_u8GDCLARD1(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARD1LL(ctrlr) (pst_u8GDCLARD1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARD1LH(ctrlr,ParValue) (pst_u8GDCLARD1(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARD1LH(ctrlr) (pst_u8GDCLARD1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARD1HL(ctrlr,ParValue) (pst_u8GDCLARD1(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARD1HL(ctrlr) (pst_u8GDCLARD1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARD1HH(ctrlr,ParValue) (pst_u8GDCLARD1(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARD1HH(ctrlr) (pst_u8GDCLARD1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARD1L(ctrlr,ParValue) (pst_u16GDCLARD1(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARD1L(ctrlr) (pst_u16GDCLARD1(ctrlr) -> u16L)
N#define vSetGDCLARD1H(ctrlr,ParValue) (pst_u16GDCLARD1(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARD1H(ctrlr) (pst_u16GDCLARD1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARD1(ctrlr,ParValue)  (*pu32GDCLARD1(ctrlr) = (ParValue))
N#define u32GetGDCLARD1(ctrlr)  (*pu32GDCLARD1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCMWRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02068                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCMWRA_REG__       0xC0C02068U
N#else
S#define GDCMWRA_REG__ ((uint32_t) GDCMWRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   MWR	:13; 	 /* 0..12  bit(s) R/W */ 
N  uint16_t   	:3; 	 /* 13..63  bit(s) R */                    
N} GDCMWRA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCMWRA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCMWRA_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCMWRA(ctrlr)     ((volatile GDCMWRA_bit_view_st *)\
S(GDCMWRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCMWRA(ctrlr)     ((volatile GDCMWRA_bit_view_st *)(GDCMWRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCMWRA(ctrlr)     ((volatile GDCMWRA_byte_view_st *)\
S(GDCMWRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCMWRA(ctrlr)     ((volatile GDCMWRA_byte_view_st *)(GDCMWRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD */
S#define pu16GDCMWRA(ctrlr)     ((volatile u16GDCMWRA_halfword_view *)\
S(GDCMWRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCMWRA(ctrlr)     ((volatile u16GDCMWRA_halfword_view *)(GDCMWRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N/* Pointer to BIT-struct */
N#define pst_bitGDCMWRA(ctrlr)     ((volatile GDCMWRA_bit_view_st *) &u32GDCMWRA_REG__Var[(ctrlr)])
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCMWRA(ctrlr)     ((volatile GDCMWRA_byte_view_st *) &u32GDCMWRA_REG__Var[(ctrlr)])
N            
N/* Pointer to HALFWORD */
N#define pu16GDCMWRA(ctrlr)     ((volatile u16GDCMWRA_halfword_view *) &u32GDCMWRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCMWRA_MWR(ctrlr) (pst_bitGDCMWRA(ctrlr) -> MWR)
N#define vSetGDCMWRA_MWR(ctrlr,ParValue)  (pst_bitGDCMWRA(ctrlr) -> MWR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGDCMWRAL(ctrlr,ParValue) (pst_u8GDCMWRA(ctrlr) -> u8L = (ParValue))
N#define u8GetGDCMWRAL(ctrlr) (pst_u8GDCMWRA(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetGDCMWRAH(ctrlr,ParValue) (pst_u8GDCMWRA(ctrlr) -> u8H = (ParValue))
N#define u8GetGDCMWRAH(ctrlr) (pst_u8GDCMWRA(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetGDCMWRA(ctrlr,ParValue) (*pu16GDCMWRA(ctrlr)  = (ParValue))
N#define u16GetGDCMWRA(ctrlr) (*pu16GDCMWRA(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCMWRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02070                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCMWRB_REG__       0xC0C02070U
N#else
S#define GDCMWRB_REG__ ((uint32_t) GDCMWRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   MWR	:13; 	 /* 0..12  bit(s) R/W */ 
N  uint16_t   	:3; 	 /* 13..63  bit(s) R */                    
N} GDCMWRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCMWRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCMWRB_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCMWRB(ctrlr)     ((volatile GDCMWRB_bit_view_st *)\
S(GDCMWRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCMWRB(ctrlr)     ((volatile GDCMWRB_bit_view_st *)(GDCMWRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCMWRB(ctrlr)     ((volatile GDCMWRB_byte_view_st *)\
S(GDCMWRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCMWRB(ctrlr)     ((volatile GDCMWRB_byte_view_st *)(GDCMWRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD */
S#define pu16GDCMWRB(ctrlr)     ((volatile u16GDCMWRB_halfword_view *)\
S(GDCMWRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCMWRB(ctrlr)     ((volatile u16GDCMWRB_halfword_view *)(GDCMWRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCMWRB(ctrlr)     ((volatile GDCMWRB_bit_view_st *) &u32GDCMWRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCMWRB(ctrlr)     ((volatile GDCMWRB_byte_view_st *) &u32GDCMWRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD */
N#define pu16GDCMWRB(ctrlr)     ((volatile u16GDCMWRB_halfword_view *) &u32GDCMWRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCMWRB_MWR(ctrlr) (pst_bitGDCMWRB(ctrlr) -> MWR)
N#define vSetGDCMWRB_MWR(ctrlr,ParValue)  (pst_bitGDCMWRB(ctrlr) -> MWR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGDCMWRBL(ctrlr,ParValue) (pst_u8GDCMWRB(ctrlr) -> u8L = (ParValue))
N#define u8GetGDCMWRBL(ctrlr) (pst_u8GDCMWRB(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetGDCMWRBH(ctrlr,ParValue) (pst_u8GDCMWRB(ctrlr) -> u8H = (ParValue))
N#define u8GetGDCMWRBH(ctrlr) (pst_u8GDCMWRB(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetGDCMWRB(ctrlr,ParValue) (*pu16GDCMWRB(ctrlr)  = (ParValue))
N#define u16GetGDCMWRB(ctrlr) (*pu16GDCMWRB(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCMWRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02078                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCMWRC_REG__       0xC0C02078U
N#else
S#define GDCMWRC_REG__ ((uint32_t) GDCMWRC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   MWR	:13; 	 /* 0..12  bit(s) R/W */ 
N  uint16_t   	:3; 	 /* 13..63  bit(s) R */                    
N} GDCMWRC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCMWRC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCMWRC_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCMWRC(ctrlr)     ((volatile GDCMWRC_bit_view_st *)\
S(GDCMWRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCMWRC(ctrlr)     ((volatile GDCMWRC_bit_view_st *)(GDCMWRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCMWRC(ctrlr)     ((volatile GDCMWRC_byte_view_st *)\
S(GDCMWRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCMWRC(ctrlr)     ((volatile GDCMWRC_byte_view_st *)(GDCMWRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD */
S#define pu16GDCMWRC(ctrlr)     ((volatile u16GDCMWRC_halfword_view *)\
S(GDCMWRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCMWRC(ctrlr)     ((volatile u16GDCMWRC_halfword_view *)(GDCMWRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCMWRC(ctrlr)     ((volatile GDCMWRC_bit_view_st *) &u32GDCMWRC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCMWRC(ctrlr)     ((volatile GDCMWRC_byte_view_st *) &u32GDCMWRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD */
N#define pu16GDCMWRC(ctrlr)     ((volatile u16GDCMWRC_halfword_view *) &u32GDCMWRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCMWRC_MWR(ctrlr) (pst_bitGDCMWRC(ctrlr) -> MWR)
N#define vSetGDCMWRC_MWR(ctrlr,ParValue)  (pst_bitGDCMWRC(ctrlr) -> MWR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGDCMWRCL(ctrlr,ParValue) (pst_u8GDCMWRC(ctrlr) -> u8L = (ParValue))
N#define u8GetGDCMWRCL(ctrlr) (pst_u8GDCMWRC(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetGDCMWRCH(ctrlr,ParValue) (pst_u8GDCMWRC(ctrlr) -> u8H = (ParValue))
N#define u8GetGDCMWRCH(ctrlr) (pst_u8GDCMWRC(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetGDCMWRC(ctrlr,ParValue) (*pu16GDCMWRC(ctrlr)  = (ParValue))
N#define u16GetGDCMWRC(ctrlr) (*pu16GDCMWRC(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCMWRD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02080                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCMWRD_REG__       0xC0C02080U
N#else
S#define GDCMWRD_REG__ ((uint32_t) GDCMWRD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   MWR	:13; 	 /* 0..12  bit(s) R/W */ 
N  uint16_t   	:3; 	 /* 13..63  bit(s) R */                    
N} GDCMWRD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCMWRD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCMWRD_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCMWRD(ctrlr)     ((volatile GDCMWRD_bit_view_st *)\
S(GDCMWRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCMWRD(ctrlr)     ((volatile GDCMWRD_bit_view_st *)(GDCMWRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCMWRD(ctrlr)     ((volatile GDCMWRD_byte_view_st *)\
S(GDCMWRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCMWRD(ctrlr)     ((volatile GDCMWRD_byte_view_st *)(GDCMWRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD */
S#define pu16GDCMWRD(ctrlr)     ((volatile u16GDCMWRD_halfword_view *)\
S(GDCMWRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCMWRD(ctrlr)     ((volatile u16GDCMWRD_halfword_view *)(GDCMWRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCMWRD(ctrlr)     ((volatile GDCMWRD_bit_view_st *) &u32GDCMWRD_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCMWRD(ctrlr)     ((volatile GDCMWRD_byte_view_st *) &u32GDCMWRD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD */
N#define pu16GDCMWRD(ctrlr)     ((volatile u16GDCMWRD_halfword_view *) &u32GDCMWRD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCMWRD_MWR(ctrlr) (pst_bitGDCMWRD(ctrlr) -> MWR)
N#define vSetGDCMWRD_MWR(ctrlr,ParValue)  (pst_bitGDCMWRD(ctrlr) -> MWR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGDCMWRDL(ctrlr,ParValue) (pst_u8GDCMWRD(ctrlr) -> u8L = (ParValue))
N#define u8GetGDCMWRDL(ctrlr) (pst_u8GDCMWRD(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetGDCMWRDH(ctrlr,ParValue) (pst_u8GDCMWRD(ctrlr) -> u8H = (ParValue))
N#define u8GetGDCMWRDH(ctrlr) (pst_u8GDCMWRD(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetGDCMWRD(ctrlr,ParValue) (*pu16GDCMWRD(ctrlr)  = (ParValue))
N#define u16GetGDCMWRD(ctrlr) (*pu16GDCMWRD(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCMWRE                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02088                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCMWRE_REG__       0xC0C02088U
N#else
S#define GDCMWRE_REG__ ((uint32_t) GDCMWRE_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   MWR	:13; 	 /* 0..12  bit(s) R/W */ 
N  uint16_t   	:3; 	 /* 13..63  bit(s) R */                    
N} GDCMWRE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCMWRE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCMWRE_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCMWRE(ctrlr)     ((volatile GDCMWRE_bit_view_st *)\
S(GDCMWRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCMWRE(ctrlr)     ((volatile GDCMWRE_bit_view_st *)(GDCMWRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCMWRE(ctrlr)     ((volatile GDCMWRE_byte_view_st *)\
S(GDCMWRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCMWRE(ctrlr)     ((volatile GDCMWRE_byte_view_st *)(GDCMWRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD */
S#define pu16GDCMWRE(ctrlr)     ((volatile u16GDCMWRE_halfword_view *)\
S(GDCMWRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCMWRE(ctrlr)     ((volatile u16GDCMWRE_halfword_view *)(GDCMWRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCMWRE(ctrlr)     ((volatile GDCMWRE_bit_view_st *) &u32GDCMWRE_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCMWRE(ctrlr)     ((volatile GDCMWRE_byte_view_st *) &u32GDCMWRE_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD */
N#define pu16GDCMWRE(ctrlr)     ((volatile u16GDCMWRE_halfword_view *) &u32GDCMWRE_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCMWRE_MWR(ctrlr) (pst_bitGDCMWRE(ctrlr) -> MWR)
N#define vSetGDCMWRE_MWR(ctrlr,ParValue)  (pst_bitGDCMWRE(ctrlr) -> MWR=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGDCMWREL(ctrlr,ParValue) (pst_u8GDCMWRE(ctrlr) -> u8L = (ParValue))
N#define u8GetGDCMWREL(ctrlr) (pst_u8GDCMWRE(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetGDCMWREH(ctrlr,ParValue) (pst_u8GDCMWRE(ctrlr) -> u8H = (ParValue))
N#define u8GetGDCMWREH(ctrlr) (pst_u8GDCMWRE(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetGDCMWRE(ctrlr,ParValue) (*pu16GDCMWRE(ctrlr)  = (ParValue))
N#define u16GetGDCMWRE(ctrlr) (*pu16GDCMWRE(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLSRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02090                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLSRA_REG__       0xC0C02090U
N#else
S#define GDCLSRA_REG__ ((uint32_t) GDCLSRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   LHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCLSRA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLSRA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLSRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLSRA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLSRA(ctrlr)     ((volatile GDCLSRA_bit_view_st *)\
S(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLSRA(ctrlr)     ((volatile GDCLSRA_bit_view_st *)(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLSRA(ctrlr)     ((volatile GDCLSRA_byte_view_st *)\
S(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLSRA(ctrlr)     ((volatile GDCLSRA_byte_view_st *)(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLSRA(ctrlr)     ((volatile GDCLSRA_halfword_view_st *)\
S(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLSRA(ctrlr)     ((volatile GDCLSRA_halfword_view_st *)(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLSRA(ctrlr)     ((volatile u32GDCLSRA_word_view *)\
S(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLSRA(ctrlr)     ((volatile u32GDCLSRA_word_view *)(GDCLSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N/* Pointer to BIT-struct */
N#define pst_bitGDCLSRA(ctrlr)     ((volatile GDCLSRA_bit_view_st *) &u32GDCLSRA_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLSRA(ctrlr)     ((volatile GDCLSRA_byte_view_st *) &u32GDCLSRA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLSRA(ctrlr)     ((volatile GDCLSRA_halfword_view_st *) &u32GDCLSRA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLSRA(ctrlr)     ((volatile u32GDCLSRA_word_view *) &u32GDCLSRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLSRA_LVS(ctrlr) (pst_bitGDCLSRA(ctrlr) -> LVS)
N#define vSetGDCLSRA_LVS(ctrlr,ParValue)  (pst_bitGDCLSRA(ctrlr) -> LVS=(ParValue))
N#define biGetGDCLSRA_LHS(ctrlr) (pst_bitGDCLSRA(ctrlr) -> LHS)
N#define vSetGDCLSRA_LHS(ctrlr,ParValue)  (pst_bitGDCLSRA(ctrlr) -> LHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLSRALL(ctrlr,ParValue) (pst_u8GDCLSRA(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLSRALL(ctrlr) (pst_u8GDCLSRA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLSRALH(ctrlr,ParValue) (pst_u8GDCLSRA(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLSRALH(ctrlr) (pst_u8GDCLSRA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLSRAHL(ctrlr,ParValue) (pst_u8GDCLSRA(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLSRAHL(ctrlr) (pst_u8GDCLSRA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLSRAHH(ctrlr,ParValue) (pst_u8GDCLSRA(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLSRAHH(ctrlr) (pst_u8GDCLSRA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLSRAL(ctrlr,ParValue) (pst_u16GDCLSRA(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLSRAL(ctrlr) (pst_u16GDCLSRA(ctrlr) -> u16L)
N#define vSetGDCLSRAH(ctrlr,ParValue) (pst_u16GDCLSRA(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLSRAH(ctrlr) (pst_u16GDCLSRA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLSRA(ctrlr,ParValue)  (*pu32GDCLSRA(ctrlr) = (ParValue))
N#define u32GetGDCLSRA(ctrlr)  (*pu32GDCLSRA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLSRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02098                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLSRB_REG__       0xC0C02098U
N#else
S#define GDCLSRB_REG__ ((uint32_t) GDCLSRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   LHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCLSRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLSRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLSRB_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLSRB_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLSRB(ctrlr)     ((volatile GDCLSRB_bit_view_st *)\
S(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLSRB(ctrlr)     ((volatile GDCLSRB_bit_view_st *)(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLSRB(ctrlr)     ((volatile GDCLSRB_byte_view_st *)\
S(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLSRB(ctrlr)     ((volatile GDCLSRB_byte_view_st *)(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLSRB(ctrlr)     ((volatile GDCLSRB_halfword_view_st *)\
S(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLSRB(ctrlr)     ((volatile GDCLSRB_halfword_view_st *)(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLSRB(ctrlr)     ((volatile u32GDCLSRB_word_view *)\
S(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLSRB(ctrlr)     ((volatile u32GDCLSRB_word_view *)(GDCLSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLSRB(ctrlr)     ((volatile GDCLSRB_bit_view_st *) &u32GDCLSRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLSRB(ctrlr)     ((volatile GDCLSRB_byte_view_st *) &u32GDCLSRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLSRB(ctrlr)     ((volatile GDCLSRB_halfword_view_st *) &u32GDCLSRB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLSRB(ctrlr)     ((volatile u32GDCLSRB_word_view *) &u32GDCLSRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLSRB_LVS(ctrlr) (pst_bitGDCLSRB(ctrlr) -> LVS)
N#define vSetGDCLSRB_LVS(ctrlr,ParValue)  (pst_bitGDCLSRB(ctrlr) -> LVS=(ParValue))
N#define biGetGDCLSRB_LHS(ctrlr) (pst_bitGDCLSRB(ctrlr) -> LHS)
N#define vSetGDCLSRB_LHS(ctrlr,ParValue)  (pst_bitGDCLSRB(ctrlr) -> LHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLSRBLL(ctrlr,ParValue) (pst_u8GDCLSRB(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLSRBLL(ctrlr) (pst_u8GDCLSRB(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLSRBLH(ctrlr,ParValue) (pst_u8GDCLSRB(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLSRBLH(ctrlr) (pst_u8GDCLSRB(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLSRBHL(ctrlr,ParValue) (pst_u8GDCLSRB(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLSRBHL(ctrlr) (pst_u8GDCLSRB(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLSRBHH(ctrlr,ParValue) (pst_u8GDCLSRB(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLSRBHH(ctrlr) (pst_u8GDCLSRB(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLSRBL(ctrlr,ParValue) (pst_u16GDCLSRB(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLSRBL(ctrlr) (pst_u16GDCLSRB(ctrlr) -> u16L)
N#define vSetGDCLSRBH(ctrlr,ParValue) (pst_u16GDCLSRB(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLSRBH(ctrlr) (pst_u16GDCLSRB(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLSRB(ctrlr,ParValue)  (*pu32GDCLSRB(ctrlr) = (ParValue))
N#define u32GetGDCLSRB(ctrlr)  (*pu32GDCLSRB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLSRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020A0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLSRC_REG__       0xC0C020A0U
N#else
S#define GDCLSRC_REG__ ((uint32_t) GDCLSRC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   LHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCLSRC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLSRC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLSRC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLSRC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLSRC(ctrlr)     ((volatile GDCLSRC_bit_view_st *)\
S(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLSRC(ctrlr)     ((volatile GDCLSRC_bit_view_st *)(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLSRC(ctrlr)     ((volatile GDCLSRC_byte_view_st *)\
S(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLSRC(ctrlr)     ((volatile GDCLSRC_byte_view_st *)(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLSRC(ctrlr)     ((volatile GDCLSRC_halfword_view_st *)\
S(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLSRC(ctrlr)     ((volatile GDCLSRC_halfword_view_st *)(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLSRC(ctrlr)     ((volatile u32GDCLSRC_word_view *)\
S(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLSRC(ctrlr)     ((volatile u32GDCLSRC_word_view *)(GDCLSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLSRC(ctrlr)     ((volatile GDCLSRC_bit_view_st *) &u32GDCLSRC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLSRC(ctrlr)     ((volatile GDCLSRC_byte_view_st *) &u32GDCLSRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLSRC(ctrlr)     ((volatile GDCLSRC_halfword_view_st *) &u32GDCLSRC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLSRC(ctrlr)     ((volatile u32GDCLSRC_word_view *) &u32GDCLSRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLSRC_LVS(ctrlr) (pst_bitGDCLSRC(ctrlr) -> LVS)
N#define vSetGDCLSRC_LVS(ctrlr,ParValue)  (pst_bitGDCLSRC(ctrlr) -> LVS=(ParValue))
N#define biGetGDCLSRC_LHS(ctrlr) (pst_bitGDCLSRC(ctrlr) -> LHS)
N#define vSetGDCLSRC_LHS(ctrlr,ParValue)  (pst_bitGDCLSRC(ctrlr) -> LHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLSRCLL(ctrlr,ParValue) (pst_u8GDCLSRC(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLSRCLL(ctrlr) (pst_u8GDCLSRC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLSRCLH(ctrlr,ParValue) (pst_u8GDCLSRC(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLSRCLH(ctrlr) (pst_u8GDCLSRC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLSRCHL(ctrlr,ParValue) (pst_u8GDCLSRC(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLSRCHL(ctrlr) (pst_u8GDCLSRC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLSRCHH(ctrlr,ParValue) (pst_u8GDCLSRC(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLSRCHH(ctrlr) (pst_u8GDCLSRC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLSRCL(ctrlr,ParValue) (pst_u16GDCLSRC(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLSRCL(ctrlr) (pst_u16GDCLSRC(ctrlr) -> u16L)
N#define vSetGDCLSRCH(ctrlr,ParValue) (pst_u16GDCLSRC(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLSRCH(ctrlr) (pst_u16GDCLSRC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLSRC(ctrlr,ParValue)  (*pu32GDCLSRC(ctrlr) = (ParValue))
N#define u32GetGDCLSRC(ctrlr)  (*pu32GDCLSRC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLSRD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020A8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLSRD_REG__       0xC0C020A8U
N#else
S#define GDCLSRD_REG__ ((uint32_t) GDCLSRD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   LHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCLSRD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLSRD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLSRD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLSRD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLSRD(ctrlr)     ((volatile GDCLSRD_bit_view_st *)\
S(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLSRD(ctrlr)     ((volatile GDCLSRD_bit_view_st *)(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLSRD(ctrlr)     ((volatile GDCLSRD_byte_view_st *)\
S(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLSRD(ctrlr)     ((volatile GDCLSRD_byte_view_st *)(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLSRD(ctrlr)     ((volatile GDCLSRD_halfword_view_st *)\
S(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLSRD(ctrlr)     ((volatile GDCLSRD_halfword_view_st *)(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLSRD(ctrlr)     ((volatile u32GDCLSRD_word_view *)\
S(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLSRD(ctrlr)     ((volatile u32GDCLSRD_word_view *)(GDCLSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLSRD(ctrlr)     ((volatile GDCLSRD_bit_view_st *) &u32GDCLSRD_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLSRD(ctrlr)     ((volatile GDCLSRD_byte_view_st *) &u32GDCLSRD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLSRD(ctrlr)     ((volatile GDCLSRD_halfword_view_st *) &u32GDCLSRD_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLSRD(ctrlr)     ((volatile u32GDCLSRD_word_view *) &u32GDCLSRD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLSRD_LVS(ctrlr) (pst_bitGDCLSRD(ctrlr) -> LVS)
N#define vSetGDCLSRD_LVS(ctrlr,ParValue)  (pst_bitGDCLSRD(ctrlr) -> LVS=(ParValue))
N#define biGetGDCLSRD_LHS(ctrlr) (pst_bitGDCLSRD(ctrlr) -> LHS)
N#define vSetGDCLSRD_LHS(ctrlr,ParValue)  (pst_bitGDCLSRD(ctrlr) -> LHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLSRDLL(ctrlr,ParValue) (pst_u8GDCLSRD(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLSRDLL(ctrlr) (pst_u8GDCLSRD(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLSRDLH(ctrlr,ParValue) (pst_u8GDCLSRD(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLSRDLH(ctrlr) (pst_u8GDCLSRD(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLSRDHL(ctrlr,ParValue) (pst_u8GDCLSRD(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLSRDHL(ctrlr) (pst_u8GDCLSRD(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLSRDHH(ctrlr,ParValue) (pst_u8GDCLSRD(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLSRDHH(ctrlr) (pst_u8GDCLSRD(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLSRDL(ctrlr,ParValue) (pst_u16GDCLSRD(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLSRDL(ctrlr) (pst_u16GDCLSRD(ctrlr) -> u16L)
N#define vSetGDCLSRDH(ctrlr,ParValue) (pst_u16GDCLSRD(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLSRDH(ctrlr) (pst_u16GDCLSRD(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLSRD(ctrlr,ParValue)  (*pu32GDCLSRD(ctrlr) = (ParValue))
N#define u32GetGDCLSRD(ctrlr)  (*pu32GDCLSRD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLSRE                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020B0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLSRE_REG__       0xC0C020B0U
N#else
S#define GDCLSRE_REG__ ((uint32_t) GDCLSRE_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   LHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCLSRE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLSRE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLSRE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLSRE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLSRE(ctrlr)     ((volatile GDCLSRE_bit_view_st *)\
S(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLSRE(ctrlr)     ((volatile GDCLSRE_bit_view_st *)(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLSRE(ctrlr)     ((volatile GDCLSRE_byte_view_st *)\
S(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLSRE(ctrlr)     ((volatile GDCLSRE_byte_view_st *)(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLSRE(ctrlr)     ((volatile GDCLSRE_halfword_view_st *)\
S(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLSRE(ctrlr)     ((volatile GDCLSRE_halfword_view_st *)(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLSRE(ctrlr)     ((volatile u32GDCLSRE_word_view *)\
S(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLSRE(ctrlr)     ((volatile u32GDCLSRE_word_view *)(GDCLSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLSRE(ctrlr)     ((volatile GDCLSRE_bit_view_st *) &u32GDCLSRE_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLSRE(ctrlr)     ((volatile GDCLSRE_byte_view_st *) &u32GDCLSRE_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLSRE(ctrlr)     ((volatile GDCLSRE_halfword_view_st *) &u32GDCLSRE_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLSRE(ctrlr)     ((volatile u32GDCLSRE_word_view *) &u32GDCLSRE_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLSRE_LVS(ctrlr) (pst_bitGDCLSRE(ctrlr) -> LVS)
N#define vSetGDCLSRE_LVS(ctrlr,ParValue)  (pst_bitGDCLSRE(ctrlr) -> LVS=(ParValue))
N#define biGetGDCLSRE_LHS(ctrlr) (pst_bitGDCLSRE(ctrlr) -> LHS)
N#define vSetGDCLSRE_LHS(ctrlr,ParValue)  (pst_bitGDCLSRE(ctrlr) -> LHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLSRELL(ctrlr,ParValue) (pst_u8GDCLSRE(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLSRELL(ctrlr) (pst_u8GDCLSRE(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLSRELH(ctrlr,ParValue) (pst_u8GDCLSRE(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLSRELH(ctrlr) (pst_u8GDCLSRE(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLSREHL(ctrlr,ParValue) (pst_u8GDCLSRE(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLSREHL(ctrlr) (pst_u8GDCLSRE(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLSREHH(ctrlr,ParValue) (pst_u8GDCLSRE(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLSREHH(ctrlr) (pst_u8GDCLSRE(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLSREL(ctrlr,ParValue) (pst_u16GDCLSRE(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLSREL(ctrlr) (pst_u16GDCLSRE(ctrlr) -> u16L)
N#define vSetGDCLSREH(ctrlr,ParValue) (pst_u16GDCLSRE(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLSREH(ctrlr) (pst_u16GDCLSRE(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLSRE(ctrlr,ParValue)  (*pu32GDCLSRE(ctrlr) = (ParValue))
N#define u32GetGDCLSRE(ctrlr)  (*pu32GDCLSRE(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLDRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020B8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLDRA_REG__       0xC0C020B8U
N#else
S#define GDCLDRA_REG__ ((uint32_t) GDCLDRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   LWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCLDRA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLDRA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLDRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLDRA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLDRA(ctrlr)     ((volatile GDCLDRA_bit_view_st *)\
S(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLDRA(ctrlr)     ((volatile GDCLDRA_bit_view_st *)(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLDRA(ctrlr)     ((volatile GDCLDRA_byte_view_st *)\
S(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLDRA(ctrlr)     ((volatile GDCLDRA_byte_view_st *)(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLDRA(ctrlr)     ((volatile GDCLDRA_halfword_view_st *)\
S(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLDRA(ctrlr)     ((volatile GDCLDRA_halfword_view_st *)(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLDRA(ctrlr)     ((volatile u32GDCLDRA_word_view *)\
S(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLDRA(ctrlr)     ((volatile u32GDCLDRA_word_view *)(GDCLDRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLDRA(ctrlr)     ((volatile GDCLDRA_bit_view_st *) &u32GDCLDRA_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLDRA(ctrlr)     ((volatile GDCLDRA_byte_view_st *) &u32GDCLDRA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLDRA(ctrlr)     ((volatile GDCLDRA_halfword_view_st *) &u32GDCLDRA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLDRA(ctrlr)     ((volatile u32GDCLDRA_word_view *) &u32GDCLDRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLDRA_LHEIGHT(ctrlr) (pst_bitGDCLDRA(ctrlr) -> LHEIGHT)
N#define vSetGDCLDRA_LHEIGHT(ctrlr,ParValue)  (pst_bitGDCLDRA(ctrlr) -> LHEIGHT=(ParValue))
N#define biGetGDCLDRA_LWIDTH(ctrlr) (pst_bitGDCLDRA(ctrlr) -> LWIDTH)
N#define vSetGDCLDRA_LWIDTH(ctrlr,ParValue)  (pst_bitGDCLDRA(ctrlr) -> LWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLDRALL(ctrlr,ParValue) (pst_u8GDCLDRA(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLDRALL(ctrlr) (pst_u8GDCLDRA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLDRALH(ctrlr,ParValue) (pst_u8GDCLDRA(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLDRALH(ctrlr) (pst_u8GDCLDRA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLDRAHL(ctrlr,ParValue) (pst_u8GDCLDRA(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLDRAHL(ctrlr) (pst_u8GDCLDRA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLDRAHH(ctrlr,ParValue) (pst_u8GDCLDRA(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLDRAHH(ctrlr) (pst_u8GDCLDRA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLDRAL(ctrlr,ParValue) (pst_u16GDCLDRA(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLDRAL(ctrlr) (pst_u16GDCLDRA(ctrlr) -> u16L)
N#define vSetGDCLDRAH(ctrlr,ParValue) (pst_u16GDCLDRA(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLDRAH(ctrlr) (pst_u16GDCLDRA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLDRA(ctrlr,ParValue)  (*pu32GDCLDRA(ctrlr) = (ParValue))
N#define u32GetGDCLDRA(ctrlr)  (*pu32GDCLDRA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLDRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020C0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLDRB_REG__       0xC0C020C0U
N#else
S#define GDCLDRB_REG__ ((uint32_t) &GDCLDRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   LWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCLDRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLDRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLDRB_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLDRB_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLDRB(ctrlr)     ((volatile GDCLDRB_bit_view_st *)\
S(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLDRB(ctrlr)     ((volatile GDCLDRB_bit_view_st *)(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLDRB(ctrlr)     ((volatile GDCLDRB_byte_view_st *)\
S(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLDRB(ctrlr)     ((volatile GDCLDRB_byte_view_st *)(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLDRB(ctrlr)     ((volatile GDCLDRB_halfword_view_st *)\
S(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLDRB(ctrlr)     ((volatile GDCLDRB_halfword_view_st *)(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLDRB(ctrlr)     ((volatile u32GDCLDRB_word_view *)\
S(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLDRB(ctrlr)     ((volatile u32GDCLDRB_word_view *)(GDCLDRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLDRB(ctrlr)     ((volatile GDCLDRB_bit_view_st *) &u32GDCLDRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLDRB(ctrlr)     ((volatile GDCLDRB_byte_view_st *) &u32GDCLDRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLDRB(ctrlr)     ((volatile GDCLDRB_halfword_view_st *) &u32GDCLDRB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLDRB(ctrlr)     ((volatile u32GDCLDRB_word_view *) &u32GDCLDRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLDRB_LHEIGHT(ctrlr) (pst_bitGDCLDRB(ctrlr) -> LHEIGHT)
N#define vSetGDCLDRB_LHEIGHT(ctrlr,ParValue)  (pst_bitGDCLDRB(ctrlr) -> LHEIGHT=(ParValue))
N#define biGetGDCLDRB_LWIDTH(ctrlr) (pst_bitGDCLDRB(ctrlr) -> LWIDTH)
N#define vSetGDCLDRB_LWIDTH(ctrlr,ParValue)  (pst_bitGDCLDRB(ctrlr) -> LWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLDRBLL(ctrlr,ParValue) (pst_u8GDCLDRB(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLDRBLL(ctrlr) (pst_u8GDCLDRB(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLDRBLH(ctrlr,ParValue) (pst_u8GDCLDRB(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLDRBLH(ctrlr) (pst_u8GDCLDRB(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLDRBHL(ctrlr,ParValue) (pst_u8GDCLDRB(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLDRBHL(ctrlr) (pst_u8GDCLDRB(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLDRBHH(ctrlr,ParValue) (pst_u8GDCLDRB(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLDRBHH(ctrlr) (pst_u8GDCLDRB(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLDRBL(ctrlr,ParValue) (pst_u16GDCLDRB(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLDRBL(ctrlr) (pst_u16GDCLDRB(ctrlr) -> u16L)
N#define vSetGDCLDRBH(ctrlr,ParValue) (pst_u16GDCLDRB(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLDRBH(ctrlr) (pst_u16GDCLDRB(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLDRB(ctrlr,ParValue)  (*pu32GDCLDRB(ctrlr) = (ParValue))
N#define u32GetGDCLDRB(ctrlr)  (*pu32GDCLDRB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLDRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020C8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLDRC_REG__       0xC0C020C8U
N#else
S#define GDCLDRC_REG__ ((uint32_t) GDCLDRC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   LWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCLDRC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLDRC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLDRC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLDRC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLDRC(ctrlr)     ((volatile GDCLDRC_bit_view_st *)\
S(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLDRC(ctrlr)     ((volatile GDCLDRC_bit_view_st *)(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLDRC(ctrlr)     ((volatile GDCLDRC_byte_view_st *)\
S(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLDRC(ctrlr)     ((volatile GDCLDRC_byte_view_st *)(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLDRC(ctrlr)     ((volatile GDCLDRC_halfword_view_st *)\
S(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLDRC(ctrlr)     ((volatile GDCLDRC_halfword_view_st *)(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLDRC(ctrlr)     ((volatile u32GDCLDRC_word_view *)\
S(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLDRC(ctrlr)     ((volatile u32GDCLDRC_word_view *)(GDCLDRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLDRC(ctrlr)     ((volatile GDCLDRC_bit_view_st *) &u32GDCLDRC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLDRC(ctrlr)     ((volatile GDCLDRC_byte_view_st *) &u32GDCLDRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLDRC(ctrlr)     ((volatile GDCLDRC_halfword_view_st *) &u32GDCLDRC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLDRC(ctrlr)     ((volatile u32GDCLDRC_word_view *) &u32GDCLDRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLDRC_LHEIGHT(ctrlr) (pst_bitGDCLDRC(ctrlr) -> LHEIGHT)
N#define vSetGDCLDRC_LHEIGHT(ctrlr,ParValue)  (pst_bitGDCLDRC(ctrlr) -> LHEIGHT=(ParValue))
N#define biGetGDCLDRC_LWIDTH(ctrlr) (pst_bitGDCLDRC(ctrlr) -> LWIDTH)
N#define vSetGDCLDRC_LWIDTH(ctrlr,ParValue)  (pst_bitGDCLDRC(ctrlr) -> LWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLDRCLL(ctrlr,ParValue) (pst_u8GDCLDRC(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLDRCLL(ctrlr) (pst_u8GDCLDRC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLDRCLH(ctrlr,ParValue) (pst_u8GDCLDRC(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLDRCLH(ctrlr) (pst_u8GDCLDRC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLDRCHL(ctrlr,ParValue) (pst_u8GDCLDRC(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLDRCHL(ctrlr) (pst_u8GDCLDRC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLDRCHH(ctrlr,ParValue) (pst_u8GDCLDRC(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLDRCHH(ctrlr) (pst_u8GDCLDRC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLDRCL(ctrlr,ParValue) (pst_u16GDCLDRC(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLDRCL(ctrlr) (pst_u16GDCLDRC(ctrlr) -> u16L)
N#define vSetGDCLDRCH(ctrlr,ParValue) (pst_u16GDCLDRC(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLDRCH(ctrlr) (pst_u16GDCLDRC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLDRC(ctrlr,ParValue)  (*pu32GDCLDRC(ctrlr) = (ParValue))
N#define u32GetGDCLDRC(ctrlr)  (*pu32GDCLDRC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLDRD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020D0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLDRD_REG__       0xC0C020D0U
N#else
S#define GDCLDRD_REG__ ((uint32_t) GDCLDRD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   LWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCLDRD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLDRD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLDRD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLDRD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLDRD(ctrlr)     ((volatile GDCLDRD_bit_view_st *)\
S(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLDRD(ctrlr)     ((volatile GDCLDRD_bit_view_st *)(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLDRD(ctrlr)     ((volatile GDCLDRD_byte_view_st *)\
S(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLDRD(ctrlr)     ((volatile GDCLDRD_byte_view_st *)(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLDRD(ctrlr)     ((volatile GDCLDRD_halfword_view_st *)\
S(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLDRD(ctrlr)     ((volatile GDCLDRD_halfword_view_st *)(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLDRD(ctrlr)     ((volatile u32GDCLDRD_word_view *)\
S(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLDRD(ctrlr)     ((volatile u32GDCLDRD_word_view *)(GDCLDRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLDRD(ctrlr)     ((volatile GDCLDRD_bit_view_st *) &u32GDCLDRD_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLDRD(ctrlr)     ((volatile GDCLDRD_byte_view_st *) &u32GDCLDRD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLDRD(ctrlr)     ((volatile GDCLDRD_halfword_view_st *) &u32GDCLDRD_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLDRD(ctrlr)     ((volatile u32GDCLDRD_word_view *) &u32GDCLDRD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLDRD_LHEIGHT(ctrlr) (pst_bitGDCLDRD(ctrlr) -> LHEIGHT)
N#define vSetGDCLDRD_LHEIGHT(ctrlr,ParValue)  (pst_bitGDCLDRD(ctrlr) -> LHEIGHT=(ParValue))
N#define biGetGDCLDRD_LWIDTH(ctrlr) (pst_bitGDCLDRD(ctrlr) -> LWIDTH)
N#define vSetGDCLDRD_LWIDTH(ctrlr,ParValue)  (pst_bitGDCLDRD(ctrlr) -> LWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLDRDLL(ctrlr,ParValue) (pst_u8GDCLDRD(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLDRDLL(ctrlr) (pst_u8GDCLDRD(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLDRDLH(ctrlr,ParValue) (pst_u8GDCLDRD(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLDRDLH(ctrlr) (pst_u8GDCLDRD(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLDRDHL(ctrlr,ParValue) (pst_u8GDCLDRD(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLDRDHL(ctrlr) (pst_u8GDCLDRD(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLDRDHH(ctrlr,ParValue) (pst_u8GDCLDRD(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLDRDHH(ctrlr) (pst_u8GDCLDRD(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLDRDL(ctrlr,ParValue) (pst_u16GDCLDRD(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLDRDL(ctrlr) (pst_u16GDCLDRD(ctrlr) -> u16L)
N#define vSetGDCLDRDH(ctrlr,ParValue) (pst_u16GDCLDRD(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLDRDH(ctrlr) (pst_u16GDCLDRD(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLDRD(ctrlr,ParValue)  (*pu32GDCLDRD(ctrlr) = (ParValue))
N#define u32GetGDCLDRD(ctrlr)  (*pu32GDCLDRD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLDRE                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020D8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLDRE_REG__       0xC0C020D8U
N#else
S#define GDCLDRE_REG__ ((uint32_t) GDCLDRE_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   LWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCLDRE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLDRE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLDRE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLDRE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLDRE(ctrlr)     ((volatile GDCLDRE_bit_view_st *)\
S(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLDRE(ctrlr)     ((volatile GDCLDRE_bit_view_st *)(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLDRE(ctrlr)     ((volatile GDCLDRE_byte_view_st *)\
S(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLDRE(ctrlr)     ((volatile GDCLDRE_byte_view_st *)(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLDRE(ctrlr)     ((volatile GDCLDRE_halfword_view_st *)\
S(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLDRE(ctrlr)     ((volatile GDCLDRE_halfword_view_st *)(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLDRE(ctrlr)     ((volatile u32GDCLDRE_word_view *)\
S(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLDRE(ctrlr)     ((volatile u32GDCLDRE_word_view *)(GDCLDRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLDRE(ctrlr)     ((volatile GDCLDRE_bit_view_st *) &u32GDCLDRE_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLDRE(ctrlr)     ((volatile GDCLDRE_byte_view_st *) &u32GDCLDRE_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLDRE(ctrlr)     ((volatile GDCLDRE_halfword_view_st *) &u32GDCLDRE_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLDRE(ctrlr)     ((volatile u32GDCLDRE_word_view *) &u32GDCLDRE_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLDRE_LHEIGHT(ctrlr) (pst_bitGDCLDRE(ctrlr) -> LHEIGHT)
N#define vSetGDCLDRE_LHEIGHT(ctrlr,ParValue)  (pst_bitGDCLDRE(ctrlr) -> LHEIGHT=(ParValue))
N#define biGetGDCLDRE_LWIDTH(ctrlr) (pst_bitGDCLDRE(ctrlr) -> LWIDTH)
N#define vSetGDCLDRE_LWIDTH(ctrlr,ParValue)  (pst_bitGDCLDRE(ctrlr) -> LWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLDRELL(ctrlr,ParValue) (pst_u8GDCLDRE(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLDRELL(ctrlr) (pst_u8GDCLDRE(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLDRELH(ctrlr,ParValue) (pst_u8GDCLDRE(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLDRELH(ctrlr) (pst_u8GDCLDRE(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLDREHL(ctrlr,ParValue) (pst_u8GDCLDRE(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLDREHL(ctrlr) (pst_u8GDCLDRE(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLDREHH(ctrlr,ParValue) (pst_u8GDCLDRE(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLDREHH(ctrlr) (pst_u8GDCLDRE(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLDREL(ctrlr,ParValue) (pst_u16GDCLDRE(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLDREL(ctrlr) (pst_u16GDCLDRE(ctrlr) -> u16L)
N#define vSetGDCLDREH(ctrlr,ParValue) (pst_u16GDCLDRE(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLDREH(ctrlr) (pst_u16GDCLDRE(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLDRE(ctrlr,ParValue)  (*pu32GDCLDRE(ctrlr) = (ParValue))
N#define u32GetGDCLDRE(ctrlr)  (*pu32GDCLDRE(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWSRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020E0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWSRA_REG__       0xC0C020E0U
N#else
S#define GDCWSRA_REG__ ((uint32_t) GDCWSRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   WHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCWSRA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWSRA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWSRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWSRA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWSRA(ctrlr)     ((volatile GDCWSRA_bit_view_st *)\
S(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWSRA(ctrlr)     ((volatile GDCWSRA_bit_view_st *)(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWSRA(ctrlr)     ((volatile GDCWSRA_byte_view_st *)\
S(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWSRA(ctrlr)     ((volatile GDCWSRA_byte_view_st *)(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWSRA(ctrlr)     ((volatile GDCWSRA_halfword_view_st *)\
S(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWSRA(ctrlr)     ((volatile GDCWSRA_halfword_view_st *)(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWSRA(ctrlr)     ((volatile u32GDCWSRA_word_view *)\
S(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWSRA(ctrlr)     ((volatile u32GDCWSRA_word_view *)(GDCWSRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWSRA(ctrlr)     ((volatile GDCWSRA_bit_view_st *) &u32GDCWSRA_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWSRA(ctrlr)     ((volatile GDCWSRA_byte_view_st *) &u32GDCWSRA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWSRA(ctrlr)     ((volatile GDCWSRA_halfword_view_st *) &u32GDCWSRA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWSRA(ctrlr)     ((volatile u32GDCWSRA_word_view *) &u32GDCWSRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWSRA_WVS(ctrlr) (pst_bitGDCWSRA(ctrlr) -> WVS)
N#define vSetGDCWSRA_WVS(ctrlr,ParValue)  (pst_bitGDCWSRA(ctrlr) -> WVS=(ParValue))
N#define biGetGDCWSRA_WHS(ctrlr) (pst_bitGDCWSRA(ctrlr) -> WHS)
N#define vSetGDCWSRA_WHS(ctrlr,ParValue)  (pst_bitGDCWSRA(ctrlr) -> WHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWSRALL(ctrlr,ParValue) (pst_u8GDCWSRA(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWSRALL(ctrlr) (pst_u8GDCWSRA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWSRALH(ctrlr,ParValue) (pst_u8GDCWSRA(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWSRALH(ctrlr) (pst_u8GDCWSRA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWSRAHL(ctrlr,ParValue) (pst_u8GDCWSRA(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWSRAHL(ctrlr) (pst_u8GDCWSRA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWSRAHH(ctrlr,ParValue) (pst_u8GDCWSRA(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWSRAHH(ctrlr) (pst_u8GDCWSRA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWSRAL(ctrlr,ParValue) (pst_u16GDCWSRA(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWSRAL(ctrlr) (pst_u16GDCWSRA(ctrlr) -> u16L)
N#define vSetGDCWSRAH(ctrlr,ParValue) (pst_u16GDCWSRA(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWSRAH(ctrlr) (pst_u16GDCWSRA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWSRA(ctrlr,ParValue)  (*pu32GDCWSRA(ctrlr) = (ParValue))
N#define u32GetGDCWSRA(ctrlr)  (*pu32GDCWSRA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWSRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020E8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWSRB_REG__       0xC0C020E8U
N#else
S#define GDCWSRB_REG__ ((uint32_t) GDCWSRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WVDS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   WHDS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCWSRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWSRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWSRB_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWSRB_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWSRB(ctrlr)     ((volatile GDCWSRB_bit_view_st *)\
S(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWSRB(ctrlr)     ((volatile GDCWSRB_bit_view_st *)(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWSRB(ctrlr)     ((volatile GDCWSRB_byte_view_st *)\
S(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWSRB(ctrlr)     ((volatile GDCWSRB_byte_view_st *)(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWSRB(ctrlr)     ((volatile GDCWSRB_halfword_view_st *)\
S(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWSRB(ctrlr)     ((volatile GDCWSRB_halfword_view_st *)(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWSRB(ctrlr)     ((volatile u32GDCWSRB_word_view *)\
S(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWSRB(ctrlr)     ((volatile u32GDCWSRB_word_view *)(GDCWSRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWSRB(ctrlr)     ((volatile GDCWSRB_bit_view_st *) &u32GDCWSRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWSRB(ctrlr)     ((volatile GDCWSRB_byte_view_st *) &u32GDCWSRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWSRB(ctrlr)     ((volatile GDCWSRB_halfword_view_st *) &u32GDCWSRB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWSRB(ctrlr)     ((volatile u32GDCWSRB_word_view *) &u32GDCWSRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWSRB_WVDS(ctrlr) (pst_bitGDCWSRB(ctrlr) -> WVDS)
N#define vSetGDCWSRB_WVDS(ctrlr,ParValue)  (pst_bitGDCWSRB(ctrlr) -> WVDS=(ParValue))
N#define biGetGDCWSRB_WHDS(ctrlr) (pst_bitGDCWSRB(ctrlr) -> WHDS)
N#define vSetGDCWSRB_WHDS(ctrlr,ParValue)  (pst_bitGDCWSRB(ctrlr) -> WHDS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWSRBLL(ctrlr,ParValue) (pst_u8GDCWSRB(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWSRBLL(ctrlr) (pst_u8GDCWSRB(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWSRBLH(ctrlr,ParValue) (pst_u8GDCWSRB(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWSRBLH(ctrlr) (pst_u8GDCWSRB(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWSRBHL(ctrlr,ParValue) (pst_u8GDCWSRB(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWSRBHL(ctrlr) (pst_u8GDCWSRB(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWSRBHH(ctrlr,ParValue) (pst_u8GDCWSRB(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWSRBHH(ctrlr) (pst_u8GDCWSRB(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWSRBL(ctrlr,ParValue) (pst_u16GDCWSRB(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWSRBL(ctrlr) (pst_u16GDCWSRB(ctrlr) -> u16L)
N#define vSetGDCWSRBH(ctrlr,ParValue) (pst_u16GDCWSRB(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWSRBH(ctrlr) (pst_u16GDCWSRB(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWSRB(ctrlr,ParValue)  (*pu32GDCWSRB(ctrlr) = (ParValue))
N#define u32GetGDCWSRB(ctrlr)  (*pu32GDCWSRB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWIMRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020F0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWIMRA_REG__       0xC0C020F0U
N#else
S#define GDCWIMRA_REG__ ((uint32_t) GDCWIMRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   WWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCWIMRA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWIMRA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWIMRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWIMRA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWIMRA(ctrlr)     ((volatile GDCWIMRA_bit_view_st *)\
S(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWIMRA(ctrlr)     ((volatile GDCWIMRA_bit_view_st *)(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWIMRA(ctrlr)     ((volatile GDCWIMRA_byte_view_st *)\
S(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWIMRA(ctrlr)     ((volatile GDCWIMRA_byte_view_st *)(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWIMRA(ctrlr)     ((volatile GDCWIMRA_halfword_view_st *)\
S(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWIMRA(ctrlr)     ((volatile GDCWIMRA_halfword_view_st *)(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWIMRA(ctrlr)     ((volatile u32GDCWIMRA_word_view *)\
S(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWIMRA(ctrlr)     ((volatile u32GDCWIMRA_word_view *)(GDCWIMRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWIMRA(ctrlr)     ((volatile GDCWIMRA_bit_view_st *) &u32GDCWIMRA_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWIMRA(ctrlr)     ((volatile GDCWIMRA_byte_view_st *) &u32GDCWIMRA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWIMRA(ctrlr)     ((volatile GDCWIMRA_halfword_view_st *) &u32GDCWIMRA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWIMRA(ctrlr)     ((volatile u32GDCWIMRA_word_view *) &u32GDCWIMRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWIMRA_WHEIGHT(ctrlr) (pst_bitGDCWIMRA(ctrlr) -> WHEIGHT)
N#define vSetGDCWIMRA_WHEIGHT(ctrlr,ParValue)  (pst_bitGDCWIMRA(ctrlr) -> WHEIGHT=(ParValue))
N#define biGetGDCWIMRA_WWIDTH(ctrlr) (pst_bitGDCWIMRA(ctrlr) -> WWIDTH)
N#define vSetGDCWIMRA_WWIDTH(ctrlr,ParValue)  (pst_bitGDCWIMRA(ctrlr) -> WWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWIMRALL(ctrlr,ParValue) (pst_u8GDCWIMRA(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWIMRALL(ctrlr) (pst_u8GDCWIMRA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWIMRALH(ctrlr,ParValue) (pst_u8GDCWIMRA(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWIMRALH(ctrlr) (pst_u8GDCWIMRA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWIMRAHL(ctrlr,ParValue) (pst_u8GDCWIMRA(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWIMRAHL(ctrlr) (pst_u8GDCWIMRA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWIMRAHH(ctrlr,ParValue) (pst_u8GDCWIMRA(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWIMRAHH(ctrlr) (pst_u8GDCWIMRA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWIMRAL(ctrlr,ParValue) (pst_u16GDCWIMRA(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWIMRAL(ctrlr) (pst_u16GDCWIMRA(ctrlr) -> u16L)
N#define vSetGDCWIMRAH(ctrlr,ParValue) (pst_u16GDCWIMRA(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWIMRAH(ctrlr) (pst_u16GDCWIMRA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWIMRA(ctrlr,ParValue)  (*pu32GDCWIMRA(ctrlr) = (ParValue))
N#define u32GetGDCWIMRA(ctrlr)  (*pu32GDCWIMRA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWIMRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C020F8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWIMRB_REG__       0xC0C020F8U
N#else
S#define GDCWIMRB_REG__ ((uint32_t) GDCWIMRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   WWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCWIMRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWIMRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWIMRB_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWIMRB_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWIMRB(ctrlr)     ((volatile GDCWIMRB_bit_view_st *)\
S(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWIMRB(ctrlr)     ((volatile GDCWIMRB_bit_view_st *)(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWIMRB(ctrlr)     ((volatile GDCWIMRB_byte_view_st *)\
S(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWIMRB(ctrlr)     ((volatile GDCWIMRB_byte_view_st *)(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWIMRB(ctrlr)     ((volatile GDCWIMRB_halfword_view_st *)\
S(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWIMRB(ctrlr)     ((volatile GDCWIMRB_halfword_view_st *)(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWIMRB(ctrlr)     ((volatile u32GDCWIMRB_word_view *)\
S(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWIMRB(ctrlr)     ((volatile u32GDCWIMRB_word_view *)(GDCWIMRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWIMRB(ctrlr)     ((volatile GDCWIMRB_bit_view_st *) &u32GDCWIMRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWIMRB(ctrlr)     ((volatile GDCWIMRB_byte_view_st *) &u32GDCWIMRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWIMRB(ctrlr)     ((volatile GDCWIMRB_halfword_view_st *) &u32GDCWIMRB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWIMRB(ctrlr)     ((volatile u32GDCWIMRB_word_view *) &u32GDCWIMRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWIMRB_WHEIGHT(ctrlr) (pst_bitGDCWIMRB(ctrlr) -> WHEIGHT)
N#define vSetGDCWIMRB_WHEIGHT(ctrlr,ParValue)  (pst_bitGDCWIMRB(ctrlr) -> WHEIGHT=(ParValue))
N#define biGetGDCWIMRB_WWIDTH(ctrlr) (pst_bitGDCWIMRB(ctrlr) -> WWIDTH)
N#define vSetGDCWIMRB_WWIDTH(ctrlr,ParValue)  (pst_bitGDCWIMRB(ctrlr) -> WWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWIMRBLL(ctrlr,ParValue) (pst_u8GDCWIMRB(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWIMRBLL(ctrlr) (pst_u8GDCWIMRB(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWIMRBLH(ctrlr,ParValue) (pst_u8GDCWIMRB(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWIMRBLH(ctrlr) (pst_u8GDCWIMRB(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWIMRBHL(ctrlr,ParValue) (pst_u8GDCWIMRB(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWIMRBHL(ctrlr) (pst_u8GDCWIMRB(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWIMRBHH(ctrlr,ParValue) (pst_u8GDCWIMRB(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWIMRBHH(ctrlr) (pst_u8GDCWIMRB(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWIMRBL(ctrlr,ParValue) (pst_u16GDCWIMRB(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWIMRBL(ctrlr) (pst_u16GDCWIMRB(ctrlr) -> u16L)
N#define vSetGDCWIMRBH(ctrlr,ParValue) (pst_u16GDCWIMRB(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWIMRBH(ctrlr) (pst_u16GDCWIMRB(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWIMRB(ctrlr,ParValue)  (*pu32GDCWIMRB(ctrlr) = (ParValue))
N#define u32GetGDCWIMRB(ctrlr)  (*pu32GDCWIMRB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCAVRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02100                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCAVRA_REG__       0xC0C02100U
N#else
S#define GDCCAVRA_REG__ ((uint32_t) GDCCAVRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   ALPHAA	:8; 	 /* 0..7  bit(s) R/W */
N  uint64_t   WALPHAA	:8; 	 /* 8..15  bit(s) R/W */
N  uint64_t   ALPHAB	:8; 	 /* 16..23  bit(s) R/W */
N  uint64_t   WALPHAB	:8; 	 /* 24..31  bit(s) R/W */
N  uint64_t   ALPHAC	:8; 	 /* 32..39  bit(s) R/W */
N  uint64_t   WALPHAC	:8; 	 /* 40..47  bit(s) R/W */
N  uint64_t   ALPHAD	:8; 	 /* 48..55  bit(s) R/W */ 
N  uint64_t   WALPHAD	:8; 	 /* 56..63  bit(s) R/W */                    
N} GDCCAVRA_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCCAVRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCCAVRA_word_view_st;
N
N/* LONGWORD View */
Ntypedef uint64_t u64GDCCAVRA_longword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCCAVRA(ctrlr)     ((volatile GDCCAVRA_bit_view_st *)\
S(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCCAVRA(ctrlr)     ((volatile GDCCAVRA_bit_view_st *)(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCCAVRA(ctrlr)     ((volatile GDCCAVRA_halfword_view_st *)\
S(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCCAVRA(ctrlr)     ((volatile GDCCAVRA_halfword_view_st *)(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32GDCCAVRA(ctrlr)   ((volatile GDCCAVRA_word_view_st *) \
S(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCCAVRA(ctrlr)   ((volatile GDCCAVRA_word_view_st *) (GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
S/* Pointer to LONG_WORD  */
S#define pu64GDCCAVRA(ctrlr)    ((volatile u64GDCCAVRA_longword_view *)\
S(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCCAVRA(ctrlr)    ((volatile u64GDCCAVRA_longword_view *)(GDCCAVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCAVRA(ctrlr)     ((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCCAVRA(ctrlr)     ((volatile GDCCAVRA_halfword_view_st *) &u64GDCCAVRA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCCAVRA(ctrlr)   ((volatile GDCCAVRA_word_view_st *) &u64GDCCAVRA_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64GDCCAVRA(ctrlr)    ((volatile u64GDCCAVRA_longword_view *) &u64GDCCAVRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCAVRA_ALPHAA(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> ALPHAA)
N#define vSetGDCCAVRA_ALPHAA(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> ALPHAA=(ParValue))
N#define biGetGDCCAVRA_WALPHAA(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> WALPHAA)
N#define vSetGDCCAVRA_WALPHAA(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> WALPHAA=(ParValue))
N#define biGetGDCCAVRA_ALPHAB(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> ALPHAB)
N#define vSetGDCCAVRA_ALPHAB(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> ALPHAB=(ParValue))
N#define biGetGDCCAVRA_WALPHAB(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> WALPHAB)
N#define vSetGDCCAVRA_WALPHAB(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> WALPHAB=(ParValue))
N#define biGetGDCCAVRA_ALPHAC(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> ALPHAC)
N#define vSetGDCCAVRA_ALPHAC(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> ALPHAC=(ParValue))
N#define biGetGDCCAVRA_WALPHAC(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> WALPHAC)
N#define vSetGDCCAVRA_WALPHAC(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> WALPHAC=(ParValue))
N#define biGetGDCCAVRA_ALPHAD(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> ALPHAD)
N#define vSetGDCCAVRA_ALPHAD(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> ALPHAD=(ParValue))
N#define biGetGDCCAVRA_WALPHAD(ctrlr) (pst_bitGDCCAVRA(ctrlr) -> WALPHAD)
N#define vSetGDCCAVRA_WALPHAD(ctrlr,ParValue)  (pst_bitGDCCAVRA(ctrlr) -> WALPHAD=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetGDCCAVRALL(ctrlr,ParValue) (pst_u16GDCCAVRA(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCCAVRALL(ctrlr) (pst_u16GDCCAVRA(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCCAVRALH(ctrlr,ParValue) (pst_u16GDCCAVRA(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCCAVRALH(ctrlr) (pst_u16GDCCAVRA(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCCAVRAHL(ctrlr,ParValue) (pst_u16GDCCAVRA(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCCAVRAHL(ctrlr) (pst_u16GDCCAVRA(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCCAVRAHH(ctrlr,ParValue) (pst_u16GDCCAVRA(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCCAVRAHH(ctrlr) (pst_u16GDCCAVRA(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCCAVRAL(ctrlr,ParValue) (pst_u32GDCCAVRA(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCCAVRAL(ctrlr) (pst_u32GDCCAVRA(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCCAVRAH(ctrlr,ParValue) (pst_u32GDCCAVRA(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCCAVRAH(ctrlr) (pst_u32GDCCAVRA(ctrlr) -> u32H)
N
N/* Long  Word access */ 
N#define vSetGDCCAVRA(ctrlr,ParValue)  (*pu64GDCCAVRA(ctrlr) = (ParValue))
N#define u64GetGDCCAVRA(ctrlr)  (*pu64GDCCAVRA(ctrlr) )
N
N     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCAVRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02108                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCAVRB_REG__       0xC0C02108U
N#else
S#define GDCCAVRB_REG__ ((uint32_t) GDCCAVRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   ALPHAE	:8; 	 /* 0..7  bit(s) R/W */
N  uint16_t   WALPHAE	:8; 	 /* 8..15  bit(s) R/W */                    
N} GDCCAVRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCCAVRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCCAVRB_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCCAVRB(ctrlr)     ((volatile GDCCAVRB_bit_view_st *)\
S(GDCCAVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCCAVRB(ctrlr)     ((volatile GDCCAVRB_bit_view_st *)(GDCCAVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCCAVRB(ctrlr)     ((volatile GDCCAVRB_byte_view_st *)\
S(GDCCAVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCCAVRB(ctrlr)     ((volatile GDCCAVRB_byte_view_st *)(GDCCAVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD */
S#define pu16GDCCAVRB(ctrlr)     ((volatile u16GDCCAVRB_halfword_view *)\
S(GDCCAVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCCAVRB(ctrlr)     ((volatile u16GDCCAVRB_halfword_view *)(GDCCAVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCAVRB(ctrlr)     ((volatile GDCCAVRB_bit_view_st *) &u32GDCCAVRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCCAVRB(ctrlr)     ((volatile GDCCAVRB_byte_view_st *) &u32GDCCAVRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD */
N#define pu16GDCCAVRB(ctrlr)     ((volatile u16GDCCAVRB_halfword_view *) &u32GDCCAVRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCAVRB_ALPHAE(ctrlr) (pst_bitGDCCAVRB(ctrlr) -> ALPHAE)
N#define vSetGDCCAVRB_ALPHAE(ctrlr,ParValue)  (pst_bitGDCCAVRB(ctrlr) -> ALPHAE=(ParValue))
N#define biGetGDCCAVRB_WALPHAE(ctrlr) (pst_bitGDCCAVRB(ctrlr) -> WALPHAE)
N#define vSetGDCCAVRB_WALPHAE(ctrlr,ParValue)  (pst_bitGDCCAVRB(ctrlr) -> WALPHAE=(ParValue))
N            
N/* L-struct byte access */
N#define vSetGDCCAVRBL(ctrlr,ParValue) (pst_u8GDCCAVRB(ctrlr) -> u8L = (ParValue))
N#define u8GetGDCCAVRBL(ctrlr) (pst_u8GDCCAVRB(ctrlr) -> u8L)
N/* H-struct byte access */
N#define vSetGDCCAVRBH(ctrlr,ParValue) (pst_u8GDCCAVRB(ctrlr) -> u8H = (ParValue))
N#define u8GetGDCCAVRBH(ctrlr) (pst_u8GDCCAVRB(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define vSetGDCCAVRB(ctrlr,ParValue) (*pu16GDCCAVRB(ctrlr)  = (ParValue))
N#define u16GetGDCCAVRB(ctrlr) (*pu16GDCCAVRB(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCHSR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02110                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N
N#define GDCHSR_REG__       0xC0C02110U
N#else
S#define GDCHSR_REG__ ((uint32_t) GDCHSR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   HCR	:13; 	 /* 0..12  bit(s) R/W */
N  uint32_t   	:3; 	 /* 13..15  bit(s) R */
N  uint32_t   HSPWR	:8; 	 /* 16..23  bit(s) R/W */ 
N  uint32_t   	:8; 	 /* 24..63  bit(s) R */                    
N} GDCHSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCHSR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCHSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCHSR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCHSR(ctrlr)     ((volatile GDCHSR_bit_view_st *)\
S(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCHSR(ctrlr)     ((volatile GDCHSR_bit_view_st *)(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCHSR(ctrlr)     ((volatile GDCHSR_byte_view_st *)\
S(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCHSR(ctrlr)     ((volatile GDCHSR_byte_view_st *)(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCHSR(ctrlr)     ((volatile GDCHSR_halfword_view_st *)\
S(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCHSR(ctrlr)     ((volatile GDCHSR_halfword_view_st *)(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCHSR(ctrlr)     ((volatile u32GDCHSR_word_view *)\
S(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCHSR(ctrlr)     ((volatile u32GDCHSR_word_view *)(GDCHSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCHSR(ctrlr)     ((volatile GDCHSR_bit_view_st *) &u32GDCHSR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCHSR(ctrlr)     ((volatile GDCHSR_byte_view_st *) &u32GDCHSR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCHSR(ctrlr)     ((volatile GDCHSR_halfword_view_st *) &u32GDCHSR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCHSR(ctrlr)     ((volatile u32GDCHSR_word_view *) &u32GDCHSR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCHSR_HCR(ctrlr) (pst_bitGDCHSR(ctrlr) -> HCR)
N#define vSetGDCHSR_HCR(ctrlr,ParValue)  (pst_bitGDCHSR(ctrlr) -> HCR=(ParValue))
N#define biGetGDCHSR_HSPWR(ctrlr) (pst_bitGDCHSR(ctrlr) -> HSPWR)
N#define vSetGDCHSR_HSPWR(ctrlr,ParValue)  (pst_bitGDCHSR(ctrlr) -> HSPWR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCHSRLL(ctrlr,ParValue) (pst_u8GDCHSR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCHSRLL(ctrlr) (pst_u8GDCHSR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCHSRLH(ctrlr,ParValue) (pst_u8GDCHSR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCHSRLH(ctrlr) (pst_u8GDCHSR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCHSRHL(ctrlr,ParValue) (pst_u8GDCHSR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCHSRHL(ctrlr) (pst_u8GDCHSR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCHSRHH(ctrlr,ParValue) (pst_u8GDCHSR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCHSRHH(ctrlr) (pst_u8GDCHSR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCHSRL(ctrlr,ParValue) (pst_u16GDCHSR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCHSRL(ctrlr) (pst_u16GDCHSR(ctrlr) -> u16L)
N#define vSetGDCHSRH(ctrlr,ParValue) (pst_u16GDCHSR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCHSRH(ctrlr) (pst_u16GDCHSR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCHSR(ctrlr,ParValue)  (*pu32GDCHSR(ctrlr) = (ParValue))
N#define u32GetGDCHSR(ctrlr)  (*pu32GDCHSR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCVSR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02118                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCVSR_REG__       0xC0C02118U
N#else
S#define GDCVSR_REG__ ((uint32_t) GDCVSR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   VCR	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   VSPWR	:8; 	 /* 16..23  bit(s) R/W */
N  uint32_t   RSRVD24	:2; 	 /* 24..25  bit(s) R/W */ 
N  uint32_t   	:6; 	 /* 26..63  bit(s) R */                    
N} GDCVSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCVSR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCVSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCVSR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCVSR(ctrlr)     ((volatile GDCVSR_bit_view_st *)\
S(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCVSR(ctrlr)     ((volatile GDCVSR_bit_view_st *)(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCVSR(ctrlr)     ((volatile GDCVSR_byte_view_st *)\
S(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCVSR(ctrlr)     ((volatile GDCVSR_byte_view_st *)(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCVSR(ctrlr)     ((volatile GDCVSR_halfword_view_st *)\
S(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCVSR(ctrlr)     ((volatile GDCVSR_halfword_view_st *)(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCVSR(ctrlr)     ((volatile u32GDCVSR_word_view *)\
S(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCVSR(ctrlr)     ((volatile u32GDCVSR_word_view *)(GDCVSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCVSR(ctrlr)     ((volatile GDCVSR_bit_view_st *) &u32GDCVSR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCVSR(ctrlr)     ((volatile GDCVSR_byte_view_st *) &u32GDCVSR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCVSR(ctrlr)     ((volatile GDCVSR_halfword_view_st *) &u32GDCVSR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCVSR(ctrlr)     ((volatile u32GDCVSR_word_view *) &u32GDCVSR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCVSR_VCR(ctrlr) (pst_bitGDCVSR(ctrlr) -> VCR)
N#define vSetGDCVSR_VCR(ctrlr,ParValue)  (pst_bitGDCVSR(ctrlr) -> VCR=(ParValue))
N#define biGetGDCVSR_VSPWR(ctrlr) (pst_bitGDCVSR(ctrlr) -> VSPWR)
N#define vSetGDCVSR_VSPWR(ctrlr,ParValue)  (pst_bitGDCVSR(ctrlr) -> VSPWR=(ParValue))
N#define biGetGDCVSR_RSRVD24(ctrlr) (pst_bitGDCVSR(ctrlr) -> RSRVD24)
N#define vSetGDCVSR_RSRVD24(ctrlr,ParValue)  (pst_bitGDCVSR(ctrlr) -> RSRVD24=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCVSRLL(ctrlr,ParValue) (pst_u8GDCVSR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCVSRLL(ctrlr) (pst_u8GDCVSR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCVSRLH(ctrlr,ParValue) (pst_u8GDCVSR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCVSRLH(ctrlr) (pst_u8GDCVSR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCVSRHL(ctrlr,ParValue) (pst_u8GDCVSR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCVSRHL(ctrlr) (pst_u8GDCVSR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCVSRHH(ctrlr,ParValue) (pst_u8GDCVSR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCVSRHH(ctrlr) (pst_u8GDCVSR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCVSRL(ctrlr,ParValue) (pst_u16GDCVSR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCVSRL(ctrlr) (pst_u16GDCVSR(ctrlr) -> u16L)
N#define vSetGDCVSRH(ctrlr,ParValue) (pst_u16GDCVSR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCVSRH(ctrlr) (pst_u16GDCVSR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCVSR(ctrlr,ParValue)  (*pu32GDCVSR(ctrlr) = (ParValue))
N#define u32GetGDCVSR(ctrlr)  (*pu32GDCVSR(ctrlr) )
N                
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCBAR0                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02128                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCBAR0_REG__       0xC0C02128U
N#else
S#define GDCCBAR0_REG__ ((uint32_t) GDCCBAR0_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   CBAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCCBAR0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCCBAR0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCCBAR0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCCBAR0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCCBAR0(ctrlr)     ((volatile GDCCBAR0_bit_view_st *)\
S(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCCBAR0(ctrlr)     ((volatile GDCCBAR0_bit_view_st *)(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCCBAR0(ctrlr)     ((volatile GDCCBAR0_byte_view_st *)\
S(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCCBAR0(ctrlr)     ((volatile GDCCBAR0_byte_view_st *)(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCCBAR0(ctrlr)     ((volatile GDCCBAR0_halfword_view_st *)\
S(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCCBAR0(ctrlr)     ((volatile GDCCBAR0_halfword_view_st *)(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCCBAR0(ctrlr)     ((volatile u32GDCCBAR0_word_view *)\
S(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCCBAR0(ctrlr)     ((volatile u32GDCCBAR0_word_view *)(GDCCBAR0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCBAR0(ctrlr)     ((volatile GDCCBAR0_bit_view_st *) &u32GDCCBAR0_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCCBAR0(ctrlr)     ((volatile GDCCBAR0_byte_view_st *) &u32GDCCBAR0_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCCBAR0(ctrlr)     ((volatile GDCCBAR0_halfword_view_st *) &u32GDCCBAR0_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCCBAR0(ctrlr)     ((volatile u32GDCCBAR0_word_view *) &u32GDCCBAR0_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCBAR0_CBAR(ctrlr) (pst_bitGDCCBAR0(ctrlr) -> CBAR)
N#define vSetGDCCBAR0_CBAR(ctrlr,ParValue)  (pst_bitGDCCBAR0(ctrlr) -> CBAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCCBAR0LL(ctrlr,ParValue) (pst_u8GDCCBAR0(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCCBAR0LL(ctrlr) (pst_u8GDCCBAR0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCCBAR0LH(ctrlr,ParValue) (pst_u8GDCCBAR0(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCCBAR0LH(ctrlr) (pst_u8GDCCBAR0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCCBAR0HL(ctrlr,ParValue) (pst_u8GDCCBAR0(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCCBAR0HL(ctrlr) (pst_u8GDCCBAR0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCCBAR0HH(ctrlr,ParValue) (pst_u8GDCCBAR0(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCCBAR0HH(ctrlr) (pst_u8GDCCBAR0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCCBAR0L(ctrlr,ParValue) (pst_u16GDCCBAR0(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCCBAR0L(ctrlr) (pst_u16GDCCBAR0(ctrlr) -> u16L)
N#define vSetGDCCBAR0H(ctrlr,ParValue) (pst_u16GDCCBAR0(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCCBAR0H(ctrlr) (pst_u16GDCCBAR0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCCBAR0(ctrlr,ParValue)  (*pu32GDCCBAR0(ctrlr) = (ParValue))
N#define u32GetGDCCBAR0(ctrlr)  (*pu32GDCCBAR0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCBAR1                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02130                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCBAR1_REG__       0xC0C02130U
N#else
S#define GDCCBAR1_REG__ ((uint32_t) GDCCBAR1_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   CBAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCCBAR1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCCBAR1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCCBAR1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCCBAR1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCCBAR1(ctrlr)     ((volatile GDCCBAR1_bit_view_st *)\
S(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCCBAR1(ctrlr)     ((volatile GDCCBAR1_bit_view_st *)(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCCBAR1(ctrlr)     ((volatile GDCCBAR1_byte_view_st *)\
S(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCCBAR1(ctrlr)     ((volatile GDCCBAR1_byte_view_st *)(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCCBAR1(ctrlr)     ((volatile GDCCBAR1_halfword_view_st *)\
S(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCCBAR1(ctrlr)     ((volatile GDCCBAR1_halfword_view_st *)(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCCBAR1(ctrlr)     ((volatile u32GDCCBAR1_word_view *)\
S(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCCBAR1(ctrlr)     ((volatile u32GDCCBAR1_word_view *)(GDCCBAR1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCBAR1(ctrlr)     ((volatile GDCCBAR1_bit_view_st *) &u32GDCCBAR1_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCCBAR1(ctrlr)     ((volatile GDCCBAR1_byte_view_st *) &u32GDCCBAR1_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCCBAR1(ctrlr)     ((volatile GDCCBAR1_halfword_view_st *) &u32GDCCBAR1_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCCBAR1(ctrlr)     ((volatile u32GDCCBAR1_word_view *) &u32GDCCBAR1_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCBAR1_CBAR(ctrlr) (pst_bitGDCCBAR1(ctrlr) -> CBAR)
N#define vSetGDCCBAR1_CBAR(ctrlr,ParValue)  (pst_bitGDCCBAR1(ctrlr) -> CBAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCCBAR1LL(ctrlr,ParValue) (pst_u8GDCCBAR1(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCCBAR1LL(ctrlr) (pst_u8GDCCBAR1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCCBAR1LH(ctrlr,ParValue) (pst_u8GDCCBAR1(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCCBAR1LH(ctrlr) (pst_u8GDCCBAR1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCCBAR1HL(ctrlr,ParValue) (pst_u8GDCCBAR1(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCCBAR1HL(ctrlr) (pst_u8GDCCBAR1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCCBAR1HH(ctrlr,ParValue) (pst_u8GDCCBAR1(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCCBAR1HH(ctrlr) (pst_u8GDCCBAR1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCCBAR1L(ctrlr,ParValue) (pst_u16GDCCBAR1(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCCBAR1L(ctrlr) (pst_u16GDCCBAR1(ctrlr) -> u16L)
N#define vSetGDCCBAR1H(ctrlr,ParValue) (pst_u16GDCCBAR1(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCCBAR1H(ctrlr) (pst_u16GDCCBAR1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCCBAR1(ctrlr,ParValue)  (*pu32GDCCBAR1(ctrlr) = (ParValue))
N#define u32GetGDCCBAR1(ctrlr)  (*pu32GDCCBAR1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCBAR2                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02138                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCBAR2_REG__       0xC0C02138U
N#else
S#define GDCCBAR2_REG__ ((uint32_t) GDCCBAR2_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   CBAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCCBAR2_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCCBAR2_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCCBAR2_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCCBAR2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCCBAR2(ctrlr)     ((volatile GDCCBAR2_bit_view_st *)\
S(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCCBAR2(ctrlr)     ((volatile GDCCBAR2_bit_view_st *)(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCCBAR2(ctrlr)     ((volatile GDCCBAR2_byte_view_st *)\
S(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCCBAR2(ctrlr)     ((volatile GDCCBAR2_byte_view_st *)(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCCBAR2(ctrlr)     ((volatile GDCCBAR2_halfword_view_st *)\
S(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCCBAR2(ctrlr)     ((volatile GDCCBAR2_halfword_view_st *)(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCCBAR2(ctrlr)     ((volatile u32GDCCBAR2_word_view *)\
S(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCCBAR2(ctrlr)     ((volatile u32GDCCBAR2_word_view *)(GDCCBAR2_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCBAR2(ctrlr)     ((volatile GDCCBAR2_bit_view_st *) &u32GDCCBAR2_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCCBAR2(ctrlr)     ((volatile GDCCBAR2_byte_view_st *) &u32GDCCBAR2_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCCBAR2(ctrlr)     ((volatile GDCCBAR2_halfword_view_st *)GDCCBAR2_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCCBAR2(ctrlr)     ((volatile u32GDCCBAR2_word_view *) &u32GDCCBAR2_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCBAR2_CBAR(ctrlr) (pst_bitGDCCBAR2(ctrlr) -> CBAR)
N#define vSetGDCCBAR2_CBAR(ctrlr,ParValue)  (pst_bitGDCCBAR2(ctrlr) -> CBAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCCBAR2LL(ctrlr,ParValue) (pst_u8GDCCBAR2(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCCBAR2LL(ctrlr) (pst_u8GDCCBAR2(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCCBAR2LH(ctrlr,ParValue) (pst_u8GDCCBAR2(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCCBAR2LH(ctrlr) (pst_u8GDCCBAR2(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCCBAR2HL(ctrlr,ParValue) (pst_u8GDCCBAR2(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCCBAR2HL(ctrlr) (pst_u8GDCCBAR2(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCCBAR2HH(ctrlr,ParValue) (pst_u8GDCCBAR2(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCCBAR2HH(ctrlr) (pst_u8GDCCBAR2(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCCBAR2L(ctrlr,ParValue) (pst_u16GDCCBAR2(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCCBAR2L(ctrlr) (pst_u16GDCCBAR2(ctrlr) -> u16L)
N#define vSetGDCCBAR2H(ctrlr,ParValue) (pst_u16GDCCBAR2(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCCBAR2H(ctrlr) (pst_u16GDCCBAR2(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCCBAR2(ctrlr,ParValue)  (*pu32GDCCBAR2(ctrlr) = (ParValue))
N#define u32GetGDCCBAR2(ctrlr)  (*pu32GDCCBAR2(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCINTR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02140                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level
N*                        
N*****************************************************************************/
N/*NOTE!: This register is NOT a SHADOW-Register!:*/
N
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCINTR_REG__       0xC0C02140U
N#else
S#define GDCINTR_REG__ ((uint32_t) GDCINTR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   GAPMSK	:1; 	 /* 0..0  bit(s) R/W */
N  uint64_t   HSYNCMSK	:1; 	 /* 1..1  bit(s) R/W */
N  uint64_t   VSYNCMSK	:1; 	 /* 2..2  bit(s) R/W */
N  uint64_t   GBERMSK	:1; 	 /* 3..3  bit(s) R/W */
N  uint64_t   GAPINT	:1; 	 /* 4..4  bit(s) R/W1C */
N  uint64_t   HSYNCINT	:1; 	 /* 5..5  bit(s) R/W1C */
N  uint64_t   VSYNCINT	:1; 	 /* 6..6  bit(s) R/W1C */
N  uint64_t   GBERINT	:1; 	 /* 7..7  bit(s) R/W1C */
N  uint64_t   IFURMSK	:1; 	 /* 8..8  bit(s) R/W */
N  uint64_t   OFURMSK	:1; 	 /* 9..9  bit(s) R/W */
N  uint64_t   RSRVD10	:1; 	 /* 10..10  bit(s) R/W */
N  uint64_t   GPEMSK	:1; 	 /* 11..11  bit(s) R/W */
N  uint64_t   IFURINT	:1; 	 /* 12..12  bit(s) R/W1C */
N  uint64_t   OFURINT	:1; 	 /* 13..13  bit(s) R/W1C */
N  uint64_t   	:1; 	 /* 14..14  bit(s) R */
N  uint64_t   GPEINT	:1; 	 /* 15..15  bit(s) R/W1C */
N  uint64_t   LINE	:11; 	 /* 16..26  bit(s) R/W */
N  uint64_t   DLEMSK	:1; 	 /* 27..27  bit(s) R/W */
N  uint64_t   	:3; 	 /* 28..30  bit(s) R */
N  uint64_t   DLEINT	:1; 	 /* 31..31  bit(s) R/W1C */
N  uint64_t   APCMSK	:1; 	 /* 32..32  bit(s) R/W */
N  uint64_t   APEMSK	:1; 	 /* 33..33  bit(s) R/W */
N  uint64_t   	:2; 	 /* 34..35  bit(s) R */
N  uint64_t   APCINT	:1; 	 /* 36..36  bit(s) R/W1C */
N  uint64_t   APEINT	:1; 	 /* 37..37  bit(s) R/W1C */ 
N  uint64_t   	:26; 	 /* 38..63  bit(s) R */                    
N} GDCINTR_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCINTR_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCINTR_word_view_st;
N            
N/* LONGWORD View */
Ntypedef uint64_t u64GDCINTR_longword_view;
N             
N
N
N/************************     ACCESS POINTERS     ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCINTR(ctrlr)     ((volatile GDCINTR_bit_view_st *)\
N(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCINTR(ctrlr)     ((volatile GDCINTR_bit_view_st *)(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N        
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCINTR(ctrlr)     ((volatile GDCINTR_halfword_view_st *)\
N(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCINTR(ctrlr)     ((volatile GDCINTR_halfword_view_st *)(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N             
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCINTR(ctrlr)   ((volatile GDCINTR_word_view_st *) \
N(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCINTR(ctrlr)   ((volatile GDCINTR_word_view_st *) (GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to LONG_WORD  */
N#define pu64GDCINTR(ctrlr)    ((volatile u64GDCINTR_longword_view *)\
N(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCINTR(ctrlr)    ((volatile u64GDCINTR_longword_view *)(GDCINTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCINTR_GAPMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> GAPMSK)
N#define vSetGDCINTR_GAPMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> GAPMSK=(ParValue))
N#define biGetGDCINTR_HSYNCMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> HSYNCMSK)
N#define vSetGDCINTR_HSYNCMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> HSYNCMSK=(ParValue))
N#define biGetGDCINTR_VSYNCMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> VSYNCMSK)
N#define vSetGDCINTR_VSYNCMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> VSYNCMSK=(ParValue))
N#define biGetGDCINTR_GBERMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> GBERMSK)
N#define vSetGDCINTR_GBERMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> GBERMSK=(ParValue))
N#define biGetGDCINTR_GAPINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> GAPINT)
N#define vClrGDCINTR_GAPINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> GAPINT = (1))
N#define biGetGDCINTR_HSYNCINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> HSYNCINT)
N#define vClrGDCINTR_HSYNCINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> HSYNCINT = (1))
N#define biGetGDCINTR_VSYNCINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> VSYNCINT)
N#define vClrGDCINTR_VSYNCINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> VSYNCINT = (1))
N#define biGetGDCINTR_GBERINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> GBERINT)
N#define vClrGDCINTR_GBERINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> GBERINT = (1))
N#define biGetGDCINTR_IFURMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> IFURMSK)
N#define vSetGDCINTR_IFURMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> IFURMSK=(ParValue))
N#define biGetGDCINTR_OFURMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> OFURMSK)
N#define vSetGDCINTR_OFURMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> OFURMSK=(ParValue))
N#define biGetGDCINTR_RSRVD10(ctrlr) (pst_bitGDCINTR(ctrlr) -> RSRVD10)
N#define vSetGDCINTR_RSRVD10(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> RSRVD10=(ParValue))
N#define biGetGDCINTR_GPEMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> GPEMSK)
N#define vSetGDCINTR_GPEMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> GPEMSK=(ParValue))
N#define biGetGDCINTR_IFURINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> IFURINT)
N#define vClrGDCINTR_IFURINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> IFURINT = (1))
N#define biGetGDCINTR_OFURINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> OFURINT)
N#define vClrGDCINTR_OFURINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> OFURINT = (1))
N#define biGetGDCINTR_GPEINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> GPEINT)
N#define vClrGDCINTR_GPEINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> GPEINT = (1))
N#define biGetGDCINTR_LINE(ctrlr) (pst_bitGDCINTR(ctrlr) -> LINE)
N#define vSetGDCINTR_LINE(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> LINE=(ParValue))
N#define biGetGDCINTR_DLEMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> DLEMSK)
N#define vSetGDCINTR_DLEMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> DLEMSK=(ParValue))
N#define biGetGDCINTR_DLEINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> DLEINT)
N#define vClrGDCINTR_DLEINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> DLEINT = (1))
N#define biGetGDCINTR_APCMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> APCMSK)
N#define vSetGDCINTR_APCMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> APCMSK=(ParValue))
N#define biGetGDCINTR_APEMSK(ctrlr) (pst_bitGDCINTR(ctrlr) -> APEMSK)
N#define vSetGDCINTR_APEMSK(ctrlr,ParValue)  (pst_bitGDCINTR(ctrlr) -> APEMSK=(ParValue))
N#define biGetGDCINTR_APCINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> APCINT)
N#define vClrGDCINTR_APCINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> APCINT = (1))
N#define biGetGDCINTR_APEINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> APEINT)
N#define vClrGDCINTR_APEINT(ctrlr) (pst_bitGDCINTR(ctrlr) -> APEINT = (1))
N
N/* Half-word struct access LL */ 
N#define vSetGDCINTRLL(ctrlr,ParValue) (pst_u16GDCINTR(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCINTRLL(ctrlr) (pst_u16GDCINTR(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCINTRLH(ctrlr,ParValue) (pst_u16GDCINTR(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCINTRLH(ctrlr) (pst_u16GDCINTR(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCINTRHL(ctrlr,ParValue) (pst_u16GDCINTR(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCINTRHL(ctrlr) (pst_u16GDCINTR(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCINTRHH(ctrlr,ParValue) (pst_u16GDCINTR(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCINTRHH(ctrlr) (pst_u16GDCINTR(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCINTRL(ctrlr,ParValue) (pst_u32GDCINTR(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCINTRL(ctrlr) (pst_u32GDCINTR(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCINTRH(ctrlr,ParValue) (pst_u32GDCINTR(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCINTRH(ctrlr) (pst_u32GDCINTR(ctrlr) -> u32H)
N            
N/* Long  Word access */ 
N#define vSetGDCINTR(ctrlr,ParValue)  (*pu64GDCINTR(ctrlr) = (ParValue))
N#define u64GetGDCINTR(ctrlr)  (*pu64GDCINTR(ctrlr) )
N     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCPTCR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02148                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCPTCR_REG__       0xC0C02148U
N#else
S#define GDCPTCR_REG__ ((uint32_t) GDCPTCR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   ORGBEN	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   OINVEN	:1; 	 /* 1..1  bit(s) R/W */
N  uint32_t   ERGBEN	:1; 	 /* 2..2  bit(s) R/W */
N  uint32_t   EINVEN	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   ALT	:1; 	 /* 4..4  bit(s) R/W */
N  uint32_t   DCAL	:1; 	 /* 5..5  bit(s) R/W */
N  uint32_t   DDAL	:1; 	 /* 6..6  bit(s) R/W */
N  uint32_t   PPSYNC	:1; 	 /* 7..7  bit(s) R/W */
N  uint32_t   GPP0EN	:1; 	 /* 8..8  bit(s) R/W */
N  uint32_t   GPP1EN	:1; 	 /* 9..9  bit(s) R/W */
N  uint32_t   GPP2EN	:1; 	 /* 10..10  bit(s) R/W */
N  uint32_t   GPP3EN	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GPP4EN	:1; 	 /* 12..12  bit(s) R/W */
N  uint32_t   GPP5EN	:1; 	 /* 13..13  bit(s) R/W */
N  uint32_t   GPP6EN	:1; 	 /* 14..14  bit(s) R/W */
N  uint32_t   GPP7EN	:1; 	 /* 15..15  bit(s) R/W */
N  uint32_t   GPP8EN	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   GPP9EN	:1; 	 /* 17..17  bit(s) R/W */
N  uint32_t   GPP10EN	:1; 	 /* 18..18  bit(s) R/W */
N  uint32_t   GPP11EN	:1; 	 /* 19..19  bit(s) R/W */
N  uint32_t   RSPUP	:1; 	 /* 20..20  bit(s) R */
N  uint32_t   RSDRDY	:1; 	 /* 21..21  bit(s) R */
N  uint32_t   RSDSEN	:1; 	 /* 22..22  bit(s) R/W */
N  uint32_t   PSMEN	:1; 	 /* 23..23  bit(s) R/W */
N  uint32_t   OCMD	:2; 	 /* 24..25  bit(s) R/W */
N  uint32_t   PEMD	:2; 	 /* 26..27  bit(s) R/W */
N  uint32_t   HIZEN	:1; 	 /* 28..28  bit(s) R/W */
N  uint32_t   	:1; 	 /* 29..29  bit(s) R */
N  uint32_t   PSYNC	:1; 	 /* 30..30  bit(s) R */
N  uint32_t   PTCEN	:1; 	 /* 31..31  bit(s) R */                    
N} GDCPTCR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCPTCR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCPTCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCPTCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCPTCR(ctrlr)     ((volatile GDCPTCR_bit_view_st *)\
S(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCPTCR(ctrlr)     ((volatile GDCPTCR_bit_view_st *)(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCPTCR(ctrlr)     ((volatile GDCPTCR_byte_view_st *)\
S(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCPTCR(ctrlr)     ((volatile GDCPTCR_byte_view_st *)(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCPTCR(ctrlr)     ((volatile GDCPTCR_halfword_view_st *)\
S(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCPTCR(ctrlr)     ((volatile GDCPTCR_halfword_view_st *)(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCPTCR(ctrlr)     ((volatile u32GDCPTCR_word_view *)\
S(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCPTCR(ctrlr)     ((volatile u32GDCPTCR_word_view *)(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N/* Pointer to BIT-struct of shadow register*/
N#define pst_bitGDCPTCR_Direct(ctrlr)     ((volatile GDCPTCR_bit_view_st *)\
N(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCPTCR_Direct(ctrlr)     ((volatile GDCPTCR_bit_view_st *)(GDCPTCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCPTCR(ctrlr)     ((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCPTCR(ctrlr)     ((volatile GDCPTCR_byte_view_st *) &u32GDCPTCR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCPTCR(ctrlr)     ((volatile GDCPTCR_halfword_view_st *) &u32GDCPTCR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCPTCR(ctrlr)     ((volatile u32GDCPTCR_word_view *) &u32GDCPTCR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCPTCR_ORGBEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> ORGBEN)
N#define vSetGDCPTCR_ORGBEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> ORGBEN=(ParValue))
N#define biGetGDCPTCR_OINVEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> OINVEN)
N#define vSetGDCPTCR_OINVEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> OINVEN=(ParValue))
N#define biGetGDCPTCR_ERGBEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> ERGBEN)
N#define vSetGDCPTCR_ERGBEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> ERGBEN=(ParValue))
N#define biGetGDCPTCR_EINVEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> EINVEN)
N#define vSetGDCPTCR_EINVEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> EINVEN=(ParValue))
N#define biGetGDCPTCR_ALT(ctrlr) (pst_bitGDCPTCR(ctrlr) -> ALT)
N#define vSetGDCPTCR_ALT(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> ALT=(ParValue))
N#define biGetGDCPTCR_DCAL(ctrlr) (pst_bitGDCPTCR(ctrlr) -> DCAL)
N#define vSetGDCPTCR_DCAL(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> DCAL=(ParValue))
N#define biGetGDCPTCR_DDAL(ctrlr) (pst_bitGDCPTCR(ctrlr) -> DDAL)
N#define vSetGDCPTCR_DDAL(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> DDAL=(ParValue))
N#define biGetGDCPTCR_PPSYNC(ctrlr) (pst_bitGDCPTCR(ctrlr) -> PPSYNC)
N#define vSetGDCPTCR_PPSYNC(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> PPSYNC=(ParValue))
N#define biGetGDCPTCR_GPP0EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP0EN)
N#define vSetGDCPTCR_GPP0EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP0EN=(ParValue))
N#define biGetGDCPTCR_GPP1EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP1EN)
N#define vSetGDCPTCR_GPP1EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP1EN=(ParValue))
N#define biGetGDCPTCR_GPP2EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP2EN)
N#define vSetGDCPTCR_GPP2EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP2EN=(ParValue))
N#define biGetGDCPTCR_GPP3EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP3EN)
N#define vSetGDCPTCR_GPP3EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP3EN=(ParValue))
N#define biGetGDCPTCR_GPP4EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP4EN)
N#define vSetGDCPTCR_GPP4EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP4EN=(ParValue))
N#define biGetGDCPTCR_GPP5EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP5EN)
N#define vSetGDCPTCR_GPP5EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP5EN=(ParValue))
N#define biGetGDCPTCR_GPP6EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP6EN)
N#define vSetGDCPTCR_GPP6EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP6EN=(ParValue))
N#define biGetGDCPTCR_GPP7EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP7EN)
N#define vSetGDCPTCR_GPP7EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP7EN=(ParValue))
N#define biGetGDCPTCR_GPP8EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP8EN)
N#define vSetGDCPTCR_GPP8EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP8EN=(ParValue))
N#define biGetGDCPTCR_GPP9EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP9EN)
N#define vSetGDCPTCR_GPP9EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP9EN=(ParValue))
N#define biGetGDCPTCR_GPP10EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP10EN)
N#define vSetGDCPTCR_GPP10EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP10EN=(ParValue))
N#define biGetGDCPTCR_GPP11EN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> GPP11EN)
N#define vSetGDCPTCR_GPP11EN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> GPP11EN=(ParValue))            
N
N/**********************************************************************
N ** "Read Only" signals should be read directly fom shadow register  **
N **********************************************************************/
N#define biGetGDCPTCR_RSPUP(ctrlr) (pst_bitGDCPTCR_Direct(ctrlr) -> RSPUP)
N#define biGetGDCPTCR_RSDRDY(ctrlr) (pst_bitGDCPTCR_Direct(ctrlr) -> RSDRDY)
N/**********************************************************************/
N
N#define biGetGDCPTCR_RSDSEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> RSDSEN)
N#define vSetGDCPTCR_RSDSEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> RSDSEN=(ParValue))
N#define biGetGDCPTCR_PSMEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> PSMEN)
N#define vSetGDCPTCR_PSMEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> PSMEN=(ParValue))
N#define biGetGDCPTCR_OCMD(ctrlr) (pst_bitGDCPTCR(ctrlr) -> OCMD)
N#define vSetGDCPTCR_OCMD(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> OCMD=(ParValue))
N#define biGetGDCPTCR_PEMD(ctrlr) (pst_bitGDCPTCR(ctrlr) -> PEMD)
N#define vSetGDCPTCR_PEMD(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> PEMD=(ParValue))
N#define biGetGDCPTCR_HIZEN(ctrlr) (pst_bitGDCPTCR(ctrlr) -> HIZEN)
N#define vSetGDCPTCR_HIZEN(ctrlr,ParValue)  (pst_bitGDCPTCR(ctrlr) -> HIZEN=(ParValue))            
N
N/**********************************************************************
N ** "Read Only" signals should be read directly fom shadow register  **
N **********************************************************************/
N#define biGetGDCPTCR_PSYNC(ctrlr) (pst_bitGDCPTCR_Direct(ctrlr) -> PSYNC)
N#define biGetGDCPTCR_PTCEN(ctrlr) (pst_bitGDCPTCR_Direct(ctrlr) -> PTCEN)
N/**********************************************************************/
N
N/* LL-struct byte access */
N#define vSetGDCPTCRLL(ctrlr,ParValue) (pst_u8GDCPTCR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCPTCRLL(ctrlr) (pst_u8GDCPTCR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCPTCRLH(ctrlr,ParValue) (pst_u8GDCPTCR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCPTCRLH(ctrlr) (pst_u8GDCPTCR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCPTCRHL(ctrlr,ParValue) (pst_u8GDCPTCR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCPTCRHL(ctrlr) (pst_u8GDCPTCR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCPTCRHH(ctrlr,ParValue) (pst_u8GDCPTCR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCPTCRHH(ctrlr) (pst_u8GDCPTCR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCPTCRL(ctrlr,ParValue) (pst_u16GDCPTCR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCPTCRL(ctrlr) (pst_u16GDCPTCR(ctrlr) -> u16L)
N#define vSetGDCPTCRH(ctrlr,ParValue) (pst_u16GDCPTCR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCPTCRH(ctrlr) (pst_u16GDCPTCR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCPTCR(ctrlr,ParValue)  (*pu32GDCPTCR(ctrlr) = (ParValue))
N#define u32GetGDCPTCR(ctrlr)  (*pu32GDCPTCR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCGPCRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02150                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCGPCRA_REG__       0xC0C02150U
N#else
S#define GDCGPCRA_REG__ ((uint32_t) GDCGPCRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   OUTSEL0	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   CGSEL0	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   TRIG0	:3; 	 /* 4..6  bit(s) R/W */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   OUTSEL1	:3; 	 /* 8..10  bit(s) R/W */
N  uint32_t   CGSEL1	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   TRIG1	:3; 	 /* 12..14  bit(s) R/W */
N  uint32_t   	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   OUTSEL2	:3; 	 /* 16..18  bit(s) R/W */
N  uint32_t   CGSEL2	:1; 	 /* 19..19  bit(s) R/W */
N  uint32_t   TRIG2	:3; 	 /* 20..22  bit(s) R/W */
N  uint32_t   	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   OUTSEL3	:3; 	 /* 24..26  bit(s) R/W */
N  uint32_t   CGSEL3	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   TRIG3	:3; 	 /* 28..30  bit(s) R/W */ 
N  uint32_t   	:1; 	 /* 31..63  bit(s) R */                    
N} GDCGPCRA_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCGPCRA_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCGPCRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCGPCRA_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCGPCRA(ctrlr)     ((volatile GDCGPCRA_bit_view_st *)\
S(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCGPCRA(ctrlr)     ((volatile GDCGPCRA_bit_view_st *)(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCGPCRA(ctrlr)     ((volatile GDCGPCRA_byte_view_st *)\
S(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCGPCRA(ctrlr)     ((volatile GDCGPCRA_byte_view_st *)(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCGPCRA(ctrlr)     ((volatile GDCGPCRA_halfword_view_st *)\
S(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCGPCRA(ctrlr)     ((volatile GDCGPCRA_halfword_view_st *)(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCGPCRA(ctrlr)     ((volatile u32GDCGPCRA_word_view *)\
S(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCGPCRA(ctrlr)     ((volatile u32GDCGPCRA_word_view *)(GDCGPCRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCGPCRA(ctrlr)     ((volatile GDCGPCRA_bit_view_st *) &u32GDCGPCRA_REG__Var[(ctrlr)])
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCGPCRA(ctrlr)     ((volatile GDCGPCRA_byte_view_st *) &u32GDCGPCRA_REG__Var[(ctrlr)])
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCGPCRA(ctrlr)     ((volatile GDCGPCRA_halfword_view_st *) &u32GDCGPCRA_REG__Var[(ctrlr)])
N            
N/* Pointer to WORD  */ 
N#define pu32GDCGPCRA(ctrlr)     ((volatile u32GDCGPCRA_word_view *) &u32GDCGPCRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCGPCRA_OUTSEL0(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> OUTSEL0)
N#define vSetGDCGPCRA_OUTSEL0(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> OUTSEL0=(ParValue))
N#define biGetGDCGPCRA_CGSEL0(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> CGSEL0)
N#define vSetGDCGPCRA_CGSEL0(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> CGSEL0=(ParValue))
N#define biGetGDCGPCRA_TRIG0(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> TRIG0)
N#define vSetGDCGPCRA_TRIG0(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> TRIG0=(ParValue))
N#define biGetGDCGPCRA_OUTSEL1(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> OUTSEL1)
N#define vSetGDCGPCRA_OUTSEL1(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> OUTSEL1=(ParValue))
N#define biGetGDCGPCRA_CGSEL1(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> CGSEL1)
N#define vSetGDCGPCRA_CGSEL1(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> CGSEL1=(ParValue))
N#define biGetGDCGPCRA_TRIG1(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> TRIG1)
N#define vSetGDCGPCRA_TRIG1(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> TRIG1=(ParValue))
N#define biGetGDCGPCRA_OUTSEL2(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> OUTSEL2)
N#define vSetGDCGPCRA_OUTSEL2(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> OUTSEL2=(ParValue))
N#define biGetGDCGPCRA_CGSEL2(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> CGSEL2)
N#define vSetGDCGPCRA_CGSEL2(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> CGSEL2=(ParValue))
N#define biGetGDCGPCRA_TRIG2(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> TRIG2)
N#define vSetGDCGPCRA_TRIG2(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> TRIG2=(ParValue))
N#define biGetGDCGPCRA_OUTSEL3(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> OUTSEL3)
N#define vSetGDCGPCRA_OUTSEL3(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> OUTSEL3=(ParValue))
N#define biGetGDCGPCRA_CGSEL3(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> CGSEL3)
N#define vSetGDCGPCRA_CGSEL3(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> CGSEL3=(ParValue))
N#define biGetGDCGPCRA_TRIG3(ctrlr) (pst_bitGDCGPCRA(ctrlr) -> TRIG3)
N#define vSetGDCGPCRA_TRIG3(ctrlr,ParValue)  (pst_bitGDCGPCRA(ctrlr) -> TRIG3=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCGPCRALL(ctrlr,ParValue) (pst_u8GDCGPCRA(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCGPCRALL(ctrlr) (pst_u8GDCGPCRA(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCGPCRALH(ctrlr,ParValue) (pst_u8GDCGPCRA(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCGPCRALH(ctrlr) (pst_u8GDCGPCRA(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCGPCRAHL(ctrlr,ParValue) (pst_u8GDCGPCRA(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCGPCRAHL(ctrlr) (pst_u8GDCGPCRA(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCGPCRAHH(ctrlr,ParValue) (pst_u8GDCGPCRA(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCGPCRAHH(ctrlr) (pst_u8GDCGPCRA(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCGPCRAL(ctrlr,ParValue) (pst_u16GDCGPCRA(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCGPCRAL(ctrlr) (pst_u16GDCGPCRA(ctrlr) -> u16L)
N#define vSetGDCGPCRAH(ctrlr,ParValue) (pst_u16GDCGPCRA(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCGPCRAH(ctrlr) (pst_u16GDCGPCRA(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCGPCRA(ctrlr,ParValue)  (*pu32GDCGPCRA(ctrlr) = (ParValue))
N#define u32GetGDCGPCRA(ctrlr)  (*pu32GDCGPCRA(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCGPCRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02158                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCGPCRB_REG__       0xC0C02158U
N#else
S#define GDCGPCRB_REG__ ((uint32_t) GDCGPCRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   OUTSEL4	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   CGSEL4	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   TRIG4	:3; 	 /* 4..6  bit(s) R/W */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   OUTSEL5	:3; 	 /* 8..10  bit(s) R/W */
N  uint32_t   CGSEL5	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   TRIG5	:3; 	 /* 12..14  bit(s) R/W */
N  uint32_t   	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   OUTSEL6	:3; 	 /* 16..18  bit(s) R/W */
N  uint32_t   CGSEL6	:1; 	 /* 19..19  bit(s) R/W */
N  uint32_t   TRIG6	:3; 	 /* 20..22  bit(s) R/W */
N  uint32_t   	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   OUTSEL7	:3; 	 /* 24..26  bit(s) R/W */
N  uint32_t   CGSEL7	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   TRIG7	:3; 	 /* 28..30  bit(s) R/W */ 
N  uint32_t   	:1; 	 /* 31..63  bit(s) R */                    
N} GDCGPCRB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCGPCRB_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCGPCRB_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCGPCRB_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCGPCRB(ctrlr)     ((volatile GDCGPCRB_bit_view_st *)\
S(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCGPCRB(ctrlr)     ((volatile GDCGPCRB_bit_view_st *)(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCGPCRB(ctrlr)     ((volatile GDCGPCRB_byte_view_st *)\
S(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCGPCRB(ctrlr)     ((volatile GDCGPCRB_byte_view_st *)(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCGPCRB(ctrlr)     ((volatile GDCGPCRB_halfword_view_st *)\
S(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCGPCRB(ctrlr)     ((volatile GDCGPCRB_halfword_view_st *)(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCGPCRB(ctrlr)     ((volatile u32GDCGPCRB_word_view *)\
S(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCGPCRB(ctrlr)     ((volatile u32GDCGPCRB_word_view *)(GDCGPCRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCGPCRB(ctrlr)     ((volatile GDCGPCRB_bit_view_st *) &u32GDCGPCRB_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCGPCRB(ctrlr)     ((volatile GDCGPCRB_byte_view_st *) &u32GDCGPCRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCGPCRB(ctrlr)     ((volatile GDCGPCRB_halfword_view_st *) &u32GDCGPCRB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCGPCRB(ctrlr)     ((volatile u32GDCGPCRB_word_view *) &u32GDCGPCRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCGPCRB_OUTSEL4(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> OUTSEL4)
N#define vSetGDCGPCRB_OUTSEL4(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> OUTSEL4=(ParValue))
N#define biGetGDCGPCRB_CGSEL4(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> CGSEL4)
N#define vSetGDCGPCRB_CGSEL4(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> CGSEL4=(ParValue))
N#define biGetGDCGPCRB_TRIG4(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> TRIG4)
N#define vSetGDCGPCRB_TRIG4(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> TRIG4=(ParValue))
N#define biGetGDCGPCRB_OUTSEL5(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> OUTSEL5)
N#define vSetGDCGPCRB_OUTSEL5(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> OUTSEL5=(ParValue))
N#define biGetGDCGPCRB_CGSEL5(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> CGSEL5)
N#define vSetGDCGPCRB_CGSEL5(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> CGSEL5=(ParValue))
N#define biGetGDCGPCRB_TRIG5(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> TRIG5)
N#define vSetGDCGPCRB_TRIG5(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> TRIG5=(ParValue))
N#define biGetGDCGPCRB_OUTSEL6(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> OUTSEL6)
N#define vSetGDCGPCRB_OUTSEL6(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> OUTSEL6=(ParValue))
N#define biGetGDCGPCRB_CGSEL6(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> CGSEL6)
N#define vSetGDCGPCRB_CGSEL6(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> CGSEL6=(ParValue))
N#define biGetGDCGPCRB_TRIG6(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> TRIG6)
N#define vSetGDCGPCRB_TRIG6(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> TRIG6=(ParValue))
N#define biGetGDCGPCRB_OUTSEL7(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> OUTSEL7)
N#define vSetGDCGPCRB_OUTSEL7(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> OUTSEL7=(ParValue))
N#define biGetGDCGPCRB_CGSEL7(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> CGSEL7)
N#define vSetGDCGPCRB_CGSEL7(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> CGSEL7=(ParValue))
N#define biGetGDCGPCRB_TRIG7(ctrlr) (pst_bitGDCGPCRB(ctrlr) -> TRIG7)
N#define vSetGDCGPCRB_TRIG7(ctrlr,ParValue)  (pst_bitGDCGPCRB(ctrlr) -> TRIG7=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCGPCRBLL(ctrlr,ParValue) (pst_u8GDCGPCRB(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCGPCRBLL(ctrlr) (pst_u8GDCGPCRB(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCGPCRBLH(ctrlr,ParValue) (pst_u8GDCGPCRB(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCGPCRBLH(ctrlr) (pst_u8GDCGPCRB(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCGPCRBHL(ctrlr,ParValue) (pst_u8GDCGPCRB(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCGPCRBHL(ctrlr) (pst_u8GDCGPCRB(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCGPCRBHH(ctrlr,ParValue) (pst_u8GDCGPCRB(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCGPCRBHH(ctrlr) (pst_u8GDCGPCRB(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCGPCRBL(ctrlr,ParValue) (pst_u16GDCGPCRB(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCGPCRBL(ctrlr) (pst_u16GDCGPCRB(ctrlr) -> u16L)
N#define vSetGDCGPCRBH(ctrlr,ParValue) (pst_u16GDCGPCRB(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCGPCRBH(ctrlr) (pst_u16GDCGPCRB(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCGPCRB(ctrlr,ParValue)  (*pu32GDCGPCRB(ctrlr) = (ParValue))
N#define u32GetGDCGPCRB(ctrlr)  (*pu32GDCGPCRB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCGPCRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02160                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCGPCRC_REG__       0xC0C02160U
N#else
S#define GDCGPCRC_REG__ ((uint32_t) GDCGPCRC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   OUTSEL8	:3; 	 /* 0..2  bit(s) R/W */
N  uint32_t   CGSEL8	:1; 	 /* 3..3  bit(s) R/W */
N  uint32_t   TRIG8	:3; 	 /* 4..6  bit(s) R/W */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   OUTSEL9	:3; 	 /* 8..10  bit(s) R/W */
N  uint32_t   CGSEL9	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   TRIG9	:3; 	 /* 12..14  bit(s) R/W */
N  uint32_t   	:1; 	 /* 15..15  bit(s) R */
N  uint32_t   OUTSEL10	:3; 	 /* 16..18  bit(s) R/W */
N  uint32_t   CGSEL10	:1; 	 /* 19..19  bit(s) R/W */
N  uint32_t   TRIG10	:3; 	 /* 20..22  bit(s) R/W */
N  uint32_t   	:1; 	 /* 23..23  bit(s) R */
N  uint32_t   OUTSEL11	:3; 	 /* 24..26  bit(s) R/W */
N  uint32_t   CGSEL11	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   TRIG11	:3; 	 /* 28..30  bit(s) R/W */ 
N  uint32_t   	:1; 	 /* 31..63  bit(s) R */                    
N} GDCGPCRC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCGPCRC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCGPCRC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCGPCRC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCGPCRC(ctrlr)     ((volatile GDCGPCRC_bit_view_st *)\
S(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCGPCRC(ctrlr)     ((volatile GDCGPCRC_bit_view_st *)(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCGPCRC(ctrlr)     ((volatile GDCGPCRC_byte_view_st *)\
S(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCGPCRC(ctrlr)     ((volatile GDCGPCRC_byte_view_st *)(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCGPCRC(ctrlr)     ((volatile GDCGPCRC_halfword_view_st *)\
S(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCGPCRC(ctrlr)     ((volatile GDCGPCRC_halfword_view_st *)(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCGPCRC(ctrlr)     ((volatile u32GDCGPCRC_word_view *)\
S(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCGPCRC(ctrlr)     ((volatile u32GDCGPCRC_word_view *)(GDCGPCRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCGPCRC(ctrlr)     ((volatile GDCGPCRC_bit_view_st *) &u32GDCGPCRC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCGPCRC(ctrlr)     ((volatile GDCGPCRC_byte_view_st *) &u32GDCGPCRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCGPCRC(ctrlr)     ((volatile GDCGPCRC_halfword_view_st *) &u32GDCGPCRC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCGPCRC(ctrlr)     ((volatile u32GDCGPCRC_word_view *) &u32GDCGPCRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCGPCRC_OUTSEL8(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> OUTSEL8)
N#define vSetGDCGPCRC_OUTSEL8(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> OUTSEL8=(ParValue))
N#define biGetGDCGPCRC_CGSEL8(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> CGSEL8)
N#define vSetGDCGPCRC_CGSEL8(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> CGSEL8=(ParValue))
N#define biGetGDCGPCRC_TRIG8(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> TRIG8)
N#define vSetGDCGPCRC_TRIG8(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> TRIG8=(ParValue))
N#define biGetGDCGPCRC_OUTSEL9(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> OUTSEL9)
N#define vSetGDCGPCRC_OUTSEL9(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> OUTSEL9=(ParValue))
N#define biGetGDCGPCRC_CGSEL9(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> CGSEL9)
N#define vSetGDCGPCRC_CGSEL9(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> CGSEL9=(ParValue))
N#define biGetGDCGPCRC_TRIG9(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> TRIG9)
N#define vSetGDCGPCRC_TRIG9(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> TRIG9=(ParValue))
N#define biGetGDCGPCRC_OUTSEL10(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> OUTSEL10)
N#define vSetGDCGPCRC_OUTSEL10(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> OUTSEL10=(ParValue))
N#define biGetGDCGPCRC_CGSEL10(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> CGSEL10)
N#define vSetGDCGPCRC_CGSEL10(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> CGSEL10=(ParValue))
N#define biGetGDCGPCRC_TRIG10(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> TRIG10)
N#define vSetGDCGPCRC_TRIG10(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> TRIG10=(ParValue))
N#define biGetGDCGPCRC_OUTSEL11(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> OUTSEL11)
N#define vSetGDCGPCRC_OUTSEL11(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> OUTSEL11=(ParValue))
N#define biGetGDCGPCRC_CGSEL11(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> CGSEL11)
N#define vSetGDCGPCRC_CGSEL11(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> CGSEL11=(ParValue))
N#define biGetGDCGPCRC_TRIG11(ctrlr) (pst_bitGDCGPCRC(ctrlr) -> TRIG11)
N#define vSetGDCGPCRC_TRIG11(ctrlr,ParValue)  (pst_bitGDCGPCRC(ctrlr) -> TRIG11=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCGPCRCLL(ctrlr,ParValue) (pst_u8GDCGPCRC(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCGPCRCLL(ctrlr) (pst_u8GDCGPCRC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCGPCRCLH(ctrlr,ParValue) (pst_u8GDCGPCRC(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCGPCRCLH(ctrlr) (pst_u8GDCGPCRC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCGPCRCHL(ctrlr,ParValue) (pst_u8GDCGPCRC(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCGPCRCHL(ctrlr) (pst_u8GDCGPCRC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCGPCRCHH(ctrlr,ParValue) (pst_u8GDCGPCRC(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCGPCRCHH(ctrlr) (pst_u8GDCGPCRC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCGPCRCL(ctrlr,ParValue) (pst_u16GDCGPCRC(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCGPCRCL(ctrlr) (pst_u16GDCGPCRC(ctrlr) -> u16L)
N#define vSetGDCGPCRCH(ctrlr,ParValue) (pst_u16GDCGPCRC(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCGPCRCH(ctrlr) (pst_u16GDCGPCRC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCGPCRC(ctrlr,ParValue)  (*pu32GDCGPCRC(ctrlr) = (ParValue))
N#define u32GetGDCGPCRC(ctrlr)  (*pu32GDCGPCRC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP0GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02168                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP0GAR_REG__       0xC0C02168U
N#else
S#define GDCP0GAR_REG__ ((uint32_t) GDCP0GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP0GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP0GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP0GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP0GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP0GAR(ctrlr)     ((volatile GDCP0GAR_bit_view_st *)\
S(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP0GAR(ctrlr)     ((volatile GDCP0GAR_bit_view_st *)(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP0GAR(ctrlr)     ((volatile GDCP0GAR_byte_view_st *)\
S(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP0GAR(ctrlr)     ((volatile GDCP0GAR_byte_view_st *)(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP0GAR(ctrlr)     ((volatile GDCP0GAR_halfword_view_st *)\
S(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP0GAR(ctrlr)     ((volatile GDCP0GAR_halfword_view_st *)(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP0GAR(ctrlr)     ((volatile u32GDCP0GAR_word_view *)\
S(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP0GAR(ctrlr)     ((volatile u32GDCP0GAR_word_view *)(GDCP0GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP0GAR(ctrlr)     ((volatile GDCP0GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][0])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP0GAR(ctrlr)     ((volatile GDCP0GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][0])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP0GAR(ctrlr)     ((volatile GDCP0GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][0])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP0GAR(ctrlr)     ((volatile u32GDCP0GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][0])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP0GAR_GAWID(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GAWID)
N#define vSetGDCP0GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP0GAR_GAINV(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GAINV)
N#define vSetGDCP0GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP0GAR_GADIV(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GADIV)
N#define vSetGDCP0GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP0GAR_GADEL(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GADEL)
N#define vSetGDCP0GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP0GAR_GABYP(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GABYP)
N#define vSetGDCP0GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP0GAR_GAINSEL(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP0GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP0GAR_GALVL(ctrlr) (pst_bitGDCP0GAR(ctrlr) -> GALVL)
N#define vSetGDCP0GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP0GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP0GARLL(ctrlr,ParValue) (pst_u8GDCP0GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP0GARLL(ctrlr) (pst_u8GDCP0GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP0GARLH(ctrlr,ParValue) (pst_u8GDCP0GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP0GARLH(ctrlr) (pst_u8GDCP0GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP0GARHL(ctrlr,ParValue) (pst_u8GDCP0GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP0GARHL(ctrlr) (pst_u8GDCP0GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP0GARHH(ctrlr,ParValue) (pst_u8GDCP0GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP0GARHH(ctrlr) (pst_u8GDCP0GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP0GARL(ctrlr,ParValue) (pst_u16GDCP0GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP0GARL(ctrlr) (pst_u16GDCP0GAR(ctrlr) -> u16L)
N#define vSetGDCP0GARH(ctrlr,ParValue) (pst_u16GDCP0GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP0GARH(ctrlr) (pst_u16GDCP0GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP0GAR(ctrlr,ParValue)  (*pu32GDCP0GAR(ctrlr) = (ParValue))
N#define u32GetGDCP0GAR(ctrlr)  (*pu32GDCP0GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP1GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02170                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP1GAR_REG__       0xC0C02170U
N#else
S#define GDCP1GAR_REG__ ((uint32_t) GDCP1GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP1GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP1GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP1GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP1GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP1GAR(ctrlr)     ((volatile GDCP1GAR_bit_view_st *)\
S(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP1GAR(ctrlr)     ((volatile GDCP1GAR_bit_view_st *)(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP1GAR(ctrlr)     ((volatile GDCP1GAR_byte_view_st *)\
S(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP1GAR(ctrlr)     ((volatile GDCP1GAR_byte_view_st *)(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP1GAR(ctrlr)     ((volatile GDCP1GAR_halfword_view_st *)\
S(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP1GAR(ctrlr)     ((volatile GDCP1GAR_halfword_view_st *)(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP1GAR(ctrlr)     ((volatile u32GDCP1GAR_word_view *)\
S(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP1GAR(ctrlr)     ((volatile u32GDCP1GAR_word_view *)(GDCP1GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP1GAR(ctrlr)     ((volatile GDCP1GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][1])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP1GAR(ctrlr)     ((volatile GDCP1GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][1])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP1GAR(ctrlr)     ((volatile GDCP1GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][1])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP1GAR(ctrlr)     ((volatile u32GDCP1GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][1])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP1GAR_GAWID(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GAWID)
N#define vSetGDCP1GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP1GAR_GAINV(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GAINV)
N#define vSetGDCP1GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP1GAR_GADIV(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GADIV)
N#define vSetGDCP1GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP1GAR_GADEL(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GADEL)
N#define vSetGDCP1GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP1GAR_GABYP(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GABYP)
N#define vSetGDCP1GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP1GAR_GAINSEL(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP1GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP1GAR_GALVL(ctrlr) (pst_bitGDCP1GAR(ctrlr) -> GALVL)
N#define vSetGDCP1GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP1GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP1GARLL(ctrlr,ParValue) (pst_u8GDCP1GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP1GARLL(ctrlr) (pst_u8GDCP1GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP1GARLH(ctrlr,ParValue) (pst_u8GDCP1GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP1GARLH(ctrlr) (pst_u8GDCP1GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP1GARHL(ctrlr,ParValue) (pst_u8GDCP1GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP1GARHL(ctrlr) (pst_u8GDCP1GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP1GARHH(ctrlr,ParValue) (pst_u8GDCP1GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP1GARHH(ctrlr) (pst_u8GDCP1GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP1GARL(ctrlr,ParValue) (pst_u16GDCP1GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP1GARL(ctrlr) (pst_u16GDCP1GAR(ctrlr) -> u16L)
N#define vSetGDCP1GARH(ctrlr,ParValue) (pst_u16GDCP1GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP1GARH(ctrlr) (pst_u16GDCP1GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP1GAR(ctrlr,ParValue)  (*pu32GDCP1GAR(ctrlr) = (ParValue))
N#define u32GetGDCP1GAR(ctrlr)  (*pu32GDCP1GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP2GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02178                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP2GAR_REG__       0xC0C02178U
N#else
S#define GDCP2GAR_REG__ ((uint32_t) GDCP2GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP2GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP2GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP2GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP2GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP2GAR(ctrlr)     ((volatile GDCP2GAR_bit_view_st *)\
S(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP2GAR(ctrlr)     ((volatile GDCP2GAR_bit_view_st *)(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP2GAR(ctrlr)     ((volatile GDCP2GAR_byte_view_st *)\
S(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP2GAR(ctrlr)     ((volatile GDCP2GAR_byte_view_st *)(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP2GAR(ctrlr)     ((volatile GDCP2GAR_halfword_view_st *)\
S(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP2GAR(ctrlr)     ((volatile GDCP2GAR_halfword_view_st *)(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP2GAR(ctrlr)     ((volatile u32GDCP2GAR_word_view *)\
S(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP2GAR(ctrlr)     ((volatile u32GDCP2GAR_word_view *)(GDCP2GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP2GAR(ctrlr)     ((volatile GDCP2GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][2])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP2GAR(ctrlr)     ((volatile GDCP2GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][2])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP2GAR(ctrlr)     ((volatile GDCP2GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][2])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP2GAR(ctrlr)     ((volatile u32GDCP2GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][2])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP2GAR_GAWID(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GAWID)
N#define vSetGDCP2GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP2GAR_GAINV(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GAINV)
N#define vSetGDCP2GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP2GAR_GADIV(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GADIV)
N#define vSetGDCP2GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP2GAR_GADEL(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GADEL)
N#define vSetGDCP2GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP2GAR_GABYP(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GABYP)
N#define vSetGDCP2GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP2GAR_GAINSEL(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP2GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP2GAR_GALVL(ctrlr) (pst_bitGDCP2GAR(ctrlr) -> GALVL)
N#define vSetGDCP2GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP2GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP2GARLL(ctrlr,ParValue) (pst_u8GDCP2GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP2GARLL(ctrlr) (pst_u8GDCP2GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP2GARLH(ctrlr,ParValue) (pst_u8GDCP2GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP2GARLH(ctrlr) (pst_u8GDCP2GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP2GARHL(ctrlr,ParValue) (pst_u8GDCP2GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP2GARHL(ctrlr) (pst_u8GDCP2GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP2GARHH(ctrlr,ParValue) (pst_u8GDCP2GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP2GARHH(ctrlr) (pst_u8GDCP2GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP2GARL(ctrlr,ParValue) (pst_u16GDCP2GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP2GARL(ctrlr) (pst_u16GDCP2GAR(ctrlr) -> u16L)
N#define vSetGDCP2GARH(ctrlr,ParValue) (pst_u16GDCP2GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP2GARH(ctrlr) (pst_u16GDCP2GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP2GAR(ctrlr,ParValue)  (*pu32GDCP2GAR(ctrlr) = (ParValue))
N#define u32GetGDCP2GAR(ctrlr)  (*pu32GDCP2GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP3GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02180                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP3GAR_REG__       0xC0C02180U
N#else
S#define GDCP3GAR_REG__ ((uint32_t) GDCP3GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP3GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP3GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP3GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP3GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP3GAR(ctrlr)     ((volatile GDCP3GAR_bit_view_st *)\
S(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP3GAR(ctrlr)     ((volatile GDCP3GAR_bit_view_st *)(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP3GAR(ctrlr)     ((volatile GDCP3GAR_byte_view_st *)\
S(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP3GAR(ctrlr)     ((volatile GDCP3GAR_byte_view_st *)(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP3GAR(ctrlr)     ((volatile GDCP3GAR_halfword_view_st *)\
S(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP3GAR(ctrlr)     ((volatile GDCP3GAR_halfword_view_st *)(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP3GAR(ctrlr)     ((volatile u32GDCP3GAR_word_view *)\
S(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP3GAR(ctrlr)     ((volatile u32GDCP3GAR_word_view *)(GDCP3GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP3GAR(ctrlr)     ((volatile GDCP3GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][3])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP3GAR(ctrlr)     ((volatile GDCP3GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][3])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP3GAR(ctrlr)     ((volatile GDCP3GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][3])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP3GAR(ctrlr)     ((volatile u32GDCP3GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][3])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP3GAR_GAWID(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GAWID)
N#define vSetGDCP3GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP3GAR_GAINV(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GAINV)
N#define vSetGDCP3GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP3GAR_GADIV(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GADIV)
N#define vSetGDCP3GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP3GAR_GADEL(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GADEL)
N#define vSetGDCP3GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP3GAR_GABYP(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GABYP)
N#define vSetGDCP3GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP3GAR_GAINSEL(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP3GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP3GAR_GALVL(ctrlr) (pst_bitGDCP3GAR(ctrlr) -> GALVL)
N#define vSetGDCP3GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP3GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP3GARLL(ctrlr,ParValue) (pst_u8GDCP3GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP3GARLL(ctrlr) (pst_u8GDCP3GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP3GARLH(ctrlr,ParValue) (pst_u8GDCP3GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP3GARLH(ctrlr) (pst_u8GDCP3GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP3GARHL(ctrlr,ParValue) (pst_u8GDCP3GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP3GARHL(ctrlr) (pst_u8GDCP3GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP3GARHH(ctrlr,ParValue) (pst_u8GDCP3GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP3GARHH(ctrlr) (pst_u8GDCP3GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP3GARL(ctrlr,ParValue) (pst_u16GDCP3GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP3GARL(ctrlr) (pst_u16GDCP3GAR(ctrlr) -> u16L)
N#define vSetGDCP3GARH(ctrlr,ParValue) (pst_u16GDCP3GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP3GARH(ctrlr) (pst_u16GDCP3GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP3GAR(ctrlr,ParValue)  (*pu32GDCP3GAR(ctrlr) = (ParValue))
N#define u32GetGDCP3GAR(ctrlr)  (*pu32GDCP3GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP4GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02188                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP4GAR_REG__       0xC0C02188U
N#else
S#define GDCP4GAR_REG__ ((uint32_t) GDCP4GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP4GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP4GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP4GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP4GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP4GAR(ctrlr)     ((volatile GDCP4GAR_bit_view_st *)\
S(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP4GAR(ctrlr)     ((volatile GDCP4GAR_bit_view_st *)(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP4GAR(ctrlr)     ((volatile GDCP4GAR_byte_view_st *)\
S(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP4GAR(ctrlr)     ((volatile GDCP4GAR_byte_view_st *)(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP4GAR(ctrlr)     ((volatile GDCP4GAR_halfword_view_st *)\
S(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP4GAR(ctrlr)     ((volatile GDCP4GAR_halfword_view_st *)(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP4GAR(ctrlr)     ((volatile u32GDCP4GAR_word_view *)\
S(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP4GAR(ctrlr)     ((volatile u32GDCP4GAR_word_view *)(GDCP4GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP4GAR(ctrlr)     ((volatile GDCP4GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][4])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP4GAR(ctrlr)     ((volatile GDCP4GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][4])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP4GAR(ctrlr)     ((volatile GDCP4GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][4])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP4GAR(ctrlr)     ((volatile u32GDCP4GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][4])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP4GAR_GAWID(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GAWID)
N#define vSetGDCP4GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP4GAR_GAINV(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GAINV)
N#define vSetGDCP4GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP4GAR_GADIV(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GADIV)
N#define vSetGDCP4GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP4GAR_GADEL(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GADEL)
N#define vSetGDCP4GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP4GAR_GABYP(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GABYP)
N#define vSetGDCP4GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP4GAR_GAINSEL(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP4GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP4GAR_GALVL(ctrlr) (pst_bitGDCP4GAR(ctrlr) -> GALVL)
N#define vSetGDCP4GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP4GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP4GARLL(ctrlr,ParValue) (pst_u8GDCP4GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP4GARLL(ctrlr) (pst_u8GDCP4GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP4GARLH(ctrlr,ParValue) (pst_u8GDCP4GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP4GARLH(ctrlr) (pst_u8GDCP4GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP4GARHL(ctrlr,ParValue) (pst_u8GDCP4GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP4GARHL(ctrlr) (pst_u8GDCP4GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP4GARHH(ctrlr,ParValue) (pst_u8GDCP4GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP4GARHH(ctrlr) (pst_u8GDCP4GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP4GARL(ctrlr,ParValue) (pst_u16GDCP4GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP4GARL(ctrlr) (pst_u16GDCP4GAR(ctrlr) -> u16L)
N#define vSetGDCP4GARH(ctrlr,ParValue) (pst_u16GDCP4GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP4GARH(ctrlr) (pst_u16GDCP4GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP4GAR(ctrlr,ParValue)  (*pu32GDCP4GAR(ctrlr) = (ParValue))
N#define u32GetGDCP4GAR(ctrlr)  (*pu32GDCP4GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP5GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02190                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP5GAR_REG__       0xC0C02190U
N#else
S#define GDCP5GAR_REG__ ((uint32_t) GDCP5GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP5GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP5GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP5GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP5GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP5GAR(ctrlr)     ((volatile GDCP5GAR_bit_view_st *)\
S(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP5GAR(ctrlr)     ((volatile GDCP5GAR_bit_view_st *)(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP5GAR(ctrlr)     ((volatile GDCP5GAR_byte_view_st *)\
S(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP5GAR(ctrlr)     ((volatile GDCP5GAR_byte_view_st *)(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP5GAR(ctrlr)     ((volatile GDCP5GAR_halfword_view_st *)\
S(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP5GAR(ctrlr)     ((volatile GDCP5GAR_halfword_view_st *)(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP5GAR(ctrlr)     ((volatile u32GDCP5GAR_word_view *)\
S(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP5GAR(ctrlr)     ((volatile u32GDCP5GAR_word_view *)(GDCP5GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP5GAR(ctrlr)     ((volatile GDCP5GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][5])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP5GAR(ctrlr)     ((volatile GDCP5GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][5])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP5GAR(ctrlr)     ((volatile GDCP5GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][5])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP5GAR(ctrlr)     ((volatile u32GDCP5GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][5])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP5GAR_GAWID(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GAWID)
N#define vSetGDCP5GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP5GAR_GAINV(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GAINV)
N#define vSetGDCP5GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP5GAR_GADIV(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GADIV)
N#define vSetGDCP5GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP5GAR_GADEL(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GADEL)
N#define vSetGDCP5GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP5GAR_GABYP(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GABYP)
N#define vSetGDCP5GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP5GAR_GAINSEL(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP5GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP5GAR_GALVL(ctrlr) (pst_bitGDCP5GAR(ctrlr) -> GALVL)
N#define vSetGDCP5GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP5GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP5GARLL(ctrlr,ParValue) (pst_u8GDCP5GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP5GARLL(ctrlr) (pst_u8GDCP5GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP5GARLH(ctrlr,ParValue) (pst_u8GDCP5GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP5GARLH(ctrlr) (pst_u8GDCP5GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP5GARHL(ctrlr,ParValue) (pst_u8GDCP5GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP5GARHL(ctrlr) (pst_u8GDCP5GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP5GARHH(ctrlr,ParValue) (pst_u8GDCP5GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP5GARHH(ctrlr) (pst_u8GDCP5GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP5GARL(ctrlr,ParValue) (pst_u16GDCP5GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP5GARL(ctrlr) (pst_u16GDCP5GAR(ctrlr) -> u16L)
N#define vSetGDCP5GARH(ctrlr,ParValue) (pst_u16GDCP5GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP5GARH(ctrlr) (pst_u16GDCP5GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP5GAR(ctrlr,ParValue)  (*pu32GDCP5GAR(ctrlr) = (ParValue))
N#define u32GetGDCP5GAR(ctrlr)  (*pu32GDCP5GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP6GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02198                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP6GAR_REG__       0xC0C02198U
N#else
S#define GDCP6GAR_REG__ ((uint32_t) GDCP6GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP6GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP6GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP6GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP6GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP6GAR(ctrlr)     ((volatile GDCP6GAR_bit_view_st *)\
S(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP6GAR(ctrlr)     ((volatile GDCP6GAR_bit_view_st *)(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP6GAR(ctrlr)     ((volatile GDCP6GAR_byte_view_st *)\
S(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP6GAR(ctrlr)     ((volatile GDCP6GAR_byte_view_st *)(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP6GAR(ctrlr)     ((volatile GDCP6GAR_halfword_view_st *)\
S(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP6GAR(ctrlr)     ((volatile GDCP6GAR_halfword_view_st *)(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP6GAR(ctrlr)     ((volatile u32GDCP6GAR_word_view *)\
S(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP6GAR(ctrlr)     ((volatile u32GDCP6GAR_word_view *)(GDCP6GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP6GAR(ctrlr)     ((volatile GDCP6GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][6])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP6GAR(ctrlr)     ((volatile GDCP6GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][6])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP6GAR(ctrlr)     ((volatile GDCP6GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][6])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP6GAR(ctrlr)     ((volatile u32GDCP6GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][6])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP6GAR_GAWID(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GAWID)
N#define vSetGDCP6GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP6GAR_GAINV(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GAINV)
N#define vSetGDCP6GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP6GAR_GADIV(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GADIV)
N#define vSetGDCP6GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP6GAR_GADEL(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GADEL)
N#define vSetGDCP6GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP6GAR_GABYP(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GABYP)
N#define vSetGDCP6GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP6GAR_GAINSEL(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP6GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP6GAR_GALVL(ctrlr) (pst_bitGDCP6GAR(ctrlr) -> GALVL)
N#define vSetGDCP6GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP6GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP6GARLL(ctrlr,ParValue) (pst_u8GDCP6GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP6GARLL(ctrlr) (pst_u8GDCP6GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP6GARLH(ctrlr,ParValue) (pst_u8GDCP6GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP6GARLH(ctrlr) (pst_u8GDCP6GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP6GARHL(ctrlr,ParValue) (pst_u8GDCP6GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP6GARHL(ctrlr) (pst_u8GDCP6GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP6GARHH(ctrlr,ParValue) (pst_u8GDCP6GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP6GARHH(ctrlr) (pst_u8GDCP6GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP6GARL(ctrlr,ParValue) (pst_u16GDCP6GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP6GARL(ctrlr) (pst_u16GDCP6GAR(ctrlr) -> u16L)
N#define vSetGDCP6GARH(ctrlr,ParValue) (pst_u16GDCP6GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP6GARH(ctrlr) (pst_u16GDCP6GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP6GAR(ctrlr,ParValue)  (*pu32GDCP6GAR(ctrlr) = (ParValue))
N#define u32GetGDCP6GAR(ctrlr)  (*pu32GDCP6GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP7GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021A0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP7GAR_REG__       0xC0C021A0U
N#else
S#define GDCP7GAR_REG__ ((uint32_t) GDCP7GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP7GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP7GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP7GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP7GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP7GAR(ctrlr)     ((volatile GDCP7GAR_bit_view_st *)\
S(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP7GAR(ctrlr)     ((volatile GDCP7GAR_bit_view_st *)(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP7GAR(ctrlr)     ((volatile GDCP7GAR_byte_view_st *)\
S(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP7GAR(ctrlr)     ((volatile GDCP7GAR_byte_view_st *)(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP7GAR(ctrlr)     ((volatile GDCP7GAR_halfword_view_st *)\
S(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP7GAR(ctrlr)     ((volatile GDCP7GAR_halfword_view_st *)(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP7GAR(ctrlr)     ((volatile u32GDCP7GAR_word_view *)\
S(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP7GAR(ctrlr)     ((volatile u32GDCP7GAR_word_view *)(GDCP7GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP7GAR(ctrlr)     ((volatile GDCP7GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][7])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP7GAR(ctrlr)     ((volatile GDCP7GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][7])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP7GAR(ctrlr)     ((volatile GDCP7GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][7])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP7GAR(ctrlr)     ((volatile u32GDCP7GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][7])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP7GAR_GAWID(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GAWID)
N#define vSetGDCP7GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP7GAR_GAINV(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GAINV)
N#define vSetGDCP7GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP7GAR_GADIV(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GADIV)
N#define vSetGDCP7GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP7GAR_GADEL(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GADEL)
N#define vSetGDCP7GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP7GAR_GABYP(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GABYP)
N#define vSetGDCP7GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP7GAR_GAINSEL(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP7GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP7GAR_GALVL(ctrlr) (pst_bitGDCP7GAR(ctrlr) -> GALVL)
N#define vSetGDCP7GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP7GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP7GARLL(ctrlr,ParValue) (pst_u8GDCP7GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP7GARLL(ctrlr) (pst_u8GDCP7GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP7GARLH(ctrlr,ParValue) (pst_u8GDCP7GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP7GARLH(ctrlr) (pst_u8GDCP7GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP7GARHL(ctrlr,ParValue) (pst_u8GDCP7GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP7GARHL(ctrlr) (pst_u8GDCP7GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP7GARHH(ctrlr,ParValue) (pst_u8GDCP7GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP7GARHH(ctrlr) (pst_u8GDCP7GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP7GARL(ctrlr,ParValue) (pst_u16GDCP7GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP7GARL(ctrlr) (pst_u16GDCP7GAR(ctrlr) -> u16L)
N#define vSetGDCP7GARH(ctrlr,ParValue) (pst_u16GDCP7GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP7GARH(ctrlr) (pst_u16GDCP7GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP7GAR(ctrlr,ParValue)  (*pu32GDCP7GAR(ctrlr) = (ParValue))
N#define u32GetGDCP7GAR(ctrlr)  (*pu32GDCP7GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP8GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021A8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP8GAR_REG__       0xC0C021A8U
N#else
S#define GDCP8GAR_REG__ ((uint32_t) GDCP8GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP8GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP8GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP8GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP8GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP8GAR(ctrlr)     ((volatile GDCP8GAR_bit_view_st *)\
S(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP8GAR(ctrlr)     ((volatile GDCP8GAR_bit_view_st *)(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP8GAR(ctrlr)     ((volatile GDCP8GAR_byte_view_st *)\
S(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP8GAR(ctrlr)     ((volatile GDCP8GAR_byte_view_st *)(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP8GAR(ctrlr)     ((volatile GDCP8GAR_halfword_view_st *)\
S(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP8GAR(ctrlr)     ((volatile GDCP8GAR_halfword_view_st *)(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP8GAR(ctrlr)     ((volatile u32GDCP8GAR_word_view *)\
S(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP8GAR(ctrlr)     ((volatile u32GDCP8GAR_word_view *)(GDCP8GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP8GAR(ctrlr)     ((volatile GDCP8GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][8])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP8GAR(ctrlr)     ((volatile GDCP8GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][8])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP8GAR(ctrlr)     ((volatile GDCP8GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][8])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP8GAR(ctrlr)     ((volatile u32GDCP8GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][8])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP8GAR_GAWID(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GAWID)
N#define vSetGDCP8GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP8GAR_GAINV(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GAINV)
N#define vSetGDCP8GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP8GAR_GADIV(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GADIV)
N#define vSetGDCP8GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP8GAR_GADEL(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GADEL)
N#define vSetGDCP8GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP8GAR_GABYP(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GABYP)
N#define vSetGDCP8GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP8GAR_GAINSEL(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP8GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP8GAR_GALVL(ctrlr) (pst_bitGDCP8GAR(ctrlr) -> GALVL)
N#define vSetGDCP8GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP8GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP8GARLL(ctrlr,ParValue) (pst_u8GDCP8GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP8GARLL(ctrlr) (pst_u8GDCP8GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP8GARLH(ctrlr,ParValue) (pst_u8GDCP8GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP8GARLH(ctrlr) (pst_u8GDCP8GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP8GARHL(ctrlr,ParValue) (pst_u8GDCP8GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP8GARHL(ctrlr) (pst_u8GDCP8GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP8GARHH(ctrlr,ParValue) (pst_u8GDCP8GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP8GARHH(ctrlr) (pst_u8GDCP8GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP8GARL(ctrlr,ParValue) (pst_u16GDCP8GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP8GARL(ctrlr) (pst_u16GDCP8GAR(ctrlr) -> u16L)
N#define vSetGDCP8GARH(ctrlr,ParValue) (pst_u16GDCP8GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP8GARH(ctrlr) (pst_u16GDCP8GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP8GAR(ctrlr,ParValue)  (*pu32GDCP8GAR(ctrlr) = (ParValue))
N#define u32GetGDCP8GAR(ctrlr)  (*pu32GDCP8GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP9GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021B0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP9GAR_REG__       0xC0C021B0U
N#else
S#define GDCP9GAR_REG__ ((uint32_t) GDCP9GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP9GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP9GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP9GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP9GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP9GAR(ctrlr)     ((volatile GDCP9GAR_bit_view_st *)\
S(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP9GAR(ctrlr)     ((volatile GDCP9GAR_bit_view_st *)(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP9GAR(ctrlr)     ((volatile GDCP9GAR_byte_view_st *)\
S(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP9GAR(ctrlr)     ((volatile GDCP9GAR_byte_view_st *)(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP9GAR(ctrlr)     ((volatile GDCP9GAR_halfword_view_st *)\
S(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP9GAR(ctrlr)     ((volatile GDCP9GAR_halfword_view_st *)(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP9GAR(ctrlr)     ((volatile u32GDCP9GAR_word_view *)\
S(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP9GAR(ctrlr)     ((volatile u32GDCP9GAR_word_view *)(GDCP9GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP9GAR(ctrlr)     ((volatile GDCP9GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][9])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP9GAR(ctrlr)     ((volatile GDCP9GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][9])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP9GAR(ctrlr)     ((volatile GDCP9GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][9])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP9GAR(ctrlr)     ((volatile u32GDCP9GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][9])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP9GAR_GAWID(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GAWID)
N#define vSetGDCP9GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP9GAR_GAINV(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GAINV)
N#define vSetGDCP9GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP9GAR_GADIV(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GADIV)
N#define vSetGDCP9GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP9GAR_GADEL(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GADEL)
N#define vSetGDCP9GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP9GAR_GABYP(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GABYP)
N#define vSetGDCP9GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP9GAR_GAINSEL(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP9GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP9GAR_GALVL(ctrlr) (pst_bitGDCP9GAR(ctrlr) -> GALVL)
N#define vSetGDCP9GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP9GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP9GARLL(ctrlr,ParValue) (pst_u8GDCP9GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP9GARLL(ctrlr) (pst_u8GDCP9GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP9GARLH(ctrlr,ParValue) (pst_u8GDCP9GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP9GARLH(ctrlr) (pst_u8GDCP9GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP9GARHL(ctrlr,ParValue) (pst_u8GDCP9GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP9GARHL(ctrlr) (pst_u8GDCP9GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP9GARHH(ctrlr,ParValue) (pst_u8GDCP9GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP9GARHH(ctrlr) (pst_u8GDCP9GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP9GARL(ctrlr,ParValue) (pst_u16GDCP9GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP9GARL(ctrlr) (pst_u16GDCP9GAR(ctrlr) -> u16L)
N#define vSetGDCP9GARH(ctrlr,ParValue) (pst_u16GDCP9GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP9GARH(ctrlr) (pst_u16GDCP9GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP9GAR(ctrlr,ParValue)  (*pu32GDCP9GAR(ctrlr) = (ParValue))
N#define u32GetGDCP9GAR(ctrlr)  (*pu32GDCP9GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP10GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021B8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP10GAR_REG__       0xC0C021B8U
N#else
S#define GDCP10GAR_REG__ ((uint32_t) GDCP10GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP10GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP10GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP10GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP10GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP10GAR(ctrlr)     ((volatile GDCP10GAR_bit_view_st *)\
S(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP10GAR(ctrlr)     ((volatile GDCP10GAR_bit_view_st *)(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP10GAR(ctrlr)     ((volatile GDCP10GAR_byte_view_st *)\
S(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP10GAR(ctrlr)     ((volatile GDCP10GAR_byte_view_st *)(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP10GAR(ctrlr)     ((volatile GDCP10GAR_halfword_view_st *)\
S(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP10GAR(ctrlr)     ((volatile GDCP10GAR_halfword_view_st *)(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP10GAR(ctrlr)     ((volatile u32GDCP10GAR_word_view *)\
S(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP10GAR(ctrlr)     ((volatile u32GDCP10GAR_word_view *)(GDCP10GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP10GAR(ctrlr)     ((volatile GDCP10GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][10])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP10GAR(ctrlr)     ((volatile GDCP10GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][10])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP10GAR(ctrlr)     ((volatile GDCP10GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][10])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP10GAR(ctrlr)     ((volatile u32GDCP10GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][10])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP10GAR_GAWID(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GAWID)
N#define vSetGDCP10GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP10GAR_GAINV(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GAINV)
N#define vSetGDCP10GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP10GAR_GADIV(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GADIV)
N#define vSetGDCP10GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP10GAR_GADEL(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GADEL)
N#define vSetGDCP10GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP10GAR_GABYP(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GABYP)
N#define vSetGDCP10GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP10GAR_GAINSEL(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP10GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP10GAR_GALVL(ctrlr) (pst_bitGDCP10GAR(ctrlr) -> GALVL)
N#define vSetGDCP10GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP10GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP10GARLL(ctrlr,ParValue) (pst_u8GDCP10GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP10GARLL(ctrlr) (pst_u8GDCP10GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP10GARLH(ctrlr,ParValue) (pst_u8GDCP10GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP10GARLH(ctrlr) (pst_u8GDCP10GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP10GARHL(ctrlr,ParValue) (pst_u8GDCP10GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP10GARHL(ctrlr) (pst_u8GDCP10GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP10GARHH(ctrlr,ParValue) (pst_u8GDCP10GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP10GARHH(ctrlr) (pst_u8GDCP10GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP10GARL(ctrlr,ParValue) (pst_u16GDCP10GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP10GARL(ctrlr) (pst_u16GDCP10GAR(ctrlr) -> u16L)
N#define vSetGDCP10GARH(ctrlr,ParValue) (pst_u16GDCP10GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP10GARH(ctrlr) (pst_u16GDCP10GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP10GAR(ctrlr,ParValue)  (*pu32GDCP10GAR(ctrlr) = (ParValue))
N#define u32GetGDCP10GAR(ctrlr)  (*pu32GDCP10GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP11GAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021C0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP11GAR_REG__       0xC0C021C0U
N#else
S#define GDCP11GAR_REG__ ((uint32_t) GDCP11GAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GAWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GAINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GADIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GADEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GABYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GAINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GALVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP11GAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP11GAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP11GAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP11GAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP11GAR(ctrlr)     ((volatile GDCP11GAR_bit_view_st *)\
S(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP11GAR(ctrlr)     ((volatile GDCP11GAR_bit_view_st *)(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP11GAR(ctrlr)     ((volatile GDCP11GAR_byte_view_st *)\
S(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP11GAR(ctrlr)     ((volatile GDCP11GAR_byte_view_st *)(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP11GAR(ctrlr)     ((volatile GDCP11GAR_halfword_view_st *)\
S(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP11GAR(ctrlr)     ((volatile GDCP11GAR_halfword_view_st *)(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP11GAR(ctrlr)     ((volatile u32GDCP11GAR_word_view *)\
S(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP11GAR(ctrlr)     ((volatile u32GDCP11GAR_word_view *)(GDCP11GAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP11GAR(ctrlr)     ((volatile GDCP11GAR_bit_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][11])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP11GAR(ctrlr)     ((volatile GDCP11GAR_byte_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][11])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP11GAR(ctrlr)     ((volatile GDCP11GAR_halfword_view_st *) &u32GDCPxGAR_REG__Var[(ctrlr)][11])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP11GAR(ctrlr)     ((volatile u32GDCP11GAR_word_view *) &u32GDCPxGAR_REG__Var[(ctrlr)][11])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP11GAR_GAWID(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GAWID)
N#define vSetGDCP11GAR_GAWID(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GAWID=(ParValue))
N#define biGetGDCP11GAR_GAINV(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GAINV)
N#define vSetGDCP11GAR_GAINV(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GAINV=(ParValue))
N#define biGetGDCP11GAR_GADIV(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GADIV)
N#define vSetGDCP11GAR_GADIV(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GADIV=(ParValue))
N#define biGetGDCP11GAR_GADEL(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GADEL)
N#define vSetGDCP11GAR_GADEL(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GADEL=(ParValue))
N#define biGetGDCP11GAR_GABYP(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GABYP)
N#define vSetGDCP11GAR_GABYP(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GABYP=(ParValue))
N#define biGetGDCP11GAR_GAINSEL(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GAINSEL)
N#define vSetGDCP11GAR_GAINSEL(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GAINSEL=(ParValue))
N#define biGetGDCP11GAR_GALVL(ctrlr) (pst_bitGDCP11GAR(ctrlr) -> GALVL)
N#define vSetGDCP11GAR_GALVL(ctrlr,ParValue)  (pst_bitGDCP11GAR(ctrlr) -> GALVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP11GARLL(ctrlr,ParValue) (pst_u8GDCP11GAR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP11GARLL(ctrlr) (pst_u8GDCP11GAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP11GARLH(ctrlr,ParValue) (pst_u8GDCP11GAR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP11GARLH(ctrlr) (pst_u8GDCP11GAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP11GARHL(ctrlr,ParValue) (pst_u8GDCP11GAR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP11GARHL(ctrlr) (pst_u8GDCP11GAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP11GARHH(ctrlr,ParValue) (pst_u8GDCP11GAR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP11GARHH(ctrlr) (pst_u8GDCP11GAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP11GARL(ctrlr,ParValue) (pst_u16GDCP11GAR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP11GARL(ctrlr) (pst_u16GDCP11GAR(ctrlr) -> u16L)
N#define vSetGDCP11GARH(ctrlr,ParValue) (pst_u16GDCP11GAR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP11GARH(ctrlr) (pst_u16GDCP11GAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP11GAR(ctrlr,ParValue)  (*pu32GDCP11GAR(ctrlr) = (ParValue))
N#define u32GetGDCP11GAR(ctrlr)  (*pu32GDCP11GAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP0GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021C8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP0GBR_REG__       0xC0C021C8U
N#else
S#define GDCP0GBR_REG__ ((uint32_t) GDCP0GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP0GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP0GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP0GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP0GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP0GBR(ctrlr)     ((volatile GDCP0GBR_bit_view_st *)\
S(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP0GBR(ctrlr)     ((volatile GDCP0GBR_bit_view_st *)(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP0GBR(ctrlr)     ((volatile GDCP0GBR_byte_view_st *)\
S(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP0GBR(ctrlr)     ((volatile GDCP0GBR_byte_view_st *)(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP0GBR(ctrlr)     ((volatile GDCP0GBR_halfword_view_st *)\
S(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP0GBR(ctrlr)     ((volatile GDCP0GBR_halfword_view_st *)(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP0GBR(ctrlr)     ((volatile u32GDCP0GBR_word_view *)\
S(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP0GBR(ctrlr)     ((volatile u32GDCP0GBR_word_view *)(GDCP0GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP0GBR(ctrlr)     ((volatile GDCP0GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][0])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP0GBR(ctrlr)     ((volatile GDCP0GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][0])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP0GBR(ctrlr)     ((volatile GDCP0GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][0])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP0GBR(ctrlr)     ((volatile u32GDCP0GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][0])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP0GBR_GBWID(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBWID)
N#define vSetGDCP0GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP0GBR_GBINV(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBINV)
N#define vSetGDCP0GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP0GBR_GBDIV(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBDIV)
N#define vSetGDCP0GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP0GBR_GBDEL(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBDEL)
N#define vSetGDCP0GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP0GBR_GBBYP(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBBYP)
N#define vSetGDCP0GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP0GBR_GBINSEL(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP0GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP0GBR_GBLVL(ctrlr) (pst_bitGDCP0GBR(ctrlr) -> GBLVL)
N#define vSetGDCP0GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP0GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP0GBRLL(ctrlr,ParValue) (pst_u8GDCP0GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP0GBRLL(ctrlr) (pst_u8GDCP0GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP0GBRLH(ctrlr,ParValue) (pst_u8GDCP0GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP0GBRLH(ctrlr) (pst_u8GDCP0GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP0GBRHL(ctrlr,ParValue) (pst_u8GDCP0GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP0GBRHL(ctrlr) (pst_u8GDCP0GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP0GBRHH(ctrlr,ParValue) (pst_u8GDCP0GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP0GBRHH(ctrlr) (pst_u8GDCP0GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP0GBRL(ctrlr,ParValue) (pst_u16GDCP0GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP0GBRL(ctrlr) (pst_u16GDCP0GBR(ctrlr) -> u16L)
N#define vSetGDCP0GBRH(ctrlr,ParValue) (pst_u16GDCP0GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP0GBRH(ctrlr) (pst_u16GDCP0GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP0GBR(ctrlr,ParValue)  (*pu32GDCP0GBR(ctrlr) = (ParValue))
N#define u32GetGDCP0GBR(ctrlr)  (*pu32GDCP0GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP1GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021D0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP1GBR_REG__       0xC0C021D0U
N#else
S#define GDCP1GBR_REG__ ((uint32_t) GDCP1GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP1GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP1GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP1GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP1GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP1GBR(ctrlr)     ((volatile GDCP1GBR_bit_view_st *)\
S(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP1GBR(ctrlr)     ((volatile GDCP1GBR_bit_view_st *)(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP1GBR(ctrlr)     ((volatile GDCP1GBR_byte_view_st *)\
S(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP1GBR(ctrlr)     ((volatile GDCP1GBR_byte_view_st *)(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP1GBR(ctrlr)     ((volatile GDCP1GBR_halfword_view_st *)\
S(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP1GBR(ctrlr)     ((volatile GDCP1GBR_halfword_view_st *)(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP1GBR(ctrlr)     ((volatile u32GDCP1GBR_word_view *)\
S(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP1GBR(ctrlr)     ((volatile u32GDCP1GBR_word_view *)(GDCP1GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP1GBR(ctrlr)     ((volatile GDCP1GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][1])
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP1GBR(ctrlr)     ((volatile GDCP1GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][1])
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP1GBR(ctrlr)     ((volatile GDCP1GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][1])
N            
N/* Pointer to WORD  */ 
N#define pu32GDCP1GBR(ctrlr)     ((volatile u32GDCP1GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][1])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP1GBR_GBWID(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBWID)
N#define vSetGDCP1GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP1GBR_GBINV(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBINV)
N#define vSetGDCP1GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP1GBR_GBDIV(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBDIV)
N#define vSetGDCP1GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP1GBR_GBDEL(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBDEL)
N#define vSetGDCP1GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP1GBR_GBBYP(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBBYP)
N#define vSetGDCP1GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP1GBR_GBINSEL(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP1GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP1GBR_GBLVL(ctrlr) (pst_bitGDCP1GBR(ctrlr) -> GBLVL)
N#define vSetGDCP1GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP1GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP1GBRLL(ctrlr,ParValue) (pst_u8GDCP1GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP1GBRLL(ctrlr) (pst_u8GDCP1GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP1GBRLH(ctrlr,ParValue) (pst_u8GDCP1GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP1GBRLH(ctrlr) (pst_u8GDCP1GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP1GBRHL(ctrlr,ParValue) (pst_u8GDCP1GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP1GBRHL(ctrlr) (pst_u8GDCP1GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP1GBRHH(ctrlr,ParValue) (pst_u8GDCP1GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP1GBRHH(ctrlr) (pst_u8GDCP1GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP1GBRL(ctrlr,ParValue) (pst_u16GDCP1GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP1GBRL(ctrlr) (pst_u16GDCP1GBR(ctrlr) -> u16L)
N#define vSetGDCP1GBRH(ctrlr,ParValue) (pst_u16GDCP1GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP1GBRH(ctrlr) (pst_u16GDCP1GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP1GBR(ctrlr,ParValue)  (*pu32GDCP1GBR(ctrlr) = (ParValue))
N#define u32GetGDCP1GBR(ctrlr)  (*pu32GDCP1GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP2GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021D8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP2GBR_REG__       0xC0C021D8U
N#else
S#define GDCP2GBR_REG__ ((uint32_t) GDCP2GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP2GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP2GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP2GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP2GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP2GBR(ctrlr)     ((volatile GDCP2GBR_bit_view_st *)\
S(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP2GBR(ctrlr)     ((volatile GDCP2GBR_bit_view_st *)(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP2GBR(ctrlr)     ((volatile GDCP2GBR_byte_view_st *)\
S(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP2GBR(ctrlr)     ((volatile GDCP2GBR_byte_view_st *)(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP2GBR(ctrlr)     ((volatile GDCP2GBR_halfword_view_st *)\
S(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP2GBR(ctrlr)     ((volatile GDCP2GBR_halfword_view_st *)(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP2GBR(ctrlr)     ((volatile u32GDCP2GBR_word_view *)\
S(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP2GBR(ctrlr)     ((volatile u32GDCP2GBR_word_view *)(GDCP2GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP2GBR(ctrlr)     ((volatile GDCP2GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][2])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP2GBR(ctrlr)     ((volatile GDCP2GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][2])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP2GBR(ctrlr)     ((volatile GDCP2GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][2])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP2GBR(ctrlr)     ((volatile u32GDCP2GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][2])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP2GBR_GBWID(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBWID)
N#define vSetGDCP2GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP2GBR_GBINV(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBINV)
N#define vSetGDCP2GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP2GBR_GBDIV(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBDIV)
N#define vSetGDCP2GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP2GBR_GBDEL(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBDEL)
N#define vSetGDCP2GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP2GBR_GBBYP(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBBYP)
N#define vSetGDCP2GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP2GBR_GBINSEL(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP2GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP2GBR_GBLVL(ctrlr) (pst_bitGDCP2GBR(ctrlr) -> GBLVL)
N#define vSetGDCP2GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP2GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP2GBRLL(ctrlr,ParValue) (pst_u8GDCP2GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP2GBRLL(ctrlr) (pst_u8GDCP2GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP2GBRLH(ctrlr,ParValue) (pst_u8GDCP2GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP2GBRLH(ctrlr) (pst_u8GDCP2GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP2GBRHL(ctrlr,ParValue) (pst_u8GDCP2GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP2GBRHL(ctrlr) (pst_u8GDCP2GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP2GBRHH(ctrlr,ParValue) (pst_u8GDCP2GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP2GBRHH(ctrlr) (pst_u8GDCP2GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP2GBRL(ctrlr,ParValue) (pst_u16GDCP2GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP2GBRL(ctrlr) (pst_u16GDCP2GBR(ctrlr) -> u16L)
N#define vSetGDCP2GBRH(ctrlr,ParValue) (pst_u16GDCP2GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP2GBRH(ctrlr) (pst_u16GDCP2GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP2GBR(ctrlr,ParValue)  (*pu32GDCP2GBR(ctrlr) = (ParValue))
N#define u32GetGDCP2GBR(ctrlr)  (*pu32GDCP2GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP3GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021E0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP3GBR_REG__       0xC0C021E0U
N#else
S#define GDCP3GBR_REG__ ((uint32_t) GDCP3GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP3GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP3GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP3GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP3GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP3GBR(ctrlr)     ((volatile GDCP3GBR_bit_view_st *)\
S(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP3GBR(ctrlr)     ((volatile GDCP3GBR_bit_view_st *)(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP3GBR(ctrlr)     ((volatile GDCP3GBR_byte_view_st *)\
S(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP3GBR(ctrlr)     ((volatile GDCP3GBR_byte_view_st *)(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP3GBR(ctrlr)     ((volatile GDCP3GBR_halfword_view_st *)\
S(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP3GBR(ctrlr)     ((volatile GDCP3GBR_halfword_view_st *)(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP3GBR(ctrlr)     ((volatile u32GDCP3GBR_word_view *)\
S(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP3GBR(ctrlr)     ((volatile u32GDCP3GBR_word_view *)(GDCP3GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP3GBR(ctrlr)     ((volatile GDCP3GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][3])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP3GBR(ctrlr)     ((volatile GDCP3GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][3])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP3GBR(ctrlr)     ((volatile GDCP3GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][3])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP3GBR(ctrlr)     ((volatile u32GDCP3GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][3])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP3GBR_GBWID(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBWID)
N#define vSetGDCP3GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP3GBR_GBINV(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBINV)
N#define vSetGDCP3GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP3GBR_GBDIV(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBDIV)
N#define vSetGDCP3GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP3GBR_GBDEL(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBDEL)
N#define vSetGDCP3GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP3GBR_GBBYP(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBBYP)
N#define vSetGDCP3GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP3GBR_GBINSEL(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP3GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP3GBR_GBLVL(ctrlr) (pst_bitGDCP3GBR(ctrlr) -> GBLVL)
N#define vSetGDCP3GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP3GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP3GBRLL(ctrlr,ParValue) (pst_u8GDCP3GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP3GBRLL(ctrlr) (pst_u8GDCP3GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP3GBRLH(ctrlr,ParValue) (pst_u8GDCP3GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP3GBRLH(ctrlr) (pst_u8GDCP3GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP3GBRHL(ctrlr,ParValue) (pst_u8GDCP3GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP3GBRHL(ctrlr) (pst_u8GDCP3GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP3GBRHH(ctrlr,ParValue) (pst_u8GDCP3GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP3GBRHH(ctrlr) (pst_u8GDCP3GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP3GBRL(ctrlr,ParValue) (pst_u16GDCP3GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP3GBRL(ctrlr) (pst_u16GDCP3GBR(ctrlr) -> u16L)
N#define vSetGDCP3GBRH(ctrlr,ParValue) (pst_u16GDCP3GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP3GBRH(ctrlr) (pst_u16GDCP3GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP3GBR(ctrlr,ParValue)  (*pu32GDCP3GBR(ctrlr) = (ParValue))
N#define u32GetGDCP3GBR(ctrlr)  (*pu32GDCP3GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP4GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021E8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP4GBR_REG__       0xC0C021E8U
N#else
S#define GDCP4GBR_REG__ ((uint32_t) GDCP4GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP4GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP4GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP4GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP4GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP4GBR(ctrlr)     ((volatile GDCP4GBR_bit_view_st *)\
S(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP4GBR(ctrlr)     ((volatile GDCP4GBR_bit_view_st *)(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP4GBR(ctrlr)     ((volatile GDCP4GBR_byte_view_st *)\
S(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP4GBR(ctrlr)     ((volatile GDCP4GBR_byte_view_st *)(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP4GBR(ctrlr)     ((volatile GDCP4GBR_halfword_view_st *)\
S(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP4GBR(ctrlr)     ((volatile GDCP4GBR_halfword_view_st *)(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP4GBR(ctrlr)     ((volatile u32GDCP4GBR_word_view *)\
S(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP4GBR(ctrlr)     ((volatile u32GDCP4GBR_word_view *)(GDCP4GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP4GBR(ctrlr)     ((volatile GDCP4GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][4])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP4GBR(ctrlr)     ((volatile GDCP4GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][4])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP4GBR(ctrlr)     ((volatile GDCP4GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][4])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP4GBR(ctrlr)     ((volatile u32GDCP4GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][4])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP4GBR_GBWID(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBWID)
N#define vSetGDCP4GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP4GBR_GBINV(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBINV)
N#define vSetGDCP4GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP4GBR_GBDIV(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBDIV)
N#define vSetGDCP4GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP4GBR_GBDEL(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBDEL)
N#define vSetGDCP4GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP4GBR_GBBYP(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBBYP)
N#define vSetGDCP4GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP4GBR_GBINSEL(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP4GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP4GBR_GBLVL(ctrlr) (pst_bitGDCP4GBR(ctrlr) -> GBLVL)
N#define vSetGDCP4GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP4GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP4GBRLL(ctrlr,ParValue) (pst_u8GDCP4GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP4GBRLL(ctrlr) (pst_u8GDCP4GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP4GBRLH(ctrlr,ParValue) (pst_u8GDCP4GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP4GBRLH(ctrlr) (pst_u8GDCP4GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP4GBRHL(ctrlr,ParValue) (pst_u8GDCP4GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP4GBRHL(ctrlr) (pst_u8GDCP4GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP4GBRHH(ctrlr,ParValue) (pst_u8GDCP4GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP4GBRHH(ctrlr) (pst_u8GDCP4GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP4GBRL(ctrlr,ParValue) (pst_u16GDCP4GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP4GBRL(ctrlr) (pst_u16GDCP4GBR(ctrlr) -> u16L)
N#define vSetGDCP4GBRH(ctrlr,ParValue) (pst_u16GDCP4GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP4GBRH(ctrlr) (pst_u16GDCP4GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP4GBR(ctrlr,ParValue)  (*pu32GDCP4GBR(ctrlr) = (ParValue))
N#define u32GetGDCP4GBR(ctrlr)  (*pu32GDCP4GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP5GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021F0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP5GBR_REG__       0xC0C021F0U
N#else
S#define GDCP5GBR_REG__ ((uint32_t) GDCP5GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP5GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP5GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP5GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP5GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP5GBR(ctrlr)     ((volatile GDCP5GBR_bit_view_st *)\
S(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP5GBR(ctrlr)     ((volatile GDCP5GBR_bit_view_st *)(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP5GBR(ctrlr)     ((volatile GDCP5GBR_byte_view_st *)\
S(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP5GBR(ctrlr)     ((volatile GDCP5GBR_byte_view_st *)(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP5GBR(ctrlr)     ((volatile GDCP5GBR_halfword_view_st *)\
S(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP5GBR(ctrlr)     ((volatile GDCP5GBR_halfword_view_st *)(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP5GBR(ctrlr)     ((volatile u32GDCP5GBR_word_view *)\
S(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP5GBR(ctrlr)     ((volatile u32GDCP5GBR_word_view *)(GDCP5GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP5GBR(ctrlr)     ((volatile GDCP5GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][5])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP5GBR(ctrlr)     ((volatile GDCP5GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][5])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP5GBR(ctrlr)     ((volatile GDCP5GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][5])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP5GBR(ctrlr)     ((volatile u32GDCP5GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][5])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP5GBR_GBWID(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBWID)
N#define vSetGDCP5GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP5GBR_GBINV(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBINV)
N#define vSetGDCP5GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP5GBR_GBDIV(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBDIV)
N#define vSetGDCP5GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP5GBR_GBDEL(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBDEL)
N#define vSetGDCP5GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP5GBR_GBBYP(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBBYP)
N#define vSetGDCP5GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP5GBR_GBINSEL(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP5GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP5GBR_GBLVL(ctrlr) (pst_bitGDCP5GBR(ctrlr) -> GBLVL)
N#define vSetGDCP5GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP5GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP5GBRLL(ctrlr,ParValue) (pst_u8GDCP5GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP5GBRLL(ctrlr) (pst_u8GDCP5GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP5GBRLH(ctrlr,ParValue) (pst_u8GDCP5GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP5GBRLH(ctrlr) (pst_u8GDCP5GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP5GBRHL(ctrlr,ParValue) (pst_u8GDCP5GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP5GBRHL(ctrlr) (pst_u8GDCP5GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP5GBRHH(ctrlr,ParValue) (pst_u8GDCP5GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP5GBRHH(ctrlr) (pst_u8GDCP5GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP5GBRL(ctrlr,ParValue) (pst_u16GDCP5GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP5GBRL(ctrlr) (pst_u16GDCP5GBR(ctrlr) -> u16L)
N#define vSetGDCP5GBRH(ctrlr,ParValue) (pst_u16GDCP5GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP5GBRH(ctrlr) (pst_u16GDCP5GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP5GBR(ctrlr,ParValue)  (*pu32GDCP5GBR(ctrlr) = (ParValue))
N#define u32GetGDCP5GBR(ctrlr)  (*pu32GDCP5GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP6GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C021F8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP6GBR_REG__       0xC0C021F8U
N#else
S#define GDCP6GBR_REG__ ((uint32_t) GDCP6GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP6GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP6GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP6GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP6GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP6GBR(ctrlr)     ((volatile GDCP6GBR_bit_view_st *)\
S(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP6GBR(ctrlr)     ((volatile GDCP6GBR_bit_view_st *)(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP6GBR(ctrlr)     ((volatile GDCP6GBR_byte_view_st *)\
S(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP6GBR(ctrlr)     ((volatile GDCP6GBR_byte_view_st *)(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP6GBR(ctrlr)     ((volatile GDCP6GBR_halfword_view_st *)\
S(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP6GBR(ctrlr)     ((volatile GDCP6GBR_halfword_view_st *)(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP6GBR(ctrlr)     ((volatile u32GDCP6GBR_word_view *)\
S(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP6GBR(ctrlr)     ((volatile u32GDCP6GBR_word_view *)(GDCP6GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP6GBR(ctrlr)     ((volatile GDCP6GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][6])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP6GBR(ctrlr)     ((volatile GDCP6GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][6])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP6GBR(ctrlr)     ((volatile GDCP6GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][6])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP6GBR(ctrlr)     ((volatile u32GDCP6GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][6])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP6GBR_GBWID(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBWID)
N#define vSetGDCP6GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP6GBR_GBINV(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBINV)
N#define vSetGDCP6GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP6GBR_GBDIV(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBDIV)
N#define vSetGDCP6GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP6GBR_GBDEL(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBDEL)
N#define vSetGDCP6GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP6GBR_GBBYP(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBBYP)
N#define vSetGDCP6GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP6GBR_GBINSEL(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP6GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP6GBR_GBLVL(ctrlr) (pst_bitGDCP6GBR(ctrlr) -> GBLVL)
N#define vSetGDCP6GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP6GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP6GBRLL(ctrlr,ParValue) (pst_u8GDCP6GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP6GBRLL(ctrlr) (pst_u8GDCP6GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP6GBRLH(ctrlr,ParValue) (pst_u8GDCP6GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP6GBRLH(ctrlr) (pst_u8GDCP6GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP6GBRHL(ctrlr,ParValue) (pst_u8GDCP6GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP6GBRHL(ctrlr) (pst_u8GDCP6GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP6GBRHH(ctrlr,ParValue) (pst_u8GDCP6GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP6GBRHH(ctrlr) (pst_u8GDCP6GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP6GBRL(ctrlr,ParValue) (pst_u16GDCP6GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP6GBRL(ctrlr) (pst_u16GDCP6GBR(ctrlr) -> u16L)
N#define vSetGDCP6GBRH(ctrlr,ParValue) (pst_u16GDCP6GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP6GBRH(ctrlr) (pst_u16GDCP6GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP6GBR(ctrlr,ParValue)  (*pu32GDCP6GBR(ctrlr) = (ParValue))
N#define u32GetGDCP6GBR(ctrlr)  (*pu32GDCP6GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP7GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02200                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP7GBR_REG__       0xC0C02200U
N#else
S#define GDCP7GBR_REG__ ((uint32_t) GDCP7GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP7GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP7GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP7GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP7GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP7GBR(ctrlr)     ((volatile GDCP7GBR_bit_view_st *)\
S(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP7GBR(ctrlr)     ((volatile GDCP7GBR_bit_view_st *)(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP7GBR(ctrlr)     ((volatile GDCP7GBR_byte_view_st *)\
S(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP7GBR(ctrlr)     ((volatile GDCP7GBR_byte_view_st *)(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP7GBR(ctrlr)     ((volatile GDCP7GBR_halfword_view_st *)\
S(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP7GBR(ctrlr)     ((volatile GDCP7GBR_halfword_view_st *)(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP7GBR(ctrlr)     ((volatile u32GDCP7GBR_word_view *)\
S(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP7GBR(ctrlr)     ((volatile u32GDCP7GBR_word_view *)(GDCP7GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP7GBR(ctrlr)     ((volatile GDCP7GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][7])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP7GBR(ctrlr)     ((volatile GDCP7GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][7])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP7GBR(ctrlr)     ((volatile GDCP7GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][7])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP7GBR(ctrlr)     ((volatile u32GDCP7GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][7])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP7GBR_GBWID(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBWID)
N#define vSetGDCP7GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP7GBR_GBINV(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBINV)
N#define vSetGDCP7GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP7GBR_GBDIV(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBDIV)
N#define vSetGDCP7GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP7GBR_GBDEL(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBDEL)
N#define vSetGDCP7GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP7GBR_GBBYP(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBBYP)
N#define vSetGDCP7GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP7GBR_GBINSEL(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP7GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP7GBR_GBLVL(ctrlr) (pst_bitGDCP7GBR(ctrlr) -> GBLVL)
N#define vSetGDCP7GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP7GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP7GBRLL(ctrlr,ParValue) (pst_u8GDCP7GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP7GBRLL(ctrlr) (pst_u8GDCP7GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP7GBRLH(ctrlr,ParValue) (pst_u8GDCP7GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP7GBRLH(ctrlr) (pst_u8GDCP7GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP7GBRHL(ctrlr,ParValue) (pst_u8GDCP7GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP7GBRHL(ctrlr) (pst_u8GDCP7GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP7GBRHH(ctrlr,ParValue) (pst_u8GDCP7GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP7GBRHH(ctrlr) (pst_u8GDCP7GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP7GBRL(ctrlr,ParValue) (pst_u16GDCP7GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP7GBRL(ctrlr) (pst_u16GDCP7GBR(ctrlr) -> u16L)
N#define vSetGDCP7GBRH(ctrlr,ParValue) (pst_u16GDCP7GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP7GBRH(ctrlr) (pst_u16GDCP7GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP7GBR(ctrlr,ParValue)  (*pu32GDCP7GBR(ctrlr) = (ParValue))
N#define u32GetGDCP7GBR(ctrlr)  (*pu32GDCP7GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP8GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02208                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP8GBR_REG__       0xC0C02208U
N#else
S#define GDCP8GBR_REG__ ((uint32_t) GDCP8GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP8GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP8GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP8GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP8GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP8GBR(ctrlr)     ((volatile GDCP8GBR_bit_view_st *)\
S(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP8GBR(ctrlr)     ((volatile GDCP8GBR_bit_view_st *)(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP8GBR(ctrlr)     ((volatile GDCP8GBR_byte_view_st *)\
S(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP8GBR(ctrlr)     ((volatile GDCP8GBR_byte_view_st *)(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP8GBR(ctrlr)     ((volatile GDCP8GBR_halfword_view_st *)\
S(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP8GBR(ctrlr)     ((volatile GDCP8GBR_halfword_view_st *)(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP8GBR(ctrlr)     ((volatile u32GDCP8GBR_word_view *)\
S(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP8GBR(ctrlr)     ((volatile u32GDCP8GBR_word_view *)(GDCP8GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP8GBR(ctrlr)     ((volatile GDCP8GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][8])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP8GBR(ctrlr)     ((volatile GDCP8GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][8])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP8GBR(ctrlr)     ((volatile GDCP8GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][8])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP8GBR(ctrlr)     ((volatile u32GDCP8GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][8])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP8GBR_GBWID(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBWID)
N#define vSetGDCP8GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP8GBR_GBINV(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBINV)
N#define vSetGDCP8GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP8GBR_GBDIV(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBDIV)
N#define vSetGDCP8GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP8GBR_GBDEL(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBDEL)
N#define vSetGDCP8GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP8GBR_GBBYP(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBBYP)
N#define vSetGDCP8GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP8GBR_GBINSEL(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP8GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP8GBR_GBLVL(ctrlr) (pst_bitGDCP8GBR(ctrlr) -> GBLVL)
N#define vSetGDCP8GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP8GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP8GBRLL(ctrlr,ParValue) (pst_u8GDCP8GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP8GBRLL(ctrlr) (pst_u8GDCP8GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP8GBRLH(ctrlr,ParValue) (pst_u8GDCP8GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP8GBRLH(ctrlr) (pst_u8GDCP8GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP8GBRHL(ctrlr,ParValue) (pst_u8GDCP8GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP8GBRHL(ctrlr) (pst_u8GDCP8GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP8GBRHH(ctrlr,ParValue) (pst_u8GDCP8GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP8GBRHH(ctrlr) (pst_u8GDCP8GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP8GBRL(ctrlr,ParValue) (pst_u16GDCP8GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP8GBRL(ctrlr) (pst_u16GDCP8GBR(ctrlr) -> u16L)
N#define vSetGDCP8GBRH(ctrlr,ParValue) (pst_u16GDCP8GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP8GBRH(ctrlr) (pst_u16GDCP8GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP8GBR(ctrlr,ParValue)  (*pu32GDCP8GBR(ctrlr) = (ParValue))
N#define u32GetGDCP8GBR(ctrlr)  (*pu32GDCP8GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP9GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02210                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP9GBR_REG__       0xC0C02210U
N#else
S#define GDCP9GBR_REG__ ((uint32_t) GDCP9GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP9GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP9GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP9GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP9GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP9GBR(ctrlr)     ((volatile GDCP9GBR_bit_view_st *)\
S(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP9GBR(ctrlr)     ((volatile GDCP9GBR_bit_view_st *)(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP9GBR(ctrlr)     ((volatile GDCP9GBR_byte_view_st *)\
S(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP9GBR(ctrlr)     ((volatile GDCP9GBR_byte_view_st *)(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP9GBR(ctrlr)     ((volatile GDCP9GBR_halfword_view_st *)\
S(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP9GBR(ctrlr)     ((volatile GDCP9GBR_halfword_view_st *)(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP9GBR(ctrlr)     ((volatile u32GDCP9GBR_word_view *)\
S(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP9GBR(ctrlr)     ((volatile u32GDCP9GBR_word_view *)(GDCP9GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP9GBR(ctrlr)     ((volatile GDCP9GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][9])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP9GBR(ctrlr)     ((volatile GDCP9GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][9])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP9GBR(ctrlr)     ((volatile GDCP9GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][9])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP9GBR(ctrlr)     ((volatile u32GDCP9GBR_word_view *)GDCP9GBR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP9GBR_GBWID(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBWID)
N#define vSetGDCP9GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP9GBR_GBINV(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBINV)
N#define vSetGDCP9GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP9GBR_GBDIV(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBDIV)
N#define vSetGDCP9GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP9GBR_GBDEL(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBDEL)
N#define vSetGDCP9GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP9GBR_GBBYP(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBBYP)
N#define vSetGDCP9GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP9GBR_GBINSEL(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP9GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP9GBR_GBLVL(ctrlr) (pst_bitGDCP9GBR(ctrlr) -> GBLVL)
N#define vSetGDCP9GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP9GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP9GBRLL(ctrlr,ParValue) (pst_u8GDCP9GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP9GBRLL(ctrlr) (pst_u8GDCP9GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP9GBRLH(ctrlr,ParValue) (pst_u8GDCP9GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP9GBRLH(ctrlr) (pst_u8GDCP9GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP9GBRHL(ctrlr,ParValue) (pst_u8GDCP9GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP9GBRHL(ctrlr) (pst_u8GDCP9GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP9GBRHH(ctrlr,ParValue) (pst_u8GDCP9GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP9GBRHH(ctrlr) (pst_u8GDCP9GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP9GBRL(ctrlr,ParValue) (pst_u16GDCP9GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP9GBRL(ctrlr) (pst_u16GDCP9GBR(ctrlr) -> u16L)
N#define vSetGDCP9GBRH(ctrlr,ParValue) (pst_u16GDCP9GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP9GBRH(ctrlr) (pst_u16GDCP9GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP9GBR(ctrlr,ParValue)  (*pu32GDCP9GBR(ctrlr) = (ParValue))
N#define u32GetGDCP9GBR(ctrlr)  (*pu32GDCP9GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP10GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02218                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP10GBR_REG__       0xC0C02218U
N#else
S#define GDCP10GBR_REG__ ((uint32_t) GDCP10GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP10GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP10GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP10GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP10GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP10GBR(ctrlr)     ((volatile GDCP10GBR_bit_view_st *)\
S(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP10GBR(ctrlr)     ((volatile GDCP10GBR_bit_view_st *)(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP10GBR(ctrlr)     ((volatile GDCP10GBR_byte_view_st *)\
S(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP10GBR(ctrlr)     ((volatile GDCP10GBR_byte_view_st *)(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP10GBR(ctrlr)     ((volatile GDCP10GBR_halfword_view_st *)\
S(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP10GBR(ctrlr)     ((volatile GDCP10GBR_halfword_view_st *)(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP10GBR(ctrlr)     ((volatile u32GDCP10GBR_word_view *)\
S(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP10GBR(ctrlr)     ((volatile u32GDCP10GBR_word_view *)(GDCP10GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP10GBR(ctrlr)     ((volatile GDCP10GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][10])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP10GBR(ctrlr)     ((volatile GDCP10GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][10])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP10GBR(ctrlr)     ((volatile GDCP10GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][10])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP10GBR(ctrlr)     ((volatile u32GDCP10GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][10])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP10GBR_GBWID(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBWID)
N#define vSetGDCP10GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP10GBR_GBINV(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBINV)
N#define vSetGDCP10GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP10GBR_GBDIV(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBDIV)
N#define vSetGDCP10GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP10GBR_GBDEL(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBDEL)
N#define vSetGDCP10GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP10GBR_GBBYP(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBBYP)
N#define vSetGDCP10GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP10GBR_GBINSEL(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP10GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP10GBR_GBLVL(ctrlr) (pst_bitGDCP10GBR(ctrlr) -> GBLVL)
N#define vSetGDCP10GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP10GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP10GBRLL(ctrlr,ParValue) (pst_u8GDCP10GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP10GBRLL(ctrlr) (pst_u8GDCP10GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP10GBRLH(ctrlr,ParValue) (pst_u8GDCP10GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP10GBRLH(ctrlr) (pst_u8GDCP10GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP10GBRHL(ctrlr,ParValue) (pst_u8GDCP10GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP10GBRHL(ctrlr) (pst_u8GDCP10GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP10GBRHH(ctrlr,ParValue) (pst_u8GDCP10GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP10GBRHH(ctrlr) (pst_u8GDCP10GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP10GBRL(ctrlr,ParValue) (pst_u16GDCP10GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP10GBRL(ctrlr) (pst_u16GDCP10GBR(ctrlr) -> u16L)
N#define vSetGDCP10GBRH(ctrlr,ParValue) (pst_u16GDCP10GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP10GBRH(ctrlr) (pst_u16GDCP10GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP10GBR(ctrlr,ParValue)  (*pu32GDCP10GBR(ctrlr) = (ParValue))
N#define u32GetGDCP10GBR(ctrlr)  (*pu32GDCP10GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCP11GBR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02220                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCP11GBR_REG__       0xC0C02220U
N#else
S#define GDCP11GBR_REG__ ((uint32_t) GDCP11GBR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBWID	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   GBINV	:1; 	 /* 11..11  bit(s) R/W */
N  uint32_t   GBDIV	:4; 	 /* 12..15  bit(s) R/W */
N  uint32_t   GBDEL	:11; 	 /* 16..26  bit(s) R/W */
N  uint32_t   GBBYP	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   GBINSEL	:3; 	 /* 28..30  bit(s) R/W */
N  uint32_t   GBLVL	:1; 	 /* 31..31  bit(s) R/W */                    
N} GDCP11GBR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCP11GBR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCP11GBR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCP11GBR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCP11GBR(ctrlr)     ((volatile GDCP11GBR_bit_view_st *)\
S(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCP11GBR(ctrlr)     ((volatile GDCP11GBR_bit_view_st *)(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCP11GBR(ctrlr)     ((volatile GDCP11GBR_byte_view_st *)\
S(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCP11GBR(ctrlr)     ((volatile GDCP11GBR_byte_view_st *)(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCP11GBR(ctrlr)     ((volatile GDCP11GBR_halfword_view_st *)\
S(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCP11GBR(ctrlr)     ((volatile GDCP11GBR_halfword_view_st *)(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCP11GBR(ctrlr)     ((volatile u32GDCP11GBR_word_view *)\
S(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCP11GBR(ctrlr)     ((volatile u32GDCP11GBR_word_view *)(GDCP11GBR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCP11GBR(ctrlr)     ((volatile GDCP11GBR_bit_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][11])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCP11GBR(ctrlr)     ((volatile GDCP11GBR_byte_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][11])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCP11GBR(ctrlr)     ((volatile GDCP11GBR_halfword_view_st *) &u32GDCPxGBR_REG__Var[(ctrlr)][11])
N
N/* Pointer to WORD  */ 
N#define pu32GDCP11GBR(ctrlr)     ((volatile u32GDCP11GBR_word_view *) &u32GDCPxGBR_REG__Var[(ctrlr)][11])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCP11GBR_GBWID(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBWID)
N#define vSetGDCP11GBR_GBWID(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBWID=(ParValue))
N#define biGetGDCP11GBR_GBINV(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBINV)
N#define vSetGDCP11GBR_GBINV(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBINV=(ParValue))
N#define biGetGDCP11GBR_GBDIV(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBDIV)
N#define vSetGDCP11GBR_GBDIV(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBDIV=(ParValue))
N#define biGetGDCP11GBR_GBDEL(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBDEL)
N#define vSetGDCP11GBR_GBDEL(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBDEL=(ParValue))
N#define biGetGDCP11GBR_GBBYP(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBBYP)
N#define vSetGDCP11GBR_GBBYP(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBBYP=(ParValue))
N#define biGetGDCP11GBR_GBINSEL(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBINSEL)
N#define vSetGDCP11GBR_GBINSEL(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBINSEL=(ParValue))
N#define biGetGDCP11GBR_GBLVL(ctrlr) (pst_bitGDCP11GBR(ctrlr) -> GBLVL)
N#define vSetGDCP11GBR_GBLVL(ctrlr,ParValue)  (pst_bitGDCP11GBR(ctrlr) -> GBLVL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCP11GBRLL(ctrlr,ParValue) (pst_u8GDCP11GBR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCP11GBRLL(ctrlr) (pst_u8GDCP11GBR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCP11GBRLH(ctrlr,ParValue) (pst_u8GDCP11GBR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCP11GBRLH(ctrlr) (pst_u8GDCP11GBR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCP11GBRHL(ctrlr,ParValue) (pst_u8GDCP11GBR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCP11GBRHL(ctrlr) (pst_u8GDCP11GBR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCP11GBRHH(ctrlr,ParValue) (pst_u8GDCP11GBR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCP11GBRHH(ctrlr) (pst_u8GDCP11GBR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCP11GBRL(ctrlr,ParValue) (pst_u16GDCP11GBR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCP11GBRL(ctrlr) (pst_u16GDCP11GBR(ctrlr) -> u16L)
N#define vSetGDCP11GBRH(ctrlr,ParValue) (pst_u16GDCP11GBR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCP11GBRH(ctrlr) (pst_u16GDCP11GBR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCP11GBR(ctrlr,ParValue)  (*pu32GDCP11GBR(ctrlr) = (ParValue))
N#define u32GetGDCP11GBR(ctrlr)  (*pu32GDCP11GBR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCPSMR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02228                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCPSMR_REG__       0xC0C02228U
N#else
S#define GDCPSMR_REG__ ((uint32_t) GDCPSMR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PSDEL	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   PSDDEL	:4; 	 /* 16..19  bit(s) R/W */ 
N  uint32_t   	:12; 	 /* 20..63  bit(s) R */                    
N} GDCPSMR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCPSMR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCPSMR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCPSMR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCPSMR(ctrlr)     ((volatile GDCPSMR_bit_view_st *)\
S(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCPSMR(ctrlr)     ((volatile GDCPSMR_bit_view_st *)(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCPSMR(ctrlr)     ((volatile GDCPSMR_byte_view_st *)\
S(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCPSMR(ctrlr)     ((volatile GDCPSMR_byte_view_st *)(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCPSMR(ctrlr)     ((volatile GDCPSMR_halfword_view_st *)\
S(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCPSMR(ctrlr)     ((volatile GDCPSMR_halfword_view_st *)(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCPSMR(ctrlr)     ((volatile u32GDCPSMR_word_view *)\
S(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCPSMR(ctrlr)     ((volatile u32GDCPSMR_word_view *)(GDCPSMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCPSMR(ctrlr)     ((volatile GDCPSMR_bit_view_st *) &u32GDCPSMR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCPSMR(ctrlr)     ((volatile GDCPSMR_byte_view_st *) &u32GDCPSMR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCPSMR(ctrlr)     ((volatile GDCPSMR_halfword_view_st *) &u32GDCPSMR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCPSMR(ctrlr)     ((volatile u32GDCPSMR_word_view *) &u32GDCPSMR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCPSMR_PSDEL(ctrlr) (pst_bitGDCPSMR(ctrlr) -> PSDEL)
N#define vSetGDCPSMR_PSDEL(ctrlr,ParValue)  (pst_bitGDCPSMR(ctrlr) -> PSDEL=(ParValue))
N#define biGetGDCPSMR_PSDDEL(ctrlr) (pst_bitGDCPSMR(ctrlr) -> PSDDEL)
N#define vSetGDCPSMR_PSDDEL(ctrlr,ParValue)  (pst_bitGDCPSMR(ctrlr) -> PSDDEL=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCPSMRLL(ctrlr,ParValue) (pst_u8GDCPSMR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCPSMRLL(ctrlr) (pst_u8GDCPSMR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCPSMRLH(ctrlr,ParValue) (pst_u8GDCPSMR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCPSMRLH(ctrlr) (pst_u8GDCPSMR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCPSMRHL(ctrlr,ParValue) (pst_u8GDCPSMR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCPSMRHL(ctrlr) (pst_u8GDCPSMR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCPSMRHH(ctrlr,ParValue) (pst_u8GDCPSMR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCPSMRHH(ctrlr) (pst_u8GDCPSMR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCPSMRL(ctrlr,ParValue) (pst_u16GDCPSMR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCPSMRL(ctrlr) (pst_u16GDCPSMR(ctrlr) -> u16L)
N#define vSetGDCPSMRH(ctrlr,ParValue) (pst_u16GDCPSMR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCPSMRH(ctrlr) (pst_u16GDCPSMR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCPSMR(ctrlr,ParValue)  (*pu32GDCPSMR(ctrlr) = (ParValue))
N#define u32GetGDCPSMR(ctrlr)  (*pu32GDCPSMR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARE0                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02230                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARE0_REG__       0xC0C02230U
N#else
S#define GDCLARE0_REG__ ((uint32_t) GDCLARE0_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARE0_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARE0_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARE0_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARE0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARE0(ctrlr)     ((volatile GDCLARE0_bit_view_st *)\
S(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARE0(ctrlr)     ((volatile GDCLARE0_bit_view_st *)(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARE0(ctrlr)     ((volatile GDCLARE0_byte_view_st *)\
S(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARE0(ctrlr)     ((volatile GDCLARE0_byte_view_st *)(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARE0(ctrlr)     ((volatile GDCLARE0_halfword_view_st *)\
S(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARE0(ctrlr)     ((volatile GDCLARE0_halfword_view_st *)(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARE0(ctrlr)     ((volatile u32GDCLARE0_word_view *)\
S(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARE0(ctrlr)     ((volatile u32GDCLARE0_word_view *)(GDCLARE0_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARE0(ctrlr)     ((volatile GDCLARE0_bit_view_st *) &u32GDCLARE0_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARE0(ctrlr)     ((volatile GDCLARE0_byte_view_st *) &u32GDCLARE0_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARE0(ctrlr)     ((volatile GDCLARE0_halfword_view_st *) &u32GDCLARE0_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARE0(ctrlr)     ((volatile u32GDCLARE0_word_view *) &u32GDCLARE0_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARE0_SSCROLL(ctrlr) (pst_bitGDCLARE0(ctrlr) -> SSCROLL)
N#define vSetGDCLARE0_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARE0(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARE0_SAR(ctrlr) (pst_bitGDCLARE0(ctrlr) -> SAR)
N#define vSetGDCLARE0_SAR(ctrlr,ParValue)  (pst_bitGDCLARE0(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARE0LL(ctrlr,ParValue) (pst_u8GDCLARE0(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARE0LL(ctrlr) (pst_u8GDCLARE0(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARE0LH(ctrlr,ParValue) (pst_u8GDCLARE0(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARE0LH(ctrlr) (pst_u8GDCLARE0(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARE0HL(ctrlr,ParValue) (pst_u8GDCLARE0(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARE0HL(ctrlr) (pst_u8GDCLARE0(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARE0HH(ctrlr,ParValue) (pst_u8GDCLARE0(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARE0HH(ctrlr) (pst_u8GDCLARE0(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARE0L(ctrlr,ParValue) (pst_u16GDCLARE0(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARE0L(ctrlr) (pst_u16GDCLARE0(ctrlr) -> u16L)
N#define vSetGDCLARE0H(ctrlr,ParValue) (pst_u16GDCLARE0(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARE0H(ctrlr) (pst_u16GDCLARE0(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARE0(ctrlr,ParValue)  (*pu32GDCLARE0(ctrlr) = (ParValue))
N#define u32GetGDCLARE0(ctrlr)  (*pu32GDCLARE0(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCLARE1                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02238                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCLARE1_REG__       0xC0C02238U
N#else
S#define GDCLARE1_REG__ ((uint32_t) GDCLARE1_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   SSCROLL	:2; 	 /* 1..2  bit(s) R/W */
N  uint32_t   SAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCLARE1_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCLARE1_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCLARE1_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCLARE1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCLARE1(ctrlr)     ((volatile GDCLARE1_bit_view_st *)\
S(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCLARE1(ctrlr)     ((volatile GDCLARE1_bit_view_st *)(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCLARE1(ctrlr)     ((volatile GDCLARE1_byte_view_st *)\
S(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCLARE1(ctrlr)     ((volatile GDCLARE1_byte_view_st *)(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCLARE1(ctrlr)     ((volatile GDCLARE1_halfword_view_st *)\
S(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCLARE1(ctrlr)     ((volatile GDCLARE1_halfword_view_st *)(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCLARE1(ctrlr)     ((volatile u32GDCLARE1_word_view *)\
S(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCLARE1(ctrlr)     ((volatile u32GDCLARE1_word_view *)(GDCLARE1_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCLARE1(ctrlr)     ((volatile GDCLARE1_bit_view_st *) &u32GDCLARE1_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCLARE1(ctrlr)     ((volatile GDCLARE1_byte_view_st *) &u32GDCLARE1_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCLARE1(ctrlr)     ((volatile GDCLARE1_halfword_view_st *) &u32GDCLARE1_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCLARE1(ctrlr)     ((volatile u32GDCLARE1_word_view *) &u32GDCLARE1_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCLARE1_SSCROLL(ctrlr) (pst_bitGDCLARE1(ctrlr) -> SSCROLL)
N#define vSetGDCLARE1_SSCROLL(ctrlr,ParValue)  (pst_bitGDCLARE1(ctrlr) -> SSCROLL=(ParValue))
N#define biGetGDCLARE1_SAR(ctrlr) (pst_bitGDCLARE1(ctrlr) -> SAR)
N#define vSetGDCLARE1_SAR(ctrlr,ParValue)  (pst_bitGDCLARE1(ctrlr) -> SAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCLARE1LL(ctrlr,ParValue) (pst_u8GDCLARE1(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCLARE1LL(ctrlr) (pst_u8GDCLARE1(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCLARE1LH(ctrlr,ParValue) (pst_u8GDCLARE1(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCLARE1LH(ctrlr) (pst_u8GDCLARE1(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCLARE1HL(ctrlr,ParValue) (pst_u8GDCLARE1(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCLARE1HL(ctrlr) (pst_u8GDCLARE1(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCLARE1HH(ctrlr,ParValue) (pst_u8GDCLARE1(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCLARE1HH(ctrlr) (pst_u8GDCLARE1(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCLARE1L(ctrlr,ParValue) (pst_u16GDCLARE1(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCLARE1L(ctrlr) (pst_u16GDCLARE1(ctrlr) -> u16L)
N#define vSetGDCLARE1H(ctrlr,ParValue) (pst_u16GDCLARE1(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCLARE1H(ctrlr) (pst_u16GDCLARE1(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCLARE1(ctrlr,ParValue)  (*pu32GDCLARE1(ctrlr) = (ParValue))
N#define u32GetGDCLARE1(ctrlr)  (*pu32GDCLARE1(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWARC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02240                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWARC_REG__       0xC0C02240U
N#else
S#define GDCWARC_REG__ ((uint32_t) GDCWARC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   WAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCWARC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWARC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWARC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWARC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWARC(ctrlr)     ((volatile GDCWARC_bit_view_st *)\
S(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWARC(ctrlr)     ((volatile GDCWARC_bit_view_st *)(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWARC(ctrlr)     ((volatile GDCWARC_byte_view_st *)\
S(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWARC(ctrlr)     ((volatile GDCWARC_byte_view_st *)(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWARC(ctrlr)     ((volatile GDCWARC_halfword_view_st *)\
S(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWARC(ctrlr)     ((volatile GDCWARC_halfword_view_st *)(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWARC(ctrlr)     ((volatile u32GDCWARC_word_view *)\
S(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWARC(ctrlr)     ((volatile u32GDCWARC_word_view *)(GDCWARC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWARC(ctrlr)     ((volatile GDCWARC_bit_view_st *) &u32GDCWARC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWARC(ctrlr)     ((volatile GDCWARC_byte_view_st *) &u32GDCWARC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWARC(ctrlr)     ((volatile GDCWARC_halfword_view_st *) &u32GDCWARC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWARC(ctrlr)     ((volatile u32GDCWARC_word_view *) &u32GDCWARC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWARC_WAR(ctrlr) (pst_bitGDCWARC(ctrlr) -> WAR)
N#define vSetGDCWARC_WAR(ctrlr,ParValue)  (pst_bitGDCWARC(ctrlr) -> WAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWARCLL(ctrlr,ParValue) (pst_u8GDCWARC(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWARCLL(ctrlr) (pst_u8GDCWARC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWARCLH(ctrlr,ParValue) (pst_u8GDCWARC(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWARCLH(ctrlr) (pst_u8GDCWARC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWARCHL(ctrlr,ParValue) (pst_u8GDCWARC(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWARCHL(ctrlr) (pst_u8GDCWARC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWARCHH(ctrlr,ParValue) (pst_u8GDCWARC(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWARCHH(ctrlr) (pst_u8GDCWARC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWARCL(ctrlr,ParValue) (pst_u16GDCWARC(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWARCL(ctrlr) (pst_u16GDCWARC(ctrlr) -> u16L)
N#define vSetGDCWARCH(ctrlr,ParValue) (pst_u16GDCWARC(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWARCH(ctrlr) (pst_u16GDCWARC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWARC(ctrlr,ParValue)  (*pu32GDCWARC(ctrlr) = (ParValue))
N#define u32GetGDCWARC(ctrlr)  (*pu32GDCWARC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWARD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02248                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWARD_REG__       0xC0C02248U
N#else
S#define GDCWARD_REG__ ((uint32_t) GDCWARD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   WAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCWARD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWARD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWARD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWARD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWARD(ctrlr)     ((volatile GDCWARD_bit_view_st *)\
S(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWARD(ctrlr)     ((volatile GDCWARD_bit_view_st *)(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWARD(ctrlr)     ((volatile GDCWARD_byte_view_st *)\
S(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWARD(ctrlr)     ((volatile GDCWARD_byte_view_st *)(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWARD(ctrlr)     ((volatile GDCWARD_halfword_view_st *)\
S(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWARD(ctrlr)     ((volatile GDCWARD_halfword_view_st *)(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWARD(ctrlr)     ((volatile u32GDCWARD_word_view *)\
S(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWARD(ctrlr)     ((volatile u32GDCWARD_word_view *)(GDCWARD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWARD(ctrlr)     ((volatile GDCWARD_bit_view_st *) &u32GDCWARD_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWARD(ctrlr)     ((volatile GDCWARD_byte_view_st *) &u32GDCWARD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWARD(ctrlr)     ((volatile GDCWARD_halfword_view_st *) &u32GDCWARD_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWARD(ctrlr)     ((volatile u32GDCWARD_word_view *) &u32GDCWARD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWARD_WAR(ctrlr) (pst_bitGDCWARD(ctrlr) -> WAR)
N#define vSetGDCWARD_WAR(ctrlr,ParValue)  (pst_bitGDCWARD(ctrlr) -> WAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWARDLL(ctrlr,ParValue) (pst_u8GDCWARD(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWARDLL(ctrlr) (pst_u8GDCWARD(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWARDLH(ctrlr,ParValue) (pst_u8GDCWARD(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWARDLH(ctrlr) (pst_u8GDCWARD(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWARDHL(ctrlr,ParValue) (pst_u8GDCWARD(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWARDHL(ctrlr) (pst_u8GDCWARD(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWARDHH(ctrlr,ParValue) (pst_u8GDCWARD(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWARDHH(ctrlr) (pst_u8GDCWARD(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWARDL(ctrlr,ParValue) (pst_u16GDCWARD(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWARDL(ctrlr) (pst_u16GDCWARD(ctrlr) -> u16L)
N#define vSetGDCWARDH(ctrlr,ParValue) (pst_u16GDCWARD(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWARDH(ctrlr) (pst_u16GDCWARD(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWARD(ctrlr,ParValue)  (*pu32GDCWARD(ctrlr) = (ParValue))
N#define u32GetGDCWARD(ctrlr)  (*pu32GDCWARD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWARE                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02250                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWARE_REG__       0xC0C02250U
N#else
S#define GDCWARE_REG__ ((uint32_t) GDCWARE_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   WAR	:29; 	 /* 3..31  bit(s) R/W */                    
N} GDCWARE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWARE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWARE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWARE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWARE(ctrlr)     ((volatile GDCWARE_bit_view_st *)\
S(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWARE(ctrlr)     ((volatile GDCWARE_bit_view_st *)(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWARE(ctrlr)     ((volatile GDCWARE_byte_view_st *)\
S(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWARE(ctrlr)     ((volatile GDCWARE_byte_view_st *)(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWARE(ctrlr)     ((volatile GDCWARE_halfword_view_st *)\
S(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWARE(ctrlr)     ((volatile GDCWARE_halfword_view_st *)(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWARE(ctrlr)     ((volatile u32GDCWARE_word_view *)\
S(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWARE(ctrlr)     ((volatile u32GDCWARE_word_view *)(GDCWARE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWARE(ctrlr)     ((volatile GDCWARE_bit_view_st *) &u32GDCWARE_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWARE(ctrlr)     ((volatile GDCWARE_byte_view_st *) &u32GDCWARE_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWARE(ctrlr)     ((volatile GDCWARE_halfword_view_st *) &u32GDCWARE_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWARE(ctrlr)     ((volatile u32GDCWARE_word_view *) &u32GDCWARE_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWARE_WAR(ctrlr) (pst_bitGDCWARE(ctrlr) -> WAR)
N#define vSetGDCWARE_WAR(ctrlr,ParValue)  (pst_bitGDCWARE(ctrlr) -> WAR=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWARELL(ctrlr,ParValue) (pst_u8GDCWARE(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWARELL(ctrlr) (pst_u8GDCWARE(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWARELH(ctrlr,ParValue) (pst_u8GDCWARE(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWARELH(ctrlr) (pst_u8GDCWARE(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWAREHL(ctrlr,ParValue) (pst_u8GDCWARE(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWAREHL(ctrlr) (pst_u8GDCWARE(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWAREHH(ctrlr,ParValue) (pst_u8GDCWARE(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWAREHH(ctrlr) (pst_u8GDCWARE(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWAREL(ctrlr,ParValue) (pst_u16GDCWARE(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWAREL(ctrlr) (pst_u16GDCWARE(ctrlr) -> u16L)
N#define vSetGDCWAREH(ctrlr,ParValue) (pst_u16GDCWARE(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWAREH(ctrlr) (pst_u16GDCWARE(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWARE(ctrlr,ParValue)  (*pu32GDCWARE(ctrlr) = (ParValue))
N#define u32GetGDCWARE(ctrlr)  (*pu32GDCWARE(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWSRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02258                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWSRC_REG__       0xC0C02258U
N#else
S#define GDCWSRC_REG__ ((uint32_t) GDCWSRC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WVDS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   WHDS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCWSRC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWSRC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWSRC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWSRC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWSRC(ctrlr)     ((volatile GDCWSRC_bit_view_st *)\
S(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWSRC(ctrlr)     ((volatile GDCWSRC_bit_view_st *)(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWSRC(ctrlr)     ((volatile GDCWSRC_byte_view_st *)\
S(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWSRC(ctrlr)     ((volatile GDCWSRC_byte_view_st *)(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWSRC(ctrlr)     ((volatile GDCWSRC_halfword_view_st *)\
S(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWSRC(ctrlr)     ((volatile GDCWSRC_halfword_view_st *)(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWSRC(ctrlr)     ((volatile u32GDCWSRC_word_view *)\
S(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWSRC(ctrlr)     ((volatile u32GDCWSRC_word_view *)(GDCWSRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWSRC(ctrlr)     ((volatile GDCWSRC_bit_view_st *) &u32GDCWSRC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWSRC(ctrlr)     ((volatile GDCWSRC_byte_view_st *) &u32GDCWSRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWSRC(ctrlr)     ((volatile GDCWSRC_halfword_view_st *) &u32GDCWSRC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWSRC(ctrlr)     ((volatile u32GDCWSRC_word_view *) &u32GDCWSRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWSRC_WVDS(ctrlr) (pst_bitGDCWSRC(ctrlr) -> WVDS)
N#define vSetGDCWSRC_WVDS(ctrlr,ParValue)  (pst_bitGDCWSRC(ctrlr) -> WVDS=(ParValue))
N#define biGetGDCWSRC_WHDS(ctrlr) (pst_bitGDCWSRC(ctrlr) -> WHDS)
N#define vSetGDCWSRC_WHDS(ctrlr,ParValue)  (pst_bitGDCWSRC(ctrlr) -> WHDS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWSRCLL(ctrlr,ParValue) (pst_u8GDCWSRC(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWSRCLL(ctrlr) (pst_u8GDCWSRC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWSRCLH(ctrlr,ParValue) (pst_u8GDCWSRC(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWSRCLH(ctrlr) (pst_u8GDCWSRC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWSRCHL(ctrlr,ParValue) (pst_u8GDCWSRC(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWSRCHL(ctrlr) (pst_u8GDCWSRC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWSRCHH(ctrlr,ParValue) (pst_u8GDCWSRC(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWSRCHH(ctrlr) (pst_u8GDCWSRC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWSRCL(ctrlr,ParValue) (pst_u16GDCWSRC(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWSRCL(ctrlr) (pst_u16GDCWSRC(ctrlr) -> u16L)
N#define vSetGDCWSRCH(ctrlr,ParValue) (pst_u16GDCWSRC(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWSRCH(ctrlr) (pst_u16GDCWSRC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWSRC(ctrlr,ParValue)  (*pu32GDCWSRC(ctrlr) = (ParValue))
N#define u32GetGDCWSRC(ctrlr)  (*pu32GDCWSRC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWSRD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02260                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWSRD_REG__       0xC0C02260U
N#else
S#define GDCWSRD_REG__ ((uint32_t) GDCWSRD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WVDS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   WHDS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCWSRD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWSRD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWSRD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWSRD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWSRD(ctrlr)     ((volatile GDCWSRD_bit_view_st *)\
S(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWSRD(ctrlr)     ((volatile GDCWSRD_bit_view_st *)(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWSRD(ctrlr)     ((volatile GDCWSRD_byte_view_st *)\
S(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWSRD(ctrlr)     ((volatile GDCWSRD_byte_view_st *)(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWSRD(ctrlr)     ((volatile GDCWSRD_halfword_view_st *)\
S(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWSRD(ctrlr)     ((volatile GDCWSRD_halfword_view_st *)(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWSRD(ctrlr)     ((volatile u32GDCWSRD_word_view *)\
S(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWSRD(ctrlr)     ((volatile u32GDCWSRD_word_view *)(GDCWSRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWSRD(ctrlr)     ((volatile GDCWSRD_bit_view_st *) &u32GDCWSRD_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWSRD(ctrlr)     ((volatile GDCWSRD_byte_view_st *) &u32GDCWSRD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWSRD(ctrlr)     ((volatile GDCWSRD_halfword_view_st *) &u32GDCWSRD_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWSRD(ctrlr)     ((volatile u32GDCWSRD_word_view *) &u32GDCWSRD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWSRD_WVDS(ctrlr) (pst_bitGDCWSRD(ctrlr) -> WVDS)
N#define vSetGDCWSRD_WVDS(ctrlr,ParValue)  (pst_bitGDCWSRD(ctrlr) -> WVDS=(ParValue))
N#define biGetGDCWSRD_WHDS(ctrlr) (pst_bitGDCWSRD(ctrlr) -> WHDS)
N#define vSetGDCWSRD_WHDS(ctrlr,ParValue)  (pst_bitGDCWSRD(ctrlr) -> WHDS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWSRDLL(ctrlr,ParValue) (pst_u8GDCWSRD(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWSRDLL(ctrlr) (pst_u8GDCWSRD(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWSRDLH(ctrlr,ParValue) (pst_u8GDCWSRD(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWSRDLH(ctrlr) (pst_u8GDCWSRD(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWSRDHL(ctrlr,ParValue) (pst_u8GDCWSRD(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWSRDHL(ctrlr) (pst_u8GDCWSRD(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWSRDHH(ctrlr,ParValue) (pst_u8GDCWSRD(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWSRDHH(ctrlr) (pst_u8GDCWSRD(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWSRDL(ctrlr,ParValue) (pst_u16GDCWSRD(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWSRDL(ctrlr) (pst_u16GDCWSRD(ctrlr) -> u16L)
N#define vSetGDCWSRDH(ctrlr,ParValue) (pst_u16GDCWSRD(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWSRDH(ctrlr) (pst_u16GDCWSRD(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWSRD(ctrlr,ParValue)  (*pu32GDCWSRD(ctrlr) = (ParValue))
N#define u32GetGDCWSRD(ctrlr)  (*pu32GDCWSRD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWSRE                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02268                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWSRE_REG__       0xC0C02268U
N#else
S#define GDCWSRE_REG__ ((uint32_t) GDCWSRE_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WVDS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   WHDS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCWSRE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWSRE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWSRE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWSRE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWSRE(ctrlr)     ((volatile GDCWSRE_bit_view_st *)\
S(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWSRE(ctrlr)     ((volatile GDCWSRE_bit_view_st *)(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWSRE(ctrlr)     ((volatile GDCWSRE_byte_view_st *)\
S(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWSRE(ctrlr)     ((volatile GDCWSRE_byte_view_st *)(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWSRE(ctrlr)     ((volatile GDCWSRE_halfword_view_st *)\
S(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWSRE(ctrlr)     ((volatile GDCWSRE_halfword_view_st *)(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWSRE(ctrlr)     ((volatile u32GDCWSRE_word_view *)\
S(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWSRE(ctrlr)     ((volatile u32GDCWSRE_word_view *)(GDCWSRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWSRE(ctrlr)     ((volatile GDCWSRE_bit_view_st *) &u32GDCWSRE_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWSRE(ctrlr)     ((volatile GDCWSRE_byte_view_st *) &u32GDCWSRE_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWSRE(ctrlr)     ((volatile GDCWSRE_halfword_view_st *) &u32GDCWSRE_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWSRE(ctrlr)     ((volatile u32GDCWSRE_word_view *) &u32GDCWSRE_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWSRE_WVDS(ctrlr) (pst_bitGDCWSRE(ctrlr) -> WVDS)
N#define vSetGDCWSRE_WVDS(ctrlr,ParValue)  (pst_bitGDCWSRE(ctrlr) -> WVDS=(ParValue))
N#define biGetGDCWSRE_WHDS(ctrlr) (pst_bitGDCWSRE(ctrlr) -> WHDS)
N#define vSetGDCWSRE_WHDS(ctrlr,ParValue)  (pst_bitGDCWSRE(ctrlr) -> WHDS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWSRELL(ctrlr,ParValue) (pst_u8GDCWSRE(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWSRELL(ctrlr) (pst_u8GDCWSRE(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWSRELH(ctrlr,ParValue) (pst_u8GDCWSRE(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWSRELH(ctrlr) (pst_u8GDCWSRE(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWSREHL(ctrlr,ParValue) (pst_u8GDCWSRE(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWSREHL(ctrlr) (pst_u8GDCWSRE(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWSREHH(ctrlr,ParValue) (pst_u8GDCWSRE(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWSREHH(ctrlr) (pst_u8GDCWSRE(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWSREL(ctrlr,ParValue) (pst_u16GDCWSRE(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWSREL(ctrlr) (pst_u16GDCWSRE(ctrlr) -> u16L)
N#define vSetGDCWSREH(ctrlr,ParValue) (pst_u16GDCWSRE(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWSREH(ctrlr) (pst_u16GDCWSRE(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWSRE(ctrlr,ParValue)  (*pu32GDCWSRE(ctrlr) = (ParValue))
N#define u32GetGDCWSRE(ctrlr)  (*pu32GDCWSRE(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWIMRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02270                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWIMRC_REG__       0xC0C02270U
N#else
S#define GDCWIMRC_REG__ ((uint32_t) GDCWIMRC_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   WWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCWIMRC_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWIMRC_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWIMRC_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWIMRC_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWIMRC(ctrlr)     ((volatile GDCWIMRC_bit_view_st *)\
S(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWIMRC(ctrlr)     ((volatile GDCWIMRC_bit_view_st *)(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWIMRC(ctrlr)     ((volatile GDCWIMRC_byte_view_st *)\
S(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWIMRC(ctrlr)     ((volatile GDCWIMRC_byte_view_st *)(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWIMRC(ctrlr)     ((volatile GDCWIMRC_halfword_view_st *)\
S(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWIMRC(ctrlr)     ((volatile GDCWIMRC_halfword_view_st *)(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWIMRC(ctrlr)     ((volatile u32GDCWIMRC_word_view *)\
S(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWIMRC(ctrlr)     ((volatile u32GDCWIMRC_word_view *)(GDCWIMRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWIMRC(ctrlr)     ((volatile GDCWIMRC_bit_view_st *) &u32GDCWIMRC_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWIMRC(ctrlr)     ((volatile GDCWIMRC_byte_view_st *) &u32GDCWIMRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWIMRC(ctrlr)     ((volatile GDCWIMRC_halfword_view_st *) &u32GDCWIMRC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWIMRC(ctrlr)     ((volatile u32GDCWIMRC_word_view *) &u32GDCWIMRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWIMRC_WHEIGHT(ctrlr) (pst_bitGDCWIMRC(ctrlr) -> WHEIGHT)
N#define vSetGDCWIMRC_WHEIGHT(ctrlr,ParValue)  (pst_bitGDCWIMRC(ctrlr) -> WHEIGHT=(ParValue))
N#define biGetGDCWIMRC_WWIDTH(ctrlr) (pst_bitGDCWIMRC(ctrlr) -> WWIDTH)
N#define vSetGDCWIMRC_WWIDTH(ctrlr,ParValue)  (pst_bitGDCWIMRC(ctrlr) -> WWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWIMRCLL(ctrlr,ParValue) (pst_u8GDCWIMRC(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWIMRCLL(ctrlr) (pst_u8GDCWIMRC(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWIMRCLH(ctrlr,ParValue) (pst_u8GDCWIMRC(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWIMRCLH(ctrlr) (pst_u8GDCWIMRC(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWIMRCHL(ctrlr,ParValue) (pst_u8GDCWIMRC(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWIMRCHL(ctrlr) (pst_u8GDCWIMRC(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWIMRCHH(ctrlr,ParValue) (pst_u8GDCWIMRC(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWIMRCHH(ctrlr) (pst_u8GDCWIMRC(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWIMRCL(ctrlr,ParValue) (pst_u16GDCWIMRC(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWIMRCL(ctrlr) (pst_u16GDCWIMRC(ctrlr) -> u16L)
N#define vSetGDCWIMRCH(ctrlr,ParValue) (pst_u16GDCWIMRC(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWIMRCH(ctrlr) (pst_u16GDCWIMRC(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWIMRC(ctrlr,ParValue)  (*pu32GDCWIMRC(ctrlr) = (ParValue))
N#define u32GetGDCWIMRC(ctrlr)  (*pu32GDCWIMRC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWIMRD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02278                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWIMRD_REG__       0xC0C02278U
N#else
S#define GDCWIMRD_REG__ ((uint32_t) GDCWIMRD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   WWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCWIMRD_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWIMRD_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWIMRD_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWIMRD_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWIMRD(ctrlr)     ((volatile GDCWIMRD_bit_view_st *)\
S(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWIMRD(ctrlr)     ((volatile GDCWIMRD_bit_view_st *)(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWIMRD(ctrlr)     ((volatile GDCWIMRD_byte_view_st *)\
S(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWIMRD(ctrlr)     ((volatile GDCWIMRD_byte_view_st *)(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWIMRD(ctrlr)     ((volatile GDCWIMRD_halfword_view_st *)\
S(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWIMRD(ctrlr)     ((volatile GDCWIMRD_halfword_view_st *)(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWIMRD(ctrlr)     ((volatile u32GDCWIMRD_word_view *)\
S(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWIMRD(ctrlr)     ((volatile u32GDCWIMRD_word_view *)(GDCWIMRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWIMRD(ctrlr)     ((volatile GDCWIMRD_bit_view_st *) &u32GDCWIMRD_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWIMRD(ctrlr)     ((volatile GDCWIMRD_byte_view_st *) &u32GDCWIMRD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWIMRD(ctrlr)     ((volatile GDCWIMRD_halfword_view_st *) &u32GDCWIMRD_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWIMRD(ctrlr)     ((volatile u32GDCWIMRD_word_view *) &u32GDCWIMRD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWIMRD_WHEIGHT(ctrlr) (pst_bitGDCWIMRD(ctrlr) -> WHEIGHT)
N#define vSetGDCWIMRD_WHEIGHT(ctrlr,ParValue)  (pst_bitGDCWIMRD(ctrlr) -> WHEIGHT=(ParValue))
N#define biGetGDCWIMRD_WWIDTH(ctrlr) (pst_bitGDCWIMRD(ctrlr) -> WWIDTH)
N#define vSetGDCWIMRD_WWIDTH(ctrlr,ParValue)  (pst_bitGDCWIMRD(ctrlr) -> WWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWIMRDLL(ctrlr,ParValue) (pst_u8GDCWIMRD(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWIMRDLL(ctrlr) (pst_u8GDCWIMRD(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWIMRDLH(ctrlr,ParValue) (pst_u8GDCWIMRD(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWIMRDLH(ctrlr) (pst_u8GDCWIMRD(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWIMRDHL(ctrlr,ParValue) (pst_u8GDCWIMRD(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWIMRDHL(ctrlr) (pst_u8GDCWIMRD(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWIMRDHH(ctrlr,ParValue) (pst_u8GDCWIMRD(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWIMRDHH(ctrlr) (pst_u8GDCWIMRD(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWIMRDL(ctrlr,ParValue) (pst_u16GDCWIMRD(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWIMRDL(ctrlr) (pst_u16GDCWIMRD(ctrlr) -> u16L)
N#define vSetGDCWIMRDH(ctrlr,ParValue) (pst_u16GDCWIMRD(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWIMRDH(ctrlr) (pst_u16GDCWIMRD(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWIMRD(ctrlr,ParValue)  (*pu32GDCWIMRD(ctrlr) = (ParValue))
N#define u32GetGDCWIMRD(ctrlr)  (*pu32GDCWIMRD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCWIMRE                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02280                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCWIMRE_REG__       0xC0C02280U
N#else
S#define GDCWIMRE_REG__ ((uint32_t) GDCWIMRE_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   WWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCWIMRE_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCWIMRE_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCWIMRE_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCWIMRE_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCWIMRE(ctrlr)     ((volatile GDCWIMRE_bit_view_st *)\
S(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCWIMRE(ctrlr)     ((volatile GDCWIMRE_bit_view_st *)(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCWIMRE(ctrlr)     ((volatile GDCWIMRE_byte_view_st *)\
S(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCWIMRE(ctrlr)     ((volatile GDCWIMRE_byte_view_st *)(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCWIMRE(ctrlr)     ((volatile GDCWIMRE_halfword_view_st *)\
S(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCWIMRE(ctrlr)     ((volatile GDCWIMRE_halfword_view_st *)(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCWIMRE(ctrlr)     ((volatile u32GDCWIMRE_word_view *)\
S(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCWIMRE(ctrlr)     ((volatile u32GDCWIMRE_word_view *)(GDCWIMRE_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCWIMRE(ctrlr)     ((volatile GDCWIMRE_bit_view_st *) &u32GDCWIMRE_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCWIMRE(ctrlr)     ((volatile GDCWIMRE_byte_view_st *) &u32GDCWIMRE_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCWIMRE(ctrlr)     ((volatile GDCWIMRE_halfword_view_st *) &u32GDCWIMRE_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCWIMRE(ctrlr)     ((volatile u32GDCWIMRE_word_view *) &u32GDCWIMRE_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCWIMRE_WHEIGHT(ctrlr) (pst_bitGDCWIMRE(ctrlr) -> WHEIGHT)
N#define vSetGDCWIMRE_WHEIGHT(ctrlr,ParValue)  (pst_bitGDCWIMRE(ctrlr) -> WHEIGHT=(ParValue))
N#define biGetGDCWIMRE_WWIDTH(ctrlr) (pst_bitGDCWIMRE(ctrlr) -> WWIDTH)
N#define vSetGDCWIMRE_WWIDTH(ctrlr,ParValue)  (pst_bitGDCWIMRE(ctrlr) -> WWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCWIMRELL(ctrlr,ParValue) (pst_u8GDCWIMRE(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCWIMRELL(ctrlr) (pst_u8GDCWIMRE(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCWIMRELH(ctrlr,ParValue) (pst_u8GDCWIMRE(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCWIMRELH(ctrlr) (pst_u8GDCWIMRE(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCWIMREHL(ctrlr,ParValue) (pst_u8GDCWIMRE(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCWIMREHL(ctrlr) (pst_u8GDCWIMRE(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCWIMREHH(ctrlr,ParValue) (pst_u8GDCWIMRE(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCWIMREHH(ctrlr) (pst_u8GDCWIMRE(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCWIMREL(ctrlr,ParValue) (pst_u16GDCWIMRE(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCWIMREL(ctrlr) (pst_u16GDCWIMRE(ctrlr) -> u16L)
N#define vSetGDCWIMREH(ctrlr,ParValue) (pst_u16GDCWIMRE(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCWIMREH(ctrlr) (pst_u16GDCWIMRE(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCWIMRE(ctrlr,ParValue)  (*pu32GDCWIMRE(ctrlr) = (ParValue))
N#define u32GetGDCWIMRE(ctrlr)  (*pu32GDCWIMRE(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCSCVRA                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02288                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCSCVRA_REG__       0xC0C02288U
N#else
S#define GDCSCVRA_REG__ ((uint32_t) GDCSCVRA_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   CCV0	:24; 	 /* 0..23  bit(s) R/W */
N  uint64_t   	:7; 	 /* 24..30  bit(s) R */
N  uint64_t   ACT0	:1; 	 /* 31..31  bit(s) R/W */
N  uint64_t   CCV1	:24; 	 /* 32..55  bit(s) R/W */
N  uint64_t   	:7; 	 /* 56..62  bit(s) R */ 
N  uint64_t   ACT1	:1; 	 /* 63..63  bit(s) R/W */                    
N} GDCSCVRA_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCSCVRA_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCSCVRA_word_view_st;
N
N/* LONGWORD View */
Ntypedef uint64_t u64GDCSCVRA_longword_view;                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCSCVRA(ctrlr)     ((volatile GDCSCVRA_bit_view_st *)\
S(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCSCVRA(ctrlr)     ((volatile GDCSCVRA_bit_view_st *)(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCSCVRA(ctrlr)     ((volatile GDCSCVRA_halfword_view_st *)\
S(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCSCVRA(ctrlr)     ((volatile GDCSCVRA_halfword_view_st *)(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32GDCSCVRA(ctrlr)   ((volatile GDCSCVRA_word_view_st *) \
S(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCSCVRA(ctrlr)   ((volatile GDCSCVRA_word_view_st *) (GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
S/* Pointer to LONG_WORD  */
S#define pu64GDCSCVRA(ctrlr)    ((volatile u64GDCSCVRA_longword_view *)\
S(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCSCVRA(ctrlr)    ((volatile u64GDCSCVRA_longword_view *)(GDCSCVRA_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCSCVRA(ctrlr)     ((volatile GDCSCVRA_bit_view_st *) &u64GDCSCVRA_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCSCVRA(ctrlr)     ((volatile GDCSCVRA_halfword_view_st *) &u64GDCSCVRA_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCSCVRA(ctrlr)   ((volatile GDCSCVRA_word_view_st *) &u64GDCSCVRA_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64GDCSCVRA(ctrlr)    ((volatile u64GDCSCVRA_longword_view *) &u64GDCSCVRA_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCSCVRA_CCV0(ctrlr) (pst_bitGDCSCVRA(ctrlr) -> CCV0)
N#define vSetGDCSCVRA_CCV0(ctrlr,ParValue)  (pst_bitGDCSCVRA(ctrlr) -> CCV0=(ParValue))
N#define biGetGDCSCVRA_ACT0(ctrlr) (pst_bitGDCSCVRA(ctrlr) -> ACT0)
N#define vSetGDCSCVRA_ACT0(ctrlr,ParValue)  (pst_bitGDCSCVRA(ctrlr) -> ACT0=(ParValue))
N#define biGetGDCSCVRA_CCV1(ctrlr) (pst_bitGDCSCVRA(ctrlr) -> CCV1)
N#define vSetGDCSCVRA_CCV1(ctrlr,ParValue)  (pst_bitGDCSCVRA(ctrlr) -> CCV1=(ParValue))
N#define biGetGDCSCVRA_ACT1(ctrlr) (pst_bitGDCSCVRA(ctrlr) -> ACT1)
N#define vSetGDCSCVRA_ACT1(ctrlr,ParValue)  (pst_bitGDCSCVRA(ctrlr) -> ACT1=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetGDCSCVRALL(ctrlr,ParValue) (pst_u16GDCSCVRA(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCSCVRALL(ctrlr) (pst_u16GDCSCVRA(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCSCVRALH(ctrlr,ParValue) (pst_u16GDCSCVRA(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCSCVRALH(ctrlr) (pst_u16GDCSCVRA(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCSCVRAHL(ctrlr,ParValue) (pst_u16GDCSCVRA(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCSCVRAHL(ctrlr) (pst_u16GDCSCVRA(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCSCVRAHH(ctrlr,ParValue) (pst_u16GDCSCVRA(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCSCVRAHH(ctrlr) (pst_u16GDCSCVRA(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCSCVRAL(ctrlr,ParValue) (pst_u32GDCSCVRA(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCSCVRAL(ctrlr) (pst_u32GDCSCVRA(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCSCVRAH(ctrlr,ParValue) (pst_u32GDCSCVRA(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCSCVRAH(ctrlr) (pst_u32GDCSCVRA(ctrlr) -> u32H)
N
N/* Long  Word access */ 
N#define vSetGDCSCVRA(ctrlr,ParValue)  (*pu64GDCSCVRA(ctrlr) = (ParValue))
N#define u64GetGDCSCVRA(ctrlr)  (*pu64GDCSCVRA(ctrlr) )
N
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCSCVRB                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02290                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                      
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCSCVRB_REG__       0xC0C02290U
N#else
S#define GDCSCVRB_REG__ ((uint32_t) GDCSCVRB_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   CCV2	:24; 	 /* 0..23  bit(s) R/W */
N  uint64_t   	:7; 	 /* 24..30  bit(s) R */
N  uint64_t   ACT2	:1; 	 /* 31..31  bit(s) R/W */
N  uint64_t   CCV3	:24; 	 /* 32..55  bit(s) R/W */
N  uint64_t   	:7; 	 /* 56..62  bit(s) R */ 
N  uint64_t   ACT3	:1; 	 /* 63..63  bit(s) R/W */                    
N} GDCSCVRB_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCSCVRB_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCSCVRB_word_view_st;
N
N/* LONGWORD View */
Ntypedef uint64_t u64GDCSCVRB_longword_view;
N
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCSCVRB(ctrlr)     ((volatile GDCSCVRB_bit_view_st *)\
S(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCSCVRB(ctrlr)     ((volatile GDCSCVRB_bit_view_st *)(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCSCVRB(ctrlr)     ((volatile GDCSCVRB_halfword_view_st *)\
S(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCSCVRB(ctrlr)     ((volatile GDCSCVRB_halfword_view_st *)(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32GDCSCVRB(ctrlr)   ((volatile GDCSCVRB_word_view_st *) \
S(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCSCVRB(ctrlr)   ((volatile GDCSCVRB_word_view_st *) (GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
S/* Pointer to LONG_WORD  */
S#define pu64GDCSCVRB(ctrlr)    ((volatile u64GDCSCVRB_longword_view *)\
S(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCSCVRB(ctrlr)    ((volatile u64GDCSCVRB_longword_view *)(GDCSCVRB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCSCVRB(ctrlr)     ((volatile GDCSCVRB_bit_view_st *) &u64GDCSCVRB_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCSCVRB(ctrlr)     ((volatile GDCSCVRB_halfword_view_st *) &u64GDCSCVRB_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCSCVRB(ctrlr)   ((volatile GDCSCVRB_word_view_st *) &u64GDCSCVRB_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64GDCSCVRB(ctrlr)    ((volatile u64GDCSCVRB_longword_view *) &u64GDCSCVRB_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCSCVRB_CCV2(ctrlr) (pst_bitGDCSCVRB(ctrlr) -> CCV2)
N#define vSetGDCSCVRB_CCV2(ctrlr,ParValue)  (pst_bitGDCSCVRB(ctrlr) -> CCV2=(ParValue))
N#define biGetGDCSCVRB_ACT2(ctrlr) (pst_bitGDCSCVRB(ctrlr) -> ACT2)
N#define vSetGDCSCVRB_ACT2(ctrlr,ParValue)  (pst_bitGDCSCVRB(ctrlr) -> ACT2=(ParValue))
N#define biGetGDCSCVRB_CCV3(ctrlr) (pst_bitGDCSCVRB(ctrlr) -> CCV3)
N#define vSetGDCSCVRB_CCV3(ctrlr,ParValue)  (pst_bitGDCSCVRB(ctrlr) -> CCV3=(ParValue))
N#define biGetGDCSCVRB_ACT3(ctrlr) (pst_bitGDCSCVRB(ctrlr) -> ACT3)
N#define vSetGDCSCVRB_ACT3(ctrlr,ParValue)  (pst_bitGDCSCVRB(ctrlr) -> ACT3=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetGDCSCVRBLL(ctrlr,ParValue) (pst_u16GDCSCVRB(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCSCVRBLL(ctrlr) (pst_u16GDCSCVRB(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCSCVRBLH(ctrlr,ParValue) (pst_u16GDCSCVRB(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCSCVRBLH(ctrlr) (pst_u16GDCSCVRB(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCSCVRBHL(ctrlr,ParValue) (pst_u16GDCSCVRB(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCSCVRBHL(ctrlr) (pst_u16GDCSCVRB(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCSCVRBHH(ctrlr,ParValue) (pst_u16GDCSCVRB(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCSCVRBHH(ctrlr) (pst_u16GDCSCVRB(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCSCVRBL(ctrlr,ParValue) (pst_u32GDCSCVRB(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCSCVRBL(ctrlr) (pst_u32GDCSCVRB(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCSCVRBH(ctrlr,ParValue) (pst_u32GDCSCVRB(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCSCVRBH(ctrlr) (pst_u32GDCSCVRB(ctrlr) -> u32H)
N
N/* Long  Word access */ 
N#define vSetGDCSCVRB(ctrlr,ParValue)  (*pu64GDCSCVRB(ctrlr) = (ParValue))
N#define u64GetGDCSCVRB(ctrlr)  (*pu64GDCSCVRB(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCSCVRC                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02298                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCSCVRC_REG__       0xC0C02298U
N#else
S#define GDCSCVRC_REG__ ((uint32_t) GDCSCVRC_REG_EMUL)
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   CCV4	:24; 	 /* 0..23  bit(s) R/W */
N  uint64_t   	:7; 	 /* 24..30  bit(s) R */
N  uint64_t   ACT4	:1; 	 /* 31..31  bit(s) R/W */
N  uint64_t   CCV5	:24; 	 /* 32..55  bit(s) R/W */
N  uint64_t   	:7; 	 /* 56..62  bit(s) R */ 
N  uint64_t   ACT5	:1; 	 /* 63..63  bit(s) R/W */                    
N} GDCSCVRC_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCSCVRC_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCSCVRC_word_view_st;
N                 
N/* LONGWORD View */
Ntypedef uint64_t u64GDCSCVRC_longword_view;
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCSCVRC(ctrlr)     ((volatile GDCSCVRC_bit_view_st *)\
S(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCSCVRC(ctrlr)     ((volatile GDCSCVRC_bit_view_st *)(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCSCVRC(ctrlr)     ((volatile GDCSCVRC_halfword_view_st *)\
S(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCSCVRC(ctrlr)     ((volatile GDCSCVRC_halfword_view_st *)(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32GDCSCVRC(ctrlr)   ((volatile GDCSCVRC_word_view_st *) \
S(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCSCVRC(ctrlr)   ((volatile GDCSCVRC_word_view_st *) (GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
S/* Pointer to LONG_WORD  */
S#define pu64GDCSCVRC(ctrlr)    ((volatile u64GDCSCVRC_longword_view *)\
S(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCSCVRC(ctrlr)    ((volatile u64GDCSCVRC_longword_view *)(GDCSCVRC_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCSCVRC(ctrlr)     ((volatile GDCSCVRC_bit_view_st *) &u64GDCSCVRC_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCSCVRC(ctrlr)     ((volatile GDCSCVRC_halfword_view_st *) &u64GDCSCVRC_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCSCVRC(ctrlr)   ((volatile GDCSCVRC_word_view_st *) &u64GDCSCVRC_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64GDCSCVRC(ctrlr)    ((volatile u64GDCSCVRC_longword_view *) &u64GDCSCVRC_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCSCVRC_CCV4(ctrlr) (pst_bitGDCSCVRC(ctrlr) -> CCV4)
N#define vSetGDCSCVRC_CCV4(ctrlr,ParValue)  (pst_bitGDCSCVRC(ctrlr) -> CCV4=(ParValue))
N#define biGetGDCSCVRC_ACT4(ctrlr) (pst_bitGDCSCVRC(ctrlr) -> ACT4)
N#define vSetGDCSCVRC_ACT4(ctrlr,ParValue)  (pst_bitGDCSCVRC(ctrlr) -> ACT4=(ParValue))
N#define biGetGDCSCVRC_CCV5(ctrlr) (pst_bitGDCSCVRC(ctrlr) -> CCV5)
N#define vSetGDCSCVRC_CCV5(ctrlr,ParValue)  (pst_bitGDCSCVRC(ctrlr) -> CCV5=(ParValue))
N#define biGetGDCSCVRC_ACT5(ctrlr) (pst_bitGDCSCVRC(ctrlr) -> ACT5)
N#define vSetGDCSCVRC_ACT5(ctrlr,ParValue)  (pst_bitGDCSCVRC(ctrlr) -> ACT5=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetGDCSCVRCLL(ctrlr,ParValue) (pst_u16GDCSCVRC(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCSCVRCLL(ctrlr) (pst_u16GDCSCVRC(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCSCVRCLH(ctrlr,ParValue) (pst_u16GDCSCVRC(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCSCVRCLH(ctrlr) (pst_u16GDCSCVRC(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCSCVRCHL(ctrlr,ParValue) (pst_u16GDCSCVRC(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCSCVRCHL(ctrlr) (pst_u16GDCSCVRC(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCSCVRCHH(ctrlr,ParValue) (pst_u16GDCSCVRC(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCSCVRCHH(ctrlr) (pst_u16GDCSCVRC(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCSCVRCL(ctrlr,ParValue) (pst_u32GDCSCVRC(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCSCVRCL(ctrlr) (pst_u32GDCSCVRC(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCSCVRCH(ctrlr,ParValue) (pst_u32GDCSCVRC(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCSCVRCH(ctrlr) (pst_u32GDCSCVRC(ctrlr) -> u32H)
N
N/* Long  Word access */ 
N#define vSetGDCSCVRC(ctrlr,ParValue)  (*pu64GDCSCVRC(ctrlr) = (ParValue))
N#define u64GetGDCSCVRC(ctrlr)  (*pu64GDCSCVRC(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCSCVRD                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022A0                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCSCVRD_REG__       0xC0C022A0U
N#else
S#define GDCSCVRD_REG__ ((uint32_t) GDCSCVRD_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   CCV6	:24; 	 /* 0..23  bit(s) R/W */
N  uint64_t   	:7; 	 /* 24..30  bit(s) R */
N  uint64_t   ACT6	:1; 	 /* 31..31  bit(s) R/W */
N  uint64_t   CCV7	:24; 	 /* 32..55  bit(s) R/W */
N  uint64_t   	:7; 	 /* 56..62  bit(s) R */ 
N  uint64_t   ACT7	:1; 	 /* 63..63  bit(s) R/W */                    
N} GDCSCVRD_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} GDCSCVRD_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} GDCSCVRD_word_view_st;
N
N/* LONGWORD View */
Ntypedef uint64_t u64GDCSCVRD_longword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCSCVRD(ctrlr)     ((volatile GDCSCVRD_bit_view_st *)\
S(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCSCVRD(ctrlr)     ((volatile GDCSCVRD_bit_view_st *)(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCSCVRD(ctrlr)     ((volatile GDCSCVRD_halfword_view_st *)\
S(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCSCVRD(ctrlr)     ((volatile GDCSCVRD_halfword_view_st *)(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32GDCSCVRD(ctrlr)   ((volatile GDCSCVRD_word_view_st *) \
S(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32GDCSCVRD(ctrlr)   ((volatile GDCSCVRD_word_view_st *) (GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
S/* Pointer to LONG_WORD  */
S#define pu64GDCSCVRD(ctrlr)    ((volatile u64GDCSCVRD_longword_view *)\
S(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64GDCSCVRD(ctrlr)    ((volatile u64GDCSCVRD_longword_view *)(GDCSCVRD_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCSCVRD(ctrlr)     ((volatile GDCSCVRD_bit_view_st *) &u64GDCSCVRD_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCSCVRD(ctrlr)     ((volatile GDCSCVRD_halfword_view_st *) &u64GDCSCVRD_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32GDCSCVRD(ctrlr)   ((volatile GDCSCVRD_word_view_st *)  &u64GDCSCVRD_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64GDCSCVRD(ctrlr)    ((volatile u64GDCSCVRD_longword_view *) &u64GDCSCVRD_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCSCVRD_CCV6(ctrlr) (pst_bitGDCSCVRD(ctrlr) -> CCV6)
N#define vSetGDCSCVRD_CCV6(ctrlr,ParValue)  (pst_bitGDCSCVRD(ctrlr) -> CCV6=(ParValue))
N#define biGetGDCSCVRD_ACT6(ctrlr) (pst_bitGDCSCVRD(ctrlr) -> ACT6)
N#define vSetGDCSCVRD_ACT6(ctrlr,ParValue)  (pst_bitGDCSCVRD(ctrlr) -> ACT6=(ParValue))
N#define biGetGDCSCVRD_CCV7(ctrlr) (pst_bitGDCSCVRD(ctrlr) -> CCV7)
N#define vSetGDCSCVRD_CCV7(ctrlr,ParValue)  (pst_bitGDCSCVRD(ctrlr) -> CCV7=(ParValue))
N#define biGetGDCSCVRD_ACT7(ctrlr) (pst_bitGDCSCVRD(ctrlr) -> ACT7)
N#define vSetGDCSCVRD_ACT7(ctrlr,ParValue)  (pst_bitGDCSCVRD(ctrlr) -> ACT7=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetGDCSCVRDLL(ctrlr,ParValue) (pst_u16GDCSCVRD(ctrlr) -> u16LL = (ParValue))
N#define u16GetGDCSCVRDLL(ctrlr) (pst_u16GDCSCVRD(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetGDCSCVRDLH(ctrlr,ParValue) (pst_u16GDCSCVRD(ctrlr) -> u16LH = (ParValue))
N#define u16GetGDCSCVRDLH(ctrlr) (pst_u16GDCSCVRD(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetGDCSCVRDHL(ctrlr,ParValue) (pst_u16GDCSCVRD(ctrlr) -> u16HL = (ParValue))
N#define u16GetGDCSCVRDHL(ctrlr) (pst_u16GDCSCVRD(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetGDCSCVRDHH(ctrlr,ParValue) (pst_u16GDCSCVRD(ctrlr) -> u16HH = (ParValue))
N#define u16GetGDCSCVRDHH(ctrlr) (pst_u16GDCSCVRD(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetGDCSCVRDL(ctrlr,ParValue) (pst_u32GDCSCVRD(ctrlr) -> u32L= (ParValue))
N#define u32GetGDCSCVRDL(ctrlr) (pst_u32GDCSCVRD(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetGDCSCVRDH(ctrlr,ParValue) (pst_u32GDCSCVRD(ctrlr) -> u32H = (ParValue))
N#define u32GetGDCSCVRDH(ctrlr) (pst_u32GDCSCVRD(ctrlr) -> u32H)
N
N/* Long  Word access */ 
N#define vSetGDCSCVRD(ctrlr,ParValue)  (*pu64GDCSCVRD(ctrlr) = (ParValue))
N#define u64GetGDCSCVRD(ctrlr)  (*pu64GDCSCVRD(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCGCAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022A8                             
N*       ACCESS  : 8, 16, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCGCAR_REG__       0xC0C022A8U
N#else
S#define GDCGCAR_REG__ ((uint32_t) GDCGCAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint16_t   GCAR	:16; 	 /* 0..15  bit(s) R/C */                    
N} GDCGCAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8L;       
N  uint8_t u8H;       
N} GDCGCAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef uint16_t u16GDCGCAR_halfword_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N/* Pointer to BIT-struct */
N#define pst_bitGDCGCAR(ctrlr)     ((volatile GDCGCAR_bit_view_st *)\
N(GDCGCAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCGCAR(ctrlr)     ((volatile GDCGCAR_bit_view_st *)(GDCGCAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCGCAR(ctrlr)     ((volatile GDCGCAR_byte_view_st *)\
N(GDCGCAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCGCAR(ctrlr)     ((volatile GDCGCAR_byte_view_st *)(GDCGCAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to HALFWORD */
N#define pu16GDCGCAR(ctrlr)     ((volatile u16GDCGCAR_halfword_view *)\
N(GDCGCAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu16GDCGCAR(ctrlr)     ((volatile u16GDCGCAR_halfword_view *)(GDCGCAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCGCAR_GCAR(ctrlr) (pst_bitGDCGCAR(ctrlr) -> GCAR)
N            
N/* L-struct byte access */
N#define u8GetGDCGCARL(ctrlr) (pst_u8GDCGCAR(ctrlr) -> u8L)
N/* H-struct byte access */
N#define u8GetGDCGCARH(ctrlr) (pst_u8GDCGCAR(ctrlr) -> u8H)
N            
N/* Half-word access */ 
N#define u16GetGDCGCAR(ctrlr) (*pu16GDCGCAR(ctrlr) )     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCDSR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022B0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCDSR_REG__       0xC0C022B0U
N#else
S#define GDCDSR_REG__ ((uint32_t) GDCDSR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DVS	:10; 	 /* 0..9  bit(s) R/W */
N  uint32_t   	:6; 	 /* 10..15  bit(s) R */
N  uint32_t   DHS	:11; 	 /* 16..26  bit(s) R/W */ 
N  uint32_t   	:5; 	 /* 27..63  bit(s) R */                    
N} GDCDSR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCDSR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCDSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCDSR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCDSR(ctrlr)     ((volatile GDCDSR_bit_view_st *)\
S(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCDSR(ctrlr)     ((volatile GDCDSR_bit_view_st *)(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCDSR(ctrlr)     ((volatile GDCDSR_byte_view_st *)\
S(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCDSR(ctrlr)     ((volatile GDCDSR_byte_view_st *)(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCDSR(ctrlr)     ((volatile GDCDSR_halfword_view_st *)\
S(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCDSR(ctrlr)     ((volatile GDCDSR_halfword_view_st *)(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCDSR(ctrlr)     ((volatile u32GDCDSR_word_view *)\
S(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCDSR(ctrlr)     ((volatile u32GDCDSR_word_view *)(GDCDSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCDSR(ctrlr)     ((volatile GDCDSR_bit_view_st *) &u32GDCDSR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCDSR(ctrlr)     ((volatile GDCDSR_byte_view_st *) &u32GDCDSR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCDSR(ctrlr)     ((volatile GDCDSR_halfword_view_st *) &u32GDCDSR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCDSR(ctrlr)     ((volatile u32GDCDSR_word_view *) &u32GDCDSR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCDSR_DVS(ctrlr) (pst_bitGDCDSR(ctrlr) -> DVS)
N#define vSetGDCDSR_DVS(ctrlr,ParValue)  (pst_bitGDCDSR(ctrlr) -> DVS=(ParValue))
N#define biGetGDCDSR_DHS(ctrlr) (pst_bitGDCDSR(ctrlr) -> DHS)
N#define vSetGDCDSR_DHS(ctrlr,ParValue)  (pst_bitGDCDSR(ctrlr) -> DHS=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCDSRLL(ctrlr,ParValue) (pst_u8GDCDSR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCDSRLL(ctrlr) (pst_u8GDCDSR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCDSRLH(ctrlr,ParValue) (pst_u8GDCDSR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCDSRLH(ctrlr) (pst_u8GDCDSR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCDSRHL(ctrlr,ParValue) (pst_u8GDCDSR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCDSRHL(ctrlr) (pst_u8GDCDSR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCDSRHH(ctrlr,ParValue) (pst_u8GDCDSR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCDSRHH(ctrlr) (pst_u8GDCDSR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCDSRL(ctrlr,ParValue) (pst_u16GDCDSR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCDSRL(ctrlr) (pst_u16GDCDSR(ctrlr) -> u16L)
N#define vSetGDCDSRH(ctrlr,ParValue) (pst_u16GDCDSR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCDSRH(ctrlr) (pst_u16GDCDSR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCDSR(ctrlr,ParValue)  (*pu32GDCDSR(ctrlr) = (ParValue))
N#define u32GetGDCDSR(ctrlr)  (*pu32GDCDSR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCDIMR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022B8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCDIMR_REG__       0xC0C022B8U
N#else
S#define GDCDIMR_REG__ ((uint32_t) GDCDIMR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DHEIGHT	:11; 	 /* 0..10  bit(s) R/W */
N  uint32_t   	:5; 	 /* 11..15  bit(s) R */
N  uint32_t   DWIDTH	:12; 	 /* 16..27  bit(s) R/W */ 
N  uint32_t   	:4; 	 /* 28..63  bit(s) R */                    
N} GDCDIMR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCDIMR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCDIMR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCDIMR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCDIMR(ctrlr)     ((volatile GDCDIMR_bit_view_st *)\
S(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCDIMR(ctrlr)     ((volatile GDCDIMR_bit_view_st *)(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE-struct  */
S#define pst_u8GDCDIMR(ctrlr)     ((volatile GDCDIMR_byte_view_st *)\
S(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCDIMR(ctrlr)     ((volatile GDCDIMR_byte_view_st *)(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to HALFWORD-struct */
S#define pst_u16GDCDIMR(ctrlr)     ((volatile GDCDIMR_halfword_view_st *)\
S(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCDIMR(ctrlr)     ((volatile GDCDIMR_halfword_view_st *)(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to WORD  */ 
S#define pu32GDCDIMR(ctrlr)     ((volatile u32GDCDIMR_word_view *)\
S(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCDIMR(ctrlr)     ((volatile u32GDCDIMR_word_view *)(GDCDIMR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCDIMR(ctrlr)     ((volatile GDCDIMR_bit_view_st *) &u32GDCDIMR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCDIMR(ctrlr)     ((volatile GDCDIMR_byte_view_st *) &u32GDCDIMR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCDIMR(ctrlr)     ((volatile GDCDIMR_halfword_view_st *) &u32GDCDIMR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD  */ 
N#define pu32GDCDIMR(ctrlr)     ((volatile u32GDCDIMR_word_view *) &u32GDCDIMR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCDIMR_DHEIGHT(ctrlr) (pst_bitGDCDIMR(ctrlr) -> DHEIGHT)
N#define vSetGDCDIMR_DHEIGHT(ctrlr,ParValue)  (pst_bitGDCDIMR(ctrlr) -> DHEIGHT=(ParValue))
N#define biGetGDCDIMR_DWIDTH(ctrlr) (pst_bitGDCDIMR(ctrlr) -> DWIDTH)
N#define vSetGDCDIMR_DWIDTH(ctrlr,ParValue)  (pst_bitGDCDIMR(ctrlr) -> DWIDTH=(ParValue))
N            
N/* LL-struct byte access */
N#define vSetGDCDIMRLL(ctrlr,ParValue) (pst_u8GDCDIMR(ctrlr) -> u8LL = (ParValue))
N#define u8GetGDCDIMRLL(ctrlr) (pst_u8GDCDIMR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define vSetGDCDIMRLH(ctrlr,ParValue) (pst_u8GDCDIMR(ctrlr) -> u8LH = (ParValue))
N#define u8GetGDCDIMRLH(ctrlr) (pst_u8GDCDIMR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define vSetGDCDIMRHL(ctrlr,ParValue) (pst_u8GDCDIMR(ctrlr) -> u8HL = (ParValue))
N#define u8GetGDCDIMRHL(ctrlr) (pst_u8GDCDIMR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define vSetGDCDIMRHH(ctrlr,ParValue) (pst_u8GDCDIMR(ctrlr) -> u8HH = (ParValue))
N#define u8GetGDCDIMRHH(ctrlr) (pst_u8GDCDIMR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define vSetGDCDIMRL(ctrlr,ParValue) (pst_u16GDCDIMR(ctrlr) -> u16L = (ParValue))
N#define u16GetGDCDIMRL(ctrlr) (pst_u16GDCDIMR(ctrlr) -> u16L)
N#define vSetGDCDIMRH(ctrlr,ParValue) (pst_u16GDCDIMR(ctrlr) -> u16H = (ParValue))
N#define u16GetGDCDIMRH(ctrlr) (pst_u16GDCDIMR(ctrlr) -> u16H)
N            
N/* Word access */
N#define vSetGDCDIMR(ctrlr,ParValue)  (*pu32GDCDIMR(ctrlr) = (ParValue))
N#define u32GetGDCDIMR(ctrlr)  (*pu32GDCDIMR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCPROTR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022C0                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCPROTR_REG__       0xC0C022C0U
N#else
S#define GDCPROTR_REG__ ((uint32_t) GDCPROTR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   GDCWPL	:2; 	 /* 0..1  bit(s) R/W */ 
N  uint8_t   	:6; 	 /* 2..63  bit(s) R */                    
N} GDCPROTR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GDCPROTR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitGDCPROTR(ctrlr)     ((volatile GDCPROTR_bit_view_st *)\
S(GDCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCPROTR(ctrlr)     ((volatile GDCPROTR_bit_view_st *)(GDCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE  */
S#define pu8GDCPROTR(ctrlr)     ((volatile u8GDCPROTR_byte_view *)\
S(GDCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu8GDCPROTR(ctrlr)     ((volatile u8GDCPROTR_byte_view *)(GDCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCPROTR(ctrlr)     ((volatile GDCPROTR_bit_view_st *) &u32GDCPROTR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE  */
N#define pu8GDCPROTR(ctrlr)     ((volatile u8GDCPROTR_byte_view *) GDCPROTR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCPROTR_GDCWPL(ctrlr) (pst_bitGDCPROTR(ctrlr) -> GDCWPL)
N#define vSetGDCPROTR_GDCWPL(ctrlr,ParValue)  (pst_bitGDCPROTR(ctrlr) -> GDCWPL=(ParValue))
N            
N/* byte access */
N#define vSetGDCPROTR(ctrlr,ParValue) (*pu8GDCPROTR(ctrlr) = (ParValue))
N#define u8GetGDCPROTR(ctrlr) (*pu8GDCPROTR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCGBEAR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022C8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCGBEAR_REG__       0xC0C022C8U
N#else
S#define GDCGBEAR_REG__ ((uint32_t) GDCGBEAR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   GBADDR	:32; 	 /* 0..31  bit(s) R */                    
N} GDCGBEAR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCGBEAR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCGBEAR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCGBEAR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N/* Pointer to BIT-struct */
N#define pst_bitGDCGBEAR(ctrlr)     ((volatile GDCGBEAR_bit_view_st *)\
N(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCGBEAR(ctrlr)     ((volatile GDCGBEAR_bit_view_st *)(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCGBEAR(ctrlr)     ((volatile GDCGBEAR_byte_view_st *)\
N(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCGBEAR(ctrlr)     ((volatile GDCGBEAR_byte_view_st *)(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCGBEAR(ctrlr)     ((volatile GDCGBEAR_halfword_view_st *)\
N(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCGBEAR(ctrlr)     ((volatile GDCGBEAR_halfword_view_st *)(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to WORD  */ 
N#define pu32GDCGBEAR(ctrlr)     ((volatile u32GDCGBEAR_word_view *)\
N(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCGBEAR(ctrlr)     ((volatile u32GDCGBEAR_word_view *)(GDCGBEAR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGDCGBEAR_GBADDR(ctrlr) (pst_bitGDCGBEAR(ctrlr) -> GBADDR)
N
N/* LL-struct byte access */
N#define u8GetGDCGBEARLL(ctrlr) (pst_u8GDCGBEAR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define u8GetGDCGBEARLH(ctrlr) (pst_u8GDCGBEAR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define u8GetGDCGBEARHL(ctrlr) (pst_u8GDCGBEAR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define u8GetGDCGBEARHH(ctrlr) (pst_u8GDCGBEAR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGDCGBEARL(ctrlr) (pst_u16GDCGBEAR(ctrlr) -> u16L)
N#define u16GetGDCGBEARH(ctrlr) (pst_u16GDCGBEAR(ctrlr) -> u16H)
N            
N/* Word access */
N#define u32GetGDCGBEAR(ctrlr)  (*pu32GDCGBEAR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCGBECR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C022D0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCGBECR_REG__       0xC0C022D0U
N#else
S#define GDCGBECR_REG__ ((uint32_t) GDCGBECR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   WR	:1; 	 /* 0..0  bit(s) R */
N  uint32_t   BTYPE	:1; 	 /* 1..1  bit(s) R */
N  uint32_t   BSIZE	:3; 	 /* 2..4  bit(s) R */
N  uint32_t   RTYPE	:2; 	 /* 5..6  bit(s) R */
N  uint32_t   	:1; 	 /* 7..7  bit(s) R */
N  uint32_t   BEN	:8; 	 /* 8..15  bit(s) R */
N  uint32_t   ID	:4; 	 /* 16..19  bit(s) R */
N  uint32_t   LEN	:4; 	 /* 20..23  bit(s) R */ 
N  uint32_t   	:8; 	 /* 24..63  bit(s) R */                    
N} GDCGBECR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef struct{      
N  uint8_t u8LL;      
N  uint8_t u8LH;      
N  uint8_t u8HL;      
N  uint8_t u8HH;      
N} GDCGBECR_byte_view_st;
N            
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16L;     
N  uint16_t u16H;     
N} GDCGBECR_halfword_view_st;
N            
N/* WORD View */
Ntypedef uint32_t u32GDCGBECR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCGBECR(ctrlr)     ((volatile GDCGBECR_bit_view_st *)\
N(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitGDCGBECR(ctrlr)     ((volatile GDCGBECR_bit_view_st *)(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N        
N/* Pointer to BYTE-struct  */
N#define pst_u8GDCGBECR(ctrlr)     ((volatile GDCGBECR_byte_view_st *)\
N(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u8GDCGBECR(ctrlr)     ((volatile GDCGBECR_byte_view_st *)(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to HALFWORD-struct */
N#define pst_u16GDCGBECR(ctrlr)     ((volatile GDCGBECR_halfword_view_st *)\
N(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16GDCGBECR(ctrlr)     ((volatile GDCGBECR_halfword_view_st *)(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to WORD  */ 
N#define pu32GDCGBECR(ctrlr)     ((volatile u32GDCGBECR_word_view *)\
N(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu32GDCGBECR(ctrlr)     ((volatile u32GDCGBECR_word_view *)(GDCGBECR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetGDCGBECR_WR(ctrlr) (pst_bitGDCGBECR(ctrlr) -> WR)            
N#define biGetGDCGBECR_BTYPE(ctrlr) (pst_bitGDCGBECR(ctrlr) -> BTYPE)            
N#define biGetGDCGBECR_BSIZE(ctrlr) (pst_bitGDCGBECR(ctrlr) -> BSIZE)            
N#define biGetGDCGBECR_RTYPE(ctrlr) (pst_bitGDCGBECR(ctrlr) -> RTYPE)            
N#define biGetGDCGBECR_BEN(ctrlr) (pst_bitGDCGBECR(ctrlr) -> BEN)            
N#define biGetGDCGBECR_ID(ctrlr) (pst_bitGDCGBECR(ctrlr) -> ID)            
N#define biGetGDCGBECR_LEN(ctrlr) (pst_bitGDCGBECR(ctrlr) -> LEN)
N            
N/* LL-struct byte access */
N#define u8GetGDCGBECRLL(ctrlr) (pst_u8GDCGBECR(ctrlr) -> u8LL)
N/* LH-struct byte access */
N#define u8GetGDCGBECRLH(ctrlr) (pst_u8GDCGBECR(ctrlr) -> u8LH)
N/* HL-struct byte access */
N#define u8GetGDCGBECRHL(ctrlr) (pst_u8GDCGBECR(ctrlr) -> u8HL)
N/* HH-struct byte access */
N#define u8GetGDCGBECRHH(ctrlr) (pst_u8GDCGBECR(ctrlr) -> u8HH)
N            
N            
N/* Half-word struct access */ 
N#define u16GetGDCGBECRL(ctrlr) (pst_u16GDCGBECR(ctrlr) -> u16L)
N#define u16GetGDCGBECRH(ctrlr) (pst_u16GDCGBECR(ctrlr) -> u16H)
N            
N/* Word access */
N#define u32GetGDCGBECR(ctrlr)  (*pu32GDCGBECR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: APCCR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02300                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                      
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define APCCR_REG__       0xC0C02300U
N#else
S#define APCCR_REG__ ((uint32_t) &APCCR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   APCCHKFR   :7;      /* 0..6  bit(s) R/W */
N  uint64_t   APCCHKERR  :1;      /* 7..7  bit(s) R */
N  uint64_t      :22;     /* 8..29  bit(s) R */
N  uint64_t   APCAUTO    :1;      /* 30..30  bit(s) R/W */
N  uint64_t   APCON  :1;      /* 31..31  bit(s) R/W */
N  uint64_t   APCPG  :7;      /* 32..38  bit(s) R/W */
N  uint64_t   Reserved   :1;      /* 39..39  bit(s) R */ 
N  uint64_t      :24;     /* 40..63  bit(s) R */                    
N} APCCR_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} APCCR_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} APCCR_word_view_st;
N                 
N/* LONGWORD View */
Ntypedef uint64_t u64APCCR_longword_view;
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitAPCCR(ctrlr)     ((volatile APCCR_bit_view_st *)\
S(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCCR(ctrlr)     ((volatile APCCR_bit_view_st *)(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16APCCR(ctrlr)     ((volatile APCCR_halfword_view_st *)\
S(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16APCCR(ctrlr)     ((volatile APCCR_halfword_view_st *)(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32APCCR(ctrlr)   ((volatile APCCR_word_view_st *) \
S(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32APCCR(ctrlr)   ((volatile APCCR_word_view_st *) (APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S
S/* Pointer to LONG_WORD  */
S#define pu64APCCR(ctrlr)    ((volatile u64APCCR_longword_view *)\
S(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64APCCR(ctrlr)    ((volatile u64APCCR_longword_view *)(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N/* Pointer to BIT-struct */
N#define pst_bitAPCCR_Direct(ctrlr)     ((volatile APCCR_bit_view_st *)\
N(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCCR_Direct(ctrlr)     ((volatile APCCR_bit_view_st *)(APCCR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N/* Pointer to BIT-struct */
N#define pst_bitAPCCR(ctrlr)     ((volatile APCCR_bit_view_st *) &u64APCCR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16APCCR(ctrlr)     ((volatile APCCR_halfword_view_st *) &u64APCCR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32APCCR(ctrlr)   ((volatile APCCR_word_view_st *) &u64APCCR_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64APCCR(ctrlr)    ((volatile u64APCCR_longword_view *) &u64APCCR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetAPCCR_APCCHKFR(ctrlr) (pst_bitAPCCR(ctrlr) -> APCCHKFR)
N#define vSetAPCCR_APCCHKFR(ctrlr,ParValue)  (pst_bitAPCCR(ctrlr) -> APCCHKFR=(ParValue))            
N
N/**********************************************************************
N ** "Read Only" signals should be read directly fom shadow register  **
N **********************************************************************/
N#define biGetAPCCR_APCCHKERR(ctrlr) (pst_bitAPCCR_Direct(ctrlr) -> APCCHKERR)
N
N#define biGetAPCCR_APCAUTO(ctrlr) (pst_bitAPCCR(ctrlr) -> APCAUTO)
N#define vSetAPCCR_APCAUTO(ctrlr,ParValue)  (pst_bitAPCCR(ctrlr) -> APCAUTO=(ParValue))
N#define biGetAPCCR_APCON(ctrlr) (pst_bitAPCCR(ctrlr) -> APCON)
N#define vSetAPCCR_APCON(ctrlr,ParValue)  (pst_bitAPCCR(ctrlr) -> APCON=(ParValue))
N#define biGetAPCCR_APCPG(ctrlr) (pst_bitAPCCR(ctrlr) -> APCPG)
N#define vSetAPCCR_APCPG(ctrlr,ParValue)  (pst_bitAPCCR(ctrlr) -> APCPG=(ParValue))            
N#define biGetAPCCR_Reserved(ctrlr) (pst_bitAPCCR(ctrlr) -> Reserved)
N
N/* Half-word struct access LL */ 
N#define vSetAPCCRLL(ctrlr,ParValue) (pst_u16APCCR(ctrlr) -> u16LL = (ParValue))
N#define u16GetAPCCRLL(ctrlr) (pst_u16APCCR(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetAPCCRLH(ctrlr,ParValue) (pst_u16APCCR(ctrlr) -> u16LH = (ParValue))
N#define u16GetAPCCRLH(ctrlr) (pst_u16APCCR(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetAPCCRHL(ctrlr,ParValue) (pst_u16APCCR(ctrlr) -> u16HL = (ParValue))
N#define u16GetAPCCRHL(ctrlr) (pst_u16APCCR(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetAPCCRHH(ctrlr,ParValue) (pst_u16APCCR(ctrlr) -> u16HH = (ParValue))
N#define u16GetAPCCRHH(ctrlr) (pst_u16APCCR(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetAPCCRL(ctrlr,ParValue) (pst_u32APCCR(ctrlr) -> u32L= (ParValue))
N#define u32GetAPCCRL(ctrlr) (pst_u32APCCR(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetAPCCRH(ctrlr,ParValue) (pst_u32APCCR(ctrlr) -> u32H = (ParValue))
N#define u32GetAPCCRH(ctrlr) (pst_u32APCCR(ctrlr) -> u32H)
N
N/* Long  Word access */ 
N#define vSetAPCCR(ctrlr,ParValue)  (*pu64APCCR(ctrlr) = (ParValue))
N#define u64GetAPCCR(ctrlr)  (*pu64APCCR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: APCCWR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02308                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define APCCWR_REG__       0xC0C02308U
N#else
S#define APCCWR_REG__ ((uint32_t) &APCCWR_REG_EMUL)
N#endif            
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   VCWS	:11; 	 /* 0..10  bit(s) R/W */
N  uint64_t   	:5; 	 /* 11..15  bit(s) R */
N  uint64_t   HCWS	:12; 	 /* 16..27  bit(s) R/W */
N  uint64_t   	:4; 	 /* 28..31  bit(s) R */
N  uint64_t   CWHEIGHT	:7; 	 /* 32..38  bit(s) R/W */
N  uint64_t   	:9; 	 /* 39..47  bit(s) R */
N  uint64_t   CWWIDTH	:8; 	 /* 48..55  bit(s) R/W */ 
N  uint64_t   	:8; 	 /* 56..63  bit(s) R */                    
N} APCCWR_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} APCCWR_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} APCCWR_word_view_st;
N            
N/* LONGWORD View */
Ntypedef uint64_t u64APCCWR_longword_view;
N             
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitAPCCWR(ctrlr)     ((volatile APCCWR_bit_view_st *)\
S(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCCWR(ctrlr)     ((volatile APCCWR_bit_view_st *)(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16APCCWR(ctrlr)     ((volatile APCCWR_halfword_view_st *)\
S(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16APCCWR(ctrlr)     ((volatile APCCWR_halfword_view_st *)(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32APCCWR(ctrlr)   ((volatile APCCWR_word_view_st *) \
S(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32APCCWR(ctrlr)   ((volatile APCCWR_word_view_st *) (APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to LONG_WORD  */
S#define pu64APCCWR(ctrlr)    ((volatile u64APCCWR_longword_view *)\
S(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64APCCWR(ctrlr)    ((volatile u64APCCWR_longword_view *)(APCCWR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitAPCCWR(ctrlr)     ((volatile APCCWR_bit_view_st *) &u64APCCWR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16APCCWR(ctrlr)     ((volatile APCCWR_halfword_view_st *) &u64APCCWR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32APCCWR(ctrlr)   ((volatile APCCWR_word_view_st *)  &u64APCCWR_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64APCCWR(ctrlr)    ((volatile u64APCCWR_longword_view *) &u64APCCWR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetAPCCWR_VCWS(ctrlr) (pst_bitAPCCWR(ctrlr) -> VCWS)
N#define vSetAPCCWR_VCWS(ctrlr,ParValue)  (pst_bitAPCCWR(ctrlr) -> VCWS=(ParValue))
N#define biGetAPCCWR_HCWS(ctrlr) (pst_bitAPCCWR(ctrlr) -> HCWS)
N#define vSetAPCCWR_HCWS(ctrlr,ParValue)  (pst_bitAPCCWR(ctrlr) -> HCWS=(ParValue))
N#define biGetAPCCWR_CWHEIGHT(ctrlr) (pst_bitAPCCWR(ctrlr) -> CWHEIGHT)
N#define vSetAPCCWR_CWHEIGHT(ctrlr,ParValue)  (pst_bitAPCCWR(ctrlr) -> CWHEIGHT=(ParValue))
N#define biGetAPCCWR_CWWIDTH(ctrlr) (pst_bitAPCCWR(ctrlr) -> CWWIDTH)
N#define vSetAPCCWR_CWWIDTH(ctrlr,ParValue)  (pst_bitAPCCWR(ctrlr) -> CWWIDTH=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetAPCCWRLL(ctrlr,ParValue) (pst_u16APCCWR(ctrlr) -> u16LL = (ParValue))
N#define u16GetAPCCWRLL(ctrlr) (pst_u16APCCWR(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetAPCCWRLH(ctrlr,ParValue) (pst_u16APCCWR(ctrlr) -> u16LH = (ParValue))
N#define u16GetAPCCWRLH(ctrlr) (pst_u16APCCWR(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetAPCCWRHL(ctrlr,ParValue) (pst_u16APCCWR(ctrlr) -> u16HL = (ParValue))
N#define u16GetAPCCWRHL(ctrlr) (pst_u16APCCWR(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetAPCCWRHH(ctrlr,ParValue) (pst_u16APCCWR(ctrlr) -> u16HH = (ParValue))
N#define u16GetAPCCWRHH(ctrlr) (pst_u16APCCWR(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetAPCCWRL(ctrlr,ParValue) (pst_u32APCCWR(ctrlr) -> u32L= (ParValue))
N#define u32GetAPCCWRL(ctrlr) (pst_u32APCCWR(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetAPCCWRH(ctrlr,ParValue) (pst_u32APCCWR(ctrlr) -> u32H = (ParValue))
N#define u32GetAPCCWRH(ctrlr) (pst_u32APCCWR(ctrlr) -> u32H)
N            
N/* Long  Word access */ 
N#define vSetAPCCWR(ctrlr,ParValue)  (*pu64APCCWR(ctrlr) = (ParValue))
N#define u64GetAPCCWR(ctrlr)  (*pu64APCCWR(ctrlr) )
N     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: APCCSR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02310                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define APCCSR_REG__       0xC0C02310U
N#else
S#define APCCSR_REG__ ((uint32_t) &APCCSR_REG_EMUL)
N#endif
N
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   CURCHKSUM	:22; 	 /* 0..21  bit(s) R/C */
N  uint64_t   	:10; 	 /* 22..31  bit(s) R */
N  uint64_t   EXPCHKSUM	:22; 	 /* 32..53  bit(s) R/W */ 
N  uint64_t   	:10; 	 /* 54..63  bit(s) R */                    
N} APCCSR_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} APCCSR_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} APCCSR_word_view_st;
N            
N/* LONGWORD View */
Ntypedef uint64_t u64APCCSR_longword_view;
N             
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitAPCCSR(ctrlr)     ((volatile APCCSR_bit_view_st *)\
S(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCCSR(ctrlr)     ((volatile APCCSR_bit_view_st *)(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to HALFWORD-struct */
S#define pst_u16APCCSR(ctrlr)     ((volatile APCCSR_halfword_view_st *)\
S(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16APCCSR(ctrlr)     ((volatile APCCSR_halfword_view_st *)(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S             
S/* Pointer to WORD-struct  */ 
S#define pst_u32APCCSR(ctrlr)   ((volatile APCCSR_word_view_st *) \
S(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32APCCSR(ctrlr)   ((volatile APCCSR_word_view_st *) (APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S            
S/* Pointer to LONG_WORD  */
S#define pu64APCCSR(ctrlr)    ((volatile u64APCCSR_longword_view *)\
S(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64APCCSR(ctrlr)    ((volatile u64APCCSR_longword_view *)(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct of shadow register:*/
N#define pst_bitAPCCSR_Direct(ctrlr)     ((volatile APCCSR_bit_view_st *)\
N(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCCSR_Direct(ctrlr)     ((volatile APCCSR_bit_view_st *)(APCCSR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N/* Pointer to BIT-struct */
N#define pst_bitAPCCSR(ctrlr)     ((volatile APCCSR_bit_view_st *) &u64APCCSR_REG__Var[(ctrlr)])
N
N/* Pointer to HALFWORD-struct */
N#define pst_u16APCCSR(ctrlr)     ((volatile APCCSR_halfword_view_st *) &u64APCCSR_REG__Var[(ctrlr)])
N
N/* Pointer to WORD-struct  */ 
N#define pst_u32APCCSR(ctrlr)   ((volatile APCCSR_word_view_st *)  &APCCSR_REG__Var[(ctrlr)])
N
N/* Pointer to LONG_WORD  */
N#define pu64APCCSR(ctrlr)    ((volatile u64APCCSR_longword_view *)&u64APCCSR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N
N/**********************************************************************
N ** "Read Only" signals should be read directly fom shadow register  **
N **********************************************************************/
N#define biGetAPCCSR_CURCHKSUM(ctrlr) (pst_bitAPCCSR_Direct(ctrlr) -> CURCHKSUM)
N/**********************************************************************/
N/* CURCHKSUM is R/C bit, no SET:
N#define vSetAPCCSR_CURCHKSUM(ctrlr) (pst_bitAPCCSR(ctrlr) -> CURCHKSUM=(0))
N*/
N#define biGetAPCCSR_EXPCHKSUM(ctrlr) (pst_bitAPCCSR(ctrlr) -> EXPCHKSUM)
N#define vSetAPCCSR_EXPCHKSUM(ctrlr,ParValue)  (pst_bitAPCCSR(ctrlr) -> EXPCHKSUM=(ParValue))
N
N/* Half-word struct access LL */ 
N#define vSetAPCCSRLL(ctrlr,ParValue) (pst_u16APCCSR(ctrlr) -> u16LL = (ParValue))
N#define u16GetAPCCSRLL(ctrlr) (pst_u16APCCSR(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define vSetAPCCSRLH(ctrlr,ParValue) (pst_u16APCCSR(ctrlr) -> u16LH = (ParValue))
N#define u16GetAPCCSRLH(ctrlr) (pst_u16APCCSR(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define vSetAPCCSRHL(ctrlr,ParValue) (pst_u16APCCSR(ctrlr) -> u16HL = (ParValue))
N#define u16GetAPCCSRHL(ctrlr) (pst_u16APCCSR(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define vSetAPCCSRHH(ctrlr,ParValue) (pst_u16APCCSR(ctrlr) -> u16HH = (ParValue))
N#define u16GetAPCCSRHH(ctrlr) (pst_u16APCCSR(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define vSetAPCCSRL(ctrlr,ParValue) (pst_u32APCCSR(ctrlr) -> u32L= (ParValue))
N#define u32GetAPCCSRL(ctrlr) (pst_u32APCCSR(ctrlr) -> u32L)
N/* Word-struct access H */
N#define vSetAPCCSRH(ctrlr,ParValue) (pst_u32APCCSR(ctrlr) -> u32H = (ParValue))
N#define u32GetAPCCSRH(ctrlr) (pst_u32APCCSR(ctrlr) -> u32H)
N            
N/* Long  Word access */ 
N#define vSetAPCCSR(ctrlr,ParValue)  (*pu64APCCSR(ctrlr) = (ParValue))
N#define u64GetAPCCSR(ctrlr)  (*pu64APCCSR(ctrlr) )
N     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: APCPVR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02318                             
N*       ACCESS  : 8, 16, 32, 64, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define APCPVR_REG__       0xC0C02318U
N#else
S#define APCPVR_REG__ ((uint32_t) &APCPVR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint64_t   BLUEL	:8; 	 /* 0..7  bit(s) R */
N  uint64_t   GREENL	:8; 	 /* 8..15  bit(s) R */
N  uint64_t   REDL	:8; 	 /* 16..23  bit(s) R */
N  uint64_t   	:8; 	 /* 24..31  bit(s) R */
N  uint64_t   BLUEP	:8; 	 /* 32..39  bit(s) R */
N  uint64_t   GREENP	:8; 	 /* 40..47  bit(s) R */
N  uint64_t   REDP	:8; 	 /* 48..55  bit(s) R */ 
N  uint64_t   	:8; 	 /* 56..63  bit(s) R */                    
N} APCPVR_bit_view_st;
N        
N
N/* HALFWORD View */
Ntypedef struct{      
N  uint16_t u16LL;    
N  uint16_t u16LH;    
N  uint16_t u16HL;    
N  uint16_t u16HH;    
N} APCPVR_halfword_view_st;
N            
N/* WORD View */
Ntypedef struct{      
N  uint32_t u32L;     
N  uint32_t u32H;     
N} APCPVR_word_view_st;
N            
N/* LONGWORD View */
Ntypedef uint64_t u64APCPVR_longword_view;
N             
N
N
N/************************     ACCESS POINTERS     ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitAPCPVR(ctrlr)     ((volatile APCPVR_bit_view_st *)\
N(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCPVR(ctrlr)     ((volatile APCPVR_bit_view_st *)(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N        
N/* Pointer to HALFWORD-struct */
N#define pst_u16APCPVR(ctrlr)     ((volatile APCPVR_halfword_view_st *)\
N(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u16APCPVR(ctrlr)     ((volatile APCPVR_halfword_view_st *)(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N             
N/* Pointer to WORD-struct  */ 
N#define pst_u32APCPVR(ctrlr)   ((volatile APCPVR_word_view_st *) \
N(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_u32APCPVR(ctrlr)   ((volatile APCPVR_word_view_st *) (APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N            
N/* Pointer to LONG_WORD  */
N#define pu64APCPVR(ctrlr)    ((volatile u64APCPVR_longword_view *)\
N(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu64APCPVR(ctrlr)    ((volatile u64APCPVR_longword_view *)(APCPVR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetAPCPVR_BLUEL(ctrlr) (pst_bitAPCPVR(ctrlr) -> BLUEL)            
N#define biGetAPCPVR_GREENL(ctrlr) (pst_bitAPCPVR(ctrlr) -> GREENL)            
N#define biGetAPCPVR_REDL(ctrlr) (pst_bitAPCPVR(ctrlr) -> REDL)            
N#define biGetAPCPVR_BLUEP(ctrlr) (pst_bitAPCPVR(ctrlr) -> BLUEP)            
N#define biGetAPCPVR_GREENP(ctrlr) (pst_bitAPCPVR(ctrlr) -> GREENP)            
N#define biGetAPCPVR_REDP(ctrlr) (pst_bitAPCPVR(ctrlr) -> REDP)
N
N/* Half-word struct access LL */ 
N#define u16GetAPCPVRLL(ctrlr) (pst_u16APCPVR(ctrlr) -> u16LL)
N/* Half-word struct access LH */ 
N#define u16GetAPCPVRLH(ctrlr) (pst_u16APCPVR(ctrlr) -> u16LH)
N/* Half-word struct access HL */ 
N#define u16GetAPCPVRHL(ctrlr) (pst_u16APCPVR(ctrlr) -> u16HL)
N/* Half-word struct access HH */ 
N#define u16GetAPCPVRHH(ctrlr) (pst_u16APCPVR(ctrlr) -> u16HH)
N                      
N            
N/* Word-struct access L */
N#define u32GetAPCPVRL(ctrlr) (pst_u32APCPVR(ctrlr) -> u32L)
N/* Word-struct access H */
N#define u32GetAPCPVRH(ctrlr) (pst_u32APCPVR(ctrlr) -> u32H)
N            
N/* Long  Word access */ 
N#define u64GetAPCPVR(ctrlr)  (*pu64APCPVR(ctrlr) )
N     
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: APCPROTR                                
N*       SIZE    : 64-bits                        
N*       ADDRESS : 0xC0C02320                             
N*       ACCESS  : 8, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define APCPROTR_REG__       0xC0C02320U
N#else
S#define APCPROTR_REG__ ((uint32_t) &APCPROTR_REG_EMUL)
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint8_t   APCWPL	:2; 	 /* 0..1  bit(s) R/W */ 
N  uint8_t   	:6; 	 /* 2..63  bit(s) R */                    
N} APCPROTR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8APCPROTR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N#if 0
S/* Pointer to BIT-struct */
S#define pst_bitAPCPROTR(ctrlr)     ((volatile APCPROTR_bit_view_st *)\
S(APCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pst_bitAPCPROTR(ctrlr)     ((volatile APCPROTR_bit_view_st *)(APCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
S        
S/* Pointer to BYTE  */
S#define pu8APCPROTR(ctrlr)     ((volatile u8APCPROTR_byte_view *)\
S(APCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
X#define pu8APCPROTR(ctrlr)     ((volatile u8APCPROTR_byte_view *)(APCPROTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET) ))
N#else
N
N/* Pointer to BIT-struct */
N#define pst_bitAPCPROTR(ctrlr)     ((volatile APCPROTR_bit_view_st *) &u32APCPROTR_REG__Var[(ctrlr)])
N
N/* Pointer to BYTE  */
N#define pu8APCPROTR(ctrlr)     ((volatile u8APCPROTR_byte_view *) &u32APCPROTR_REG__Var[(ctrlr)])
N
N#endif
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetAPCPROTR_APCWPL(ctrlr) (pst_bitAPCPROTR(ctrlr) -> APCWPL)
N#define vSetAPCPROTR_APCWPL(ctrlr,ParValue)  (pst_bitAPCPROTR(ctrlr) -> APCWPL=(ParValue))
N            
N/* byte access */
N#define vSetAPCPROTR(ctrlr,ParValue) (*pu8APCPROTR(ctrlr) = (ParValue))
N#define u8GetAPCPROTR(ctrlr) (*pu8APCPROTR(ctrlr) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCCLUTR                                
N*       SIZE    : 8-bits                        
N*       ADDRESS : 0xC0C02400                             
N*       ACCESS  : 8, BIT-level
N*
N*****************************************************************************/
N/*NOTE!: This register is NOT a SHADOW-Register!:*/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCCLUTR_REG__       0xC0C02400U
N#else
S#define GDCCCLUTR_REG__ ((uint32_t) &GDCCCLUTR_REG_EMUL[0])
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint8_t   CCV	:8; 	 /* 0..7  bit(s) R/W */                    
N} GDCCCLUTR_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GDCCCLUTR_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCCLUTR(ctrlr,ch)     ((volatile GDCCCLUTR_bit_view_st *)\
N(GDCCCLUTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitGDCCCLUTR(ctrlr,ch)     ((volatile GDCCCLUTR_bit_view_st *)(GDCCCLUTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE  */
N#define pu8GDCCCLUTR(ctrlr,ch)     ((volatile u8GDCCCLUTR_byte_view *)\
N(GDCCCLUTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
X#define pu8GDCCCLUTR(ctrlr,ch)     ((volatile u8GDCCCLUTR_byte_view *)(GDCCCLUTR_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE WILL NOT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCCLUTR_CCV(ctrlr,ch) (pst_bitGDCCCLUTR((ctrlr),(ch)) -> CCV)
N#define vSetGDCCCLUTR_CCV(ctrlr,ch,ParValue)  (pst_bitGDCCCLUTR((ctrlr),(ch)) -> CCV=(ParValue))
N            
N/* byte access */
N#define vSetGDCCCLUTR(ctrlr,ch,ParValue) (*pu8GDCCCLUTR((ctrlr),(ch)) = (ParValue))
N#define u8GetGDCCCLUTR(ctrlr,ch) (*pu8GDCCCLUTR((ctrlr),(ch)) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCCLUTG                                
N*       SIZE    : 8-bits                        
N*       ADDRESS : 0xC0C02800                             
N*       ACCESS  : 8, BIT-level
N* 
N*****************************************************************************/
N/*NOTE!: This register is NOT a SHADOW-Register!:*/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCCLUTG_REG__       0xC0C02800U
N#else
S#define GDCCCLUTG_REG__ ((uint32_t) &GDCCCLUTG_REG_EMUL[0])
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint8_t   CCV	:8; 	 /* 0..7  bit(s) R/W */                    
N} GDCCCLUTG_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GDCCCLUTG_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCCLUTG(ctrlr,ch)     ((volatile GDCCCLUTG_bit_view_st *)\
N(GDCCCLUTG_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitGDCCCLUTG(ctrlr,ch)     ((volatile GDCCCLUTG_bit_view_st *)(GDCCCLUTG_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE  */
N#define pu8GDCCCLUTG(ctrlr,ch)     ((volatile u8GDCCCLUTG_byte_view *)\
N(GDCCCLUTG_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
X#define pu8GDCCCLUTG(ctrlr,ch)     ((volatile u8GDCCCLUTG_byte_view *)(GDCCCLUTG_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCCLUTG_CCV(ctrlr,ch) (pst_bitGDCCCLUTG((ctrlr),(ch)) -> CCV)
N#define vSetGDCCCLUTG_CCV(ctrlr,ch,ParValue)  (pst_bitGDCCCLUTG((ctrlr),(ch)) -> CCV=(ParValue))
N            
N/* byte access */
N#define vSetGDCCCLUTG(ctrlr,ch,ParValue) (*pu8GDCCCLUTG((ctrlr),(ch)) = (ParValue))
N#define u8GetGDCCCLUTG(ctrlr,ch) (*pu8GDCCCLUTG((ctrlr),(ch)) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: GDCCCLUTB                                
N*       SIZE    : 8-bits                        
N*       ADDRESS : 0xC0C02C00                             
N*       ACCESS  : 8, BIT-level
N*
N*****************************************************************************/
N/*NOTE!: This register is NOT a SHADOW-Register!:*/
N/* Assign Register address: */
N#ifndef HW_EMULATION_GDC
N#define GDCCCLUTB_REG__       0xC0C02C00U
N#else
S#define GDCCCLUTB_REG__ ((uint32_t) &GDCCCLUTB_REG_EMUL[0])
N#endif
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint8_t   CCV	:8; 	 /* 0..7  bit(s) R/W */                    
N} GDCCCLUTB_bit_view_st;
N        
N
N/* BYTE View */
Ntypedef uint8_t u8GDCCCLUTB_byte_view;
N                 
N
N
N/************************     ACCESS POINTERS     ****************************/
N
N/* Pointer to BIT-struct */
N#define pst_bitGDCCCLUTB(ctrlr,ch)     ((volatile GDCCCLUTB_bit_view_st *)\
N(GDCCCLUTB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
X#define pst_bitGDCCCLUTB(ctrlr,ch)     ((volatile GDCCCLUTB_bit_view_st *)(GDCCCLUTB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
N        
N/* Pointer to BYTE  */
N#define pu8GDCCCLUTB(ctrlr,ch)     ((volatile u8GDCCCLUTB_byte_view *)\
N(GDCCCLUTB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
X#define pu8GDCCCLUTB(ctrlr,ch)     ((volatile u8GDCCCLUTB_byte_view *)(GDCCCLUTB_REG__  + ((uint8_t)(ctrlr) * GDC1_REGADR_OFFSET)  + ((uint16_t)(ch) * 0x4U)))
N
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetGDCCCLUTB_CCV(ctrlr,ch) (pst_bitGDCCCLUTB((ctrlr),(ch)) -> CCV)
N#define vSetGDCCCLUTB_CCV(ctrlr,ch,ParValue)  (pst_bitGDCCCLUTB((ctrlr),(ch)) -> CCV=(ParValue))
N            
N/* byte access */
N#define vSetGDCCCLUTB(ctrlr,ch,ParValue) (*pu8GDCCCLUTB((ctrlr),(ch)) = (ParValue))
N#define u8GetGDCCCLUTB(ctrlr,ch) (*pu8GDCCCLUTB((ctrlr),(ch)) )
N            
N/****************************************************************************/
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N#endif /* GDC_IO_H */ 
N
N/****************************************************************************/
N
N
N/*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: gdc_io.c
N**  $Revision: 1.12 $
N**  $Date: 2015/05/04 09:07:16 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 230 / 6.4 - bitwise operation may not be performed on signed integer types
N** | CONS.  : allow
N** | REASON : to use macros generated by converter tool 
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/************************** BEGIN of DISCLAIMER   ************************* 
N
N- TOSHIBA is continually working to improve the quality and reliability of 
N  its products. Nevertheless, semiconductor devices in general can 
N  malfunction or fail due to their inherent electrical sensitivity and  
N  vulnerability to physical stress. It is the responsibility of the buyer, 
N  when utilizing TOSHIBA products, to comply with the standards of safety 
N  in making a safe design for the entire system, and to avoid situations in 
N  which a malfunction or failure of such TOSHIBA products could cause loss of 
N  human life, bodily injury or damage to property. 
N  
N  In developing your designs, please ensure that TOSHIBA products are used 
N  within specified operating ranges as set forth in the most recent TOSHIBA 
N  products specifications. 
N  Also, please keep in mind the precautions and conditions set forth in the 
N  Handling Guide for Semiconductor Devices, or 
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in 
N  general electronics applications (computer, personal equipment, office 
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.). 
N  These Toshiba products are neither intended nor warranted for usage in 
N  equipment that requires extraordinarily high quality and/or reliability or 
N  a malfunction or failure of which may cause loss of human life or bodily 
N  injury (Unintended Usage). Unintended Usage include atomic energy control 
N  instruments, airplane or spaceship instruments, transportation instruments, 
N  traffic signal instruments, combustion control instruments, medical 
N  instruments, all types of safety devices, etc.. 
N  Unintended Usage of Toshiba products listed in this document shall be 
N  made at the customers own risk. 
N
N- Toshiba assumes no liability for any damage or losses (including but not 
N  limited to, loss of business profit,business interruption, loss of business 
N  information,and other pecuniary losses) occurring 
N  from the use of, or inability to use, this product. 
N
N- The products described in this document are subject to the foreign exchange 
N  and foreign trade laws. 
N
N- The products described in this document contain components made in the 
N  United States and subject to export control of the U.S. authorities. 
N  Diversion contrary to the U.S. law is prohibited. 
N
N- The information contained herein is presented only as a guide for the 
N  applications of our products. 
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements 
N  of intellectual property or other rights of the third parties which may 
N  result from its use.  
N  No license is granted by implication or otherwise under any intellectual 
N  property or other rights of TOSHIBA CORPORATION or others. 
N
N- The information contained herein is subject to change without notice. 
N
N****************************  END of DISCLAIMER ****************************/ 
N
L 23 "..\..\..\..\lldd\src\gdc.c" 2
N#include "gdc.h"                            /* GDC LLDD definitions */
L 1 "..\..\..\..\lldd\inc\gdc.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Reference GDC Low Level Device Driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Graphics Display Controller (GDC)
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.20 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_7_GFX $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef GDC_H
N#define GDC_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"                      /* Core specific primitive type definitions */
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_GDC_H_REVISION     "$Revision: 1.20 $"
N#define LLDD_GDC_H_TAG          "$Name: LLDD_1_7_GFX $"
N
N#define GDC_GAWID_MAX   0x3FF
N#define GDC_GADEL_MAX   0x3FF
N
N/* #define _EXTENDED_GDC_APIS_DISABLED_ */
N/*********************************************/
N
N/* Number of entries in a color look-up table (CLUT) */
N#define GDC_CLUTSIZE_CORR                   256
N
N/*********************************************/
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
N/* Graphics display controller (channel) */
Ntypedef enum tag_gdc_ch_e
N{
N    GDC0 = 0,                               /* Controller (channel) 0 */
N    GDC1 = 1                                /* Controller (channel) 1 */
N} gdc_ch_e;
N
N/* Clr Bits in GDCDCR:*/
Ntypedef enum tag_gdc_dcr_err_e
N{
N    GDC_DCR_ERR_NONE            = 0x00U,     /* GBER bit in GDCDCR register   */
N    GDC_DCR_ERR_GBER            = 0x01U,     /* GBER bit in GDCDCR register   */
N    GDC_DCR_ERR_GAPCOL          = 0x02U,     /* GAPCOL bit in GDCDCR register */
N    GDC_DCR_ERR_GBER_AND_GAPCOL = 0x03U      /* GBER and GAPCOL bit in GDCDCR register */
N} gdc_dcr_err_e;
N
N/* Used for Signal status of HDISP, HSYNC, VSYNC */
Ntypedef enum tag_gdc_dithering_e
N{
N    GDC_DITHERING_DSIABLED                  = 0x00U,
N    GDC_DITHERING_SIMPLE_ENABLED            = 0x01U,
N    GDC_DITHERING_MAGIC_SQR_ENABLED         = 0x02U,
N    GDC_DITHERING_MAGIC_SQR_SUBPIX_ENABLED  = 0x03U
N} gdc_dithering_e;
N
N/* Update Control for shadow registers: */
Ntypedef enum tag_gdc_reg_update_mode_e
N{
N    GDC_UPDATE_BY_EVERY_VSYNC          = 0x01,  /* update with every VSYNC (default)   */
N    GDC_UPDATE_BY_NEXT_VSYNC_ONLY      = 0x02   /* manual mode: update once at next VSYNC 
N                                                   (HW will change it to 00 by next V-Sync. 
N                                                   In this case NO Update will happen later) */
N} gdc_reg_update_mode_e;
N
N/* status of Update Control for shadow registers: */
Ntypedef enum tag_gdc_reg_update_status_e
N{
N    GDC_UPDATE_STAT_DISABLED           = 0x00,  /* update is disabled (In case of 2, it will be reset by HW by next v-sync)  */
N    GDC_UPDATE_STAT_EVERY_VSYNC        = 0x01,  /* update is with every VSYNC (default)   */
N    GDC_UPDATE_STAT_NEXT_VSYNC_ONLY    = 0x02   /* update only for 1 vsync */
N} gdc_reg_update_status_e;
N
N/* Graphic Layers */
Ntypedef enum tag_gdc_layer_e
N{
N    GDC_LAYER_A = 0x0U,                     /* Main Layer A */
N    GDC_LAYER_B = 0x1U,                     /* Main Layer B */
N    GDC_LAYER_C = 0x2U,                     /* Main Layer C */
N    GDC_LAYER_D = 0x3U,                     /* Main Layer D */
N    GDC_LAYER_E = 0x4U                      /* Main Layer E */
N} gdc_layer_e;
N
N/* Display Window */
Ntypedef enum tag_gdc_win_e
N{
N    GDC_WIN_A = 0x0U,                       /* Layer A display window */
N    GDC_WIN_B = 0x1U,                       /* Layer B display window */
N    GDC_WIN_C = 0x2U,                       /* Layer C display window */
N    GDC_WIN_D = 0x3U,                       /* Layer D display window */
N    GDC_WIN_E = 0x4U                        /* Layer E display window */
N} gdc_win_e;
N
N/* *** */
N
N/*
N *  GDCSAR parameter values
N */
N
N/* Frame buffers */
Ntypedef enum tag_gdc_frmbuff_e
N{
N    GDC_BUFF_DEFAULT = 0x0U,                /* Default Frame Buffer (must be always defined) */
N    GDC_BUFF_SECOND  = 0x1U                 /* Second buffer is optional (used only during auto buffer switch) */
N} gdc_frmbuff_e;
N
N/* *** */
N
N/*
N *  GDCMSEGR parameter values
N */
N
N/* Memory segments */
Ntypedef enum tag_gdc_seg_e
N{
N    GDC_SEG_LAYER_A = 0x1U,                 /* Layer A segment */
N    GDC_SEG_LAYER_B = 0x2U,                 /* Layer B segment */
N    GDC_SEG_LAYER_C = 0x3U,                 /* Layer C segment */
N    GDC_SEG_LAYER_D = 0x4U,                 /* Layer D segment */
N    GDC_SEG_LAYER_E = 0x5U,                 /* Layer E segment */
N    GDC_SEG_WIN_A   = 0x6U,                 /* Layer A Display Window segment */
N    GDC_SEG_WIN_B   = 0x7U,                 /* Layer B Display Window segment */
N    GDC_SEG_WIN_C   = 0x8U,                 /* Layer C Display Window segment */
N    GDC_SEG_WIN_D   = 0x9U,                 /* Layer D Display Window segment */
N    GDC_SEG_WIN_E   = 0xAU                  /* Layer E Display Window segment */
N} gdc_seg_e;
N
N/* *** */
N
N/*
N * GDCCR parameter values
N */
N
N/* Enable/disable a controller, layer or window */
Ntypedef enum tag_gdc_en_e
N{
N    GDC_DISABLE = 0x0U,                     /* Disable */
N    GDC_ENABLE  = 0x1U                      /* Enable */
N} gdc_en_e;
N
N/* Selective color correction mode */
Ntypedef enum tag_gdc_ccmode_e
N{
N    GDC_EXCEPT_CMPVAL = 0,                  /* No correction of the compare values */
N    GDC_CMPVAL_ONLY   = 1                   /* Correct on match with the compare values only */
N} gdc_ccmode_e;
N
N/* Display config type */
Ntypedef enum tag_disp_config_type_e
N{
N    GDC_USE_DISP_SET_DIRECT  = 0,            /* use direct setting (GDCDSR and GDCDIMR) */
N    GDC_USE_DISP_SET_BY_LAYA = 1             /* use by setting of layer A (GDCLSRA and GDCLDRA) */
N} gdc_disp_config_type_e;
N
N/* GDC output, display, pannel control */
Ntypedef enum tag_gdc_on_e
N{
N    GDC_OFF = 0x0U,                         /* GDC output off */
N    GDC_ON  = 0x1U                          /* GDC output on */
N} gdc_on_e;
N
N/* Layer data format */
Ntypedef enum tag_gdc_dfmt_e
N{
N    GDC_RGBA32 = 0x0U,                      /* RGBA 32-bit */
N    GDC_RGB16  = 0x1U,                      /* RGB 16-bit */
N    GDC_ARGB32 = 0x2U                       /* ARGB 32-bit */
N} gdc_dfmt_e;
N
N/* Frame buffer active status */
Ntypedef enum tag_gdc_fbact_e
N{
N    GDC_BUFF0 = 0x0U,                       /* Frame buffer 0 is used for the next frame */
N    GDC_BUFF1 = 0x1U                        /* Frame buffer 1 is used for the next frame */
N} gdc_fbact_e;
N
N/* Dot-clock Selector */
Ntypedef enum tag_gdc_idc_e
N{
N    GDC_DOTCLK_EXT = 0x0U,                  /* External dot-clock used */
N/* >>> WARNING <<< When using external dot clock, output drivers can be damaged when programming "1" (GDC_DOTCLK_INT) to the related bit >>> WARNING <<< */
N    GDC_DOTCLK_INT = 0x1U                   /* Internal dot-clock used */
N
N} gdc_idc_e;
N
N/* Signal Polarity */
Ntypedef enum tag_gdc_pol_e
N{
N    GDC_NEG = 0x0U,                         /* Negative */
N    GDC_POS = 0x1U                          /* Positive */
N} gdc_pol_e;
N
N/* Artifact handling  */
Ntypedef enum tag_gdc_arth_e
N{
N    GDC_NO_ACTION   = 0x0U,                 /* No Action */
N    GDC_MULTI_BUFF  = 0x1U,                 /* Multi-buffer switching */
N    GDC_VIDEO_BLEND = 0x3U                  /* Display window video blending */
N} gdc_arth_e;
N
N/* Artifact handling location  */
Ntypedef enum tag_gdc_arthcd_e
N{
N    GDC_LAYER_AB = 0x0U,                    /* Display window layers A & B */
N    GDC_LAYER_CD = 0x1U                     /* Display window layers C & D */
N} gdc_arthcd_e;
N
N/* Layer order */
Ntypedef enum tag_gdc_vord_e
N{
N    GDC_ABCDE = 0x0U,                        /* A, B, C, D, E */
N    GDC_ACBDE = 0x1U                         /* A, C, B, D, E */
N} gdc_vord_e;
N
N/* Direction input/output selection */
Ntypedef enum tag_gdc_dir_e
N{
N    GDC_OUTPUT = 0x0U,                      /* Output mode */
N    GDC_INPUT  = 0x1U                       /* Input mode */
N} gdc_dir_e;
N
N/* Composite synchronization */
Ntypedef enum tag_gdc_csync_e
N{
N    GDC_VSYNC = 0x0U,                       /* Output VSync on DISP_vsync pin */
N    GDC_CSYNC = 0x1U                        /* Output CSync on DISP_vsync pin */
N} gdc_csync_e;
N
N/* *** */
N
N/*
N *  GDCINTR parameter values
N */
N
N/* Interrupt status */
Ntypedef enum tag_gdc_irqact_e
N{
N    GDC_IRQ_INACTIVE = 0x0U,                /* IRQ is inactive */
N    GDC_IRQ_ACTIVE   = 0x1U                 /* IRQ is active */
N} gdc_irqact_e;
N
N/* *** */
N
N/*
N *  GDCPTCR parameter values
N */
N
N/* General purpose pin selection */
Ntypedef enum tag_gdc_gpp_e
N{
N    GDC_GPP0 = 0x8U,                        /* General Purpose Pin #0, <GDCPTCR:bit 8> */
N    GDC_GPP1,                               /* General Purpose Pin #1, <GDCPTCR:bit 9> */
N    GDC_GPP2,
N    GDC_GPP3,
N    GDC_GPP4,
N    GDC_GPP5,
N    GDC_GPP6,
N    GDC_GPP7,
N    GDC_GPP8,
N    GDC_GPP9,
N    GDC_GPP10,
N    GDC_GPP11                               /* General Purpose Pin #11 */
N} gdc_gpp_e;
N
N/* Positive panel synchronization select */
Ntypedef enum tag_gdc_ppsync_e
N{
N    GDC_INPUT_LOW  = 0x0U,                    /* input is low active */
N    GDC_INPUT_HIGH = 0x1U                     /* input is high active */
N} gdc_ppsync_e;
N
N/* Reduced Swing Differential Signaling select */
Ntypedef enum tag_gdc_rsdsen_e
N{
N    GDC_RSDSEN_DIGITAL      = 0x0U,                    /* digital output */
N    GDC_RSDSEN_DIFFERENTIAL = 0x1U                     /* differential output */
N} gdc_rsdsen_e;
N
N/* Reduced Swing Differential Signaling Output Mode */
Ntypedef enum tag_gdc_rsdsoutmode_e
N{
N    GDC_RSDSOUT_HIGH      = 0x0U,                    /* high */
N    GDC_RSDSOUT_MEDIUM    = 0x1U,                    /* medium */
N    GDC_RSDSOUT_LOW       = 0x2U,                    /* low */
N    GDC_RSDSOUT_HIZ       = 0x3U                     /* high impedance */
N} gdc_rsdsoutmode_e;
N
N/* Reduced Swing Differential Signaling Pre-Emphasis Mode */
Ntypedef enum tag_gdc_rsdspreemp_e
N{
N    GDC_RSDSPEMD_HIGH      = 0x0U,                    /* high */
N    GDC_RSDSPEMD_MEDIUM    = 0x1U,                    /* medium */
N    GDC_RSDSPEMD_LOW       = 0x2U,                    /* low */
N    GDC_RSDSPEMD_DISABLE   = 0x3U                     /* pre-emp disabled */
N} gdc_rsdspreemp_e;
N
N
N
N/* Data-data alignment */
Ntypedef enum tag_gdc_ddal_e
N{
N    GDC_ALIGNED =  0x0U,                    /* Aligned */
N    GDC_DELAYED =  0x1U                     /* Hal a cycle delayed */
N} gdc_ddal_e;
N
N/* Data-clock Alignment */
Ntypedef enum tag_gdc_dcal_e
N{
N    GDC_RISING  = 0x0U,                     /* Output changes with rising edge */
N    GDC_FALLING = 0x1U                      /* Output changes with falling edge */
N} gdc_dcal_e;
N
N/* *** */
N
N/*
N *  GDCCLUT parameter values
N */
N
N/* Color correction CLUT channel selection */
Ntypedef enum tag_gdc_clut_e
N{
N    GDC_CLUT_RED   = 0x0U,                  /* Red CLUT */
N    GDC_CLUT_GREEN = 0x1U,                  /* Green CLUT */
N    GDC_CLUT_BLUE  = 0x2U                   /* Blue CLUT */
N} gdc_clut_e;
N
N/* *** */
N
N/*
N *  GDCBAR parameter values
N */
N
N/* Capture buffer selection */
Ntypedef enum tag_gdc_cbuff_e
N{
N    GDC_CBUFF1 = 0x0U,                      /* Capture buffer 0 - first */
N    GDC_CBUFF2 = 0x1U,                      /* Capture buffer 1 - second */
N    GDC_CBUFF3 = 0x2U                       /* Capture buffer 2 - third */
N} gdc_cbuff_e;
N
N/* *** */
N
N/*
N * GDCSCVRx parameter values
N */
N
N/* Selective color correction compare activation */
Ntypedef enum tag_gdc_active_e
N{
N    GDC_DEACTIVATED = 0,                    /* Active */
N    GDC_ACTIVATED   = 1                     /* Inactive */
N} gdc_active_e;
N
N/* Selective color correction compare values */
Ntypedef enum tag_gdc_cmp_e
N{
N    GDC_CCVAL0 = 0,                         /* Compare value 0 */
N    GDC_CCVAL1 = 1,                         /* Compare value 1 */
N    GDC_CCVAL2 = 2,                         /* Compare value 2 */
N    GDC_CCVAL3 = 3,                         /* Compare value 3 */
N    GDC_CCVAL4 = 4,                         /* Compare value 4 */
N    GDC_CCVAL5 = 5,                         /* Compare value 5 */
N    GDC_CCVAL6 = 6,                         /* Compare value 6 */
N    GDC_CCVAL7 = 7                          /* Compare value 7 */
N} gdc_cmp_e;
N
N/* *** */
N
N/*
N *  GDCAPCR parameter values
N */
N
N/* APC mode */
Ntypedef enum tag_gdc_apcm_e
N{
N    GDC_CPU_COMP  = 0,                      /* CPU mode */
N    GCD_AUTO_COMP = 1                       /* AUTO mode */
N} gdc_apcm_e;
N
N/* APC pixel value */
Ntypedef enum tag_gdc_apcp_e
N{
N    GDC_CURR_PIXVAL  = 0,                   /* Current mode */
N    GCD_PREV_PIXVAL  = 1                    /* Previous mode */
N} gdc_apcp_e;
N
N
N/* *** */
N
N/*
N *  GDCPROTR parameter values
N */
N
N/* Write protection level for GDC registers */
Ntypedef enum tag_gdc_write_protect_e
N{
N    GDC_WR_PROTECT_NONE            = 0x00U,   /* no protection                         */
N    GDC_WR_PROTECT_DISPL_CONFIG    = 0x01U,   /* display configuration write-protected */
N    GDC_WR_PROTECT_FEATURE_SWITCH  = 0x02U,   /* feature switches write-protected      */
N    GDC_WR_PROTECT_LAYER_PARAMS    = 0x03U    /* ayer parameters write-protected       */
N} gdc_write_protect_e;
N
N
N
N
N/* *** */
N
N/* Display Pulse Generator
N *  GDCGPCR-A, -B, -C parameter values
N */
N
N/* General purpose Pulse Generator: pulse generator selection */
Ntypedef enum tag_gdc_pg_gen_id_e
N{
N    GDC_PULSE_GEN_0  = 0x0U,      /* Pulse #0  Generator */
N    GDC_PULSE_GEN_1  = 0x1U,      /* Pulse #1  Generator */
N    GDC_PULSE_GEN_2  = 0x2U,      /* Pulse #2  Generator */
N    GDC_PULSE_GEN_3  = 0x3U,      /* Pulse #3  Generator */
N    GDC_PULSE_GEN_4  = 0x4U,      /* Pulse #4  Generator */
N    GDC_PULSE_GEN_5  = 0x5U,      /* Pulse #5  Generator */
N    GDC_PULSE_GEN_6  = 0x6U,      /* Pulse #6  Generator */
N    GDC_PULSE_GEN_7  = 0x7U,      /* Pulse #7  Generator */
N    GDC_PULSE_GEN_8  = 0x8U,      /* Pulse #8  Generator */
N    GDC_PULSE_GEN_9  = 0x9U,      /* Pulse #9  Generator */
N    GDC_PULSE_GEN_10 = 0xAU,      /* Pulse #10 Generator */
N    GDC_PULSE_GEN_11 = 0xBU       /* Pulse #11 Generator */
N} gdc_pg_gen_id_e;
N
N
N/* General purpose Pulse Generator: output clock gating enable */
Ntypedef enum tag_gdc_pg_cgsel_e
N{
N    GDC_PULSE = 0x0U,                       /* Output general purpose pulse */
N    GDC_DCLK  = 0x1U                        /* Output dotclock gated with general purpose pulse */
N} gdc_pg_cgsel_e;
N
N/* General purpose Pulse Generator: output combined logic output select */
Ntypedef enum tag_gdc_pg_outsel_e
N{
N    GDC_PGA          = 0x0U,      /* Pulse generator (PGA) */
N    GDC_PGA_AND_PGB  = 0x1U,
N    GDC_PGA_NAND_PGB = 0x2U,
N    GDC_PGA_OR_PGB   = 0x3U,
N    GDC_PGA_NOR_PGB  = 0x4U,
N    GDC_PGA_XOR_PGB  = 0x5U,
N    GDC_PGA_XNOR_PGB = 0x6U,
N    GDC_PGB          = 0x7U        /* Pulse Generator (PGB) */
N} gdc_pg_outsel_e;
N
N/* General purpose Pulse Generator: Trigger selection */
Ntypedef enum tag_gdc_pg_trigger_e
N{
N    GDC_TRIG_VSYNK  = 0x2U,
N    GDC_TRIG_HSYNC  = 0x3U,
N    GDC_TRIG_VDISP  = 0x4U,
N    GDC_TRIG_HDISP  = 0x5U,
N    GDC_TRIG_PNL    = 0x6U
N} gdc_pg_trigger_e;
N
N/* *** */
N
N/* Display Pulse Generator
N *  parameter values for  General purpose Pulse Generator 
N *  GDCPxGxR  Px: P0..P11 /GxR: GAR, GBR
N */
N/* Pulse generator A or B: */
Ntypedef enum tag_gdc_pg_A_B_e
N{
N    GDC_PULSE_GEN_A = 0x0U,
N    GDC_PULSE_GEN_B = 0x1U
N} gdc_pg_A_B_e;
N
N/* Pulse generator input signal select: */
Ntypedef enum tag_gdc_pg_input_e
N{
N    GDC_INP_DOTCLK = 0x1U,
N    GDC_INP_VSYNK  = 0x2U,
N    GDC_INP_HSYNC  = 0x3U,
N    GDC_INP_VDISP  = 0x4U,
N    GDC_INP_HDISP  = 0x5U,
N    GDC_INP_PNL    = 0x6U
N} gdc_pg_input_e;
N
N/* Pulse generator active level select:: */
Ntypedef enum tag_gdc_pg_active_level_e
N{
N    GDC_ACTIVE_LVL_0 = 0x0U,   /* active level is 0 */
N    GDC_ACTIVE_LVL_1 = 0x1U    /* active level is 1 */
N} gdc_pg_active_level_e;
N
N/*Divider value is defined by DIV+1 */
Ntypedef enum tag_gdc_pg_divider_e
N{
N    GDC_DIVIDER_BYPASS   = 0x00U,
N    GDC_DIVIDER_2        = 0x01U,
N    GDC_DIVIDER_3        = 0x02U,
N    GDC_DIVIDER_4        = 0x03U,
N    GDC_DIVIDER_5        = 0x04U,
N    GDC_DIVIDER_6        = 0x05U,
N    GDC_DIVIDER_7        = 0x06U,
N    GDC_DIVIDER_8        = 0x07U,
N    GDC_DIVIDER_9        = 0x08U,
N    GDC_DIVIDER_10       = 0x09U,
N    GDC_DIVIDER_11       = 0x0AU,
N    GDC_DIVIDER_12       = 0x0BU,
N    GDC_DIVIDER_13       = 0x0CU,
N    GDC_DIVIDER_14       = 0x0DU,
N    GDC_DIVIDER_15       = 0x0EU,
N    GDC_DIVIDER_16       = 0x0FU
N} gdc_pg_divider_e;
N
N
N/*
N *  GDCGBECR parameter values
N */
N/* Read / Write Direction */
Ntypedef enum tag_gdc_buserr_dir_e
N{
N    GDC_BUSERR_READ_TRANSF   = 0x0U,
N    GDC_BUSERR_WRITE_TRANSF  = 0x1U
N} gdc_buserr_dir_e;
N
N/* Burst Type */
Ntypedef enum tag_gdc_buserr_bursttype_e
N{
N    GDC_BUSERR_BURST_TYPE_FIXED   = 0x0U,
N    GDC_BUSERR_BURST_TYPE_INCR    = 0x1U
N} gdc_buserr_bursttype_e;
N
N/* Burst Size */
Ntypedef enum tag_gdc_buserr_burstsize_e
N{
N    GDC_BUSERR_BURST_1BYTE     = 0x0U,
N    GDC_BUSERR_BURST_2BYTE     = 0x1U,
N    GDC_BUSERR_BURST_4BYTE     = 0x2U,
N    GDC_BUSERR_BURST_81BYTE    = 0x3U,
N    GDC_BUSERR_BURST_16BYTE    = 0x4U,
N    GDC_BUSERR_BURST_32BYTE    = 0x5U,
N    GDC_BUSERR_BURST_64BYTE    = 0x6U,
N    GDC_BUSERR_BURST_128BYTE   = 0x7U
N} gdc_buserr_burstsize_e;
N
N
N/* Response Type */
Ntypedef enum tag_gdc_buserr_resptype_e
N{
N    GDC_BUSERR_RESP_OK        = 0x0U,
N    GDC_BUSERR_RESP_EXOKAY    = 0x1U,
N    GDC_BUSERR_RESP_SLVERR    = 0x2U,
N    GDC_BUSERR_RESP_DECERR    = 0x3U
N} gdc_buserr_resptype_e;
N
N
N/* *** */
N
N
N/*********************************************/
N
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N
N/* Frame buffer configuration structure */
Ntypedef struct tag_gdc_fbcfg_st
N{
N    gdc_frmbuff_e eBuff;                    /* Frame buffer selection (default/second) */
N    uint32_t      u32Addr;                  /* Frame buffer physical start address */
N    uint16_t      u16Width;                 /* Frame buffer memory width (line width), limited to 13-bits */
N} gdc_fbcfg_st;
N
N/* Synchronization configuration structure */
Ntypedef struct tag_gdc_sync_st
N{
N    gdc_csync_e eSyncType;                  /* Selects between VSYNC and CSYNC type */
N    gdc_pol_e   eVSyncPol;                  /* Polarity of VSYNC */
N    gdc_pol_e   eHSyncPol;                  /* Polarity of HSYNC */
N    uint8_t     u8HsyncWdth;                /* Width of HSYNC (dot-clocks) */
N    uint8_t     u8VsyncWdth;                /* Width of VSYNC (lines) */
N    uint16_t    u16HLineLen;                /* Horizontal line length (dot-clocks) */
N    uint16_t    u16VFrameLen;               /* Vertical frame length (lines) */
N} gdc_sync_st;
N
N/* IRQ configuration structure */
Ntypedef struct tag_gdc_irqcgf_st
N{
N    gdc_en_e eAPCIrqEn;                     /* Automatic Pixel Checker (APC) Mask */
N    uint16_t u16LineNr;                     /* Line Number HSYNCINT [Range 0x0 - 0x7FF] */
N    gdc_en_e eHSyncIrqEn;                   /* HSYNCINT Mask */
N    gdc_en_e eVSyncIrqEn;                   /* VSYNCINT Mask */
N    gdc_en_e eIfurIrqEn;                    /* IFURINT IRQ Mask */
N    gdc_en_e eOfurIrqEn;                    /* IFURINT IRQ Mask */
N} gdc_irqcgf_st;
N
N/* APC configuration structure */
Ntypedef struct tag_gdc_apccfg_st
N{
N    gdc_apcm_e eMode;                       /* APC Mode */
N    uint8_t    u8Frames;                    /* 7 bits:  Computation interval length [in frames] */
N    uint8_t    u8WWidth;                    /* 8 bits:  Window width */
N    uint8_t    u8WHeight;                   /* 7 bits:  Window height */
N    uint16_t   u16HStart;                   /* 12 bits: Horizontal start position */
N    uint16_t   u16VStart;                   /* 11 bits: Vertical start position */
N    uint32_t   u32AutoChkSum;               /* 22 bits: Expected checksum in AUTO mode */
N} gdc_apccfg_st;
N
N/* GDC bus Error Control Signal-Structure */
Ntypedef struct tag_gdc_bus_err_ctrl_st
N{
N    gdc_buserr_dir_e        eDirection;       /* Read / Write direction */
N    gdc_buserr_bursttype_e  eBurstType;       /* Burst type */
N    gdc_buserr_burstsize_e  eBurstSize;       /* Burst size */
N    gdc_buserr_resptype_e   eRespType;        /* Response Type */
N    uint8_t                 u8ByteEnables;    /* Byte-enables for the erroneous transfer. */
N    uint8_t                 u8ID;             /* ID tag of the read/write transaction that triggered an error response. */
N    uint8_t                 u8BurstLength;    /* Burst length of the read/write transaction that triggered an error response */
N} gdc_bus_err_ctrl_st;
N
N
N/* Structure for General Purpose Pulse Generator Registers (GDCPnGxR) */
Ntypedef struct tag_gdc_pulse_config_st
N{
N    gdc_pg_active_level_e   eActiveLevel;    /* Pulse generator active level select: */
N    gdc_pg_input_e          eSelectedInput;  /* Pulse generator input signal select: */
N    gdc_en_e                eByPassEnb;      /* Pulse generator bypass enable: */
N    uint16_t                u16PulseDelay;   /* Delay of generated pulse */
N    gdc_pg_divider_e        ePulseDivider;   /* Divider value is defined by DIV+1 */
N    gdc_en_e                eInvertEnb;      /* Pulse generator inversion enable: */
N    uint16_t                u16PulseWidth;   /* Width of generated pulse, measured in dot clock cycles for all input sources but VSYNC and VDISP */
N} gdc_pulse_config_st;
N
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N
N/****************************************************************************
N *
N * Function:      vGDC_GetVersion
N *
N * Purpose:       Retrieve pointers to module and header revision and tag string
N *
N * Inputs:        none
N *
N * Outputs:       pau8ModuleRevision - pointer to module revision string
N *                pau8ModuleTag      - pointer to module tag string
N *                pau8HeaderRevision - pointer to header revision string
N *                pau8HeaderTag      - pointer to header tag string
N *                pau8IORevision     - pointer to IO header revision string
N *                pau8IOTag          - pointer to IO header tag string
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGDC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                     uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                     uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/***************************************************************************
N*
N*                  G E N E R A L    C O N F I G U R A T I O N
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_Init
N *
N * Purpose:       Initializes the GDC driver and the register shadow list
N *                for the controller specified
N *
N * Inputs:        eGDC     Controller channel
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   The clock gating for the controller must be enabled first!
N *                [Please refer to CCRCR register description]
N *
N ***************************************************************************/
Nvoid vGDC_Init(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_Switch
N *
N * Purpose:       Switch GDC output On/Off
N *
N * Inputs:        eGDC     Controller channel
N *                eSwitch  On/off request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_Switch(gdc_ch_e eGDC, gdc_on_e eSwitch);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetShadowRegUpdateMode
N *
N * Purpose:       Set the mechanism of shadow register updating. 
N *
N * Inputs:        eGDC     Controller channel
N *                eCtrl    Updating mechanism
N *                         Important NOTE: 
N *                         GDC_UPDATE_BY_NEXT_VSYNC_ONLY: this mode can be used to 
N *                         disable update shadow register option. In this case
N *                         user application should wait after after the call, until
N *                         update register bit has been set to 0 by HW (eGetShadowRegUpdateStatus()     
N *
N * Outputs:       none
N *
N * Return Values: void
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGDC_SetShadowRegUpdateMode(gdc_ch_e eGDC, gdc_reg_update_mode_e eCtrl);
N
N
N/****************************************************************************
N *
N * Function:      eGetShadowRegUpdateStatus
N *
N * Purpose:       Gets the actual update mode for shadow register from HW. 
N *                NOTE: If last setting was "GDC_UPDATE_BY_NEXT_VSYNC_ONLY", 
N *                      the HW will reset it to "0" by next VSync.
N *
N * Inputs:        eGDC     Controller channel
N *
N * Outputs:       none
N *
N * Return Values: status of shadow register update
N *
N * Limitations:   none
N *
N ***************************************************************************/
Ngdc_reg_update_status_e eGetShadowRegUpdateStatus(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_ADBSEnable
N *
N * Purpose:       Enable/disable the "Automatic buffer switching" for all
N *                layers
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_ADBSEnable(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_ColorCorrectEnable
N *
N * Purpose:       Enable/disable the per channel color correction
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_ColorCorrectEnable(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetArthMode
N *
N * Purpose:       Select the artifact handling mode
N *
N * Inputs:        eGDC   Controller channel
N *                eMode  Artifact handling mode
N *                eLoc   Artifact handling location
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetArthMode(gdc_ch_e eGDC, gdc_arth_e eMode, gdc_arthcd_e eLoc);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetDitheringMode
N *
N * Purpose:       Select the artifact handling mode
N *
N * Inputs:        eGDC   Controller channel
N *                eDith  Deithering mode
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetDitheringMode(gdc_ch_e eGDC, gdc_dithering_e eDith);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetBgrColor
N *
N * Purpose:       Set the background color
N *
N * Inputs:        eGDC      Controller channel
N *                u32Color  Background color in a RGB16 format:
N *                              Red   : u32Color[23:16]
N *                              Green : u32Color[15:8]
N *                              Blue  : u32Color[7:0]
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   The color data is internally adjusted to the register layout
N *                [shifted left by 8 bits to adjust the bit values]
N *
N ***************************************************************************/
Nvoid vGDC_SetBgrColor(gdc_ch_e eGDC, uint32_t u32Color);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_GetDispStat
N *
N * Purpose:       Retrieve the display interface status [enabled/disabled]
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       none
N *
N * Return Values: Interface enabled/disabled status
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Ngdc_en_e eGDC_GetDispStat(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_GetPanelStat
N *
N * Purpose:       Retrieve the panel interface status [enabled/disabled]
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       none
N *
N * Return Values: Interface enabled/disabled status
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Ngdc_en_e eGDC_GetPanelStat(gdc_ch_e eGDC);
N
N
N#ifndef _EXTENDED_GDC_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      vGDC_SetGdcWriteProtection
N *
N * Purpose:       Defines level of Write protection for GDC control registers
N *                a register .
N *
N * Inputs:        eGDC         Controller channel
N *                eProtection  Protection Level
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGDC_SetGdcWriteProtection(gdc_ch_e eGDC, gdc_write_protect_e eProtection);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_GAPIFEnable
N *
N * Purpose:       Enable/Disable GA-Programming Interface (GAPIF)
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable GAPIF
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_GAPIFEnable(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_AccessToGapif
N *
N * Purpose:       Check if GA-Programming Interface (GAPIF) has been accessed
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       none
N *
N * Return Values: Access(C_TRUE)/ No access (C_FALSE)
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_AccessToGapif(gdc_ch_e eGDC);
N
N
N#endif /* _EXTENDED_GDC_APIS_DISABLED_ */
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                             D O T  -  C L O C K
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_SelDotClkSrc
N *
N * Purpose:       Configure the dot-clock source [internal/external]
N *
N * Inputs:        eGDC  Controller channel
N *                eSel  Source selection
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   !!! >>>  ATTENTION  <<< !!!
N *                When using internal clock, please pay attention on output
N *                drivers as they can be damaged. For more information about
N *                this topic, please refer to the Capricorn data-book
N *
N ***************************************************************************/
Nvoid vGDC_SelDotClkSrc(gdc_ch_e eGDC, gdc_idc_e eSel);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetDotClkPol
N *
N * Purpose:       Configure the dot-clock polarity [positive/negative]
N *
N * Inputs:        eGDC  Controller channel
N *                ePol  Polarity request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetDotClkPol(gdc_ch_e eGDC, gdc_pol_e ePol);
N
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                      L A Y E R    M A N I P U L A T I O N
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      i32GDC_LayerEnable
N *
N * Purpose:       Enable/disable a layer
N *
N * Inputs:        eGDC    Controller channel
N *                eLayer  Layer selection
N *                eEn     Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid layer
N *
N * Limitations:   Process one layer at a time
N *
N ***************************************************************************/
Nint32_t i32GDC_LayerEnable(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetDataFormat
N *
N * Purpose:       Set the data format (32-bit RGBA/16-bit RGB/32-bit ARGB)
N *                for a layer
N *
N * Inputs:        eGDC    Controller channel
N *                eLayer  Layer selection
N *                eFmt    Data format (32-bit RGBA/16-bit RGB/32-bit ARGB)
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on invalid layer or invalid pixel format
N *
N * Limitations:   The proper operation depends on the bit layout, thus it
N *                it must not to be changed: bit 0 of the eFmt parameter
N *                determines the data bit-width, whereas bit 1 determines
N *                the alpha position, which is not appicable and therefore
N *                ignored in 16-bit mode
N *
N ***************************************************************************/
Nint32_t i32GDC_SetDataFormat(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_dfmt_e eFmt);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetLayerStart
N *
N * Purpose:       Configure the layer start position of a layer [A, B, C,
N *                D or E]
N *
N * Inputs:        eGDC       Controller channel
N *                eLayer     Layer selection
N *                u16HStart  Horizontal start position in dot-clocks, counted
N *                           from the leading edge of HSYNC, being in the range
N *                           [64 - 2047]
N *                u16VStart  Vertical start position in number of lines,
N *                           counted from the leading edge of VSYNC, being in
N *                           the range [64 - 1023]
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one layer at a time. Start position parameters
N *                will be truncated to 11 and 10 bits respectively. All
N *                reserved bits will be kept as zeros. No parameter
N *                validity check is performed
N *
N ***************************************************************************/
Nvoid vGDC_SetLayerStart(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16HStart, uint16_t u16VStart);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetLayerSize
N *
N * Purpose:       Set the layer size [width * height] for a layer [A, B,
N *                C, D or E]
N *
N * Inputs:        eGDC      Controller channel
N *                eLayer    Layer selection
N *                u16Width  Horizontal size in the range [64-4095]
N *                u16Height Vertical size in the range [32-2047]
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on invalid lower width range
N *
N * Limitations:   Process one layer at a time. Start position parameters
N *                will be truncated to 12 and 11 bits respectively. All
N *                reserved bits will be kept as zeros. No further parameter
N *                validity check is performed
N *
N ***************************************************************************/
N int32_t i32GDC_SetLayerSize(gdc_ch_e eGDC, gdc_layer_e eLayer,
N                             uint16_t u16Width, uint16_t u16Height);
N 
N 
N/****************************************************************************
N *
N * Function:      vGDC_SetLayerOrder
N *
N * Purpose:       Select the layer order  [A-B-C-D-E or A-C-B-D-E]
N *
N * Inputs:        eGDC    Controller channel
N *                eOrder  Layer order selection
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetLayerOrder(gdc_ch_e eGDC, gdc_vord_e eOrder);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetCommonAlpha
N *
N * Purpose:       Set the comon alpha value for a layer or a display window
N *                in the range [A, B, C, D, E]
N *
N * Inputs:        eGDC     Controller channel
N *                eEntity  Layer or display window
N *                u8Alpha  Alpha value in the range [0x00 - 0xFF], where:
N *                             0x00 - transparent
N *                             0xFF - opaque
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid layer/display window
N *
N * Limitations:   Process one layer/display window at a time
N *
N ***************************************************************************/
Nint32_t i32GDC_SetCommonAlpha(gdc_ch_e eGDC, gdc_seg_e eEntity, uint8_t u8Alpha);
N
N
N/****************************************************************************
N *
N * Function:      u8GDC_GetCommonAlpha
N *
N * Purpose:       Retrieve the comon alpha value for a layer or a display
N *                window in the range [A, B, C, D, E]
N *
N * Inputs:        eGDC      Controller channel
N *                eEntity   Layer or display window
N *                pu8Alpha  Result destination
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid layer/display window
N *
N * Limitations:   Process one layer/display window at a time
N *
N ***************************************************************************/
Nint32_t i32GDC_GetCommonAlpha(gdc_ch_e eGDC, gdc_seg_e eEntity, uint8_t* pu8Alpha);
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                          F R A M E -  B U F F E R
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      i32GDC_FrameBuffConfig
N *
N * Purpose:       Configure a frame buffer for layer A, B, C, D or E
N *
N * Inputs:        eGDC        Controller channel
N *                eLayer      Layer selection [A, B, C, D or E]
N *                pstBuffCfg  Pointer to frame buffer configuration
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid layer
N *
N * Limitations:   Process one layer at a time. The scroll bits will
N *                be modified. All reserved bits are hard-wired to
N *                zero and will not be modified even a different
N *                value is passed!
N *
N ***************************************************************************/
Nint32_t i32GDC_FrameBuffConfig(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_fbcfg_st* pstBuffCfg);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_GetActiveFrameBuff
N *
N * Purpose:       Check the next active frame buffer for all layers
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Next active buffer
N *
N * Return Values: none
N *
N * Limitations:   Process one layer at a time
N *
N ***************************************************************************/
Ngdc_frmbuff_e eGDC_GetActiveFrameBuff(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetMemWidth
N *
N * Purpose:       Set the image width of the frame buffer memory in number
N *                of dots
N *
N * Inputs:        eGDC      Controller channel
N *                eLayer    Layer selection [A, B, C, D or E]
N *                u16Width  Horizontal line length of the frame buffer image,
N *                          limited to 13-bits for all layers
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one segment at a time. No parameter range check
N *                is performed
N *
N ***************************************************************************/
Nvoid vGDC_SetMemWidth(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16Width);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetLayerStartAddr
N *
N * Purpose:       Configure the start address of a layer [A, B, C, D or E]
N *
N * Inputs:        eGDC     Controller channel
N *                eLayer   Layer selection
N *                eBuff    Frame Buffer selection [Default or second (in case
N *                         of double buffering only)]
N *                u32Addr  Frame Buffer 32-bit physical start address
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid layer
N *
N * Limitations:   Any previous existing scroll value will be kept. Bit 0 is
N *                hard-wired to zero and will not be modified even a different
N *                value is passed. Process one layer at a time
N *
N ***************************************************************************/
Nint32_t i32GDC_SetLayerStartAddr(gdc_ch_e eGDC, gdc_layer_e eLayer,
N                                 gdc_frmbuff_e eBuff, uint32_t u32Addr);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetScrollVal
N *
N * Purpose:       Set the scroll value of a layer [A, B, C, D or E]
N *
N * Inputs:        eGDC      Controller channel
N *                eLayer    Layer selection
N *                eBuff     Frame Buffer selection [Default or second (in case
N *                         of double buffering only)]
N *                u8ScrVal  Scrolling value
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid layer
N *
N * Limitations:   Process one layer at a time. Both SSCROLL bits will be
N *                set regardless of the data format mode [32-bit/16-bit],
N *                thus scrolling value validation has to be done by the
N *                caller of this API
N *
N ***************************************************************************/
Nint32_t i32GDC_SetScrollVal(gdc_ch_e eGDC, gdc_layer_e eLayer,
N                            gdc_frmbuff_e eBuff, uint8_t u8ScrVal);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetStartAddrCapture
N *
N * Purpose:       Set the start address of a capture buffer
N *
N * Inputs:        eGDC     Controller channel
N *                eBuff    Capture buffer [0, 1 or 2]
N *                u32Addr  Capture buffer physical start address
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   That last three bits of the address [2:0] are hard-wired
N *                to zero, thus will be ignored
N *
N ***************************************************************************/
Nvoid vGDC_SetStartAddrCapture(gdc_ch_e eGDC, gdc_cbuff_e eBuff, uint32_t u32Addr);
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*          P E R    C H A N N E L    C O L O R    C O R R E C T I O N
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_InitCorrClut
N *
N * Purpose:       Initialize a color correction look-up table [Red, Green, Blue]
N *
N * Inputs:        eGDC     Controller channel
N *                eClut    CLUT table selection
N *                pu8Data  Pointer to buffer with the 256x 8-bit entries
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Access is based on relative controller offset, as defined
N *                in gdc_ch_e. Process one table at a time
N *
N ***************************************************************************/
Nvoid vGDC_InitCorrClut(gdc_ch_e eGDC, gdc_clut_e eClut, const uint8_t* pu8Data);
N
N
N/****************************************************************************
N *
N * Function:      bovGDC_SetSelectCorrCompVal
N *
N * Purpose:       Set a selective color correction compare value
N *
N * Inputs:        eGDC            Controller channel
N *                eSelection      Selected CCV
N *                u32CorrCompVal  Compare value to be set
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one value at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetSelectCorrCompVal(gdc_ch_e eGDC,  gdc_cmp_e eSelection, uint32_t u32CorrCompVal);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_ActivateCorrCompVal
N *
N * Purpose:       Activate a selective color correction compare value
N *
N * Inputs:        eGDC        Controller channel
N *                eSelection  Selected CCV
N *                eActive     Activate/deactivate request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one value at a time
N *
N ***************************************************************************/
Nvoid  vGDC_ActivateCorrCompVal(gdc_ch_e eGDC, gdc_cmp_e eSelection, gdc_active_e eActive);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_EnableSelectiveCorr
N *
N * Purpose:       Enable/disable the selective color correction in a specified
N *                mode
N *
N * Inputs:        eGDC   Controller channel
N *                eEn    Enable/disable request
N *                eMode  Correction mode
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_EnableSelectiveCorr(gdc_ch_e eGDC, gdc_en_e eEn, gdc_ccmode_e eMode);
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                               D I S P L A Y
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_SetDispConfigType
N *
N * Purpose:       Set display config type
N *
N * Inputs:        eGDC             Controller channel
N *                eDispConfigType  Display config type
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process a controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetDispConfigType(gdc_ch_e eGDC, gdc_disp_config_type_e eDispConfigType);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetDisplayStart
N *
N * Purpose:       Configure the display start position
N *
N * Inputs:        eGDC       Controller channel
N *                u16HStart  Horizontal start position in dot-clocks, counted
N *                           from the leading edge of HSYNC, being in the range
N *                           [64 - 2047]
N *                u16VStart  Vertical start position in number of lines,
N *                           counted from the leading edge of VSYNC, being in
N *                           the range [64 - 1023]
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on invalid lower width range
N *
N * Limitations:   Process one layer at a time. Start position parameters
N *                will be truncated to 10 and 10 bits respectively. All
N *                reserved bits will be kept as zeros. No parameter
N *                validity check is performed
N *
N ***************************************************************************/
Nint32_t i32GDC_SetDisplayStart(gdc_ch_e eGDC, uint16_t u16HStart, uint16_t u16VStart);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetDisplaySize
N *
N * Purpose:       Set the layer size [width * height]
N *
N * Inputs:        eGDC      Controller channel
N *                u16Width  Horizontal display width using number of dots [64-2047]
N *                u16Height Vertical display height using number of lines [1-1023]
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on invalid lower width range
N *
N * Limitations:   Process one layer at a time. Start position parameters
N *                will be truncated to 12 and 11 bits respectively. All
N *                reserved bits will be kept as zeros. No further parameter
N *                validity check is performed
N *
N ***************************************************************************/
N int32_t i32GDC_SetDisplaySize(gdc_ch_e eGDC, uint16_t u16Width, uint16_t u16Height);
N
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                                W I N D O W
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_WindowEnable
N *
N * Purpose:       Enable/disable a layer's display window
N *
N * Inputs:        eGDC     Controller channel
N *                eWindow  Window
N *                eEn      Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one window at a time
N *
N ***************************************************************************/
Nvoid vGDC_WindowEnable(gdc_ch_e eGDC, gdc_win_e eWindow, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetWindowSize
N *
N * Purpose:       Set a display window size [width & height]
N *
N * Inputs:        eGDC       Controller channel
N *                eWindow    Window selection [A, B, C, D or E]
N *                u16Width   Horizontal window size in the range [64-4095]
N *                u16Height  Vertical window size in the range [32-2047]
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on invalid lower width range
N *
N * Limitations:   Process one window at a time. Start position parameters
N *                will be truncated to 12 and 11 bits respectively. All
N *                reserved bits will be kept as zeros. No further parameter
N *                validity check is performed
N *
N ***************************************************************************/
Nint32_t i32GDC_SetWindowSize(gdc_ch_e eGDC, gdc_win_e eWindow,
N                             uint16_t u16Width, uint16_t u16Height);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetWindowStartPos
N *
N * Purpose:       Configure the window start position of a layer [A, B, C,
N *                D or E]
N *
N * Inputs:        eGDC       Controller channel
N *                eWindow    Window selection
N *                u16HStart  Horizontal start position in dot-clocks, counted
N *                           from the leading edge of HSYNC [64..2047]
N *                u16VStart  Vertical start position in number of lines,
N *                           counted from the leading edge of VSYNC [64..1023]
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one window at a time. Start position parameters
N *                will be truncated to 11 and 10 bits respectively. All
N *                reserved bits will be kept as zeros. No parameter
N *                validity check is performed
N *
N ***************************************************************************/
Nvoid vGDC_SetWindowStartPos(gdc_ch_e eGDC, gdc_win_e eWindow,
N                            uint16_t u16HStart, uint16_t u16VStart);
N
N
N/****************************************************************************
N *
N * Function:      i32GDC_SetWindowStartAddr
N *
N * Purpose:       Sets the start address of a window [A, B, C, D or E]
N *
N * Inputs:        eGDC     Controller channel
N *                eWindow  Window selection
N *                u32Addr  Frame buffer physical start address
N *
N * Outputs:       none
N *
N * Return Values: C_SUCCESS on success
N *                C_FAILED on ivalid window
N *
N * Limitations:   Bits 2-0 are hard-wired to zero and will not be modified
N *                even a different value is passed. Process one window at
N *                a time
N *
N ***************************************************************************/
Nint32_t i32GDC_SetWindowStartAddr(gdc_ch_e eGDC, gdc_win_e eWindow, uint32_t u32Addr);
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                       S Y N C H R O N I Z A T I O N
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_SyncConfig
N *
N * Purpose:       Configure the VSYNC and HSYNC signals by setting type,
N *                polarity, signal width, line-length and vertical frame
N *                length for a controller
N *
N * Inputs:        eGDC         Controller channel
N *                pstSyncCfg   Pointer to HSYNC/VSYNC configuration structure
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time. No parameter range or
N *                validity checks are performed
N *
N ***************************************************************************/
Nvoid vGDC_SyncConfig(gdc_ch_e eGDC, gdc_sync_st* pstSyncCfg);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetSyncDir
N *
N * Purpose:       Set the direction of VSYNC and HSYNC lines
N *
N * Inputs:        eGDC  Controller channel
N *                eDir  HSYNC/VSYNC signal direction
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N *                                !!! >>>  ATTENTION  <<< !!!
N *                When using external sync signals, the output drivers can
N *                be damaged if the direction is configure to output !!!
N *
N ***************************************************************************/
Nvoid vGDC_SetSyncDir(gdc_ch_e eGDC, gdc_dir_e eDir);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SelectCompSync
N *
N * Purpose:       Set composite signal synchronization
N *
N * Inputs:        eGDC   Controller channel
N *                eSync  VSYNC/CSYNC selection request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SelectCompSync(gdc_ch_e eGDC, gdc_csync_e eSync);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPolVSync
N *
N * Purpose:       Select the VSYNC mode [negative/positive], where:
N *                    negative => DISP_vsync is low active
N *                    positive => DISP_vsync is high active
N *
N * Inputs:        eGDC   Controller channel
N *                eMode  Positive/negative mode request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPolVSync(gdc_ch_e eGDC, gdc_pol_e eMode);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPolHSync
N *
N * Purpose:       Select the HSYNC mode [negative/positive], where:
N *                    negative => DISP_hsync is low active
N *                    positive => DISP_hsync is high active
N *
N * Inputs:        eGDC   Controller channel
N *                eMode  Positive/negative mode request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPolHSync(gdc_ch_e eGDC, gdc_pol_e eMode);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPolHDisp
N *
N * Purpose:       Select the HDISP mode [negative/positive], where:
N *                    negative => DISP_hdisp is low active
N *                    positive => DISP_hdisp is high active
N *
N * Inputs:        eGDC   Controller channel
N *                eMode  Positive/negative mode request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPolHDisp(gdc_ch_e eGDC, gdc_pol_e eMode);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetHSync
N *
N * Purpose:       Set the HSYNC pulse width and line length
N *
N * Inputs:        eGDC          Controller channel
N *                u8PulseWidth  Pulse width in number of dot-clocks
N *                u16LineLen    Line length in number of dot-clocks
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time. No parameter validity
N *                check is performed
N *
N ***************************************************************************/
Nvoid vGDC_SetHSync(gdc_ch_e eGDC, uint8_t u8PulseWidth, uint16_t u16LineLen);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetVSync
N *
N * Purpose:       Set the VSYNC pulse width and vertical frame length
N *
N * Inputs:        eGDC           Controller channel
N *                u8PulseWidth   Pulse width in number of lines
N *                u16VFrameLen   Vertical frame length in number of lines
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time. No parameter validity
N *                check is performed
N *
N ***************************************************************************/
Nvoid vGDC_SetVSync(gdc_ch_e eGDC, uint8_t u8PulseWidth, uint16_t u16VFrameLen);
N
N
N/****************************************************************************
N *
N * Function:      u32GDC_GetPolVSync
N *
N * Purpose:       Retrieve the current VSYNC mode [negative/positive], where:
N *                    negative => DISP_vsync is low active
N *                    positive => DISP_vsync is high active
N *
N * Inputs:        eGDC   Controller channel
N *
N * Outputs:       Current mode
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nuint32_t u32GDC_GetPolVSync(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      u32GDC_GetStatVSync
N *
N * Purpose:       Retrieve the current vertical synchronization signal status
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Current signal status
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nuint32_t u32GDC_GetStatVSync(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      u32GDC_GetStatHSync
N *
N * Purpose:       Retrieve the current horizontal synchronization signal status
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Current signal status
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nuint32_t u32GDC_GetStatHSync(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      u32GDC_GetStatHDisp
N *
N * Purpose:       Retrieve the current status of the horizontal display data
N *                ready signal
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Current signal status
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nuint32_t u32GDC_GetStatHDisp(gdc_ch_e eGDC);
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                             I N T E R R U P T S
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      GDC_IrqConfig
N *
N * Purpose:       Configure all GDC related interrupt sources of a controller
N *
N * Inputs:        eGDC    Controller channel
N *                pstCfg  Pointer to interrupt configuration structure
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_IrqConfig(gdc_ch_e eGDC, gdc_irqcgf_st* pstCfg);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetIrqMaskAPC
N *
N * Purpose:       Enable/disable the Automatic Pixel Checker Interrupt [APCINT]
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetIrqMaskAPC(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetHsyncIrqLine
N *
N * Purpose:       Set the number of lines in which the HSYNCINT should be
N *                generated
N *
N * Inputs:        eGDC        Controller channel
N *                u16LineNr   Line number on which the HSYNC interrupt shall
N *                            be generated. Parameter range is [0x0 - 0x7FF]
N *                            If zero is specified, the interrupt will be
N *                            generated on every line
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetHsyncIrqLine(gdc_ch_e eGDC, uint16_t u16LineNr);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetIrqMaskFifoIn
N *
N * Purpose:       Enable/disable the Input FIFO Underrun Interrupt [IFURINT]
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetIrqMaskFifoIn(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetIrqMaskFifoOut
N *
N * Purpose:       Enable/disable the Output FIFO Underrun Interrupt [OFURINT]
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetIrqMaskFifoOut(gdc_ch_e eGDC, gdc_en_e eEn);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetIrqMaskVSync
N *
N * Purpose:       Enable/disable the VSYNC Interrupt [VSYNCINT]
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetIrqMaskVSync(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetIrqMaskHSync
N *
N * Purpose:       Enable/disable the HSYNC Interrupt [HSYNCINT]
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetIrqMaskHSync(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqHSync
N *
N * Purpose:       Check whether HSYNC Interrupt [HSYNCINT] is active and
N *                clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqHSync(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqVSync
N *
N * Purpose:       Check whether VSYNC Interrupt [VSYNCINT] is active and
N *                clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqVSync(gdc_ch_e eGDC);
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqFifoIn
N *
N * Purpose:       Check whether Input FIFO Underrun Interrupt [IFURINT]
N *                is active and clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqFifoIn(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqFifoOut
N *
N * Purpose:       Check whether Output FIFO Underrun Interrupt [OFURINT]
N *                is active and clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqFifoOut(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqAPC
N *
N * Purpose:       Check whether APC Interrupt [APCINT] is active and clear
N *                the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqAPC(gdc_ch_e eGDC);
N
N
N#ifndef _EXTENDED_GDC_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqGap
N *
N * Purpose:       The function checks whether APC interrupt (GAPINT) is active 
N *                and if it is, clears the corresponding flag. 
N *                Note:
N *                     By clearing GAPINT the error bit GAPCOL in GDCDCR register
N *                     will also be cleared.
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqGap(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqGber
N *
N * Purpose:       Check whether GBUS error Interrupt (GBERINT)is active and
N *                clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqGber(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqGpe
N *
N * Purpose:       Check whether GPEINT Interrupt is active and
N *                clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e  eGDC_IsIrqGpe(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqDle
N *
N * Purpose:       Check whether DLEINT Interrupt is active and
N *                clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqDle(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_IsIrqApe
N *
N * Purpose:       Check whether APEINT Interrupt is active and
N *                clear the corresponding flag
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Active status
N *
N * Return Values: none
N *
N * Limitations:   Interrupt flag will be cleared if it was active. Process
N *                one controller at a time
N *
N ***************************************************************************/
Ngdc_irqact_e eGDC_IsIrqApe(gdc_ch_e eGDC);
N
N
N#endif /* _EXTENDED_GDC_APIS_DISABLED_ */
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*                        P A N E L   I N T E R F A C E
N*                  A P I' s   V A L I D  O N L Y   F O R   GDC0
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_PnlGppOutEnable
N *
N * Purpose:       Enable/disable the General Purpose Pulse Output
N *                Valid only for GDC0
N *
N * Inputs:        ePin  General purpose pin [GPPx]
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_PnlGppOutEnable(gdc_gpp_e ePin, gdc_en_e eEn);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlPositiveSyncSelect
N *
N * Purpose:       Set positive panel synchronization select
N *                Valid only for GDC0
N *
N * Inputs:        eSync    low-/high-active input
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlPositiveSyncSelect(gdc_ppsync_e eSync);
N
N/****************************************************************************
N *
N * Function:      boGDC_IsPnlRSPowerUpFinished
N *
N * Purpose:       Check if Reduced Swing Power Up sequence is finished
N *                Valid only for GDC0
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: C_FALSE  RSDS power up sequence not finished
N *                C_TRUE   RSDS power up sequence finished
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_IsPnlRSPowerUpFinished(void);
N
N/****************************************************************************
N *
N * Function:      boGDC_IsPnlRSReady
N *
N * Purpose:       Check if Reduced Swing DS is ready to be used
N *                Valid only for GDC0
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: C_FALSE  RSDS power up and enable sequence not finished
N *                C_TRUE   RSDS is read to be used
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_IsPnlRSReady(void);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlRSDSEnable
N *
N * Purpose:       Enable Reduced Swing Differential Signaling
N *                Valid only for GDC0
N *
N * Inputs:        eOutput  digital / differential output
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlRSDSEnable(gdc_rsdsen_e eOutput);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlSyncModeEnable
N *
N * Purpose:       Panel Synchronization Mode Enable
N *                Valid only for GDC0
N *
N * Inputs:        eEn      disable / enable to trigger PNL_syncin
N *                         Panel Timing Control Interface Output
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlSyncModeEnable(gdc_en_e eEn);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlRSDSOutputCurrentMode
N *
N * Purpose:       Set RSDS output current mode
N *                Valid only for GDC0
N *
N * Inputs:        eOutMode Output Current mode (high, medium, low, HI-Z)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlRSDSOutputCurrentMode(gdc_rsdsoutmode_e eOutMode);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlRSDSPreEmphasisMode
N *
N * Purpose:       Set RSDS pre-emphasis mode
N *                Valid only for GDC0
N *
N * Inputs:        ePreEmp  pre-emphasis mode (high, medium, low, disabled)
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlRSDSPreEmphasisMode(gdc_rsdspreemp_e ePreEmp);
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlRSDSHighImpedanceEnable
N *
N * Purpose:       Enable RSDS high impedance, or select differential output
N *                Valid only for GDC0
N *
N * Inputs:        eEn      enable high impedance
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlRSDSHighImpedanceEnable(gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_IsPnlInputSync
N *
N * Purpose:       Check if monitoring bit for synchronization input signal
N *                from panel is set
N *                Valid only for GDC0
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: C_FALSE  not synchronized
N *                C_TRUE   synchronized
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_IsPnlInputSync(void);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_IsPnlTimingControlInterfaceEnabled
N *
N * Purpose:       Check if panel timing control interface is enabled
N *                Valid only for GDC0
N *
N * Inputs:        none
N *
N * Outputs:       none
N *
N * Return Values: C_FALSE  panel timing control interface disabled
N *                C_TRUE   panel timing control interface enabled
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_IsPnlTimingControlInterfaceEnabled(void);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlAlignData
N *
N * Purpose:       Set the data alignment between DISP_RGB and PNL_ERGB bus
N *                [DISP_RGB and PNL_ERGB can change values at same clock edge
N *                or PNL_ERGB output is delayed by half of PNL_CLOCK cycle]
N *                Valid only for GDC0
N *
N * Inputs:        eAllign  Alignment request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetAlignData(gdc_ddal_e eAllign);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetPnlAlignClock
N *
N * Purpose:       Set the data to clock alignment [DISP_RGB output can change
N *                with rising or falling DISP_dotclk edge]
N *                Valid only for GDC0
N *
N * Inputs:        eEdge  Active DISP_dotclk edge selection
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetPnlAlignClock(gdc_dcal_e eEdge);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_PnlAlterEnable
N *
N * Purpose:       Enable/disable data alternation [DISP_RGB and PNL_ERGB]
N *                Valid only for GDC0
N *
N * Inputs:        eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_PnlAlterEnable(gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_PnlEvenDataInvEnable
N *
N * Purpose:       Enable/disable the even interface data inversion [RGB out]
N *                Valid only for GDC0
N *
N * Inputs:        eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Please note that inversion can be only achieved when
N *                GPP1 == 1. Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_PnlEvenDataInvEnable(gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_PnlEvenRgbOutEnable
N *
N * Purpose:       Enable/disable PNL_ERGB output [Even RGB interface]
N *                Valid only for GDC0
N *
N * Inputs:        eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_PnlEvenRgbOutEnable(gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_PnlOddDataInvEnable
N *
N * Purpose:       Enable/disable the odd interface data inversion [RGB out]
N *                Valid only for GDC0
N *
N * Inputs:        eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Please note that inversion can be only achieved when
N *                GPP0 == 1. Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_PnlOddDataInvEnable(gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_PnlOddRgbOutEnable
N *
N * Purpose:       Enables/disables output for DISP_RGB (Odd RGB interface)
N *                Valid only for GDC0
N *
N * Inputs:        eEn   Enable/Disable parameter
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_PnlOddRgbOutEnable(gdc_en_e eEn);
N
N/****************************************************************************
N *
N * Function:      i32GDC_PnlSyncMode
N *
N * Purpose:       Affect the delay time between synchronization input and data output.
N *                It is combined out of u16PnlSyncModeDelay  and u16PnlSyncDataDelay.
N *                Valid only for GDC0
N *
N * Inputs:        u16PnlSyncModeDelay:  Panel Synchronization Mode Delay
N *                                        Value may be in the range of 7 to 2047.
N *                u8PnlSyncDataDelay:   Panel Synchronization Mode Data Delay
N *                                        Value may be in the range of 0 to 15.
N * Outputs:       none
N *
N * Return Values: C_SUCCESS : No error
N *                C_FAILED  : parameter range problem
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nint32_t i32GDC_PnlSyncMode(uint16_t u16PnlSyncModeDelay, uint8_t u8PnlSyncDataDelay);
N
N
N#ifndef _EXTENDED_GDC_APIS_DISABLED_
N/****************************************************************************
N *
N * Function:      boGDC_SetPulseGen
N *
N * Purpose:       Set Pulse Generator properties
N *
N * Inputs:        eGDC        Controller channel
N *                ePGenID:    Selected pulse generator (0..11) to configure
N *                ePGenOut:   Combinatorial logic output selection
N *                ePGenClk:   Clock-gating enables Output general purpose pulse 
N *                            or Output dot clock gated with general purpose pulse
N *                ePGenTrig:  Trigger signal selection for related general purpose 
N *                            pulse generator
N * 
N * Outputs:       none
N *
N * Return Values: C_TRUE/C_FALSE
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
N bool_t boGDC_SetPulseGen(gdc_ch_e eGDC,
N                          gdc_pg_gen_id_e   ePGenID,
N                          gdc_pg_outsel_e   ePGenOut,
N                          gdc_pg_cgsel_e    ePGenClk,
N                          gdc_pg_trigger_e  ePGenTrig);
N
N/****************************************************************************
N *
N * Function:      boGDC_ConfigPulseGenA_B
N *
N * Purpose:       Configures One Shot Pulsgenerator A or B
N *
N * Inputs:        eGDC         Controller channel
N *                ePGenID:     Selected pulse generator (0..11) to configure 
N *                eGenA_B:     Selected generator A or B to configure
N *                pstConfig:   Pointer to configuration structure for  pulse generator A or B
N * 
N * Outputs:        none
N *
N * Return Values: C_TRUE/C_FALSE
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_ConfigPulseGenA_B(gdc_ch_e eGDC,
N                               gdc_pg_gen_id_e      ePGenID,
N                               gdc_pg_A_B_e         eGenA_B,
N                               gdc_pulse_config_st  *pstConfig);
N
N#endif /* _EXTENDED_GDC_APIS_DISABLED_ */
N
N/****************************************************************************/
N
N
N
N/***************************************************************************
N*
N*            A U T O M A T I C    P I X E L    C H E C K E R
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      vGDC_APCConfigure
N *
N * Purpose:       Configure the automatic pixel checker
N *
N * Inputs:        eGDC    Controller channel
N *                pstCfg  Pointer to configuration structure
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_APCConfigure(gdc_ch_e eGDC, gdc_apccfg_st* pstCfg);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_APCEnable
N *
N * Purpose:       Enable/disable the automatic pixel checker
N *
N * Inputs:        eGDC  Controller channel
N *                eEn   Enable/disable request
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_APCEnable(gdc_ch_e eGDC, gdc_en_e eEn);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_IsAPCError
N *
N * Purpose:       Check whether compare error was detected
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       none
N *
N * Return Values: C_TRUE  if detected
N *                C_FALSE if not detected
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_IsAPCError(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      vGDC_SetAPCCR_PolynomialGen
N *
N * Purpose:       Change Polynomial generator (default: 0x23)
N *                NOTE: Changing this value is not recommended!
N *
N * Inputs:        eGDC      Controller channel
N *                u8PgValue PG-Value
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nvoid vGDC_SetAPCCR_PolynomialGen(gdc_ch_e eGDC, uint8_t u8PgValue);
N
N
N/****************************************************************************
N *
N * Function:      u32GDC_GetAPCResult
N *
N * Purpose:       Retrieve the result of the last computation
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       Last computation result
N *
N * Return Values: none
N *
N * Limitations:   The bits will be automatically cleared after the read.
N *                Process one controller at a time
N *
N ***************************************************************************/
Nuint32_t u32GDC_GetAPCResult(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      u32GDC_GetAPCPixelVal
N *
N * Purpose:       Retrieve current/previous pixel value set
N *
N * Inputs:        eGDC  Controller channel
N *                ePix  Pixel set
N *
N * Outputs:       Pixel value set
N *
N * Return Values: none
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nuint32_t u32GDC_GetAPCPixelVal(gdc_ch_e eGDC, gdc_apcp_e ePix);
N
N
N#ifndef _EXTENDED_GDC_APIS_DISABLED_
N/*+-----------------------------------------------------------------------+*
N *|     START-Extended new APIs                                           |*
N *+-----------------------------------------------------------------------+*/
N
N/****************************************************************************
N *
N * Function:      vGDC_SetApcWriteProtection
N *
N * Purpose:       Defines level of Write protection for APC control registers
N *
N * Inputs:        eGDC         Controller channel
N *                eProtection  Protection Level
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nvoid vGDC_SetApcWriteProtection(gdc_ch_e eGDC, gdc_write_protect_e eProtection);
N
N
N#endif /* _EXTENDED_GDC_APIS_DISABLED_ */
N
N
N
N#ifndef _EXTENDED_GDC_APIS_DISABLED_
N/***************************************************************************
N*
N*                      Bus Errors and Collision Detection
N*
N****************************************************************************/
N
N/****************************************************************************
N *
N * Function:      u16GDC_GetLastGAPIFColAddr
N *
N * Purpose:       Get last GAPIF colision error address
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       none
N *
N * Return Values: the address
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nuint16_t u16GDC_GetLastGAPIFColAddr(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_GetBusErrAddr
N *
N * Purpose:       Returns the triggering access’s address after bus error on GB 
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       pu32BusErrAddr: Pointer to bus error address
N *
N * Return Values: Any Error?
N *                C_TRUE:  No Error
N *                C_FALSE: NULL pointer
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_GetBusErrAddr(gdc_ch_e eGDC, uint32_t* pu32BusErrAddr);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_GetBusErrCtrlStatus
N *
N * Purpose:       Returns the triggering access’s control status after bus error on GB
N *
N * Inputs:        eGDC  Controller channel
N *
N * Outputs:       control status structure
N *
N * Return Values: Any Error?
N *                C_TRUE:  No Error
N *                C_FALSE: NULL pointer
N *
N * Limitations:   Process one controller at a time
N *
N ***************************************************************************/
Nbool_t boGDC_GetBusErrCtrlStatus(gdc_ch_e eGDC, gdc_bus_err_ctrl_st* pstCtrlStatus);
N
N
N/****************************************************************************
N *
N * Function:      eGDC_GetDcrBusErrors
N *
N * Purpose:       Get status of bus error in GDCDCR register
N *
N * Inputs:        eGDC      Controller channel
N *
N * Outputs:       none
N *
N * Return Values: evtl. raised errors
N *
N * Limitations:   none
N *
N ***************************************************************************/
Ngdc_dcr_err_e eGDC_GetDcrBusErrors(gdc_ch_e eGDC);
N
N
N/****************************************************************************
N *
N * Function:      boGDC_ClrDcrBusErrors
N *
N * Purpose:       Clears error Bits (GBER, GAPCOL) in GDC register
N *                Note:
N *                     Clear GAPINT by call of function eGDC_IsIrqGap() will also
N *                     clear GAPCOL error bit.
N *
N * Inputs:        eGDC      Controller channel
N *                eClrBits  Clear Bits
N *
N * Outputs:       none
N *
N * Return Values: none
N *
N * Limitations:   none
N *
N ***************************************************************************/
Nbool_t boGDC_ClrDcrBusErrors(gdc_ch_e eGDC, gdc_dcr_err_e eClrBits);
N
N
N#endif /* _EXTENDED_GDC_APIS_DISABLED_ */
N
N
N/*+-----------------------------------------------------------------------+*
N *|     END-Extended new APIs                                             |*
N *+-----------------------------------------------------------------------+*/
N
N/****************************************************************************/
N
N#endif /* GDC_H */
N
N/****************************************************************************/
N
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: gdc.h
N**  $Revision: 1.20 $
N**  $Date: 2015/05/04 09:07:14 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   :
N** |
N** | CONS.  :
N** |
N** | REASON :
N** |
N**  ------------------------------------------------------------------------
N*****************************************************************************
N****************************************************************************/
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 24 "..\..\..\..\lldd\src\gdc.c" 2
N
N/*********************************************/
N/*********************************************
N*           Disable Misra Warnings/Rules     *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1847  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to non-integer type "type" not allowed */
S  #pragma ghs nowarning 1849  /* Rule 8.1  [R] : bitwise ~ or << expression must be immediately cast back to  underlying type, "unsigned char" */
S  #pragma ghs nowarning 1858  /* Rule 17.4 [R] : subscript operator may only be applied to objects declared as an array type */
S  #pragma ghs nowarning 1864  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to narrower underlying type, "type", not allowed */
S  #pragma ghs nowarning 1865  /* Rule 10.1 [R] : conversion from underlying type, "int", to same width underlying type, "uint32_t", not allowed */
S  #pragma ghs nowarning 1866  /* Rule 10.1 [R] : implicit conversion from underlying type, "type", to underlying type, "type", changes signedness */
S  #pragma ghs nowarning 1867  /* Rule 10.1 [R] : implicit conversion of complex expression from underlying type, "type", to underlying type, "type", not allowed */
S  #pragma ghs nowarning 1878  /* Rule 10.3 [R] : cast of complex integer expression with underlying type "type" to wider type "type" not allowed */
S  #pragma ghs nowarning 1879  /* Rule 10.3 [R] : Restrict explicit casts for integer type expressions */
S
S  #pragma ghs nowarning 1723  /* Rule 5.6  [A] : No identifiers with the same name in different name spaces except for struct and union members.. */  
S  #pragma ghs nowarning 1834  /* Rule 11.3 [A] : disable casting error (used for result of i/o header amcros) */
S  #pragma ghs nowarning 1835  /* Rule 11.4 [A] : allow cast from type "type" to type "type" */
S  #pragma ghs nowarning 1840  /* Rule 5.7  [A] : No reuse of identifiers */
S  #pragma ghs nowarning 1853  /* Rule 12.6 [A] : effectively boolean expression required */
S  #pragma ghs nowarning 1855  /* Rule 13.2 [A] : Explicit test of a value against zero unless the expression is Boolean */
S
N#endif  
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#ifdef HW_UPDATE_BUG_FIXED
S/* This macro should be moved to enum gdc_reg_update_mode_e
S * if the HW buf will be fixed: */
S
S#define GDC_NO_UPDATE_BY_VSYNC  0
S
N#endif
N
N/**********************************************
N*   Macros for Read/write shadow registers    *
N**********************************************/
N
N/* write a value in shadow register: */
N#define UPDATE_REGISTER_LOW_WORD(chn, reg, ParValue)   (*((volatile uint32_t*) ((reg) + ((uint32_t)(chn) * GDC1_REGADR_OFFSET) )) = ((uint32_t)(ParValue)))
N#define UPDATE_REGISTER_HIGH_WORD(chn, reg, ParValue)  (*((volatile uint32_t*) ((reg) + ((uint32_t)(chn) * GDC1_REGADR_OFFSET) + 4 )) = ((uint32_t)((ParValue)>>32)))
N#define UPDATE_REGISTER_64BITS(chn, reg, ParValue)     (*((volatile uint64_t*) ((reg) + ((uint32_t)(chn) * GDC1_REGADR_OFFSET) )) = (ParValue))
N
N/* Macros for 32 bit/64 bit read of shadow register: */
N#define READ_REGISTER_LOW_WORD(reg, chn)  (*((volatile uint32_t*) ((reg) + ((uint8_t)(chn) * GDC1_REGADR_OFFSET) )))
N#define READ_REGISTER_HIGH_WORD(reg, chn) (*((volatile uint32_t*) ((reg) + ((uint8_t)(chn) * GDC1_REGADR_OFFSET) + 4)))
N#define READ_REGISTER_64BITS(reg, chn)    (*((volatile uint64_t*) ((reg) + ((uint8_t)(chn) * GDC1_REGADR_OFFSET) )))
N
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N/* Access masks */
N#define GDC_SARXN_SAR_MASK                  0xFFFFFFF8U
N#define GDC_CBARX_MASK                      0xFFFFFFF8U
N#define GDC_1_BIT_MASK                      0x00000001U
N#define GDC_3_BIT_MASK                      0x00000007U
N#define GDC_8_BIT_MASK                      0x000000FFU
N#define GDC_10_BIT_MASK                     0x000003FFU
N#define GDC_11_BIT_MASK                     0x000007FFU
N#define GDC_12_BIT_MASK                     0x00000FFFU
N#define GDC_WARXN_WAR_MASK                  0xFFFFFFFEU
N#define GDC_SCVR_LCCV_MASK                  0x0000000000FFFFFFU
N#define GDC_SCVR_HACT_MASK                  0x8000000000000000U
N#define GDC_DCR_ERR_GBER_MASK               0x0000000000080000U /* Mask for Clear bit GDCDCR-GBER/Bit 19)       */
N#define GDC_DCR_ERR_GAPCOL_MASK             0x0200000000000000U /* Mask for Clear bit GDCDCR-GAPCOL/bit 57      */
N#define GDC_DCR_ERR_GBER_AND_GAPCOL_MASK   (GDC_DCR_ERR_GBER_MASK | GDC_DCR_ERR_GAPCOL_MASK) /* Mask for Clear bit GDCDCR-GBER and GAPCOL bits */
N
N#define MAX_WAIT_FOR_CLEAR                  1000
N
N/* Lower range values */
N#define GDC_DIMR_WIDTH_MIN_VAL              64
N#define GDC_WIMR_WIDHT_MIN_VAL              8
N
N/* range of display start position: */
N#define GDC_DISP_HSTART_MIN  64U
N#define GDC_DISP_HSTART_MAX  2047U
N#define GDC_DISP_VSTART_MIN  64U
N#define GDC_DISP_VSTART_MAX  1023U
N
N/* range of display size: */
N#define GDC_DISP_WIDTH_MIN   64U
N#define GDC_DISP_WIDTH_MAX   2047U
N#define GDC_DISP_HEIGHT_MIN  1U
N#define GDC_DISP_HEIGHT_MAX  1023U
N
N#define GDC_PGEN_GALVL_BITS     1
N#define GDC_PGEN_GAINSEL_BITS   3
N#define GDC_PGEN_GABYP_BIT      1
N#define GDC_PGEN_GADEL_BIT      11
N#define GDC_PGEN_GADIV_BIT      4
N#define GDC_PGEN_GAINV_BIT      1
N#define GDC_PGEN_GAWID_BIT      11
N
N#define GDC_DCP1_VAL_MIN        9
N
N/*********************************************/
N 
N/**********************************************
N*             Constants & Macros              *
N**********************************************/
N#define LAYER_FMT_32bpp   0  /* 32-bit RGBA/ARGB */
N#define LAYER_FMT_16bpp   1  /* 16-bit RGB       */  
N
N#define LLDD_GDC_C_REVISION     "$Revision: 1.19 $"
N#define LLDD_GDC_C_TAG          "$Name: LLDD_1_7_GFX $"
N
N/*********************************************/
N /* Following variables will be used to keep register data before writing in shadow registers:
N  * they should be defined as global, otherwise the usage of macros in gdx_io.h by another 
N  * applications will not work: */
N    
N volatile uint64_t u64GDCDCR_REG__Var[2]        __attribute__ ((aligned(8)));
N volatile uint64_t u64GDCCAVRA_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint64_t u64GDCSCVRA_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint64_t u64GDCSCVRB_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint64_t u64GDCSCVRC_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint64_t u64GDCSCVRD_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint64_t u64APCCR_REG__Var[2]         __attribute__ ((aligned(8)));
N volatile uint64_t u64APCCWR_REG__Var[2]        __attribute__ ((aligned(8)));
N volatile uint64_t u64APCCSR_REG__Var[2]        __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARA0_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARA1_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWARA_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCBGCR_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARB0_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARB1_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWARB_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARC0_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARC1_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARD0_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARD1_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCMWRA_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCMWRB_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCMWRC_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCMWRD_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCMWRE_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLSRA_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLSRB_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLSRC_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLSRD_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLSRE_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLDRA_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLDRB_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLDRC_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLDRD_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLDRE_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWSRA_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWSRB_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWIMRA_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWIMRB_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCCAVRB_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCHSR_REG__Var[2]        __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCVSR_REG__Var[2]        __attribute__ ((aligned(8)));
N 
N volatile uint32_t u32GDCCBAR0_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCCBAR1_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCCBAR2_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCPTCR_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCGPCRA_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCGPCRB_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCGPCRC_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCPSMR_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARE0_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCLARE1_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWARC_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWARD_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWARE_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWSRC_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWSRD_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWSRE_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWIMRC_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWIMRD_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCWIMRE_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCDSR_REG__Var[2]        __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCDIMR_REG__Var[2]       __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCPROTR_REG__Var[2]      __attribute__ ((aligned(8)));
N volatile uint32_t u32APCPROTR_REG__Var[2]      __attribute__ ((aligned(8)));
N
N volatile uint32_t u32GDCPxGAR_REG__Var[2][12]  __attribute__ ((aligned(8)));
N volatile uint32_t u32GDCPxGBR_REG__Var[2][12]  __attribute__ ((aligned(8)));
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
N/**********************************************
N*             Variables                       *
N**********************************************/
Nstatic uint8_t au8LLDD_GDC_C_REVISION[]    = LLDD_GDC_C_REVISION;
Xstatic uint8_t au8LLDD_GDC_C_REVISION[]    = "$Revision: 1.19 $";
Nstatic uint8_t au8LLDD_GDC_C_TAG[]         = LLDD_GDC_C_TAG;
Xstatic uint8_t au8LLDD_GDC_C_TAG[]         = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GDC_H_REVISION[]    = LLDD_GDC_H_REVISION;
Xstatic uint8_t au8LLDD_GDC_H_REVISION[]    = "$Revision: 1.20 $";
Nstatic uint8_t au8LLDD_GDC_H_TAG[]         = LLDD_GDC_H_TAG;
Xstatic uint8_t au8LLDD_GDC_H_TAG[]         = "$Name: LLDD_1_7_GFX $";
Nstatic uint8_t au8LLDD_GDC_IO_H_REVISION[] = LLDD_GDC_IO_H_REVISION;
Xstatic uint8_t au8LLDD_GDC_IO_H_REVISION[] = "$Revision: 1.12 $";
Nstatic uint8_t au8LLDD_GDC_IO_H_TAG[]      = LLDD_GDC_IO_H_TAG;
Xstatic uint8_t au8LLDD_GDC_IO_H_TAG[]      = "$Name: LLDD_1_7_GFX $";
N
N/**********************************************
N*             local prototypes                *
N**********************************************/
Nstatic void vUpdateDCR_HighWord_Special(gdc_ch_e eGDC);
Nstatic void vUpdateDCR_Special(gdc_ch_e eGDC);
N
N/**********************************************
N*          static functions                   *
N**********************************************/
Nstatic void vUpdateDCR_HighWord_Special(gdc_ch_e eGDC)
N{
N    /* Since UPDREG may be changed by HW (From 2 to 0) and 
N     * it belongs to higher 32 bit or register, all modifications of
N     * higher 32 bits (bits 32..63) from DCR register should be handled
N     * special, to synchronize UPDREG in HW and local storage of register: */
N    
N    gdc_reg_update_mode_e  eUpdModeHW;
N
N    /* synchronisation of update mode in HW and local storage of register: */
N    /* get the update mode from HW: */
N    eUpdModeHW = (gdc_reg_update_mode_e) biGetGDCDCR_UPDREG_Direct(eGDC);
X    eUpdModeHW = (gdc_reg_update_mode_e) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> UPDREG);
N    
N    /* to be synchronized with HW, update local variable: */
N    vSetGDCDCR_UPDREG(eGDC, eUpdModeHW);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> UPDREG=(eUpdModeHW));
N    
N    /* write now high word of DCR register in HW: */
N    UPDATE_REGISTER_HIGH_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCDCR_REG__Var[eGDC])>>32)));
N}
N/****************************************************************************/
Nstatic void vUpdateDCR_Special(gdc_ch_e eGDC)
N{
N    /* this function will be used, where Low and high word of DCR register
N     * has been changed. In this case Shadow register update should be disabled first: */
N    gdc_reg_update_mode_e  eUpdModeHW;
N
N    /* Get update mode from HW for later restore: */
N    eUpdModeHW = (gdc_reg_update_mode_e) biGetGDCDCR_UPDREG_Direct(eGDC);
X    eUpdModeHW = (gdc_reg_update_mode_e) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> UPDREG);
N
N#ifdef HW_UPDATE_BUG_FIXED
S    /* Disable Update Mode, if it was not disabled: */
S    if (GDC_NO_UPDATE_BY_VSYNC != eUpdModeHW)
S    {
S        vGDC_SetShadowRegUpdateMode(eGDC, GDC_NO_UPDATE_BY_VSYNC);
S    }
N#endif
N    /* Write Low Word first: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N
N    /* restore update mode and write high word to HW: */
N    vGDC_SetShadowRegUpdateMode(eGDC, eUpdModeHW);
N}
N/**********************************************
N*        Exported function definition         *
N**********************************************/
Nvoid vGDC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                    uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                    uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N     *pau8ModuleRevision = &au8LLDD_GDC_C_REVISION[0];
N     *pau8ModuleTag      = &au8LLDD_GDC_C_TAG[0];
N     *pau8HeaderRevision = &au8LLDD_GDC_H_REVISION[0];
N     *pau8HeaderTag      = &au8LLDD_GDC_H_TAG[0];
N     *pau8IORevision     = &au8LLDD_GDC_IO_H_REVISION[0];
N     *pau8IOTag          = &au8LLDD_GDC_IO_H_TAG[0];
N}
N
N
N/****************************************************************************/
Nvoid vGDC_Init(gdc_ch_e eGDC)
N{
N    /* this function initializes local values for registers at beginning.
N         * It is important, that Clear Bit will be set to "0" in local values,
N         * Other wise by write back to shadow register they will be reset!
N         * */
N    uint32_t u32Chn;
N    
N    u32Chn = (GDC0 == eGDC)? 0x00U : 0x01U;
N    
N    u64GDCDCR_REG__Var[u32Chn]    = READ_REGISTER_64BITS(GDCDCR_REG__ , u32Chn);
X    u64GDCDCR_REG__Var[u32Chn]    = (*((volatile uint64_t*) ((0xC0C02000U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    /* Important NOTE:
N     * Clear Bits should not be set in local variables, other wise the clear bit will be reset by
N     * next shadow register update and application will not know about it. 
N     * Mask  Clr bits (GAPCOL/bit 57 and GBER/Bit 19 ) */
N    u64GDCDCR_REG__Var[u32Chn]   &= (~GDC_DCR_ERR_GBER_AND_GAPCOL_MASK);
X    u64GDCDCR_REG__Var[u32Chn]   &= (~(0x0000000000080000U | 0x0200000000000000U));
N    
N    u64GDCCAVRA_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCCAVRA_REG__ , u32Chn);
X    u64GDCCAVRA_REG__Var[u32Chn]  = (*((volatile uint64_t*) ((0xC0C02100U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u64GDCSCVRA_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRA_REG__ , u32Chn);
X    u64GDCSCVRA_REG__Var[u32Chn]  = (*((volatile uint64_t*) ((0xC0C02288U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u64GDCSCVRB_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRB_REG__ , u32Chn);
X    u64GDCSCVRB_REG__Var[u32Chn]  = (*((volatile uint64_t*) ((0xC0C02290U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u64GDCSCVRC_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRC_REG__ , u32Chn);
X    u64GDCSCVRC_REG__Var[u32Chn]  = (*((volatile uint64_t*) ((0xC0C02298U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u64GDCSCVRD_REG__Var[u32Chn]  = READ_REGISTER_64BITS(GDCSCVRD_REG__ , u32Chn);
X    u64GDCSCVRD_REG__Var[u32Chn]  = (*((volatile uint64_t*) ((0xC0C022A0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u64APCCR_REG__Var[u32Chn]     = READ_REGISTER_64BITS(APCCR_REG__ , u32Chn);
X    u64APCCR_REG__Var[u32Chn]     = (*((volatile uint64_t*) ((0xC0C02300U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u64APCCWR_REG__Var[u32Chn]    = READ_REGISTER_64BITS(APCCWR_REG__ , u32Chn);
X    u64APCCWR_REG__Var[u32Chn]    = (*((volatile uint64_t*) ((0xC0C02308U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    
N    /* Note: CURCHKSUM is a R/C Bit, it means after read CURCHKSUM will be reset!: */
N    u64APCCSR_REG__Var[u32Chn]    = READ_REGISTER_64BITS(APCCSR_REG__ , u32Chn);
X    u64APCCSR_REG__Var[u32Chn]    = (*((volatile uint64_t*) ((0xC0C02310U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    
N    u32GDCLARA0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARA0_REG__ , u32Chn);
X    u32GDCLARA0_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02010U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARA1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARA1_REG__ , u32Chn);
X    u32GDCLARA1_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02018U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWARA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARA_REG__ , u32Chn);
X    u32GDCWARA_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02020U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCBGCR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCBGCR_REG__ , u32Chn);
X    u32GDCBGCR_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02028U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARB0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARB0_REG__ , u32Chn);
X    u32GDCLARB0_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02030U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARB1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARB1_REG__ , u32Chn);
X    u32GDCLARB1_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02038U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWARB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARB_REG__ , u32Chn);
X    u32GDCWARB_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02040U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARC0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARC0_REG__ , u32Chn);
X    u32GDCLARC0_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02048U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARC1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARC1_REG__ , u32Chn);
X    u32GDCLARC1_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02050U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARD0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARD0_REG__ , u32Chn);
X    u32GDCLARD0_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02058U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARD1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARD1_REG__ , u32Chn);
X    u32GDCLARD1_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02060U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCMWRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRA_REG__ , u32Chn);
X    u32GDCMWRA_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02068U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCMWRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRB_REG__ , u32Chn);
X    u32GDCMWRB_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02070U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCMWRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRC_REG__ , u32Chn);
X    u32GDCMWRC_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02078U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCMWRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRD_REG__ , u32Chn);
X    u32GDCMWRD_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02080U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCMWRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCMWRE_REG__ , u32Chn);
X    u32GDCMWRE_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02088U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLSRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRA_REG__ , u32Chn);
X    u32GDCLSRA_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02090U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLSRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRB_REG__ , u32Chn);
X    u32GDCLSRB_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02098U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLSRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRC_REG__ , u32Chn);
X    u32GDCLSRC_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020A0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLSRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRD_REG__ , u32Chn);
X    u32GDCLSRD_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020A8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLSRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLSRE_REG__ , u32Chn);
X    u32GDCLSRE_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020B0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLDRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRA_REG__ , u32Chn);
X    u32GDCLDRA_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020B8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLDRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRB_REG__ , u32Chn);
X    u32GDCLDRB_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020C0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLDRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRC_REG__ , u32Chn);
X    u32GDCLDRC_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020C8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLDRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRD_REG__ , u32Chn);
X    u32GDCLDRD_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020D0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLDRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCLDRE_REG__ , u32Chn);
X    u32GDCLDRE_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020D8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWSRA_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRA_REG__ , u32Chn);
X    u32GDCWSRA_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020E0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWSRB_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRB_REG__ , u32Chn);
X    u32GDCWSRB_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C020E8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWIMRA_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRA_REG__ , u32Chn);
X    u32GDCWIMRA_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C020F0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWIMRB_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRB_REG__ , u32Chn);
X    u32GDCWIMRB_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C020F8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCCAVRB_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCAVRB_REG__ , u32Chn);
X    u32GDCCAVRB_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02108U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCHSR_REG__Var[u32Chn]    = READ_REGISTER_LOW_WORD(GDCHSR_REG__ , u32Chn);
X    u32GDCHSR_REG__Var[u32Chn]    = (*((volatile uint32_t*) ((0xC0C02110U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCVSR_REG__Var[u32Chn]    = READ_REGISTER_LOW_WORD(GDCVSR_REG__ , u32Chn);
X    u32GDCVSR_REG__Var[u32Chn]    = (*((volatile uint32_t*) ((0xC0C02118U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    
N    u32GDCCBAR0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCBAR0_REG__ , u32Chn);
X    u32GDCCBAR0_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02128U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCCBAR1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCBAR1_REG__ , u32Chn);
X    u32GDCCBAR1_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02130U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCCBAR2_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCCBAR2_REG__ , u32Chn);
X    u32GDCCBAR2_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02138U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPTCR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCPTCR_REG__ , u32Chn);
X    u32GDCPTCR_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02148U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCGPCRA_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCGPCRA_REG__ , u32Chn);
X    u32GDCGPCRA_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02150U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCGPCRB_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCGPCRB_REG__ , u32Chn);
X    u32GDCGPCRB_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02158U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCGPCRC_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCGPCRC_REG__ , u32Chn);
X    u32GDCGPCRC_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02160U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPSMR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCPSMR_REG__ , u32Chn);
X    u32GDCPSMR_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02228U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARE0_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARE0_REG__ , u32Chn);
X    u32GDCLARE0_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02230U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCLARE1_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCLARE1_REG__ , u32Chn);
X    u32GDCLARE1_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02238U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWARC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARC_REG__ , u32Chn);
X    u32GDCWARC_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02240U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWARD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARD_REG__ , u32Chn);
X    u32GDCWARD_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02248U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWARE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWARE_REG__ , u32Chn);
X    u32GDCWARE_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02250U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWSRC_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRC_REG__ , u32Chn);
X    u32GDCWSRC_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02258U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWSRD_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRD_REG__ , u32Chn);
X    u32GDCWSRD_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02260U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWSRE_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCWSRE_REG__ , u32Chn);
X    u32GDCWSRE_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C02268U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWIMRC_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRC_REG__ , u32Chn);
X    u32GDCWIMRC_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02270U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWIMRD_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRD_REG__ , u32Chn);
X    u32GDCWIMRD_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02278U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCWIMRE_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCWIMRE_REG__ , u32Chn);
X    u32GDCWIMRE_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02280U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCDSR_REG__Var[u32Chn]    = READ_REGISTER_LOW_WORD(GDCDSR_REG__ , u32Chn);
X    u32GDCDSR_REG__Var[u32Chn]    = (*((volatile uint32_t*) ((0xC0C022B0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCDIMR_REG__Var[u32Chn]   = READ_REGISTER_LOW_WORD(GDCDIMR_REG__ , u32Chn);
X    u32GDCDIMR_REG__Var[u32Chn]   = (*((volatile uint32_t*) ((0xC0C022B8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPROTR_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(GDCPROTR_REG__ , u32Chn);
X    u32GDCPROTR_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C022C0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32APCPROTR_REG__Var[u32Chn]  = READ_REGISTER_LOW_WORD(APCPROTR_REG__ , u32Chn);
X    u32APCPROTR_REG__Var[u32Chn]  = (*((volatile uint32_t*) ((0xC0C02320U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N
N    u32GDCPxGAR_REG__Var[u32Chn][0]  = READ_REGISTER_LOW_WORD(GDCP0GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][0]  = (*((volatile uint32_t*) ((0xC0C02168U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][1]  = READ_REGISTER_LOW_WORD(GDCP1GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][1]  = (*((volatile uint32_t*) ((0xC0C02170U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][2]  = READ_REGISTER_LOW_WORD(GDCP2GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][2]  = (*((volatile uint32_t*) ((0xC0C02178U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][3]  = READ_REGISTER_LOW_WORD(GDCP3GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][3]  = (*((volatile uint32_t*) ((0xC0C02180U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][4]  = READ_REGISTER_LOW_WORD(GDCP4GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][4]  = (*((volatile uint32_t*) ((0xC0C02188U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][5]  = READ_REGISTER_LOW_WORD(GDCP5GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][5]  = (*((volatile uint32_t*) ((0xC0C02190U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][6]  = READ_REGISTER_LOW_WORD(GDCP6GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][6]  = (*((volatile uint32_t*) ((0xC0C02198U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][7]  = READ_REGISTER_LOW_WORD(GDCP7GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][7]  = (*((volatile uint32_t*) ((0xC0C021A0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][8]  = READ_REGISTER_LOW_WORD(GDCP8GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][8]  = (*((volatile uint32_t*) ((0xC0C021A8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][9]  = READ_REGISTER_LOW_WORD(GDCP9GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][9]  = (*((volatile uint32_t*) ((0xC0C021B0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][10] = READ_REGISTER_LOW_WORD(GDCP10GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][10] = (*((volatile uint32_t*) ((0xC0C021B8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGAR_REG__Var[u32Chn][11] = READ_REGISTER_LOW_WORD(GDCP11GAR_REG__ , u32Chn);
X    u32GDCPxGAR_REG__Var[u32Chn][11] = (*((volatile uint32_t*) ((0xC0C021C0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    
N    u32GDCPxGBR_REG__Var[u32Chn][0]  = READ_REGISTER_LOW_WORD(GDCP0GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][0]  = (*((volatile uint32_t*) ((0xC0C021C8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][1]  = READ_REGISTER_LOW_WORD(GDCP1GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][1]  = (*((volatile uint32_t*) ((0xC0C021D0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][2]  = READ_REGISTER_LOW_WORD(GDCP2GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][2]  = (*((volatile uint32_t*) ((0xC0C021D8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][3]  = READ_REGISTER_LOW_WORD(GDCP3GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][3]  = (*((volatile uint32_t*) ((0xC0C021E0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][4]  = READ_REGISTER_LOW_WORD(GDCP4GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][4]  = (*((volatile uint32_t*) ((0xC0C021E8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][5]  = READ_REGISTER_LOW_WORD(GDCP5GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][5]  = (*((volatile uint32_t*) ((0xC0C021F0U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][6]  = READ_REGISTER_LOW_WORD(GDCP6GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][6]  = (*((volatile uint32_t*) ((0xC0C021F8U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][7]  = READ_REGISTER_LOW_WORD(GDCP7GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][7]  = (*((volatile uint32_t*) ((0xC0C02200U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][8]  = READ_REGISTER_LOW_WORD(GDCP8GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][8]  = (*((volatile uint32_t*) ((0xC0C02208U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][9]  = READ_REGISTER_LOW_WORD(GDCP9GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][9]  = (*((volatile uint32_t*) ((0xC0C02210U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][10] = READ_REGISTER_LOW_WORD(GDCP10GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][10] = (*((volatile uint32_t*) ((0xC0C02218U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    u32GDCPxGBR_REG__Var[u32Chn][11] = READ_REGISTER_LOW_WORD(GDCP11GBR_REG__ , u32Chn);
X    u32GDCPxGBR_REG__Var[u32Chn][11] = (*((volatile uint32_t*) ((0xC0C02220U) + ((uint8_t)(u32Chn) * 0x1000U) )));
N    
N}
N
N
N/****************************************************************************/
Nvoid vGDC_Switch(gdc_ch_e eGDC, gdc_on_e eSwitch)
N{
N    vSetGDCDCR_GDCON(eGDC, eSwitch);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> GDCON=(eSwitch));
N    /* GDCON: belongs to high word of register: */
N    /* GDCDCR register should be updated special: */  
N    vUpdateDCR_HighWord_Special(eGDC);
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetShadowRegUpdateMode(gdc_ch_e eGDC, gdc_reg_update_mode_e eCtrl)
N{
N    /* Note:
N     * in this fucntion UPDREG bits of DCR register should be modified.
N     * These bits are in higher wordt of shadow register, so we modicy only the higher part. 
N     */
N    
N    /* Set UPDREG bits in backup variables: */
N    vSetGDCDCR_UPDREG(eGDC, eCtrl);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> UPDREG=(eCtrl));
N    /* UPDREG: belongs to high word of register: */
N    UPDATE_REGISTER_HIGH_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCDCR_REG__Var[eGDC])>>32)));
N}
N
N
N/****************************************************************************/
Ngdc_reg_update_status_e eGetShadowRegUpdateStatus(gdc_ch_e eGDC)
N{
N    gdc_reg_update_status_e eUpdMode;
N    
N    /* get the update mode from HW: */
N    eUpdMode = (gdc_reg_update_status_e) biGetGDCDCR_UPDREG_Direct(eGDC);
X    eUpdMode = (gdc_reg_update_status_e) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> UPDREG);
N    
N    /* to be synchronized with HW, update local variable: */
N    vSetGDCDCR_UPDREG(eGDC, eUpdMode);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> UPDREG=(eUpdMode));
N
N    return eUpdMode;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetDispConfigType(gdc_ch_e eGDC, gdc_disp_config_type_e eDispConfigType)
N{
N    vSetGDCDCR_LAD(eGDC, eDispConfigType);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> LAD=(eDispConfigType));
N    /* LAD: belongs to high word of register: */
N    /* GDCDCR register should be updated special: */  
N    vUpdateDCR_HighWord_Special(eGDC);
N}
N
N
N/****************************************************************************/
Nvoid vGDC_ADBSEnable(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCDCR_ADBS(eGDC, eEn);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> ADBS=(eEn));
N    /* ADBS: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_ColorCorrectEnable(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCDCR_CCEN(eGDC, eEn);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> CCEN=(eEn));
N    /* CCEN: belongs to high word of register: */
N    /* GDCDCR register should be updated special: */  
N    vUpdateDCR_HighWord_Special(eGDC);
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetArthMode(gdc_ch_e eGDC, gdc_arth_e eMode, gdc_arthcd_e eLoc)
N{
N    vSetGDCDCR_ARTHCD(eGDC, eLoc);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> ARTHCD=(eLoc));
N    vSetGDCDCR_ARTH(eGDC, eMode);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> ARTH=(eMode));
N    /* ARTH & vSetGDCDCR_ARTHCD: belong to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetDitheringMode(gdc_ch_e eGDC, gdc_dithering_e eDith)
N{
N    vSetGDCDCR_DITHEN(eGDC, eDith);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> DITHEN=(eDith));
N    /* DITHEN: belongs to high word of register: */
N    /* GDCDCR register should be updated special: */  
N    vUpdateDCR_HighWord_Special(eGDC);
N}
N
N/****************************************************************************/
Nvoid vGDC_SetBgrColor(gdc_ch_e eGDC, uint32_t u32Color)
N{
N    /* Shift to adjust the bits according to the register layout */
N    vSetGDCBGCR(eGDC, (u32Color << 8) );
X    (*((volatile u32GDCBGCR_word_view *) &u32GDCBGCR_REG__Var[(eGDC)]) = ((u32Color << 8)));
N    
N    /* Low Word of GDCBGCR register should be updated  */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCBGCR_REG__, u32GDCBGCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02028U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCBGCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Ngdc_en_e eGDC_GetDispStat(gdc_ch_e eGDC)
N{
N    return (gdc_en_e) biGetGDCDCR_DISPIFON(eGDC);
X    return (gdc_en_e) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> DISPIFON);
N}
N
N
N/****************************************************************************/
Ngdc_en_e eGDC_GetPanelStat(gdc_ch_e eGDC)
N{
N    return (gdc_en_e) biGetGDCDCR_PNLIFON(eGDC);
X    return (gdc_en_e) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> PNLIFON);
N}
N
N/****************************************************************************/
Nuint32_t u32GDC_GetStatVSync(gdc_ch_e eGDC)
N{
N    return (uint32_t) biGetGDCDCR_VSYNC(eGDC);
X    return (uint32_t) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> VSYNC);
N}
N
N
N/****************************************************************************/
Nuint32_t u32GDC_GetPolVSync(gdc_ch_e eGDC)
N{
N    return (uint32_t) biGetGDCDCR_PVSYNC(eGDC);
X    return (uint32_t) (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PVSYNC);
N}
N
N
N/****************************************************************************/
Nuint32_t u32GDC_GetStatHSync(gdc_ch_e eGDC)
N{
N    return (uint32_t) biGetGDCDCR_HSYNC(eGDC);
X    return (uint32_t) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> HSYNC);
N}
N
N
N/****************************************************************************/
Nuint32_t u32GDC_GetStatHDisp(gdc_ch_e eGDC)
N{
N    return (uint32_t) biGetGDCDCR_HDISP(eGDC);
X    return (uint32_t) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> HDISP);
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SelDotClkSrc(gdc_ch_e eGDC, gdc_idc_e eSel)
N{
N    vSetGDCDCR_IDC(eGDC, eSel);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> IDC=(eSel));
N    /* IDC: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetDotClkPol(gdc_ch_e eGDC, gdc_pol_e ePol)
N{
N    vSetGDCDCR_PDC(eGDC, ePol);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PDC=(ePol));
N    /* PDC: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_LayerEnable(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_en_e eEn)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch( eLayer )
N    {
N        case GDC_LAYER_A:
N            vSetGDCDCR_AEN(eGDC, eEn);
X            (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> AEN=(eEn));
N            /* AEN: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_B:
N            vSetGDCDCR_BEN(eGDC, eEn);
X            (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> BEN=(eEn));
N            /* BEN: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_C:
N            vSetGDCDCR_CEN(eGDC, eEn);
X            (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> CEN=(eEn));
N            /* CEN: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_D:
N            vSetGDCDCR_DEN(eGDC, eEn);
X            (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> DEN=(eEn));
N            /* DEN: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_E:
N            vSetGDCDCR_EEN(eGDC, eEn);
X            (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> EEN=(eEn));
N            /* EEN: belongs to high word of register: */
N            /* GDCDCR register should be updated special: */  
N            vUpdateDCR_HighWord_Special(eGDC);
N            break;
N
N        default:
N            /* Unsupported layer */
N            i32Res = C_FAILED;
X            i32Res = (-1);
N            break;
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetDataFormat(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_dfmt_e eFmt)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    uint8_t u8Fmt;
N
N    /* check pixel format for validity (clut not supported) */
N    switch( eFmt )
N    {
N        case GDC_RGBA32:
N        case GDC_ARGB32:
N            u8Fmt = (uint8_t)LAYER_FMT_32bpp;
X            u8Fmt = (uint8_t)0;
N            break;
N
N        case GDC_RGB16:
N            u8Fmt = (uint8_t)LAYER_FMT_16bpp;
X            u8Fmt = (uint8_t)1;
N            break;
N
N        default:
N            i32Res = C_FAILED;
X            i32Res = (-1);
N            break;
N     }
N   if (i32Res == C_SUCCESS)
X   if (i32Res == (0))
N   {
N       /* 32 vs. 16-bit mode */
N       switch( eLayer )
N       {
N           case GDC_LAYER_A:
N               vSetGDCDCR_A16(eGDC, u8Fmt);
X               (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> A16=(u8Fmt));
N               break;
N
N           case GDC_LAYER_B:
N               vSetGDCDCR_B16(eGDC, u8Fmt);
X               (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> B16=(u8Fmt));
N               break;
N
N           case GDC_LAYER_C:
N               vSetGDCDCR_C16(eGDC, u8Fmt);
X               (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> C16=(u8Fmt));
N               break;
N
N           case GDC_LAYER_D:
N               vSetGDCDCR_D16(eGDC, u8Fmt);
X               (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> D16=(u8Fmt));
N               break;
N
N           case GDC_LAYER_E:
N               vSetGDCDCR_E16(eGDC, u8Fmt);
X               (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> E16=(u8Fmt));
N               break;
N
N           /* Unsupported Layer */
N           default:
N               i32Res = C_FAILED;
X               i32Res = (-1);
N               break;
N       }
N       if ( C_FAILED != i32Res)
X       if ( (-1) != i32Res)
N       {
N           /* set the flag to indicates ARGB or RGBA format*/
N           if ( eFmt == GDC_ARGB32)
N           {
N             /* ARGB supported: This will affect all Layers!*/
N             vSetGDCDCR_ARGBEN(eGDC, 1);
X             (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> ARGBEN=(1));
N           }
N           else
N           {
N               if ( eFmt == GDC_RGBA32)
N               {
N                 /* RGBA supported: This will effect all Layers!*/
N                 vSetGDCDCR_ARGBEN(eGDC, 0);
X                 (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> ARGBEN=(0));
N               }
N           }
N           /* GDCDCR register should be updated special: */  
N           vUpdateDCR_Special(eGDC);
N       }
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetLayerStart(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16HStart, uint16_t u16VStart)
N{
N    uint32_t u32Val;
N
N    /* Compose the entire register value */
N    u32Val = (((uint32_t) (u16HStart & GDC_11_BIT_MASK)) << 16) | (u16VStart & GDC_10_BIT_MASK);
X    u32Val = (((uint32_t) (u16HStart & 0x000007FFU)) << 16) | (u16VStart & 0x000003FFU);
N
N    /* Set */
N    switch( eLayer )
N    {
N        case GDC_LAYER_A:
N            vSetGDCLSRA(eGDC, u32Val);
X            (*((volatile u32GDCLSRA_word_view *) &u32GDCLSRA_REG__Var[(eGDC)]) = (u32Val));
N            /* LVS & LHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRA_REG__, u32GDCLSRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02090U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLSRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_B:
N            vSetGDCLSRB(eGDC, u32Val);
X            (*((volatile u32GDCLSRB_word_view *) &u32GDCLSRB_REG__Var[(eGDC)]) = (u32Val));
N            /* LVS & LHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRB_REG__, u32GDCLSRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02098U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLSRB_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_C:
N            vSetGDCLSRC(eGDC, u32Val);
X            (*((volatile u32GDCLSRC_word_view *) &u32GDCLSRC_REG__Var[(eGDC)]) = (u32Val));
N            /* LVS & LHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRC_REG__, u32GDCLSRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C020A0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLSRC_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_D:
N            vSetGDCLSRD(eGDC, u32Val);
X            (*((volatile u32GDCLSRD_word_view *) &u32GDCLSRD_REG__Var[(eGDC)]) = (u32Val));
N            /* LVS & LHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRD_REG__, u32GDCLSRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C020A8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLSRD_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_E:
N            vSetGDCLSRE(eGDC, u32Val);
X            (*((volatile u32GDCLSRE_word_view *) &u32GDCLSRE_REG__Var[(eGDC)]) = (u32Val));
N            /* LVS & LHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCLSRE_REG__, u32GDCLSRE_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C020B0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLSRE_REG__Var[eGDC])));
N            break;
N
N        default:
N            break;
N    }
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetLayerSize(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16Width, uint16_t u16Height)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    uint32_t u32Val;
N
N
N    if( (u16Width & GDC_12_BIT_MASK) < GDC_DIMR_WIDTH_MIN_VAL  )
X    if( (u16Width & 0x00000FFFU) < 64  )
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        /* Compose the entire register value */
N        u32Val = (((uint32_t) (u16Width & GDC_12_BIT_MASK)) << 16) | (u16Height & GDC_11_BIT_MASK);
X        u32Val = (((uint32_t) (u16Width & 0x00000FFFU)) << 16) | (u16Height & 0x000007FFU);
N
N        /* Set */
N        switch( eLayer )
N        {
N            case GDC_LAYER_A:
N                vSetGDCLDRA(eGDC, u32Val);
X                (*((volatile u32GDCLDRA_word_view *) &u32GDCLDRA_REG__Var[(eGDC)]) = (u32Val));
N                /* LHEIGHT & LWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRA_REG__, u32GDCLDRA_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020B8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLDRA_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_B:
N                vSetGDCLDRB(eGDC, u32Val);
X                (*((volatile u32GDCLDRB_word_view *) &u32GDCLDRB_REG__Var[(eGDC)]) = (u32Val));
N                /* LHEIGHT & LWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRB_REG__, u32GDCLDRB_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020C0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLDRB_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_C:
N                vSetGDCLDRC(eGDC, u32Val);
X                (*((volatile u32GDCLDRC_word_view *) &u32GDCLDRC_REG__Var[(eGDC)]) = (u32Val));
N                /* LHEIGHT & LWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRC_REG__, u32GDCLDRC_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020C8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLDRC_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_D:
N                vSetGDCLDRD(eGDC, u32Val);
X                (*((volatile u32GDCLDRD_word_view *) &u32GDCLDRD_REG__Var[(eGDC)]) = (u32Val));
N                /* LHEIGHT & LWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRD_REG__, u32GDCLDRD_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020D0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLDRD_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_E:
N                vSetGDCLDRE(eGDC, u32Val);
X                (*((volatile u32GDCLDRE_word_view *) &u32GDCLDRE_REG__Var[(eGDC)]) = (u32Val));
N                /* LHEIGHT & LWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLDRE_REG__, u32GDCLDRE_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020D8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLDRE_REG__Var[eGDC])));
N                break;
N
N            default:
N                i32Res = C_FAILED;
X                i32Res = (-1);
N                break;
N        }
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetLayerOrder(gdc_ch_e eGDC, gdc_vord_e eOrder)
N{
N    vSetGDCDCR_VORD(eGDC, eOrder);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> VORD=(eOrder));
N    /* VORD: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetCommonAlpha(gdc_ch_e eGDC, gdc_seg_e eEntity, uint8_t u8Alpha)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch( eEntity )
N    {
N        case GDC_SEG_LAYER_A:
N            vSetGDCCAVRA_ALPHAA(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAA=(u8Alpha));
N            /* ALPHAA: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCCAVRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_SEG_LAYER_B:
N            vSetGDCCAVRA_ALPHAB(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAB=(u8Alpha));
N            /* ALPHAB: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCCAVRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_SEG_LAYER_C:
N            vSetGDCCAVRA_ALPHAC(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAC=(u8Alpha));
N            /* ALPHAC: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCCAVRA_REG__Var[eGDC])>>32)));
N            break;
N
N        case GDC_SEG_LAYER_D:
N            vSetGDCCAVRA_ALPHAD(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAD=(u8Alpha));
N            /* ALPHAD: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCCAVRA_REG__Var[eGDC])>>32)));
N            break;
N
N        case GDC_SEG_LAYER_E:
N            vSetGDCCAVRB_ALPHAE(eGDC, u8Alpha);
X            (((volatile GDCCAVRB_bit_view_st *) &u32GDCCAVRB_REG__Var[(eGDC)]) -> ALPHAE=(u8Alpha));
N            /* ALPHAE: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRB_REG__, u32GDCCAVRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02108U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCCAVRB_REG__Var[eGDC])));
N            break;
N
N        case GDC_SEG_WIN_A:
N            vSetGDCCAVRA_WALPHAA(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAA=(u8Alpha));
N            /* WALPHAA: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCCAVRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_SEG_WIN_B:
N            vSetGDCCAVRA_WALPHAB(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAB=(u8Alpha));
N            /* WALPHAB: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCCAVRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_SEG_WIN_C:
N            vSetGDCCAVRA_WALPHAC(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAC=(u8Alpha));
N            /* WALPHAC: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCCAVRA_REG__Var[eGDC])>>32)));
N            break;
N
N        case GDC_SEG_WIN_D:
N            vSetGDCCAVRA_WALPHAD(eGDC, u8Alpha);
X            (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAD=(u8Alpha));
N            /* WALPHAD: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCCAVRA_REG__, u64GDCCAVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02100U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCCAVRA_REG__Var[eGDC])>>32)));
N            break;
N
N        case GDC_SEG_WIN_E:
N            vSetGDCCAVRB_WALPHAE(eGDC, u8Alpha);
X            (((volatile GDCCAVRB_bit_view_st *) &u32GDCCAVRB_REG__Var[(eGDC)]) -> WALPHAE=(u8Alpha));
N            /* ALPHAE: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCAVRB_REG__, u32GDCCAVRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02108U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCCAVRB_REG__Var[eGDC])));
N            break;
N        default:
N            i32Res = C_FAILED;
X            i32Res = (-1);
N            break;
N    }
N    /* Report the result */
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_GetCommonAlpha(gdc_ch_e eGDC, gdc_seg_e eEntity, uint8_t* pu8Alpha)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    
N    /* check pointer: */
N    if (0x00 != pu8Alpha)
N    {
N        switch( eEntity )
N        {
N            case GDC_SEG_LAYER_A:
N                *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAA(eGDC);
X                *pu8Alpha= (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAA);
N                break;
N
N            case GDC_SEG_LAYER_B:
N                *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAB(eGDC);
X                *pu8Alpha= (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAB);
N                break;
N
N            case GDC_SEG_LAYER_C:
N                *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAC(eGDC);
X                *pu8Alpha= (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAC);
N                break;
N
N            case GDC_SEG_LAYER_D:
N                *pu8Alpha= (uint8_t) biGetGDCCAVRA_ALPHAD(eGDC);
X                *pu8Alpha= (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> ALPHAD);
N                break;
N
N            case GDC_SEG_LAYER_E:
N                *pu8Alpha= (uint8_t) biGetGDCCAVRB_ALPHAE(eGDC);
X                *pu8Alpha= (uint8_t) (((volatile GDCCAVRB_bit_view_st *) &u32GDCCAVRB_REG__Var[(eGDC)]) -> ALPHAE);
N                break;
N
N            case GDC_SEG_WIN_A:
N                *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAA(eGDC);
X                *pu8Alpha = (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAA);
N                break;
N
N            case GDC_SEG_WIN_B:
N                *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAB(eGDC);
X                *pu8Alpha = (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAB);
N                break;
N
N            case GDC_SEG_WIN_C:
N                *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAC(eGDC);
X                *pu8Alpha = (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAC);
N                break;
N
N            case GDC_SEG_WIN_D:
N                *pu8Alpha = (uint8_t) biGetGDCCAVRA_WALPHAD(eGDC);
X                *pu8Alpha = (uint8_t) (((volatile GDCCAVRA_bit_view_st *) &u64GDCCAVRA_REG__Var[(eGDC)]) -> WALPHAD);
N                break;
N
N            case GDC_SEG_WIN_E:
N                *pu8Alpha = (uint8_t) biGetGDCCAVRB_WALPHAE(eGDC);
X                *pu8Alpha = (uint8_t) (((volatile GDCCAVRB_bit_view_st *) &u32GDCCAVRB_REG__Var[(eGDC)]) -> WALPHAE);
N                break;
N
N            default:
N                /* Unsupported entity */
N                i32Res = C_FAILED;
X                i32Res = (-1);
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_FrameBuffConfig(gdc_ch_e eGDC, gdc_layer_e eLayer, gdc_fbcfg_st* pstBuffCfg)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    
N    /* check pointer: */
N    if (0x00 != pstBuffCfg)
N    {
N        switch( eLayer )
N        {
N            case GDC_LAYER_A:
N                /*
N                 *  Select default or secondary buffer, i.e. GDCLARA0 or
N                 *  GDCLARA1 and write the 32 LSbits of the buffer start
N                 *  address
N                 */
N                if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
N                {
N                    vSetGDCLARA0(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARA0_word_view *) &u32GDCLARA0_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA0_REG__, u32GDCLARA0_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02010U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARA0_REG__Var[eGDC])));
N                }
N                else
N                {
N                    vSetGDCLARA1(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARA1_word_view *) &u32GDCLARA1_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA1_REG__, u32GDCLARA1_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02018U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARA1_REG__Var[eGDC])));
N                }
N                vSetGDCMWRA_MWR(eGDC, pstBuffCfg->u16Width);
X                (((volatile GDCMWRA_bit_view_st *) &u32GDCMWRA_REG__Var[(eGDC)]) -> MWR=(pstBuffCfg->u16Width));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRA_REG__, u32GDCMWRA_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02068U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRA_REG__Var[eGDC])));
N                break;
N                
N            case GDC_LAYER_B:
N                /*
N                 *  Select default or secondary buffer, i.e. GDCSARB0 or
N                 *  GDCSARB1 and write the 32 LSbits of the buffer start
N                 *  address
N                 */
N                if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
N                {
N                    vSetGDCLARB0(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARB0_word_view *) &u32GDCLARB0_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB0_REG__, u32GDCLARB0_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02030U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARB0_REG__Var[eGDC])));
N                }
N                else
N                {
N                    vSetGDCLARB1(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARB1_word_view *) &u32GDCLARB1_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB1_REG__, u32GDCLARB1_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02038U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARB1_REG__Var[eGDC])));
N                }
N                vSetGDCMWRB_MWR(eGDC, pstBuffCfg->u16Width);
X                (((volatile GDCMWRB_bit_view_st *) &u32GDCMWRB_REG__Var[(eGDC)]) -> MWR=(pstBuffCfg->u16Width));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRB_REG__, u32GDCMWRB_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02070U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRB_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_C:
N                /*
N                 *  Select default or secondary buffer, i.e. GDCSARC0 or
N                 *  GDCSARC1 and write the 32 LSbits of the buffer start
N                 *  address
N                 */
N                if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
N                {
N                    vSetGDCLARC0(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARC0_word_view *) &u32GDCLARC0_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC0_REG__, u32GDCLARC0_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02048U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARC0_REG__Var[eGDC])));
N                }
N                else
N                {
N                    vSetGDCLARC1(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARC1_word_view *) &u32GDCLARC1_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC1_REG__, u32GDCLARC1_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02050U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARC1_REG__Var[eGDC])));
N                }
N                vSetGDCMWRC_MWR(eGDC, pstBuffCfg->u16Width);
X                (((volatile GDCMWRC_bit_view_st *) &u32GDCMWRC_REG__Var[(eGDC)]) -> MWR=(pstBuffCfg->u16Width));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRC_REG__, u32GDCMWRC_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02078U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRC_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_D:
N                /*
N                 *  Select default or secondary buffer, i.e. GDCSARD0 or
N                 *  GDCSARD1 and write the 32 LSbits of the buffer start
N                 *  address
N                 */
N                if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
N                {
N                    vSetGDCLARD0(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARD0_word_view *) &u32GDCLARD0_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD0_REG__, u32GDCLARD0_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02058U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARD0_REG__Var[eGDC])));
N                }
N                else
N                {
N                    vSetGDCLARD1(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARD1_word_view *) &u32GDCLARD1_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD1_REG__, u32GDCLARD1_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02060U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARD1_REG__Var[eGDC])));
N                }
N                vSetGDCMWRD_MWR(eGDC, pstBuffCfg->u16Width);
X                (((volatile GDCMWRD_bit_view_st *) &u32GDCMWRD_REG__Var[(eGDC)]) -> MWR=(pstBuffCfg->u16Width));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRD_REG__, u32GDCMWRD_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02080U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRD_REG__Var[eGDC])));
N                break;
N
N            case GDC_LAYER_E:
N                /*
N                 *  Select default or secondary buffer, i.e. GDCSARE0 or
N                 *  GDCSARE1 and write the 32 LSbits of the buffer start
N                 *  address
N                 */
N                if( GDC_BUFF_DEFAULT == pstBuffCfg->eBuff )
N                {
N                    vSetGDCLARE0(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARE0_word_view *) &u32GDCLARE0_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE0_REG__, u32GDCLARE0_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02230U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARE0_REG__Var[eGDC])));
N                }
N                else
N                {
N                    vSetGDCLARE1(eGDC, pstBuffCfg->u32Addr);
X                    (*((volatile u32GDCLARE1_word_view *) &u32GDCLARE1_REG__Var[(eGDC)]) = (pstBuffCfg->u32Addr));
N                    /* Copy register data to shadow register: */
N                    UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE1_REG__, u32GDCLARE1_REG__Var[eGDC]);
X                    (*((volatile uint32_t*) ((0xC0C02238U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARE1_REG__Var[eGDC])));
N                }
N                vSetGDCMWRE_MWR(eGDC, pstBuffCfg->u16Width);
X                (((volatile GDCMWRE_bit_view_st *) &u32GDCMWRE_REG__Var[(eGDC)]) -> MWR=(pstBuffCfg->u16Width));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRE_REG__, u32GDCMWRE_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02088U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRE_REG__Var[eGDC])));
N                break;
N
N            default:
N                /* Unsupported Layer */
N                i32Res = C_FAILED;
X                i32Res = (-1);
N                break;
N        }
N    }
N    else
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Ngdc_frmbuff_e eGDC_GetActiveFrameBuff(gdc_ch_e eGDC)
N{
N    return ((gdc_frmbuff_e) biGetGDCDCR_FBACT(eGDC) );
X    return ((gdc_frmbuff_e) (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> FBACT) );
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetMemWidth(gdc_ch_e eGDC, gdc_layer_e eLayer, uint16_t u16Width)
N{
N    switch( eLayer )
N    {
N        case GDC_LAYER_A:
N            vSetGDCMWRA_MWR(eGDC, u16Width);
X            (((volatile GDCMWRA_bit_view_st *) &u32GDCMWRA_REG__Var[(eGDC)]) -> MWR=(u16Width));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRA_REG__, u32GDCMWRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02068U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_B:
N            vSetGDCMWRB_MWR(eGDC, u16Width);
X            (((volatile GDCMWRB_bit_view_st *) &u32GDCMWRB_REG__Var[(eGDC)]) -> MWR=(u16Width));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRB_REG__, u32GDCMWRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02070U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRB_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_C:
N            vSetGDCMWRC_MWR(eGDC, u16Width);
X            (((volatile GDCMWRC_bit_view_st *) &u32GDCMWRC_REG__Var[(eGDC)]) -> MWR=(u16Width));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRC_REG__, u32GDCMWRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02078U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRC_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_D:
N            vSetGDCMWRD_MWR(eGDC, u16Width);
X            (((volatile GDCMWRD_bit_view_st *) &u32GDCMWRD_REG__Var[(eGDC)]) -> MWR=(u16Width));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRD_REG__, u32GDCMWRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02080U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRD_REG__Var[eGDC])));
N            break;
N
N        case GDC_LAYER_E:
N            vSetGDCMWRE_MWR(eGDC, u16Width);
X            (((volatile GDCMWRE_bit_view_st *) &u32GDCMWRE_REG__Var[(eGDC)]) -> MWR=(u16Width));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCMWRE_REG__, u32GDCMWRE_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02088U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCMWRE_REG__Var[eGDC])));
N            break;
N
N        default:
N            break;
N    }
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetLayerStartAddr(gdc_ch_e eGDC,  gdc_layer_e eLayer,
N                                 gdc_frmbuff_e eBuff, uint32_t u32Addr)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* modify Bits "SAR" in GDCLARxx register with masking: */
N    u32Addr &= GDC_SARXN_SAR_MASK;
X    u32Addr &= 0xFFFFFFF8U;
N
N    switch( eLayer )
N    {
N        case GDC_LAYER_A:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARA0(eGDC, u32Addr);
X                (*((volatile u32GDCLARA0_word_view *) &u32GDCLARA0_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA0_REG__, u32GDCLARA0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02010U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARA0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARA1(eGDC, u32Addr);
X                (*((volatile u32GDCLARA1_word_view *) &u32GDCLARA1_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA1_REG__, u32GDCLARA1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02018U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARA1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_B:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARB0(eGDC, u32Addr);
X                (*((volatile u32GDCLARB0_word_view *) &u32GDCLARB0_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB0_REG__, u32GDCLARB0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02030U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARB0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARB1(eGDC, u32Addr);
X                (*((volatile u32GDCLARB1_word_view *) &u32GDCLARB1_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB1_REG__, u32GDCLARB1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02038U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARB1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_C:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARC0(eGDC, u32Addr);
X                (*((volatile u32GDCLARC0_word_view *) &u32GDCLARC0_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC0_REG__, u32GDCLARC0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02048U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARC0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARC1(eGDC, u32Addr);
X                (*((volatile u32GDCLARC1_word_view *) &u32GDCLARC1_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC1_REG__, u32GDCLARC1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02050U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARC1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_D:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARD0(eGDC, u32Addr);
X                (*((volatile u32GDCLARD0_word_view *) &u32GDCLARD0_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD0_REG__, u32GDCLARD0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02058U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARD0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARD1(eGDC, u32Addr);
X                (*((volatile u32GDCLARD1_word_view *) &u32GDCLARD1_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD1_REG__, u32GDCLARD1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02060U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARD1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_E:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARE0(eGDC, u32Addr);
X                (*((volatile u32GDCLARE0_word_view *) &u32GDCLARE0_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE0_REG__, u32GDCLARE0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02230U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARE0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARE1(eGDC, u32Addr);
X                (*((volatile u32GDCLARE1_word_view *) &u32GDCLARE1_REG__Var[(eGDC)]) = (u32Addr));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE1_REG__, u32GDCLARE1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02238U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARE1_REG__Var[eGDC])));
N            }
N            break;
N
N        default:
N            /* Unsupported Layer */
N            i32Res = C_FAILED;
X            i32Res = (-1);
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetScrollVal(gdc_ch_e eGDC, gdc_layer_e eLayer,
N                            gdc_frmbuff_e eBuff, uint8_t u8ScrVal)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    switch( eLayer )
N    {
N        case GDC_LAYER_A:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARA0_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARA0_bit_view_st *) &u32GDCLARA0_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA0_REG__, u32GDCLARA0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02010U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARA0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARA1_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARA1_bit_view_st *) &u32GDCLARA1_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARA1_REG__, u32GDCLARA1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02018U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARA1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_B:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARB0_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARB0_bit_view_st *) &u32GDCLARB0_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB0_REG__, u32GDCLARB0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02030U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARB0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARB1_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARB1_bit_view_st *) &u32GDCLARB1_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARB1_REG__, u32GDCLARB1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02038U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARB1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_C:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARC0_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARC0_bit_view_st *) &u32GDCLARC0_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC0_REG__, u32GDCLARC0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02048U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARC0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARC1_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARC1_bit_view_st *) &u32GDCLARC1_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARC1_REG__, u32GDCLARC1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02050U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARC1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_D:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARD0_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARD0_bit_view_st *) &u32GDCLARD0_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD0_REG__, u32GDCLARD0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02058U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARD0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARD1_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARD1_bit_view_st *) &u32GDCLARD1_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARD1_REG__, u32GDCLARD1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02060U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARD1_REG__Var[eGDC])));
N            }
N            break;
N
N        case GDC_LAYER_E:
N            if( GDC_BUFF_DEFAULT == eBuff )
N            {
N                vSetGDCLARE0_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARE0_bit_view_st *) &u32GDCLARE0_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE0_REG__, u32GDCLARE0_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02230U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARE0_REG__Var[eGDC])));
N            }
N            else
N            {
N                vSetGDCLARE1_SSCROLL(eGDC, u8ScrVal);
X                (((volatile GDCLARE1_bit_view_st *) &u32GDCLARE1_REG__Var[(eGDC)]) -> SSCROLL=(u8ScrVal));
N                /* Copy register data to shadow register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCLARE1_REG__, u32GDCLARE1_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02238U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCLARE1_REG__Var[eGDC])));
N            }
N            break;
N
N        default:
N            /* Unsupported Layer */
N            i32Res = C_FAILED;
X            i32Res = (-1);
N            break;
N    }
N
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetStartAddrCapture(gdc_ch_e eGDC, gdc_cbuff_e eBuff, uint32_t u32Addr)
N{
N    switch( eBuff )
N    {
N        case GDC_CBUFF1:
N            vSetGDCCBAR0(eGDC, (u32Addr & GDC_CBARX_MASK));
X            (*((volatile u32GDCCBAR0_word_view *) &u32GDCCBAR0_REG__Var[(eGDC)]) = ((u32Addr & 0xFFFFFFF8U)));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCBAR0_REG__, u32GDCCBAR0_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02128U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCCBAR0_REG__Var[eGDC])));
N            break;
N
N        case GDC_CBUFF2:
N            vSetGDCCBAR1(eGDC, (u32Addr & GDC_CBARX_MASK));
X            (*((volatile u32GDCCBAR1_word_view *) &u32GDCCBAR1_REG__Var[(eGDC)]) = ((u32Addr & 0xFFFFFFF8U)));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCBAR1_REG__, u32GDCCBAR1_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02130U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCCBAR1_REG__Var[eGDC])));
N            break;
N
N        case GDC_CBUFF3:
N            vSetGDCCBAR2(eGDC, (u32Addr & GDC_CBARX_MASK));
X            (*((volatile u32GDCCBAR2_word_view *) &u32GDCCBAR2_REG__Var[(eGDC)]) = ((u32Addr & 0xFFFFFFF8U)));
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCCBAR2_REG__, u32GDCCBAR2_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02138U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCCBAR2_REG__Var[eGDC])));
N            break;
N
N        default:
N            break;
N    }
N}
N
N
N/****************************************************************************/
Nvoid vGDC_InitCorrClut(gdc_ch_e eGDC, gdc_clut_e eClut, const uint8_t* pu8Data)
N{
N
N    uint32_t u32Cnt;
N    
N    /* check pointer: */
N    if (0x00 != pu8Data)
N    {
N        switch (eClut)
N        {
N            case  GDC_CLUT_RED:
N                for(u32Cnt = 0; u32Cnt < GDC_CLUTSIZE_CORR; u32Cnt++)
X                for(u32Cnt = 0; u32Cnt < 256; u32Cnt++)
N                {
N                    vSetGDCCCLUTR(eGDC, u32Cnt, pu8Data[u32Cnt]);
X                    (*((volatile u8GDCCCLUTR_byte_view *)(0xC0C02400U + ((uint8_t)((eGDC)) * 0x1000U) + ((uint16_t)((u32Cnt)) * 0x4U))) = (pu8Data[u32Cnt]));
N                }
N                break;
N            case  GDC_CLUT_GREEN:
N                for(u32Cnt = 0; u32Cnt < GDC_CLUTSIZE_CORR; u32Cnt++)
X                for(u32Cnt = 0; u32Cnt < 256; u32Cnt++)
N                {
N                    vSetGDCCCLUTG(eGDC, u32Cnt, pu8Data[u32Cnt]);
X                    (*((volatile u8GDCCCLUTG_byte_view *)(0xC0C02800U + ((uint8_t)((eGDC)) * 0x1000U) + ((uint16_t)((u32Cnt)) * 0x4U))) = (pu8Data[u32Cnt]));
N                }
N                break;
N            case  GDC_CLUT_BLUE:
N                for(u32Cnt = 0; u32Cnt < GDC_CLUTSIZE_CORR; u32Cnt++)
X                for(u32Cnt = 0; u32Cnt < 256; u32Cnt++)
N                {
N                    vSetGDCCCLUTB(eGDC, u32Cnt, pu8Data[u32Cnt]);
X                    (*((volatile u8GDCCCLUTB_byte_view *)(0xC0C02C00U + ((uint8_t)((eGDC)) * 0x1000U) + ((uint16_t)((u32Cnt)) * 0x4U))) = (pu8Data[u32Cnt]));
N                }
N                break;
N            default:
N                break;
N        }
N    }
N
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetSelectCorrCompVal(gdc_ch_e eGDC,  gdc_cmp_e eSelection, uint32_t u32CorrCompVal)
N{
N    switch( eSelection )
N    {
N        /* Data from register: GDCSCVRA_REG__: */
N        case GDC_CCVAL0:  
N            vSetGDCSCVRA_CCV0(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRA_bit_view_st *) &u64GDCSCVRA_REG__Var[(eGDC)]) -> CCV0=(u32CorrCompVal));
N            /* CCV0: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02288U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRA_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL1:
N            vSetGDCSCVRA_CCV1(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRA_bit_view_st *) &u64GDCSCVRA_REG__Var[(eGDC)]) -> CCV1=(u32CorrCompVal));
N            /* CCV1: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02288U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRA_REG__Var[eGDC])>>32)));
N            break;
N            
N        /* Data from register: GDCSCVRB_REG__*/
N        case GDC_CCVAL2:
N            vSetGDCSCVRB_CCV2(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRB_bit_view_st *) &u64GDCSCVRB_REG__Var[(eGDC)]) -> CCV2=(u32CorrCompVal));
N            /* CCV2: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02290U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRB_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL3:
N            vSetGDCSCVRB_CCV3(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRB_bit_view_st *) &u64GDCSCVRB_REG__Var[(eGDC)]) -> CCV3=(u32CorrCompVal));
N            /* CCV3: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02290U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRB_REG__Var[eGDC])>>32)));
N            break;
N            
N        /* Data from register: GDCSCVRC_REG__*/
N        case GDC_CCVAL4:
N            vSetGDCSCVRC_CCV4(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRC_bit_view_st *) &u64GDCSCVRC_REG__Var[(eGDC)]) -> CCV4=(u32CorrCompVal));
N            /* CCV4: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02298U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRC_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL5:
N            vSetGDCSCVRC_CCV5(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRC_bit_view_st *) &u64GDCSCVRC_REG__Var[(eGDC)]) -> CCV5=(u32CorrCompVal));
N            /* CCV5: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02298U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRC_REG__Var[eGDC])>>32)));
N            break;
N            
N        /* Data from register: GDCSCVRD_REG__*/            
N        case GDC_CCVAL6:
N            vSetGDCSCVRD_CCV6(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRD_bit_view_st *) &u64GDCSCVRD_REG__Var[(eGDC)]) -> CCV6=(u32CorrCompVal));
N            /* CCV6: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C022A0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRD_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL7:
N            vSetGDCSCVRD_CCV7(eGDC, u32CorrCompVal);
X            (((volatile GDCSCVRD_bit_view_st *) &u64GDCSCVRD_REG__Var[(eGDC)]) -> CCV7=(u32CorrCompVal));
N            /* CCV7: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C022A0U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRD_REG__Var[eGDC])>>32)));
N            break;
N            
N        default:
N            break;
N    }
N    return;
N}
N
N
N/****************************************************************************/
Nvoid  vGDC_ActivateCorrCompVal(gdc_ch_e eGDC, gdc_cmp_e eSelection, gdc_active_e eActive)
N{
N    switch( eSelection )
N    {
N        /* Data from register: GDCSCVRA_REG__: */
N        case GDC_CCVAL0:  
N            vSetGDCSCVRA_ACT0(eGDC, eActive);
X            (((volatile GDCSCVRA_bit_view_st *) &u64GDCSCVRA_REG__Var[(eGDC)]) -> ACT0=(eActive));
N            /* CCVAL0: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02288U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRA_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL1:
N            vSetGDCSCVRA_ACT1(eGDC, eActive);
X            (((volatile GDCSCVRA_bit_view_st *) &u64GDCSCVRA_REG__Var[(eGDC)]) -> ACT1=(eActive));
N            /* CCVAL1: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRA_REG__, u64GDCSCVRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02288U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRA_REG__Var[eGDC])>>32)));
N            break;
N            
N        /* Data from register: GDCSCVRB_REG__*/
N        case GDC_CCVAL2:
N            vSetGDCSCVRB_ACT2(eGDC, eActive);
X            (((volatile GDCSCVRB_bit_view_st *) &u64GDCSCVRB_REG__Var[(eGDC)]) -> ACT2=(eActive));
N            /* CCVAL2: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02290U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRB_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL3:
N            vSetGDCSCVRB_ACT3(eGDC, eActive);
X            (((volatile GDCSCVRB_bit_view_st *) &u64GDCSCVRB_REG__Var[(eGDC)]) -> ACT3=(eActive));
N            /* CCVAL3: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRB_REG__, u64GDCSCVRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02290U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRB_REG__Var[eGDC])>>32)));
N            break;
N            
N        /* Data from register: GDCSCVRC_REG__*/
N        case GDC_CCVAL4:
N            vSetGDCSCVRC_ACT4(eGDC, eActive);
X            (((volatile GDCSCVRC_bit_view_st *) &u64GDCSCVRC_REG__Var[(eGDC)]) -> ACT4=(eActive));
N            /* CCVAL4: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02298U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRC_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL5:
N            vSetGDCSCVRC_ACT5(eGDC, eActive);
X            (((volatile GDCSCVRC_bit_view_st *) &u64GDCSCVRC_REG__Var[(eGDC)]) -> ACT5=(eActive));
N            /* CCV5: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRC_REG__, u64GDCSCVRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02298U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRC_REG__Var[eGDC])>>32)));
N            break;
N            
N        /* Data from register: GDCSCVRD_REG__*/
N        case GDC_CCVAL6:
N            vSetGDCSCVRD_ACT6(eGDC, eActive);
X            (((volatile GDCSCVRD_bit_view_st *) &u64GDCSCVRD_REG__Var[(eGDC)]) -> ACT6=(eActive));
N            /* CCVAL5: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C022A0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCSCVRD_REG__Var[eGDC])));
N            break;
N            
N        case GDC_CCVAL7:
N            vSetGDCSCVRD_ACT7(eGDC, eActive);
X            (((volatile GDCSCVRD_bit_view_st *) &u64GDCSCVRD_REG__Var[(eGDC)]) -> ACT7=(eActive));
N            /* CCVAL6: belongs to high word of register: */
N            UPDATE_REGISTER_HIGH_WORD(eGDC, GDCSCVRD_REG__, u64GDCSCVRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C022A0U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64GDCSCVRD_REG__Var[eGDC])>>32)));
N            break;
N
N        default:
N            break;
N    }
N}
N
N
N/****************************************************************************/
Nvoid vGDC_EnableSelectiveCorr(gdc_ch_e eGDC, gdc_en_e eEn, gdc_ccmode_e eMode)
N{
N    vSetGDCDCR_SCCM(eGDC, eMode);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> SCCM=(eMode));
N    vSetGDCDCR_SCCEN(eGDC, eEn);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> SCCEN=(eEn));
N    /* SCCM and SCCEN: belong to high word of register: */
N    /* GDCDCR register should be updated special: */  
N    vUpdateDCR_HighWord_Special(eGDC);
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetDisplayStart(gdc_ch_e eGDC, uint16_t u16HStart, uint16_t u16VStart)
N{
N    uint32_t u32Val;
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    
N    if ( (u16HStart<GDC_DISP_HSTART_MIN)  || (u16HStart>GDC_DISP_HSTART_MAX) || 
X    if ( (u16HStart<64U)  || (u16HStart>2047U) || 
N          (u16VStart<GDC_DISP_VSTART_MIN) || (u16VStart>GDC_DISP_VSTART_MAX) )
X          (u16VStart<64U) || (u16VStart>1023U) )
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        /* Compose the entire register value */
N        u32Val = (((uint32_t) (u16HStart & GDC_11_BIT_MASK)) << 16) | (u16VStart & GDC_10_BIT_MASK);
X        u32Val = (((uint32_t) (u16HStart & 0x000007FFU)) << 16) | (u16VStart & 0x000003FFU);
N
N        /* Set */
N        vSetGDCDSR(eGDC, u32Val);
X        (*((volatile u32GDCDSR_word_view *) &u32GDCDSR_REG__Var[(eGDC)]) = (u32Val));
N        /* DVS and DHS : belong to low word of register: */
N        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDSR_REG__, u32GDCDSR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C022B0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCDSR_REG__Var[eGDC])));
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetDisplaySize(gdc_ch_e eGDC, uint16_t u16Width, uint16_t u16Height)
N{
N    uint32_t u32Val;
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    
N    if ( (u16Width<GDC_DISP_WIDTH_MIN)   || (u16Width>GDC_DISP_WIDTH_MAX) || 
X    if ( (u16Width<64U)   || (u16Width>2047U) || 
N          (u16Height<GDC_DISP_HEIGHT_MIN) || (u16Height>GDC_DISP_HEIGHT_MAX) )
X          (u16Height<1U) || (u16Height>1023U) )
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        /* Compose the entire register value */
N        u32Val = (((uint32_t) (u16Width & GDC_12_BIT_MASK)) << 16) | (u16Height & GDC_11_BIT_MASK);
X        u32Val = (((uint32_t) (u16Width & 0x00000FFFU)) << 16) | (u16Height & 0x000007FFU);
N
N        /* Set */
N        vSetGDCDIMR(eGDC, u32Val);
X        (*((volatile u32GDCDIMR_word_view *) &u32GDCDIMR_REG__Var[(eGDC)]) = (u32Val));
N        /* DHEIGHT and DWIDTH : belong to low word of register: */
N        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDIMR_REG__, u32GDCDIMR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C022B8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCDIMR_REG__Var[eGDC])));
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_WindowEnable(gdc_ch_e eGDC, gdc_win_e eWindow, gdc_en_e eEn)
N{
N    /* Single window selection */
N    switch( eWindow )
N    {
N         case GDC_WIN_A:
N             vSetGDCDCR_WAEN(eGDC, eEn);
X             (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> WAEN=(eEn));
N             /* WAEN: belongs to low word of register: */
N             UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X             (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N             break;
N
N         case GDC_WIN_B:
N             vSetGDCDCR_WBEN(eGDC, eEn);
X             (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> WBEN=(eEn));
N             /* WBEN: belongs to low word of register: */
N             UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X             (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N             break;
N
N         case GDC_WIN_C:
N             vSetGDCDCR_WCEN(eGDC, eEn);
X             (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> WCEN=(eEn));
N             /* WCEN: belongs to low word of register: */
N             UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X             (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N             break;
N
N         case GDC_WIN_D:
N             vSetGDCDCR_WDEN(eGDC, eEn);
X             (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> WDEN=(eEn));
N             /* WDEN: belongs to low word of register: */
N             UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X             (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N             break;
N
N         case GDC_WIN_E:
N             vSetGDCDCR_WEEN(eGDC, eEn);
X             (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> WEEN=(eEn));
N             /* WEEN: belongs to high word of register: */
N             /* GDCDCR register should be updated special: */
N             vUpdateDCR_HighWord_Special(eGDC);
N             break;
N             
N         default:
N             break;
N    }
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetWindowSize(gdc_ch_e eGDC, gdc_win_e eWindow,
N                             uint16_t u16Width, uint16_t u16Height)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N    uint32_t u32Val;
N
N    if( (u16Width & GDC_12_BIT_MASK) < GDC_WIMR_WIDHT_MIN_VAL )
X    if( (u16Width & 0x00000FFFU) < 8 )
N    {
N        i32Res = C_FAILED;
X        i32Res = (-1);
N    }
N    else
N    {
N        /* Compose the entire register value */
N        u32Val = (((uint32_t) (u16Width & GDC_12_BIT_MASK)) << 16) | (u16Height & GDC_11_BIT_MASK);
X        u32Val = (((uint32_t) (u16Width & 0x00000FFFU)) << 16) | (u16Height & 0x000007FFU);
N
N        /* Set */
N        switch( eWindow )
N        {
N            case GDC_WIN_A:
N                vSetGDCWIMRA(eGDC, u32Val);
X                (*((volatile u32GDCWIMRA_word_view *) &u32GDCWIMRA_REG__Var[(eGDC)]) = (u32Val));
N                /* WHEIGHT & WWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRA_REG__, u32GDCWIMRA_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020F0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWIMRA_REG__Var[eGDC])));
N                break;
N
N            case GDC_WIN_B:
N                vSetGDCWIMRB(eGDC, u32Val);
X                (*((volatile u32GDCWIMRB_word_view *) &u32GDCWIMRB_REG__Var[(eGDC)]) = (u32Val));
N                /* WHEIGHT & WWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRB_REG__, u32GDCWIMRB_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C020F8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWIMRB_REG__Var[eGDC])));
N                break;
N
N            case GDC_WIN_C:
N                vSetGDCWIMRC(eGDC, u32Val);
X                (*((volatile u32GDCWIMRC_word_view *) &u32GDCWIMRC_REG__Var[(eGDC)]) = (u32Val));
N                /* WHEIGHT & WWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRC_REG__, u32GDCWIMRC_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02270U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWIMRC_REG__Var[eGDC])));
N                break;
N
N            case GDC_WIN_D:
N                vSetGDCWIMRD(eGDC, u32Val);
X                (*((volatile u32GDCWIMRD_word_view *) &u32GDCWIMRD_REG__Var[(eGDC)]) = (u32Val));
N                /* WHEIGHT & WWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRD_REG__, u32GDCWIMRD_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02278U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWIMRD_REG__Var[eGDC])));
N                break;
N
N            case GDC_WIN_E:
N                vSetGDCWIMRE(eGDC, u32Val);
X                (*((volatile u32GDCWIMRE_word_view *) &u32GDCWIMRE_REG__Var[(eGDC)]) = (u32Val));
N                /* WHEIGHT & WWIDTH: belong to low word of register: */
N                UPDATE_REGISTER_LOW_WORD(eGDC, GDCWIMRE_REG__, u32GDCWIMRE_REG__Var[eGDC]);
X                (*((volatile uint32_t*) ((0xC0C02280U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWIMRE_REG__Var[eGDC])));
N                break;
N                
N            default:
N                i32Res = C_FAILED;
X                i32Res = (-1);
N                break;
N        }
N    }
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetWindowStartPos(gdc_ch_e eGDC, gdc_win_e eWindow, uint16_t u16HStart, uint16_t u16VStart)
N
N{
N    uint32_t u32Val;
N
N    /* Compose the entire register value */
N    u32Val = (((uint32_t) (u16HStart & GDC_11_BIT_MASK)) << 16) | (u16VStart & GDC_10_BIT_MASK);
X    u32Val = (((uint32_t) (u16HStart & 0x000007FFU)) << 16) | (u16VStart & 0x000003FFU);
N    switch( eWindow )
N    {
N        case GDC_WIN_A:
N            vSetGDCWSRA(eGDC, u32Val);
X            (*((volatile u32GDCWSRA_word_view *) &u32GDCWSRA_REG__Var[(eGDC)]) = (u32Val));
N            /* WVS & WHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRA_REG__, u32GDCWSRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C020E0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWSRA_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_B:
N            vSetGDCWSRB(eGDC, u32Val);
X            (*((volatile u32GDCWSRB_word_view *) &u32GDCWSRB_REG__Var[(eGDC)]) = (u32Val));
N            /* WVS & WHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRB_REG__, u32GDCWSRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C020E8U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWSRB_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_C:
N            vSetGDCWSRC(eGDC, u32Val);
X            (*((volatile u32GDCWSRC_word_view *) &u32GDCWSRC_REG__Var[(eGDC)]) = (u32Val));
N            /* WVS & WHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRC_REG__, u32GDCWSRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02258U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWSRC_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_D:
N            vSetGDCWSRD(eGDC, u32Val);
X            (*((volatile u32GDCWSRD_word_view *) &u32GDCWSRD_REG__Var[(eGDC)]) = (u32Val));
N            /* WVS & WHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRD_REG__, u32GDCWSRD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02260U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWSRD_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_E:
N            vSetGDCWSRE(eGDC, u32Val);
X            (*((volatile u32GDCWSRE_word_view *) &u32GDCWSRE_REG__Var[(eGDC)]) = (u32Val));
N            /* WVS & WHS: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWSRE_REG__, u32GDCWSRE_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02268U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWSRE_REG__Var[eGDC])));
N            break;
N            
N        default:
N            break;
N    }
N}
N
N
N/****************************************************************************/
Nint32_t i32GDC_SetWindowStartAddr(gdc_ch_e eGDC, gdc_win_e eWindow, uint32_t u32Addr)
N{
N    int32_t i32Res = C_SUCCESS;
X    int32_t i32Res = (0);
N
N    /* Mask out the zero wired bits */
N    u32Addr &= GDC_WARXN_WAR_MASK;
X    u32Addr &= 0xFFFFFFFEU;
N
N    /* Window selection */
N    switch( eWindow )
N    {
N        case GDC_WIN_A:
N            vSetGDCWARA(eGDC, u32Addr);
X            (*((volatile u32GDCWARA_word_view *) &u32GDCWARA_REG__Var[(eGDC)]) = (u32Addr));
N            /* WAR: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARA_REG__, u32GDCWARA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02020U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWARA_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_B:
N            vSetGDCWARB(eGDC, u32Addr);
X            (*((volatile u32GDCWARB_word_view *) &u32GDCWARB_REG__Var[(eGDC)]) = (u32Addr));
N            /* WAR: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARB_REG__, u32GDCWARB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02040U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWARB_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_C:
N            vSetGDCWARC(eGDC, u32Addr);
X            (*((volatile u32GDCWARC_word_view *) &u32GDCWARC_REG__Var[(eGDC)]) = (u32Addr));
N            /* WAR: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARC_REG__, u32GDCWARC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02240U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWARC_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_D:
N            vSetGDCWARD(eGDC, u32Addr);
X            (*((volatile u32GDCWARD_word_view *) &u32GDCWARD_REG__Var[(eGDC)]) = (u32Addr));
N            /* WAR: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARD_REG__, u32GDCWARD_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02248U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWARD_REG__Var[eGDC])));
N            break;
N
N        case GDC_WIN_E:
N            vSetGDCWARE(eGDC, u32Addr);
X            (*((volatile u32GDCWARE_word_view *) &u32GDCWARE_REG__Var[(eGDC)]) = (u32Addr));
N            /* WAR: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCWARE_REG__, u32GDCWARE_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02250U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCWARE_REG__Var[eGDC])));
N            break;
N
N        default:
N            /* Unsupported window */
N            i32Res = C_FAILED;
X            i32Res = (-1);
N            break;
N    }
N    /* Result reporting */
N    return i32Res;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SyncConfig(gdc_ch_e eGDC, gdc_sync_st* pstSyncCfg)
N{
N#ifdef HW_UPDATE_BUG_FIXED
S    gdc_reg_update_mode_e eLastUpdateMode;
N#endif
N    if (0x00 != pstSyncCfg)
N    {
N        vSetGDCDCR_CSYNC(eGDC, pstSyncCfg->eSyncType);
X        (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> CSYNC=(pstSyncCfg->eSyncType));
N        vSetGDCDCR_PVSYNC(eGDC, pstSyncCfg->eVSyncPol);
X        (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PVSYNC=(pstSyncCfg->eVSyncPol));
N        vSetGDCDCR_PHSYNC(eGDC, pstSyncCfg->eHSyncPol);
X        (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PHSYNC=(pstSyncCfg->eHSyncPol));
N        
N        vSetGDCHSR_HSPWR(eGDC, pstSyncCfg->u8HsyncWdth);
X        (((volatile GDCHSR_bit_view_st *) &u32GDCHSR_REG__Var[(eGDC)]) -> HSPWR=(pstSyncCfg->u8HsyncWdth));
N        vSetGDCHSR_HCR(eGDC, pstSyncCfg->u16HLineLen);
X        (((volatile GDCHSR_bit_view_st *) &u32GDCHSR_REG__Var[(eGDC)]) -> HCR=(pstSyncCfg->u16HLineLen));
N
N        vSetGDCVSR_VSPWR(eGDC, pstSyncCfg->u8VsyncWdth);
X        (((volatile GDCVSR_bit_view_st *) &u32GDCVSR_REG__Var[(eGDC)]) -> VSPWR=(pstSyncCfg->u8VsyncWdth));
N        vSetGDCVSR_VCR(eGDC, pstSyncCfg->u16VFrameLen);
X        (((volatile GDCVSR_bit_view_st *) &u32GDCVSR_REG__Var[(eGDC)]) -> VCR=(pstSyncCfg->u16VFrameLen));
N        
N#ifdef HW_UPDATE_BUG_FIXED
S        /* get last actual update mode for later restore:*/
S        eLastUpdateMode = eGetShadowRegUpdateStatus(eGDC);
S
S        /* Disable Update Mode if it was not disabled: */
S        if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
S        {
S            vGDC_SetShadowRegUpdateMode(eGDC, GDC_NO_UPDATE_BY_VSYNC);
S        }
N#endif
N        /* All modified bit fields belong to Low Word of registers,
N         * so Copy register data to shadow register: */
N        UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N        UPDATE_REGISTER_LOW_WORD(eGDC, GDCHSR_REG__, u32GDCHSR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C02110U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCHSR_REG__Var[eGDC])));
N        UPDATE_REGISTER_LOW_WORD(eGDC, GDCVSR_REG__, u32GDCVSR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C02118U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCVSR_REG__Var[eGDC])));
N        
N#ifdef HW_UPDATE_BUG_FIXED
S        /* restore Update Mode if necessary */
S        if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
S        {
S            vGDC_SetShadowRegUpdateMode(eGDC, eLastUpdateMode);
S        }
N#endif
N    }
N}
N
N/****************************************************************************/
Nvoid vGDC_SetSyncDir(gdc_ch_e eGDC, gdc_dir_e eDir)
N{
N    vSetGDCDCR_EXTSYNC(eGDC, eDir);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> EXTSYNC=(eDir));
N    /* EXTSYNC: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SelectCompSync(gdc_ch_e eGDC, gdc_csync_e eSync)
N{
N    vSetGDCDCR_CSYNC(eGDC, eSync);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> CSYNC=(eSync));
N    /* CSYNC: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetPolVSync(gdc_ch_e eGDC, gdc_pol_e eMode)
N{
N    vSetGDCDCR_PVSYNC(eGDC, eMode);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PVSYNC=(eMode));
N    /* PVSYNC belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetPolHSync(gdc_ch_e eGDC, gdc_pol_e eMode)
N{
N    vSetGDCDCR_PHSYNC(eGDC, eMode);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PHSYNC=(eMode));
N    /* PHSYNC belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetPolHDisp(gdc_ch_e eGDC, gdc_pol_e eMode)
N{
N    vSetGDCDCR_PHDISP(eGDC, eMode);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> PHDISP=(eMode));
N    /* PHDISP: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetHSync(gdc_ch_e eGDC, uint8_t u8PulseWidth, uint16_t u16LineLen)
N{
N    vSetGDCHSR_HSPWR(eGDC, u8PulseWidth);
X    (((volatile GDCHSR_bit_view_st *) &u32GDCHSR_REG__Var[(eGDC)]) -> HSPWR=(u8PulseWidth));
N    vSetGDCHSR_HCR(eGDC, u16LineLen);
X    (((volatile GDCHSR_bit_view_st *) &u32GDCHSR_REG__Var[(eGDC)]) -> HCR=(u16LineLen));
N    /* Copy register data to shadow register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCHSR_REG__, u32GDCHSR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02110U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCHSR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetVSync(gdc_ch_e eGDC, uint8_t u8PulseWidth, uint16_t u16VFrameLen)
N{
N    vSetGDCVSR_VSPWR(eGDC, u8PulseWidth);
X    (((volatile GDCVSR_bit_view_st *) &u32GDCVSR_REG__Var[(eGDC)]) -> VSPWR=(u8PulseWidth));
N    vSetGDCVSR_VCR(eGDC, u16VFrameLen);
X    (((volatile GDCVSR_bit_view_st *) &u32GDCVSR_REG__Var[(eGDC)]) -> VCR=(u16VFrameLen));
N    /* Copy register data to shadow register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCVSR_REG__, u32GDCVSR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02118U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCVSR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_IrqConfig(gdc_ch_e eGDC, gdc_irqcgf_st* pstCfg)
N{
N    if (0x00 != pstCfg)
N    {
N        vSetGDCINTR_APCMSK(eGDC, pstCfg->eAPCIrqEn);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> APCMSK=(pstCfg->eAPCIrqEn));
N        vSetGDCINTR_LINE(eGDC, pstCfg->u16LineNr);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> LINE=(pstCfg->u16LineNr));
N        vSetGDCINTR_HSYNCMSK(eGDC, pstCfg->eHSyncIrqEn);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> HSYNCMSK=(pstCfg->eHSyncIrqEn));
N        vSetGDCINTR_VSYNCMSK(eGDC, pstCfg->eVSyncIrqEn);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> VSYNCMSK=(pstCfg->eVSyncIrqEn));
N
N        vSetGDCINTR_IFURMSK(eGDC, pstCfg->eIfurIrqEn);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> IFURMSK=(pstCfg->eIfurIrqEn));
N        vSetGDCINTR_OFURMSK(eGDC, pstCfg->eOfurIrqEn);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> OFURMSK=(pstCfg->eOfurIrqEn));
N    }
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetIrqMaskAPC(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCINTR_APCMSK(eGDC, eEn);
X    (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> APCMSK=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetHsyncIrqLine(gdc_ch_e eGDC, uint16_t u16LineNr)
N{
N    vSetGDCINTR_LINE(eGDC, u16LineNr);
X    (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> LINE=(u16LineNr));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetIrqMaskFifoIn(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCINTR_IFURMSK(eGDC, eEn);
X    (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> IFURMSK=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetIrqMaskFifoOut(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCINTR_OFURMSK(eGDC, eEn);
X    (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> OFURMSK=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetIrqMaskVSync(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCINTR_VSYNCMSK(eGDC, eEn);
X    (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> VSYNCMSK=(eEn));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetIrqMaskHSync(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCINTR_HSYNCMSK(eGDC, eEn);
X    (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> HSYNCMSK=(eEn));
N}
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqHSync(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = (int32_t)biGetGDCINTR_HSYNCINT(eGDC);
X    i32IrqStat = (int32_t)(((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> HSYNCINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_HSYNCINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> HSYNCINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqVSync(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = (int32_t)biGetGDCINTR_VSYNCINT(eGDC);
X    i32IrqStat = (int32_t)(((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> VSYNCINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_VSYNCINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> VSYNCINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqFifoIn(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = (int32_t)biGetGDCINTR_IFURINT(eGDC);
X    i32IrqStat = (int32_t)(((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> IFURINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_IFURINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> IFURINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqFifoOut(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = (int32_t)biGetGDCINTR_OFURINT(eGDC);
X    i32IrqStat = (int32_t)(((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> OFURINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_OFURINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> OFURINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqAPC(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = (int32_t)biGetGDCINTR_APCINT(eGDC);
X    i32IrqStat = (int32_t)(((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> APCINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_APCINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> APCINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_PnlGppOutEnable(gdc_gpp_e ePin, gdc_en_e eEn)
N{
N    uint32_t u32PinStat;
N    uint32_t u32Tmp;
N
N    /* API valid only for GDC0 : */
N    u32PinStat = u32GetGDCPTCR(GDC0);
X    u32PinStat = (*((volatile u32GDCPTCR_word_view *) &u32GDCPTCR_REG__Var[(GDC0)]) );
N
N    u32Tmp = 0x1;
N    u32Tmp <<= (uint32_t) ePin;
N
N    if( 1 == eEn )
N    {
N       u32PinStat |= u32Tmp;
N    }
N    else
N    {
N        u32PinStat &= ~u32Tmp;
N    }
N
N    vSetGDCPTCR(GDC0, u32PinStat);
X    (*((volatile u32GDCPTCR_word_view *) &u32GDCPTCR_REG__Var[(GDC0)]) = (u32PinStat));
N    /* Copy register data to shadow register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nvoid vGDC_SetPnlPositiveSyncSelect(gdc_ppsync_e eSync)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_PPSYNC(GDC0, eSync);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> PPSYNC=(eSync));
N    /* PPSYNC: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nbool_t boGDC_IsPnlRSPowerUpFinished(void)
N{
N    bool_t boRes = C_FALSE;
X    bool_t boRes = (0);
N    
N    /* API valid only for GDC0 : */
N    if( biGetGDCPTCR_RSPUP(GDC0) )
X    if( (((volatile GDCPTCR_bit_view_st *)(0xC0C02148U + ((uint8_t)(GDC0) * 0x1000U) )) -> RSPUP) )
N    {
N        boRes = C_TRUE;
X        boRes = (1);
N    }
N    return boRes;
N}
N
N/****************************************************************************/
Nbool_t boGDC_IsPnlRSReady(void)
N{
N    bool_t boRes = C_FALSE;
X    bool_t boRes = (0);
N    
N    /* API valid only for GDC0 : */
N    if( biGetGDCPTCR_RSDRDY(GDC0) )
X    if( (((volatile GDCPTCR_bit_view_st *)(0xC0C02148U + ((uint8_t)(GDC0) * 0x1000U) )) -> RSDRDY) )
N    {
N        boRes = C_TRUE;
X        boRes = (1);
N    }
N    return boRes;
N}
N
N/****************************************************************************/
Nvoid vGDC_SetPnlRSDSEnable(gdc_rsdsen_e eOutput)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_RSDSEN(GDC0, eOutput);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> RSDSEN=(eOutput));
N    /* RSDSEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nvoid vGDC_SetPnlSyncModeEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_PSMEN(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> PSMEN=(eEn));
N    /* PSMEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nvoid vGDC_SetPnlRSDSOutputCurrentMode(gdc_rsdsoutmode_e eOutMode)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_OCMD(GDC0, eOutMode);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> OCMD=(eOutMode));
N    /* OCMD: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nvoid vGDC_SetPnlRSDSPreEmphasisMode(gdc_rsdspreemp_e ePreEmp)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_PEMD(GDC0, ePreEmp);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> PEMD=(ePreEmp));
N    /* PEMD: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nvoid vGDC_SetPnlRSDSHighImpedanceEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_HIZEN(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> HIZEN=(eEn));
N    /* HIZEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nbool_t boGDC_IsPnlInputSync(void)
N{
N    bool_t boRes = C_FALSE;
X    bool_t boRes = (0);
N
N    /* API valid only for GDC0 : */
N    if( biGetGDCPTCR_PSYNC(GDC0) )
X    if( (((volatile GDCPTCR_bit_view_st *)(0xC0C02148U + ((uint8_t)(GDC0) * 0x1000U) )) -> PSYNC) )
N    {
N        boRes = C_TRUE;
X        boRes = (1);
N    }
N    return boRes;
N}
N/****************************************************************************/
Nbool_t boGDC_IsPnlTimingControlInterfaceEnabled(void)
N{
N    bool_t boRes = C_FALSE;
X    bool_t boRes = (0);
N
N    /* API valid only for GDC0 : */
N    if( biGetGDCPTCR_PTCEN(GDC0) )
X    if( (((volatile GDCPTCR_bit_view_st *)(0xC0C02148U + ((uint8_t)(GDC0) * 0x1000U) )) -> PTCEN) )
N    {
N        boRes = C_TRUE;
X        boRes = (1);
N    }
N    return boRes;
N}
N
N/****************************************************************************/
Nvoid vGDC_SetAlignData(gdc_ddal_e eAllign)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_DDAL(GDC0, eAllign);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> DDAL=(eAllign));
N    /* DDAL: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetPnlAlignClock(gdc_dcal_e eEdge)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_DCAL(GDC0, eEdge);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> DCAL=(eEdge));
N    /* DCAL: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_PnlAlterEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_ALT(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> ALT=(eEn));
N    /* ALT: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_PnlEvenDataInvEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_EINVEN(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> EINVEN=(eEn));
N    /* EINVEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_PnlEvenRgbOutEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_ERGBEN(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> ERGBEN=(eEn));
N    /* ERGBEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_PnlOddDataInvEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_OINVEN(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> OINVEN=(eEn));
N    /* OINVEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_PnlOddRgbOutEnable(gdc_en_e eEn)
N{
N    /* API valid only for GDC0 : */
N    vSetGDCPTCR_ORGBEN(GDC0, eEn);
X    (((volatile GDCPTCR_bit_view_st *) &u32GDCPTCR_REG__Var[(GDC0)]) -> ORGBEN=(eEn));
N    /* ORGBEN: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(GDC0, GDCPTCR_REG__, u32GDCPTCR_REG__Var[GDC0]);
X    (*((volatile uint32_t*) ((0xC0C02148U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPTCR_REG__Var[GDC0])));
N}
N
N/****************************************************************************/
Nint32_t i32GDC_PnlSyncMode(uint16_t u16PnlSyncModeDelay, uint8_t u8PnlSyncDataDelay)
N{
N    int32_t iRes = C_SUCCESS;
X    int32_t iRes = (0);
N
N    /* API valid only for GDC0 : */
N    /* parameter range check: */
N    if ( (u16PnlSyncModeDelay<7) || (u16PnlSyncModeDelay>2047) )
N    {
N        iRes = C_FAILED; 
X        iRes = (-1); 
N    }
N    else
N    {
N        if (u8PnlSyncDataDelay>15) 
N        {
N            iRes = C_FAILED; 
X            iRes = (-1); 
N        }
N        else
N        {
N            vSetGDCPSMR_PSDEL(GDC0, u16PnlSyncModeDelay);
X            (((volatile GDCPSMR_bit_view_st *) &u32GDCPSMR_REG__Var[(GDC0)]) -> PSDEL=(u16PnlSyncModeDelay));
N            vSetGDCPSMR_PSDDEL(GDC0, u8PnlSyncDataDelay);
X            (((volatile GDCPSMR_bit_view_st *) &u32GDCPSMR_REG__Var[(GDC0)]) -> PSDDEL=(u8PnlSyncDataDelay));
N            
N            /* PSDEL & PSDDEL: belong to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(GDC0, GDCPSMR_REG__, u32GDCPSMR_REG__Var[GDC0]);
X            (*((volatile uint32_t*) ((0xC0C02228U) + ((uint32_t)(GDC0) * 0x1000U) )) = ((uint32_t)(u32GDCPSMR_REG__Var[GDC0])));
N        }
N    }
N    return iRes;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_APCConfigure(gdc_ch_e eGDC, gdc_apccfg_st* pstCfg)
N{
N#ifdef HW_UPDATE_BUG_FIXED
S    gdc_reg_update_mode_e  eLastUpdateMode;
N#endif
N    if (0x00 != pstCfg)
N    {
N        
N        /* General */
N        vSetAPCCR_APCAUTO(eGDC, pstCfg->eMode);
X        (((volatile APCCR_bit_view_st *) &u64APCCR_REG__Var[(eGDC)]) -> APCAUTO=(pstCfg->eMode));
N        vSetAPCCR_APCCHKFR(eGDC, pstCfg->u8Frames);
X        (((volatile APCCR_bit_view_st *) &u64APCCR_REG__Var[(eGDC)]) -> APCCHKFR=(pstCfg->u8Frames));
N
N        /* Compare window definition */
N        vSetAPCCWR_CWWIDTH(eGDC, pstCfg->u8WWidth);
X        (((volatile APCCWR_bit_view_st *) &u64APCCWR_REG__Var[(eGDC)]) -> CWWIDTH=(pstCfg->u8WWidth));
N        vSetAPCCWR_CWHEIGHT(eGDC, pstCfg->u8WHeight);
X        (((volatile APCCWR_bit_view_st *) &u64APCCWR_REG__Var[(eGDC)]) -> CWHEIGHT=(pstCfg->u8WHeight));
N        vSetAPCCWR_HCWS(eGDC, pstCfg->u16HStart);
X        (((volatile APCCWR_bit_view_st *) &u64APCCWR_REG__Var[(eGDC)]) -> HCWS=(pstCfg->u16HStart));
N        vSetAPCCWR_VCWS(eGDC, pstCfg->u16VStart);
X        (((volatile APCCWR_bit_view_st *) &u64APCCWR_REG__Var[(eGDC)]) -> VCWS=(pstCfg->u16VStart));
N
N        /* Expected checksum */
N        vSetAPCCSR_EXPCHKSUM(eGDC, pstCfg->u32AutoChkSum);
X        (((volatile APCCSR_bit_view_st *) &u64APCCSR_REG__Var[(eGDC)]) -> EXPCHKSUM=(pstCfg->u32AutoChkSum));
N        
N#ifdef HW_UPDATE_BUG_FIXED
S        /* get last actual update mode for later restore:*/
S         eLastUpdateMode = eGetShadowRegUpdateStatus(eGDC);
S
S         /* Disable Update Mode if it was not disabled: */
S         if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
S         {
S             vGDC_SetShadowRegUpdateMode(eGDC, GDC_NO_UPDATE_BY_VSYNC);
S         }
N#endif
N
N        UPDATE_REGISTER_LOW_WORD (eGDC, APCCR_REG__,  u64APCCR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C02300U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64APCCR_REG__Var[eGDC])));
N        UPDATE_REGISTER_HIGH_WORD(eGDC, APCCSR_REG__, u64APCCSR_REG__Var[eGDC]);
X        (*((volatile uint32_t*) ((0xC0C02310U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64APCCSR_REG__Var[eGDC])>>32)));
N        UPDATE_REGISTER_64BITS   (eGDC, APCCWR_REG__, u64APCCWR_REG__Var[eGDC]);
X        (*((volatile uint64_t*) ((0xC0C02308U) + ((uint32_t)(eGDC) * 0x1000U) )) = (u64APCCWR_REG__Var[eGDC]));
N
N#ifdef HW_UPDATE_BUG_FIXED
S        /* restore Update Mode if necessary */
S        if (GDC_NO_UPDATE_BY_VSYNC != eLastUpdateMode)
S        {
S            vGDC_SetShadowRegUpdateMode(eGDC, eLastUpdateMode);
S        }
N#endif
N    }
N}
N
N
N/****************************************************************************/
Nvoid vGDC_APCEnable(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    /* Enable/disable */
N    vSetAPCCR_APCON(eGDC, eEn);
X    (((volatile APCCR_bit_view_st *) &u64APCCR_REG__Var[(eGDC)]) -> APCON=(eEn));
N    /* APCON: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, APCCR_REG__, u64APCCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02300U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64APCCR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nbool_t boGDC_IsAPCError(gdc_ch_e eGDC)
N{
N    bool_t boRes = C_FALSE;
X    bool_t boRes = (0);
N
N    if( biGetAPCCR_APCCHKERR(eGDC) )
X    if( (((volatile APCCR_bit_view_st *)(0xC0C02300U + ((uint8_t)(eGDC) * 0x1000U) )) -> APCCHKERR) )
N    {
N        boRes = C_TRUE;
X        boRes = (1);
N    }
N    return boRes;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetAPCCR_PolynomialGen(gdc_ch_e eGDC, uint8_t u8PgValue)
N{
N    /* Set PG Value for APC : */
N    vSetAPCCR_APCPG(eGDC, u8PgValue);
X    (((volatile APCCR_bit_view_st *) &u64APCCR_REG__Var[(eGDC)]) -> APCPG=(u8PgValue));
N    /* APCPG: belongs to high word of register: */
N    UPDATE_REGISTER_HIGH_WORD(eGDC, APCCR_REG__, u64APCCR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02300U) + ((uint32_t)(eGDC) * 0x1000U) + 4 )) = ((uint32_t)((u64APCCR_REG__Var[eGDC])>>32)));
N}
N
N
N/****************************************************************************/
Nuint32_t u32GDC_GetAPCResult(gdc_ch_e eGDC)
N{
N    /* Note: CURCHKSUM is a R/C Bit, it means after read CURCHKSUM will be reset!: */
N    return (uint32_t) biGetAPCCSR_CURCHKSUM(eGDC);
X    return (uint32_t) (((volatile APCCSR_bit_view_st *)(0xC0C02310U + ((uint8_t)(eGDC) * 0x1000U) )) -> CURCHKSUM);
N}
N
N
N/****************************************************************************/
Nuint32_t u32GDC_GetAPCPixelVal(gdc_ch_e eGDC, gdc_apcp_e ePix)
N{
N    uint32_t u32Res;
N
N    if( GDC_CURR_PIXVAL == ePix )
N    {
N        u32Res = (uint32_t) (u64GetAPCPVR(eGDC));
X        u32Res = (uint32_t) ((*((volatile u64APCPVR_longword_view *)(0xC0C02318U + ((uint8_t)(eGDC) * 0x1000U) )) ));
N    }
N    else
N    {
N        u32Res = (uint32_t) (u64GetAPCPVR(eGDC)>> 32);
X        u32Res = (uint32_t) ((*((volatile u64APCPVR_longword_view *)(0xC0C02318U + ((uint8_t)(eGDC) * 0x1000U) )) )>> 32);
N    }
N    return u32Res;
N}
N
N
N/****************************************************************************/
N/*+-----------------------------------------------------------------------+*
N *|     START-Extended new APIs                                           |*
N *+-----------------------------------------------------------------------+*/
N 
Nvoid vGDC_SetGdcWriteProtection(gdc_ch_e eGDC, gdc_write_protect_e eProtection)
N{
N    /* set protection level for GDC: */
N    vSetGDCPROTR_GDCWPL(eGDC, eProtection);
X    (((volatile GDCPROTR_bit_view_st *) &u32GDCPROTR_REG__Var[(eGDC)]) -> GDCWPL=(eProtection));
N    
N    /* GDCWPL: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, GDCPROTR_REG__, u32GDCPROTR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C022C0U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCPROTR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nvoid vGDC_SetApcWriteProtection(gdc_ch_e eGDC, gdc_write_protect_e eProtection)
N{
N    /* set protection level for APC: */
N    vSetAPCPROTR_APCWPL(eGDC, eProtection);
X    (((volatile APCPROTR_bit_view_st *) &u32APCPROTR_REG__Var[(eGDC)]) -> APCWPL=(eProtection));
N    
N    /* APCWPL: belongs to low word of register: */
N    UPDATE_REGISTER_LOW_WORD(eGDC, APCPROTR_REG__, u32APCPROTR_REG__Var[eGDC]);
X    (*((volatile uint32_t*) ((0xC0C02320U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32APCPROTR_REG__Var[eGDC])));
N}
N
N
N/****************************************************************************/
Nbool_t boGDC_SetPulseGen(gdc_ch_e eGDC,
N                         gdc_pg_gen_id_e   ePGenID,
N                         gdc_pg_outsel_e   ePGenOut,
N                         gdc_pg_cgsel_e    ePGenClk,
N                         gdc_pg_trigger_e  ePGenTrig)
N{
N    uint8_t  u8shift;
N    bool_t   boRes = C_TRUE;
X    bool_t   boRes = (1);
N    uint32_t u32NewData, u32RegData, u32RegMask;
N    
N    /* program
N                 ePGenTrig, ePGenClk, ePGenOut
N     * +--------+---------+----------+---------+
N     * | 1 bit  |  3 bits |  1 bit   | 3 bits  |
N     * | resv.  |  TRIGx  |  CGSELx  | OUTSELx |
N     * +--------+---------+----------+---------+
N     */
N    u32NewData =  ((uint32_t)ePGenTrig & GDC_3_BIT_MASK) << 4;
X    u32NewData =  ((uint32_t)ePGenTrig & 0x00000007U) << 4;
N    u32NewData += ((uint32_t)ePGenClk  & GDC_1_BIT_MASK) << 3;
X    u32NewData += ((uint32_t)ePGenClk  & 0x00000001U) << 3;
N    u32NewData += ((uint32_t)ePGenOut  & GDC_3_BIT_MASK);
X    u32NewData += ((uint32_t)ePGenOut  & 0x00000007U);
N    
N    u8shift = (ePGenID%4)*8;
N    
N    u32NewData <<= u8shift;
N    u32RegMask = GDC_8_BIT_MASK << u8shift;
X    u32RegMask = 0x000000FFU << u8shift;
N    switch( ePGenID )
N    {
N        case GDC_PULSE_GEN_0:
N        case GDC_PULSE_GEN_1:
N        case GDC_PULSE_GEN_2:
N        case GDC_PULSE_GEN_3:
N            /* Register GDCGPCRA should be modfied, first get actual data: */
N            u32RegData = u32GetGDCGPCRA(eGDC);
X            u32RegData = (*((volatile u32GDCGPCRA_word_view *) &u32GDCGPCRA_REG__Var[(eGDC)]) );
N            /* delete related 8 bits: */
N            u32RegData &= ~u32RegMask;
N            
N            /* insert new bits and write it back: */
N            u32RegData |= u32NewData;
N            vSetGDCGPCRA(eGDC, u32RegData);
X            (*((volatile u32GDCGPCRA_word_view *) &u32GDCGPCRA_REG__Var[(eGDC)]) = (u32RegData));
N            
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCGPCRA_REG__, u32GDCGPCRA_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02150U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCGPCRA_REG__Var[eGDC])));
N
N            break;
N
N        case GDC_PULSE_GEN_4:
N        case GDC_PULSE_GEN_5:
N        case GDC_PULSE_GEN_6:
N        case GDC_PULSE_GEN_7:
N            /* Register GDCGPCRB should be modfied, first get actual data: */
N            u32RegData = u32GetGDCGPCRB(eGDC);
X            u32RegData = (*((volatile u32GDCGPCRB_word_view *) &u32GDCGPCRB_REG__Var[(eGDC)]) );
N            /* delete related 8 bits: */
N            u32RegData &= ~u32RegMask;
N            
N            /* insert new bits and write it back: */
N            u32RegData |= u32NewData;
N            vSetGDCGPCRB(eGDC, u32RegData);
X            (*((volatile u32GDCGPCRB_word_view *) &u32GDCGPCRB_REG__Var[(eGDC)]) = (u32RegData));
N            
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCGPCRB_REG__, u32GDCGPCRB_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02158U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCGPCRB_REG__Var[eGDC])));
N            break;
N
N        case GDC_PULSE_GEN_8:
N        case GDC_PULSE_GEN_9:
N        case GDC_PULSE_GEN_10:
N        case GDC_PULSE_GEN_11:
N            /* Register GDCGPCRC should be modfied, first get actual data: */
N            u32RegData = u32GetGDCGPCRC(eGDC);
X            u32RegData = (*((volatile u32GDCGPCRC_word_view *) &u32GDCGPCRC_REG__Var[(eGDC)]) );
N            /* delete related 8 bits: */
N            u32RegData &= ~u32RegMask;
N            
N            /* insert new bits and write it back: */
N            u32RegData |= u32NewData;
N            vSetGDCGPCRC(eGDC, u32RegData);
X            (*((volatile u32GDCGPCRC_word_view *) &u32GDCGPCRC_REG__Var[(eGDC)]) = (u32RegData));
N            
N            /* Copy register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCGPCRC_REG__, u32GDCGPCRC_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02160U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32GDCGPCRC_REG__Var[eGDC])));
N            break;
N
N        default:
N            /* Invalid Generator ID */
N            boRes = C_FALSE;
X            boRes = (0);
N            break;
N    }
N
N    return boRes;
N}
N
N
N/****************************************************************************/
Nbool_t boGDC_ConfigPulseGenA_B(gdc_ch_e eGDC,
N                               gdc_pg_gen_id_e      ePGenID,
N                               gdc_pg_A_B_e         eGenA_B,
N                               gdc_pulse_config_st* pstConfig)
N
N{
N    uint8_t  u8Err = 0;
N    bool_t   boRes = C_TRUE;
X    bool_t   boRes = (1);
N    uint32_t u32RegData;
N    /* pulse generator properties: */
N    gdc_pg_active_level_e  eActiveLevel_x;    /* Pulse generator active level select: */
N    gdc_pg_input_e         eSelectedInput_x;  /* Pulse generator input signal select: */
N    gdc_en_e               eByPassEnb_x;      /* Pulse generator bypass enable: */
N    uint16_t               u16PulseDelay_x;   /* Delay of generated pulse */
N    gdc_pg_divider_e       ePulseDivider_x;   /* Divider value is defined by DIV+1 */
N    gdc_en_e               eInvertEnb_x;      /* Pulse generator inversion enable: */
N    uint16_t               u16PulseWidth_x;   /* Width of generated pulse, measured in dot clock cycles for all input sources but VSYNC and VDISP */
N    
N    uint32_t u32GDCPxGAR_array[12] = {GDCP0GAR_REG__, GDCP1GAR_REG__, GDCP2GAR_REG__,  GDCP3GAR_REG__,
X    uint32_t u32GDCPxGAR_array[12] = {0xC0C02168U, 0xC0C02170U, 0xC0C02178U,  0xC0C02180U,
N                                      GDCP4GAR_REG__, GDCP5GAR_REG__, GDCP6GAR_REG__,  GDCP7GAR_REG__,
X                                      0xC0C02188U, 0xC0C02190U, 0xC0C02198U,  0xC0C021A0U,
N                                      GDCP8GAR_REG__, GDCP9GAR_REG__, GDCP10GAR_REG__, GDCP11GAR_REG__
X                                      0xC0C021A8U, 0xC0C021B0U, 0xC0C021B8U, 0xC0C021C0U
N                                      };
N    uint32_t u32GDCPxGBR_array[12] = {GDCP0GBR_REG__, GDCP1GBR_REG__, GDCP2GBR_REG__,  GDCP3GBR_REG__,
X    uint32_t u32GDCPxGBR_array[12] = {0xC0C021C8U, 0xC0C021D0U, 0xC0C021D8U,  0xC0C021E0U,
N                                      GDCP4GBR_REG__, GDCP5GBR_REG__, GDCP6GBR_REG__,  GDCP7GBR_REG__,
X                                      0xC0C021E8U, 0xC0C021F0U, 0xC0C021F8U,  0xC0C02200U,
N                                      GDCP8GBR_REG__, GDCP9GBR_REG__, GDCP10GBR_REG__, GDCP11GBR_REG__
X                                      0xC0C02208U, 0xC0C02210U, 0xC0C02218U, 0xC0C02220U
N                                      };
N
N    if ((0x00 == pstConfig) || (ePGenID > GDC_PULSE_GEN_11) )
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    else
N    {
N        eActiveLevel_x   = pstConfig->eActiveLevel;
N        eSelectedInput_x = pstConfig->eSelectedInput;
N        eByPassEnb_x     = pstConfig->eByPassEnb;
N        u16PulseDelay_x  = pstConfig->u16PulseDelay;
N        ePulseDivider_x  = pstConfig->ePulseDivider;
N        eInvertEnb_x     = pstConfig->eInvertEnb;
N        u16PulseWidth_x  = pstConfig->u16PulseWidth;
N        
N        /* check parameters: */
N        if ( (GDC_ACTIVE_LVL_0 != eActiveLevel_x) && (GDC_ACTIVE_LVL_1 != eActiveLevel_x) )
N        {
N            u8Err++;
N        }
N        if ( (eSelectedInput_x < GDC_INP_DOTCLK) || (eSelectedInput_x > GDC_INP_PNL) )
N        {
N            u8Err++;
N        }
N        if ( (GDC_DISABLE != eByPassEnb_x) && (GDC_ENABLE != eByPassEnb_x) )
N        {
N            u8Err++;
N        }
N        if (u16PulseDelay_x > GDC_GADEL_MAX)
X        if (u16PulseDelay_x > 0x3FF)
N        {
N            u8Err++;
N        }
N        if (ePulseDivider_x > GDC_DIVIDER_16)
N        {
N            u8Err++;
N        }
N        if ( (GDC_DISABLE != eInvertEnb_x) && (GDC_ENABLE != eInvertEnb_x) )
N        {
N            u8Err++;
N        }
N        if (u16PulseWidth_x > GDC_GAWID_MAX)
X        if (u16PulseWidth_x > 0x3FF)
N        {
N            u8Err++;
N        }
N        /* if no error by parameters: */
N        if (0x00 == u8Err)
N        {
N            /* program configuration of one shot pulse generator A or B:
N             * +-------+----------+-------+-----------+----------+-------+-----------+
N             * | 1 bit |  3 bits  | 1 bit |  11 bits  |  4 bits  | 1 bit |  11 bits  |
N             * | GALVL |  GAINSEL | GABYP |   GADEL   |  GADIV   | GAINV |   GAWID   |
N             * +-------+----------+-------+-----------+----------+-------+-----------+
N             */
N            u32RegData = eActiveLevel_x;
N            u32RegData <<= GDC_PGEN_GAINSEL_BITS;
X            u32RegData <<= 3;
N
N            u32RegData |= (uint32_t)eSelectedInput_x;
N            u32RegData <<= GDC_PGEN_GABYP_BIT; 
X            u32RegData <<= 1; 
N
N            u32RegData |= (uint32_t)eByPassEnb_x;
N            u32RegData <<= GDC_PGEN_GADEL_BIT;
X            u32RegData <<= 11;
N
N            u32RegData |= u16PulseDelay_x;
N            u32RegData <<= GDC_PGEN_GADIV_BIT;
X            u32RegData <<= 4;
N
N            u32RegData |= (uint32_t)ePulseDivider_x;
N            u32RegData <<= GDC_PGEN_GAINV_BIT;
X            u32RegData <<= 1;
N
N            u32RegData |= (uint32_t)eInvertEnb_x;
N            u32RegData <<= GDC_PGEN_GAWID_BIT;
X            u32RegData <<= 11;
N
N            u32RegData |= u16PulseWidth_x;
N        }
N        if (GDC_PULSE_GEN_A == eGenA_B)
N        {
N            /* update back up of register in local variable: */
N            u32GDCPxGAR_REG__Var[eGDC][ePGenID] = u32RegData;
N            
N            /* Copy GDCPxGAR (x:0..11) register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, u32GDCPxGAR_array[ePGenID], u32RegData);
X            (*((volatile uint32_t*) ((u32GDCPxGAR_array[ePGenID]) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32RegData)));
N        }
N        else if (GDC_PULSE_GEN_B == eGenA_B)
N        {
N            /* update back up of register in local variable: */
N            u32GDCPxGBR_REG__Var[eGDC][ePGenID] = u32RegData;
N            
N            /* Copy GDCPxGAR (x:0..11) register data to shadow register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, u32GDCPxGBR_array[ePGenID], u32RegData);
X            (*((volatile uint32_t*) ((u32GDCPxGBR_array[ePGenID]) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u32RegData)));
N        }
N        else
N        {
N            boRes = C_FALSE;
X            boRes = (0);
N        }
N    }
N    return boRes;
N}
N
N
N/****************************************************************************/
Nuint16_t u16GDC_GetLastGAPIFColAddr(gdc_ch_e eGDC)
N{
N    uint16_t u16LastColAddr;
N    /* Note: GCAR is R/C bits, so after read it will be reset to 0: */
N    u16LastColAddr = u16GetGDCGCAR(eGDC);
X    u16LastColAddr = (*((volatile u16GDCGCAR_halfword_view *)(0xC0C022A8U + ((uint8_t)(eGDC) * 0x1000U) )) );
N    
N    return u16LastColAddr;
N}
N
N
N/****************************************************************************/
Nbool_t boGDC_GetBusErrAddr(gdc_ch_e eGDC, uint32_t* pu32BusErrAddr)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    uint32_t u32BusErrAddr;
N    if (0x00 != pu32BusErrAddr)
N    {
N        u32BusErrAddr = (uint32_t) u32GetGDCGBEAR(eGDC);
X        u32BusErrAddr = (uint32_t) (*((volatile u32GDCGBEAR_word_view *)(0xC0C022C8U + ((uint8_t)(eGDC) * 0x1000U) )) );
N        *pu32BusErrAddr = u32BusErrAddr;
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    return boRes;
N}
N
N/****************************************************************************/
Nbool_t boGDC_GetBusErrCtrlStatus(gdc_ch_e eGDC, gdc_bus_err_ctrl_st* pstCtrlStatus)
N{
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N    if(0x00 != pstCtrlStatus)
N    {
N        pstCtrlStatus->eDirection    = (gdc_buserr_dir_e) biGetGDCGBECR_WR(eGDC);
X        pstCtrlStatus->eDirection    = (gdc_buserr_dir_e) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> WR);
N        pstCtrlStatus->eBurstType    = (gdc_buserr_bursttype_e) biGetGDCGBECR_BTYPE(eGDC);
X        pstCtrlStatus->eBurstType    = (gdc_buserr_bursttype_e) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> BTYPE);
N        pstCtrlStatus->eBurstSize    = (gdc_buserr_burstsize_e) biGetGDCGBECR_BSIZE(eGDC);
X        pstCtrlStatus->eBurstSize    = (gdc_buserr_burstsize_e) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> BSIZE);
N        pstCtrlStatus->eRespType     = (gdc_buserr_resptype_e) biGetGDCGBECR_RTYPE(eGDC);
X        pstCtrlStatus->eRespType     = (gdc_buserr_resptype_e) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> RTYPE);
N        pstCtrlStatus->u8ByteEnables = (uint8_t) biGetGDCGBECR_BEN(eGDC);
X        pstCtrlStatus->u8ByteEnables = (uint8_t) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> BEN);
N        pstCtrlStatus->u8ID          = (uint8_t) biGetGDCGBECR_ID(eGDC);
X        pstCtrlStatus->u8ID          = (uint8_t) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> ID);
N        pstCtrlStatus->u8BurstLength = (uint8_t) biGetGDCGBECR_LEN(eGDC);
X        pstCtrlStatus->u8BurstLength = (uint8_t) (((volatile GDCGBECR_bit_view_st *)(0xC0C022D0U + ((uint8_t)(eGDC) * 0x1000U) )) -> LEN);
N    }
N    else
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N    }
N    return  boRes;
N}
N
N
N/****************************************************************************/
Ngdc_dcr_err_e eGDC_GetDcrBusErrors(gdc_ch_e eGDC)
N{
N    gdc_dcr_err_e  eRes;
N    uint64_t       u64GdcDcr_HW;
N    bool_t boRes_GBER   = C_FALSE;
X    bool_t boRes_GBER   = (0);
N    bool_t boRes_GAPCOL = C_FALSE;
X    bool_t boRes_GAPCOL = (0);
N    
N    /* read HW register: */
N    u64GdcDcr_HW = READ_REGISTER_64BITS(GDCDCR_REG__ , eGDC);
X    u64GdcDcr_HW = (*((volatile uint64_t*) ((0xC0C02000U) + ((uint8_t)(eGDC) * 0x1000U) )));
N    
N    /* check related bits: */
N    if (0x00 != (u64GdcDcr_HW & GDC_DCR_ERR_GBER_MASK))
X    if (0x00 != (u64GdcDcr_HW & 0x0000000000080000U))
N    {
N        boRes_GBER = C_TRUE;
X        boRes_GBER = (1);
N    }
N    /* check related bits: */
N    if (0x00 != (u64GdcDcr_HW & GDC_DCR_ERR_GAPCOL_MASK))
X    if (0x00 != (u64GdcDcr_HW & 0x0200000000000000U))
N    {
N        boRes_GAPCOL = C_TRUE;
X        boRes_GAPCOL = (1);
N    }
N    if (C_TRUE == boRes_GBER)
X    if ((1) == boRes_GBER)
N    {
N        eRes = (C_TRUE == boRes_GAPCOL)? GDC_DCR_ERR_GBER_AND_GAPCOL : GDC_DCR_ERR_GBER;
X        eRes = ((1) == boRes_GAPCOL)? GDC_DCR_ERR_GBER_AND_GAPCOL : GDC_DCR_ERR_GBER;
N    }
N    else if (C_TRUE == boRes_GAPCOL)
X    else if ((1) == boRes_GAPCOL)
N    {
N        eRes = GDC_DCR_ERR_GAPCOL;
N    }
N    else
N    {
N        eRes = GDC_DCR_ERR_NONE;
N    }
N    return eRes;
N}
N
N
N/****************************************************************************/
Nbool_t boGDC_ClrDcrBusErrors(gdc_ch_e eGDC, gdc_dcr_err_e eClrBits)
N{
N    uint32_t u32Cntr;
N    uint64_t u64GdcDcr_HW;
N    bool_t boRes = C_TRUE;
X    bool_t boRes = (1);
N
N    /* Important Not: 
N     * clear bits can not be written directly to shadow register, because it can happen that
N     * last modification of GDCDCR which are in shadow register but still waiting for VSYNC
N     * to be copied into HW register, will be overwritten:
N     *************/
N    switch(eClrBits)
N    {
N        case GDC_DCR_ERR_GBER:
N            /* set GBER bit in local variable before write to shadow register: */
N            u64GDCDCR_REG__Var [eGDC] |= GDC_DCR_ERR_GBER_MASK;
X            u64GDCDCR_REG__Var [eGDC] |= 0x0000000000080000U;
N            /* GBER: belongs to low word of register: */
N            UPDATE_REGISTER_LOW_WORD(eGDC, GDCDCR_REG__, u64GDCDCR_REG__Var[eGDC]);
X            (*((volatile uint32_t*) ((0xC0C02000U) + ((uint32_t)(eGDC) * 0x1000U) )) = ((uint32_t)(u64GDCDCR_REG__Var[eGDC])));
N            break;
N            
N        case GDC_DCR_ERR_GAPCOL:
N            /* set GAPCOL bit in local variable before write to shadow register: */
N            u64GDCDCR_REG__Var [eGDC] |= GDC_DCR_ERR_GAPCOL_MASK;
X            u64GDCDCR_REG__Var [eGDC] |= 0x0200000000000000U;
N            /* GAPCOL: belongs to high word of register: */
N            vUpdateDCR_HighWord_Special(eGDC);
N            break;
N
N        case GDC_DCR_ERR_GBER_AND_GAPCOL:
N            /* set GBER and GAPCOL bit in local variable before write to shadow register: */
N            u64GDCDCR_REG__Var [eGDC] |= GDC_DCR_ERR_GBER_AND_GAPCOL_MASK;
X            u64GDCDCR_REG__Var [eGDC] |= (0x0000000000080000U | 0x0200000000000000U);
N            /* GBER and GAPCOL: belong to Low and high word of register: */
N            vUpdateDCR_Special(eGDC);
N            break;
N
N        default:
N            boRes = C_FALSE;
X            boRes = (0);
N            break;
N    }
N    if (C_TRUE == boRes)
X    if ((1) == boRes)
N    {
N        boRes = C_FALSE;
X        boRes = (0);
N        /* set Loop Counter to 0 : */
N        u32Cntr = 0;
N        /* Wait until Clear bit(s) is(are) reset: */
N        while ( (u32Cntr<MAX_WAIT_FOR_CLEAR) && (C_FALSE==boRes) )
X        while ( (u32Cntr<1000) && ((0)==boRes) )
N        {
N            u64GdcDcr_HW = READ_REGISTER_64BITS(GDCDCR_REG__ , eGDC);
X            u64GdcDcr_HW = (*((volatile uint64_t*) ((0xC0C02000U) + ((uint8_t)(eGDC) * 0x1000U) )));
N            switch(eClrBits)
N            {
N            
N                case GDC_DCR_ERR_GBER:
N                    /* read clear bit from HW register, if it is 0 then clear has been done: */
N                    if (0x00 == (u64GdcDcr_HW & GDC_DCR_ERR_GBER_MASK))
X                    if (0x00 == (u64GdcDcr_HW & 0x0000000000080000U))
N                    {
N                        boRes = C_TRUE;
X                        boRes = (1);
N                    }
N                    break;
N                    
N                case GDC_DCR_ERR_GAPCOL:
N                    /* read clear bit from HW register, if it is 0 then clear has been done: */
N                    if (0x00 == (u64GdcDcr_HW & GDC_DCR_ERR_GAPCOL_MASK))
X                    if (0x00 == (u64GdcDcr_HW & 0x0200000000000000U))
N                    {
N                        boRes = C_TRUE;
X                        boRes = (1);
N                    }
N                    break;
N                    
N                default:
N                    /* read both clear bits from HW register, if both are 0 then clear has been done: */
N                    if (0x00 == (u64GdcDcr_HW & GDC_DCR_ERR_GBER_AND_GAPCOL_MASK))
X                    if (0x00 == (u64GdcDcr_HW & (0x0000000000080000U | 0x0200000000000000U)))
N                    {
N                        boRes = C_TRUE;
X                        boRes = (1);
N                    }
N                    break;
N            }
N            u32Cntr++;
N        } /* while .. */
N    }
N   /* Set clear bits in any case again to "0" in local variable: */
N   u64GDCDCR_REG__Var[eGDC] &= (~GDC_DCR_ERR_GBER_AND_GAPCOL_MASK);
X   u64GDCDCR_REG__Var[eGDC] &= (~(0x0000000000080000U | 0x0200000000000000U));
N    
N   return boRes;
N}
N
N
N/****************************************************************************/
Nvoid vGDC_GAPIFEnable(gdc_ch_e eGDC, gdc_en_e eEn)
N{
N    vSetGDCDCR_GAPEN(eGDC, eEn);
X    (((volatile GDCDCR_bit_view_st *) &u64GDCDCR_REG__Var[(eGDC)]) -> GAPEN=(eEn));
N    /* GAPEN: belongs to high word of register: */
N    /* GDCDCR register should be updated special: */  
N    vUpdateDCR_HighWord_Special(eGDC);
N}
N
N
N/****************************************************************************/
Nbool_t boGDC_AccessToGapif(gdc_ch_e eGDC)
N{
N    bool_t boRes;
N    boRes = ( 0x00 == biGetGDCDCR_GAPACC(eGDC))? C_FALSE : C_TRUE;
X    boRes = ( 0x00 == (((volatile GDCDCR_bit_view_st *)(0xC0C02000U + ((uint8_t)(eGDC) * 0x1000U) )) -> GAPACC))? (0) : (1);
N    return boRes;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqGap(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N    i32IrqStat = biGetGDCINTR_GAPINT(eGDC);
X    i32IrqStat = (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> GAPINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        /*
N         * Note:
N         *    By clearing GAPINT the error bit GAPCOL in GDCDCR register
N         *    will also be cleared. */
N        vClrGDCINTR_GAPINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> GAPINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqGber(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = biGetGDCINTR_GBERINT(eGDC);
X    i32IrqStat = (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> GBERINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_GBERINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> GBERINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqGpe(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = biGetGDCINTR_GPEINT(eGDC);
X    i32IrqStat = (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> GPEINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_GPEINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> GPEINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqDle(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = biGetGDCINTR_DLEINT(eGDC);
X    i32IrqStat = (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> DLEINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_DLEINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> DLEINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N
N
N/****************************************************************************/
Ngdc_irqact_e eGDC_IsIrqApe(gdc_ch_e eGDC)
N{
N    int32_t i32IrqStat;
N
N    i32IrqStat = biGetGDCINTR_APEINT(eGDC);
X    i32IrqStat = (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> APEINT);
N
N    /* Clear the flag if the interrupt is active */
N    if( 1 == i32IrqStat )
N    {
N        vClrGDCINTR_APEINT(eGDC);
X        (((volatile GDCINTR_bit_view_st *)(0xC0C02140U + ((uint8_t)(eGDC) * 0x1000U) )) -> APEINT = (1));
N    }
N
N    return (gdc_irqact_e) i32IrqStat;
N}
N/*+-----------------------------------------------------------------------+*
N *|     END-Extended new APIs                                             |*
N *+-----------------------------------------------------------------------+*/
N
N/****************************************************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N/****************************************************************************
N*****************************************************************************
N**             >>>>     MISRA-C 2004 Deviation Report     <<<<
N**                          (MISRA Rule Violation)
N**
N**  File: gdc.c
N**  $Revision: 1.19 $
N**  $Date: 2015/05/04 09:07:15 $
N**
N** **************************************************************************
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1847 / 10.3 - cast of complex integer expression with underlying type
N** |                        "type" to non-integer type "type" not allowed 
N** | CONS.  : disable
N** | REASON : to use macros from i/o header files, unavoidable when addressing 
N** |          memory mapped registers 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1849 / 8.1 - bitwise ~ or << expression must be immediately cast 
N** |                       back to  underlying type, "unsigned char" 
N** | CONS.  : allow
N** | REASON : necessary for shift oeprations, which we know it will not over run 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1858 /17.4  - subscript operator may only be applied to objects 
N** |                        declared as an array type
N** | CONS.  : allow
N** | REASON : to handle array of data by usage of pointer 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1864 /10.1  - implicit conversion from underlying type, "type", 
N** |                        to narrower underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : to use macros from i/o header files 
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1865 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to same width underlying type, "type", not allowed
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1866 /10.1  -  implicit conversion from underlying type, "type",  
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1867 /10.1  -  implicit conversion from underlying type, "type", 
N** |                         to underlying type, "type", changes signedness
N** | CONS.  : allow
N** | REASON : for usage of macros from io header files or assign parameters
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1878 /10.3  -   cast of complex integer expression with underlying 
N** |                          type "type" to wider type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as variables in io 
N** |          header file or to allow shift operation
N** |
N**  ------------------------------------------------------------------------
N**  ------------------------------------------------------------------------
N** |
N** | RULE   : 1879 /10.3  - 	 cast of complex integer expression with underlying
N** |                           type "type" to same width type "type" not allowed
N** | CONS.  : allow
N** | REASON : to assign parameters which may be defined as macros in io header file
N** |
N**  ------------------------------------------------------------------------
N**
N*****************************************************************************
N****************************************************************************/
N
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
