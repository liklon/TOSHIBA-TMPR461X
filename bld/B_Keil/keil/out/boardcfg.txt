; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\boardcfg.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\boardcfg.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\boardcfg.crf ..\..\src\boardcfg.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vInitGraphicsSystem PROC
;;;54     /***************************************************************************/
;;;55     void vInitGraphicsSystem(void)
000000  e52de004          PUSH     {lr}
;;;56     {
000004  e24ddf5d          SUB      sp,sp,#0x174
;;;57         gf_gdc_config_st stGDC0;
;;;58         gf_gdc_config_st stGDC1;
;;;59         gf_fg_config_st  stFG;
;;;60     
;;;61         /* configuration for GDC0 */
;;;62         stGDC0.u8GDCActive = GDCx0;
000008  e3a00001          MOV      r0,#1
00000c  e5cd00e0          STRB     r0,[sp,#0xe0]
;;;63     
;;;64         stGDC0.stDispConf.u8DispRes       = DISPLAY_RESOLUTION_0;
000010  e3a00022          MOV      r0,#0x22
000014  e5cd00e4          STRB     r0,[sp,#0xe4]
;;;65         stGDC0.stDispConf.u16DispStartX   = 0;
000018  e3a00000          MOV      r0,#0
00001c  e1cd0eb6          STRH     r0,[sp,#0xe6]
;;;66         stGDC0.stDispConf.u16DispStartY   = 0;
000020  e1cd0eb8          STRH     r0,[sp,#0xe8]
;;;67         stGDC0.stDispConf.u16DispWidth    = GDC0_DISPLAY_WIDTH;
000024  e3000500          MOVW     r0,#0x500
000028  e1cd0eba          STRH     r0,[sp,#0xea]
;;;68         stGDC0.stDispConf.u16DispHeight   = GDC0_DISPLAY_HEIGHT;
00002c  e30001a4          MOVW     r0,#0x1a4
000030  e1cd0ebc          STRH     r0,[sp,#0xec]
;;;69         stGDC0.stDispConf.eDispConfigType = GDC_USE_DISP_SET_BY_LAYA;
000034  e3a00001          MOV      r0,#1
000038  e5cd00ee          STRB     r0,[sp,#0xee]
;;;70     
;;;71         stGDC0.stDispConf.u8VSYNCType     = GDC_VSYNC;
00003c  e3a00000          MOV      r0,#0
000040  e5cd00ef          STRB     r0,[sp,#0xef]
;;;72     #if (OUTPUT_DEVICE == 0)
;;;73         stGDC0.stDispConf.u8VSYNCPol      = GDC_POS;
000044  e3a00001          MOV      r0,#1
000048  e5cd00f0          STRB     r0,[sp,#0xf0]
;;;74     #else
;;;75         stGDC0.stDispConf.u8VSYNCPol      = GDC_NEG;
;;;76     #endif
;;;77         stGDC0.stDispConf.u16VSYNCWidth   = VPulseWidth_0;
00004c  e3a0000a          MOV      r0,#0xa
000050  e1cd0fb2          STRH     r0,[sp,#0xf2]
;;;78         stGDC0.stDispConf.u16VPeriod      = VPeriod_0;
000054  e300020d          MOV      r0,#0x20d
000058  e1cd0fb4          STRH     r0,[sp,#0xf4]
;;;79         stGDC0.stDispConf.u16VBackPorch   = VBackPorch_0;
00005c  e3a00028          MOV      r0,#0x28
000060  e1cd0fb6          STRH     r0,[sp,#0xf6]
;;;80     
;;;81     #if (OUTPUT_DEVICE == 0)
;;;82         stGDC0.stDispConf.u8HSYNCPol      = GDC_POS;
000064  e3a00001          MOV      r0,#1
000068  e5cd00f8          STRB     r0,[sp,#0xf8]
;;;83     #else
;;;84         stGDC0.stDispConf.u8HSYNCPol      = GDC_NEG;
;;;85     #endif
;;;86         stGDC0.stDispConf.u16HSYNCWidth   = HPulseWidth_0;
00006c  e3a00070          MOV      r0,#0x70
000070  e1cd0fba          STRH     r0,[sp,#0xfa]
;;;87         stGDC0.stDispConf.u16HPeriod      = HPeriod_0;
000074  e300067c          MOV      r0,#0x67c
000078  e1cd0fbc          STRH     r0,[sp,#0xfc]
;;;88         stGDC0.stDispConf.u16HBackPorch   = HBackPorch_0;
00007c  e3a000f9          MOV      r0,#0xf9
000080  e1cd0fbe          STRH     r0,[sp,#0xfe]
;;;89     
;;;90         stGDC0.stDispConf.u8HDISPPol      = GDC_POS;
000084  e3a00001          MOV      r0,#1
000088  e5cd0100          STRB     r0,[sp,#0x100]
;;;91     
;;;92         stGDC0.stDispConf.u32BGColor      = 0x000000;
00008c  e3a00000          MOV      r0,#0
000090  e58d0104          STR      r0,[sp,#0x104]
;;;93         stGDC0.stDispConf.u8SyncDir       = GDC_OUTPUT;
000094  e5cd0108          STRB     r0,[sp,#0x108]
;;;94     
;;;95         stGDC0.stDispConf.u8DotClkPol     = GDC_POS;
000098  e3a00001          MOV      r0,#1
00009c  e5cd0109          STRB     r0,[sp,#0x109]
;;;96         stGDC0.stDispConf.u8ClkSource     = GDC_DOTCLK_INT;
0000a0  e5cd010a          STRB     r0,[sp,#0x10a]
;;;97         stGDC0.stDispConf.eClockFrequency = (ccr_clk_freq_e)ClockFrequency_0;
0000a4  e3a00011          MOV      r0,#0x11
0000a8  e5cd010b          STRB     r0,[sp,#0x10b]
;;;98         stGDC0.stDispConf.eModulated      = CCR_NON_MODULATED;
0000ac  e3a00001          MOV      r0,#1
0000b0  e5cd010c          STRB     r0,[sp,#0x10c]
;;;99     
;;;100        stGDC0.stDispConf.eDithering      = GDC_DITHERING_MAGIC_SQR_SUBPIX_ENABLED;
0000b4  e3a00003          MOV      r0,#3
0000b8  e5cd010d          STRB     r0,[sp,#0x10d]
;;;101        stGDC0.stDispConf.eLayerOrder     = GDC_ABCDE;
0000bc  e3a00000          MOV      r0,#0
0000c0  e5cd010e          STRB     r0,[sp,#0x10e]
;;;102    #if GDC0_LAYER_A
;;;103        /* Setting Layer A *******************************************************/
;;;104        stGDC0.stLayerConf_A.u8LayerActive   = GDC0_LAYER_A;
0000c4  e3a00001          MOV      r0,#1
0000c8  e5cd0110          STRB     r0,[sp,#0x110]
;;;105        stGDC0.stLayerConf_A.u8DisplayFormat = GDC0_LAYER_A_COLOR_FORMAT;
0000cc  e5cd0111          STRB     r0,[sp,#0x111]
;;;106        stGDC0.stLayerConf_A.u8DoubleBuffer  = GDC0_LAYER_A_DOUBLEFUFFERING;
0000d0  e5cd0112          STRB     r0,[sp,#0x112]
;;;107        stGDC0.stLayerConf_A.u8Alpha         = 0xff;
0000d4  e3a000ff          MOV      r0,#0xff
0000d8  e5cd0113          STRB     r0,[sp,#0x113]
;;;108        stGDC0.stLayerConf_A.u16StartX       = GDC0_LAYERA_STARTX;
0000dc  e3a00000          MOV      r0,#0
0000e0  e28d10e0          ADD      r1,sp,#0xe0
0000e4  e1c103b4          STRH     r0,[r1,#0x34]
;;;109        stGDC0.stLayerConf_A.u16StartY       = GDC0_LAYERA_STARTY;
0000e8  e28d10e0          ADD      r1,sp,#0xe0
0000ec  e1c103b6          STRH     r0,[r1,#0x36]
;;;110        stGDC0.stLayerConf_A.u16Width        = GDC0_LAYERA_WIDTH;
0000f0  e3000500          MOVW     r0,#0x500
0000f4  e28d10e0          ADD      r1,sp,#0xe0
0000f8  e1c103b8          STRH     r0,[r1,#0x38]
;;;111        stGDC0.stLayerConf_A.u16Height       = GDC0_LAYERA_HEIGHT;
0000fc  e30001a4          MOVW     r0,#0x1a4
000100  e28d10e0          ADD      r1,sp,#0xe0
000104  e1c103ba          STRH     r0,[r1,#0x3a]
;;;112        stGDC0.stLayerConf_A.u32FB0StartAddress = PHYSICAL(&FBuffRGBA_GDC0_A0[0]);
000108  e59f02cc          LDR      r0,|L1.988|
00010c  e58d011c          STR      r0,[sp,#0x11c]
;;;113      #if GDC0_LAYER_A_DOUBLEFUFFERING
;;;114        stGDC0.stLayerConf_A.u32FB1StartAddress = PHYSICAL(&FBuffRGBA_GDC0_A1[0]);
000110  e59f02c8          LDR      r0,|L1.992|
000114  e58d0120          STR      r0,[sp,#0x120]
;;;115      #else
;;;116        stGDC0.stLayerConf_A.u32FB1StartAddress = 0;
;;;117      #endif    
;;;118    #endif
;;;119    #if GDC0_LAYER_B
;;;120        /* Setting Layer B *******************************************************/
;;;121        stGDC0.stLayerConf_B.u8LayerActive   = GDC0_LAYER_B;
;;;122        stGDC0.stLayerConf_B.u8DisplayFormat = GDC0_LAYER_B_COLOR_FORMAT;
;;;123        stGDC0.stLayerConf_B.u8DoubleBuffer  = GDC0_LAYER_B_DOUBLEFUFFERING;
;;;124        stGDC0.stLayerConf_B.u8Alpha         = 0xFF;
;;;125        stGDC0.stLayerConf_B.u16StartX       = GDC0_LAYERB_STARTX;
;;;126        stGDC0.stLayerConf_B.u16StartY       = GDC0_LAYERB_STARTY;
;;;127        stGDC0.stLayerConf_B.u16Width        = GDC0_LAYERB_WIDTH;
;;;128        stGDC0.stLayerConf_B.u16Height       = GDC0_LAYERB_HEIGHT;
;;;129        stGDC0.stLayerConf_B.u32FB0StartAddress = PHYSICAL(&FBuffRGBA_GDC0_B0[0]);
;;;130      #if GDC0_LAYER_B_DOUBLEFUFFERING
;;;131        stGDC0.stLayerConf_B.u32FB1StartAddress = PHYSICAL(&FBuffRGBA_GDC0_B1[0]);
;;;132      #else
;;;133        stGDC0.stLayerConf_B.u32FB1StartAddress = 0;
;;;134      #endif    
;;;135    #endif
;;;136    #if GDC0_LAYER_C
;;;137        /* Setting Layer C *******************************************************/
;;;138        stGDC0.stLayerConf_C.u8LayerActive   = GDC0_LAYER_C;
;;;139        stGDC0.stLayerConf_C.u8DisplayFormat = GDC0_LAYER_C_COLOR_FORMAT;
;;;140        stGDC0.stLayerConf_C.u8DoubleBuffer  = GDC0_LAYER_C_DOUBLEFUFFERING;
;;;141        stGDC0.stLayerConf_C.u8Alpha         = 0xFF;
;;;142        stGDC0.stLayerConf_C.u16StartX       = GDC0_LAYERC_STARTX;
;;;143        stGDC0.stLayerConf_C.u16StartY       = GDC0_LAYERC_STARTY;
;;;144        stGDC0.stLayerConf_C.u16Width        = GDC0_LAYERC_WIDTH;
;;;145        stGDC0.stLayerConf_C.u16Height       = GDC0_LAYERC_HEIGHT;
;;;146        stGDC0.stLayerConf_C.u32FB0StartAddress = PHYSICAL(&FBuffRGBA_GDC0_C0[0]);
;;;147      #if GDC0_LAYER_C_DOUBLEFUFFERING
;;;148        stGDC0.stLayerConf_C.u32FB1StartAddress = PHYSICAL(&FBuffRGBA_GDC0_C1[0]);
;;;149      #else
;;;150        stGDC0.stLayerConf_C.u32FB1StartAddress = 0;
;;;151      #endif    
;;;152    #endif
;;;153    #if GDC0_LAYER_D
;;;154        /* Setting Layer D *******************************************************/
;;;155        stGDC0.stLayerConf_D.u8LayerActive   = GDC0_LAYER_D;
;;;156        stGDC0.stLayerConf_D.u8DisplayFormat = GDC0_LAYER_D_COLOR_FORMAT;
;;;157        stGDC0.stLayerConf_D.u8DoubleBuffer  = GDC0_LAYER_D_DOUBLEFUFFERING;
;;;158        stGDC0.stLayerConf_D.u8Alpha         = 0xFF;
;;;159        stGDC0.stLayerConf_D.u16StartX       = GDC0_LAYERD_STARTX;
;;;160        stGDC0.stLayerConf_D.u16StartY       = GDC0_LAYERD_STARTY;
;;;161        stGDC0.stLayerConf_D.u16Width        = GDC0_LAYERD_WIDTH;
;;;162        stGDC0.stLayerConf_D.u16Height       = GDC0_LAYERD_HEIGHT;
;;;163        stGDC0.stLayerConf_D.u32FB0StartAddress = PHYSICAL(&FBuffRGBA_GDC0_D0[0]);
;;;164      #if GDC0_LAYER_D_DOUBLEFUFFERING
;;;165        stGDC0.stLayerConf_D.u32FB1StartAddress = PHYSICAL(&FBuffRGBA_GDC0_D1[0]);
;;;166      #else
;;;167        stGDC0.stLayerConf_D.u32FB1StartAddress = 0;
;;;168      #endif    
;;;169    #endif
;;;170    #if GDC0_LAYER_E
;;;171        /* Setting Layer E *******************************************************/
;;;172        stGDC0.stLayerConf_E.u8LayerActive   = GDC0_LAYER_E;
;;;173        stGDC0.stLayerConf_E.u8DisplayFormat = GDC0_LAYER_E_COLOR_FORMAT;
;;;174        stGDC0.stLayerConf_E.u8DoubleBuffer  = GDC0_LAYER_E_DOUBLEFUFFERING;
;;;175        stGDC0.stLayerConf_E.u8Alpha         = 0xFF;
;;;176        stGDC0.stLayerConf_E.u16StartX       = GDC0_LAYERE_STARTX;
;;;177        stGDC0.stLayerConf_E.u16StartY       = GDC0_LAYERE_STARTY;
;;;178        stGDC0.stLayerConf_E.u16Width        = GDC0_LAYERE_WIDTH;
;;;179        stGDC0.stLayerConf_E.u16Height       = GDC0_LAYERE_HEIGHT;
;;;180        stGDC0.stLayerConf_E.u32FB0StartAddress = PHYSICAL(&FBuffRGBA_GDC0_E0[0]);
;;;181      #if GDC0_LAYER_E_DOUBLEFUFFERING
;;;182        stGDC0.stLayerConf_E.u32FB1StartAddress = PHYSICAL(&FBuffRGBA_GDC0_E1[0]);
;;;183      #else
;;;184        stGDC0.stLayerConf_E.u32FB1StartAddress = 0;
;;;185      #endif    
;;;186    #endif
;;;187    
;;;188        /* configuration for GDC1 */
;;;189        stGDC1.u8GDCActive = GDCx1;
000118  e3a00000          MOV      r0,#0
00011c  e5cd004c          STRB     r0,[sp,#0x4c]
;;;190    #if GDCx1    
;;;191        stGDC1.stDispConf.u8DispRes       = DISPLAY_RESOLUTION_1;
;;;192        stGDC1.stDispConf.u16DispStartX   = 64;
;;;193        stGDC1.stDispConf.u16DispStartY   = 64;
;;;194        stGDC1.stDispConf.u16DispWidth    = GDC1_DISPLAY_WIDTH;
;;;195        stGDC1.stDispConf.u16DispHeight   = GDC1_DISPLAY_HEIGHT;
;;;196        stGDC1.stDispConf.eDispConfigType = GDC_USE_DISP_SET_BY_LAYA;
;;;197    
;;;198        stGDC1.stDispConf.eGDC1Synchronisation = CCR_GDC_SYNC_INDEPENDANT;
;;;199        
;;;200        stGDC1.stDispConf.u8VSYNCType     = GDC_VSYNC;
;;;201    #if (OUTPUT_DEVICE == 0)
;;;202        stGDC1.stDispConf.u8VSYNCPol      = GDC_POS;
;;;203    #else
;;;204        stGDC1.stDispConf.u8VSYNCPol      = GDC_NEG;
;;;205    #endif
;;;206        stGDC1.stDispConf.u16VSYNCWidth   = VPulseWidth_1;
;;;207        stGDC1.stDispConf.u16VPeriod      = VPeriod_1;
;;;208        stGDC1.stDispConf.u16VBackPorch   = VBackPorch_1;
;;;209    
;;;210    #if (OUTPUT_DEVICE == 0)
;;;211        stGDC1.stDispConf.u8HSYNCPol      = GDC_POS;
;;;212    #else
;;;213        stGDC1.stDispConf.u8HSYNCPol      = GDC_NEG;
;;;214    #endif
;;;215        stGDC1.stDispConf.u16HSYNCWidth   = HPulseWidth_1;
;;;216        stGDC1.stDispConf.u16HPeriod      = HPeriod_1;
;;;217        stGDC1.stDispConf.u16HBackPorch   = HBackPorch_1;
;;;218    
;;;219        stGDC1.stDispConf.u8HDISPPol      = GDC_POS;
;;;220    
;;;221        stGDC1.stDispConf.u32BGColor      = 0x000000;
;;;222        stGDC1.stDispConf.u8SyncDir       = GDC_OUTPUT;
;;;223    
;;;224        stGDC1.stDispConf.u8DotClkPol     = GDC_POS;
;;;225        stGDC1.stDispConf.u8ClkSource     = GDC_DOTCLK_INT;
;;;226        stGDC1.stDispConf.eClockFrequency = (ccr_clk_freq_e)ClockFrequency_1;
;;;227        stGDC1.stDispConf.eModulated      = CCR_NON_MODULATED;
;;;228    
;;;229        stGDC1.stDispConf.eDithering      = GDC_DITHERING_MAGIC_SQR_SUBPIX_ENABLED;
;;;230        stGDC1.stDispConf.eLayerOrder     = GDC_ABCDE;
;;;231    
;;;232        stGDC1.stLayerConf_A.u8LayerActive   = GDC1_LAYER_A;
;;;233        stGDC1.stLayerConf_A.u8DisplayFormat = GDC1_LAYER_A_COLOR_FORMAT;
;;;234        stGDC1.stLayerConf_A.u8DoubleBuffer  = GDC1_LAYER_A_DOUBLEFUFFERING;
;;;235        stGDC1.stLayerConf_A.u8Alpha         = 0xFF;
;;;236        stGDC1.stLayerConf_A.u16StartX       = GDC1_LAYERA_STARTX;
;;;237        stGDC1.stLayerConf_A.u16StartY       = GDC1_LAYERA_STARTY;
;;;238        stGDC1.stLayerConf_A.u16Width        = GDC1_LAYERA_WIDTH;
;;;239        stGDC1.stLayerConf_A.u16Height       = GDC1_LAYERA_HEIGHT;
;;;240        stGDC1.stLayerConf_A.u32FB0StartAddress = PHYSICAL(&FBuffRGBA_GDC1_A0[0]);
;;;241        stGDC1.stLayerConf_A.u32FB1StartAddress = PHYSICAL(&FBuffRGBA_GDC1_A1[0]);
;;;242    
;;;243        stGDC1.stLayerConf_B.u8LayerActive   = GDC1_LAYER_B;
;;;244        stGDC1.stLayerConf_B.u8DisplayFormat = GDC1_LAYER_B_COLOR_FORMAT;
;;;245        stGDC1.stLayerConf_B.u8DoubleBuffer  = GDC1_LAYER_B_DOUBLEFUFFERING;
;;;246        stGDC1.stLayerConf_B.u8Alpha         = 0xFF;
;;;247        stGDC1.stLayerConf_B.u16StartX       = GDC1_LAYERB_STARTX;
;;;248        stGDC1.stLayerConf_B.u16StartY       = GDC1_LAYERB_STARTY;
;;;249        stGDC1.stLayerConf_B.u16Width        = GDC1_LAYERB_WIDTH;
;;;250        stGDC1.stLayerConf_B.u16Height       = GDC1_LAYERB_HEIGHT;
;;;251        stGDC1.stLayerConf_B.u32FB0StartAddress = 0;
;;;252        stGDC1.stLayerConf_B.u32FB1StartAddress = 0;
;;;253    
;;;254        stGDC1.stLayerConf_C.u8LayerActive   = GDC1_LAYER_C;
;;;255        stGDC1.stLayerConf_C.u8DisplayFormat = GDC1_LAYER_C_COLOR_FORMAT;
;;;256        stGDC1.stLayerConf_C.u8DoubleBuffer  = GDC1_LAYER_C_DOUBLEFUFFERING;
;;;257        stGDC1.stLayerConf_C.u8Alpha         = 0xFF;
;;;258        stGDC1.stLayerConf_C.u16StartX       = GDC1_LAYERC_STARTX;
;;;259        stGDC1.stLayerConf_C.u16StartY       = GDC1_LAYERC_STARTY;
;;;260        stGDC1.stLayerConf_C.u16Width        = GDC1_LAYERC_WIDTH;
;;;261        stGDC1.stLayerConf_C.u16Height       = GDC1_LAYERC_HEIGHT;
;;;262        stGDC1.stLayerConf_C.u32FB0StartAddress = 0;
;;;263        stGDC1.stLayerConf_C.u32FB1StartAddress = 0;
;;;264    
;;;265        stGDC1.stLayerConf_D.u8LayerActive   = GDC1_LAYER_D;
;;;266        stGDC1.stLayerConf_D.u8DisplayFormat = GDC1_LAYER_D_COLOR_FORMAT;
;;;267        stGDC1.stLayerConf_D.u8DoubleBuffer  = GDC1_LAYER_D_DOUBLEFUFFERING;
;;;268        stGDC1.stLayerConf_D.u8Alpha         = 0xFF;
;;;269        stGDC1.stLayerConf_D.u16StartX       = GDC1_LAYERD_STARTX;
;;;270        stGDC1.stLayerConf_D.u16StartY       = GDC1_LAYERD_STARTY;
;;;271        stGDC1.stLayerConf_D.u16Width        = GDC1_LAYERD_WIDTH;
;;;272        stGDC1.stLayerConf_D.u16Height       = GDC1_LAYERD_HEIGHT;
;;;273        stGDC1.stLayerConf_D.u32FB0StartAddress = 0;
;;;274        stGDC1.stLayerConf_D.u32FB1StartAddress = 0;
;;;275    
;;;276        stGDC1.stLayerConf_E.u8LayerActive   = GDC1_LAYER_E;
;;;277        stGDC1.stLayerConf_E.u8DisplayFormat = GDC1_LAYER_E_COLOR_FORMAT;
;;;278        stGDC1.stLayerConf_E.u8DoubleBuffer  = GDC1_LAYER_E_DOUBLEFUFFERING;
;;;279        stGDC1.stLayerConf_E.u8Alpha         = 0xFF;
;;;280        stGDC1.stLayerConf_E.u16StartX       = GDC1_LAYERE_STARTX;
;;;281        stGDC1.stLayerConf_E.u16StartY       = GDC1_LAYERE_STARTY;
;;;282        stGDC1.stLayerConf_E.u16Width        = GDC1_LAYERE_WIDTH;
;;;283        stGDC1.stLayerConf_E.u16Height       = GDC1_LAYERE_HEIGHT;
;;;284        stGDC1.stLayerConf_E.u32FB0StartAddress = 0;
;;;285        stGDC1.stLayerConf_E.u32FB1StartAddress = 0;
;;;286    #endif
;;;287    
;;;288        /* configuration of FG */
;;;289        stFG.u8FGActive = GDC_OFF;
000120  e5cd0000          STRB     r0,[sp,#0]
;;;290    
;;;291        stFG.stFgBuffer.u32CbaBufferAddr1 = 0x0;
000124  e58d0008          STR      r0,[sp,#8]
;;;292        stFG.stFgBuffer.u32CbaBufferAddr2 = 0x0;
000128  e58d000c          STR      r0,[sp,#0xc]
;;;293        stFG.stFgBuffer.u32CbaBufferAddr3 = 0x0;
00012c  e58d0010          STR      r0,[sp,#0x10]
;;;294        stFG.stFgBuffer.eCbactUsedBuffer  = FG_SINGEL_BUFFERING;
000130  e3a00001          MOV      r0,#1
000134  e5cd0004          STRB     r0,[sp,#4]
;;;295        stFG.stFgBuffer.u16LorLineOffset  = GDC0_LAYERA_WIDTH;
000138  e3000500          MOVW     r0,#0x500
00013c  e1cd00b6          STRH     r0,[sp,#6]
;;;296    
;;;297        stFG.stFgSwapYcbCr.eScbCr   = FG_SCBCR_CB_CR;
000140  e3a00000          MOV      r0,#0
000144  e5cd0022          STRB     r0,[sp,#0x22]
;;;298        stFG.stFgSwapYcbCr.eSycbcr  = FG_SYCBCR_Y2Y_CBCR2CBCR_CHANNEL;
000148  e5cd0023          STRB     r0,[sp,#0x23]
;;;299    
;;;300        stFG.stFgInMode.eBwex       = FG_BWEX_INTERPRET_CAMERAINPUT;
00014c  e5cd0019          STRB     r0,[sp,#0x19]
;;;301        stFG.stFgInMode.eComd       = FG_INP_COLORMODE_RGB;
000150  e5cd001a          STRB     r0,[sp,#0x1a]
;;;302        stFG.stFgInMode.eInterlMode = FG_INT_NORMAL_OPERATION;
000154  e5cd0018          STRB     r0,[sp,#0x18]
;;;303        stFG.stFgInMode.eNvmd       = FG_VIDEO_DATA;
000158  e5cd0017          STRB     r0,[sp,#0x17]
;;;304        stFG.stFgInMode.eRgb16_24   = FG_RGB888;
00015c  e3a00001          MOV      r0,#1
000160  e5cd0016          STRB     r0,[sp,#0x16]
;;;305        stFG.stFgInMode.eRgbPa      = FG_RGB_PARALLEL;
000164  e5cd0015          STRB     r0,[sp,#0x15]
;;;306        stFG.stFgInMode.u8Alpha     = 0xFF;
000168  e3a000ff          MOV      r0,#0xff
00016c  e5cd0014          STRB     r0,[sp,#0x14]
;;;307    
;;;308        stFG.stFgOutMode.eDeInterl       = FG_DINT_NO_DEINTERLACED;
000170  e3a00000          MOV      r0,#0
000174  e5cd001d          STRB     r0,[sp,#0x1d]
;;;309        stFG.stFgOutMode.eMonochrome     = FG_MONO_COLOUR;
000178  e5cd0020          STRB     r0,[sp,#0x20]
;;;310        stFG.stFgOutMode.eOutputSelector = FG_YCBRO_RGB;
00017c  e5cd001e          STRB     r0,[sp,#0x1e]
;;;311        stFG.stFgOutMode.eRgbFormat      = FG_RRGB_RGBA32;
000180  e5cd001f          STRB     r0,[sp,#0x1f]
;;;312        stFG.stFgOutMode.eYcbcr2RgbConv  = FG_YCBCR2RGB_ITU601;
000184  e5cd0021          STRB     r0,[sp,#0x21]
;;;313    
;;;314        stFG.stFgSignal.eHdact = FG_HIGH_ACTIVE;
000188  e3a00001          MOV      r0,#1
00018c  e5cd0029          STRB     r0,[sp,#0x29]
;;;315        stFG.stFgSignal.eHsact = FG_HIGH_ACTIVE;
000190  e5cd0027          STRB     r0,[sp,#0x27]
;;;316        stFG.stFgSignal.eVsact = FG_HIGH_ACTIVE;
000194  e5cd0028          STRB     r0,[sp,#0x28]
;;;317        stFG.stFgSignal.eNegPc = FG_NEGPC_NEG_EDGE;
000198  e5cd0025          STRB     r0,[sp,#0x25]
;;;318        stFG.stFgSignal.eNfOdd = FG_NFODD_LOWSIGNAL_FIRST;
00019c  e3a00000          MOV      r0,#0
0001a0  e5cd0024          STRB     r0,[sp,#0x24]
;;;319        stFG.stFgSignal.eOnec  = FG_ONEC_DATA_OVER_BOTH_INPCHANNELS;
0001a4  e5cd0026          STRB     r0,[sp,#0x26]
;;;320        stFG.stFgSignal.eUdsp  = FG_UDSP_HDISP_USED;
0001a8  e3a00001          MOV      r0,#1
0001ac  e5cd002a          STRB     r0,[sp,#0x2a]
;;;321        stFG.stFgSignal.eUsync = FG_USYNC_HVSYNC_USED;
0001b0  e5cd002b          STRB     r0,[sp,#0x2b]
;;;322    
;;;323        stFG.stCroppConfig.u16ItrHorizWait   = 0;
0001b4  e3a00000          MOV      r0,#0
0001b8  e1cd02bc          STRH     r0,[sp,#0x2c]
;;;324        stFG.stCroppConfig.u16ItrVertWait    = 0;
0001bc  e1cd02be          STRH     r0,[sp,#0x2e]
;;;325        stFG.stCroppConfig.u16HcrCroppLeftX  = 0;  
0001c0  e1cd03b0          STRH     r0,[sp,#0x30]
;;;326        stFG.stCroppConfig.u16VcrCroppTopY   = 0;  
0001c4  e1cd03b4          STRH     r0,[sp,#0x34]
;;;327        stFG.stCroppConfig.u16HcrCroppWidth  = 640;
0001c8  e3000280          MOVW     r0,#0x280
0001cc  e1cd03b2          STRH     r0,[sp,#0x32]
;;;328        stFG.stCroppConfig.u16VcrCroppHeight = 480;
0001d0  e30001e0          MOVW     r0,#0x1e0
0001d4  e1cd03b6          STRH     r0,[sp,#0x36]
;;;329        stFG.eCroppingEnable                 = FG_ENABLE;
0001d8  e3a00001          MOV      r0,#1
0001dc  e5cd0038          STRB     r0,[sp,#0x38]
;;;330    
;;;331        stFG.u32ScaleX = 0x800;
0001e0  e3000800          MOVW     r0,#0x800
0001e4  e58d003c          STR      r0,[sp,#0x3c]
;;;332        stFG.u32ScaleY = 0x800;
0001e8  e58d0040          STR      r0,[sp,#0x40]
;;;333    
;;;334        stFG.stMeasurement.eVcr   = FG_ENABLE;
0001ec  e3a00001          MOV      r0,#1
0001f0  e5cd0044          STRB     r0,[sp,#0x44]
;;;335        stFG.stMeasurement.eHcr   = FG_ENABLE;
0001f4  e5cd0045          STRB     r0,[sp,#0x45]
;;;336        stFG.stMeasurement.eVspwr = FG_ENABLE;
0001f8  e5cd0046          STRB     r0,[sp,#0x46]
;;;337        stFG.stMeasurement.eHspwr = FG_ENABLE;
0001fc  e5cd0047          STRB     r0,[sp,#0x47]
;;;338        stFG.stMeasurement.eHdisp = FG_ENABLE;
000200  e5cd0048          STRB     r0,[sp,#0x48]
;;;339    
;;;340        stFG.eFGEnable = FG_DISABLE;
000204  e3a00000          MOV      r0,#0
000208  e5cd0001          STRB     r0,[sp,#1]
;;;341    
;;;342        // Initialize the middleware
;;;343        vGfInitGfxMiddleWare(&stGDC0, &stGDC1, &stFG);
00020c  e1a0200d          MOV      r2,sp
000210  e28d104c          ADD      r1,sp,#0x4c
000214  e28d00e0          ADD      r0,sp,#0xe0
000218  ebfffffe          BL       vGfInitGfxMiddleWare
;;;344    }
00021c  e28ddf5d          ADD      sp,sp,#0x174
000220  e49df004          POP      {pc}
;;;345    
                          ENDP

                  vInterruptEnable PROC
;;;347    /****************************************************************************/
;;;348    static void vInterruptEnable(void)
000224  e92d4010          PUSH     {r4,lr}
;;;349    {
;;;350        /* Enable the VIC port(code from Init.s of verification ENV) */
;;;351        asm_enable_core_vic_port();
000228  ebfffffe          BL       asm_enable_core_vic_port
;;;352    
;;;353        /* enable interrupts in the core */
;;;354        asm_enable_core_int();
00022c  ebfffffe          BL       asm_enable_core_int
;;;355        asm_enable_core_fast_int();
000230  ebfffffe          BL       asm_enable_core_fast_int
;;;356    }
000234  e8bd8010          POP      {r4,pc}
;;;357    
                          ENDP

                  vConfigureQSPI0ReadAccess PROC
;;;360    #ifndef CAPBT_ROMEXEC
;;;361    static void vConfigureQSPI0ReadAccess(void)
000238  e52de004          PUSH     {lr}
;;;362    {
00023c  e24dd02c          SUB      sp,sp,#0x2c
;;;363        qspic_directconfig_st stDirConf;
;;;364        ccr_clk_freq_e eClocFreq;
;;;365        ccr_modulated_clk_e eModulationType;
;;;366        qspic_prgconfig_st stPrgConfig;
;;;367    
;;;368        i32AssignQSPISettings((qspi_dev_type_e)QSPI_DEVICE, 0x0200, &eClocFreq, &eModulationType, &stDirConf, &stPrgConfig);
000240  e28d000c          ADD      r0,sp,#0xc
000244  e28d1018          ADD      r1,sp,#0x18
000248  e58d0004          STR      r0,[sp,#4]
00024c  e58d1000          STR      r1,[sp,#0]
000250  e28d3010          ADD      r3,sp,#0x10
000254  e28d2014          ADD      r2,sp,#0x14
000258  e3001200          MOVW     r1,#0x200
00025c  e3a0000b          MOV      r0,#0xb
000260  ebfffffe          BL       i32AssignQSPISettings
;;;369        eClocFreq = CCR_CLKDIV_90_0MHz;
000264  e3a0000a          MOV      r0,#0xa
000268  e58d0014          STR      r0,[sp,#0x14]
;;;370    
;;;371        /* Configure QSPI clock */
;;;372        i32CCR_EnableModuleClock(CCR_QSPI_0, CCR_ENABLE);
00026c  e3a01001          MOV      r1,#1
000270  e3a00000          MOV      r0,#0
000274  ebfffffe          BL       i32CCR_EnableModuleClock
;;;373        i32CCR_SetClockFreq(CCR_QSPI_0, eClocFreq, eModulationType);    
000278  e5dd2010          LDRB     r2,[sp,#0x10]
00027c  e5dd1014          LDRB     r1,[sp,#0x14]
000280  e3a00000          MOV      r0,#0
000284  ebfffffe          BL       i32CCR_SetClockFreq
;;;374    
;;;375        /* Configure direct mode */
;;;376        i32QSPIC_ConfigureDirectControl(QSPIC_CNTRL_0, QSPIC_DEV_0, &stDirConf);
000288  e28d2018          ADD      r2,sp,#0x18
00028c  e3a01000          MOV      r1,#0
000290  e1a00001          MOV      r0,r1
000294  ebfffffe          BL       i32QSPIC_ConfigureDirectControl
;;;377    
;;;378        /* Configure program mode */
;;;379        i32QSPIC_ConfigurePrgControl(QSPIC_CNTRL_0, &stPrgConfig);
000298  e28d100c          ADD      r1,sp,#0xc
00029c  e3a00000          MOV      r0,#0
0002a0  ebfffffe          BL       i32QSPIC_ConfigurePrgControl
;;;380    
;;;381        /* Configure the IO pins */
;;;382        i32GPIO_EnableLatchFunction(PORT_QSPI0_SCLK, GPIO_DISABLE);
0002a4  e3a01000          MOV      r1,#0
0002a8  e3a00055          MOV      r0,#0x55
0002ac  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;383        i32GPIO_SetPinFunction(PORT_QSPI0_SCLK, PORT_QSPI0_SCLK_AS_QSPI0_SCLK);
0002b0  e3a01001          MOV      r1,#1
0002b4  e3a00055          MOV      r0,#0x55
0002b8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;384        i32GPIO_SetOutputResistance(PORT_QSPI0_SCLK, GPIO_OUTPUT_RESISTANCE_25);
0002bc  e3a01000          MOV      r1,#0
0002c0  e3a00055          MOV      r0,#0x55
0002c4  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;385        i32GPIO_EnablePullDown(PORT_QSPI0_SCLK, GPIO_DISABLE);
0002c8  e3a01000          MOV      r1,#0
0002cc  e3a00055          MOV      r0,#0x55
0002d0  ebfffffe          BL       i32GPIO_EnablePullDown
;;;386    
;;;387        i32GPIO_EnableLatchFunction(PORT_QSPI0_CS0, GPIO_DISABLE);
0002d4  e3a01000          MOV      r1,#0
0002d8  e3a00054          MOV      r0,#0x54
0002dc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;388        i32GPIO_SetPinFunction(PORT_QSPI0_CS0, PORT_QSPI0_CS0_AS_QSPI0_CS0);
0002e0  e3a01001          MOV      r1,#1
0002e4  e3a00054          MOV      r0,#0x54
0002e8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;389        i32GPIO_SetOutputResistance(PORT_QSPI0_CS0, GPIO_OUTPUT_RESISTANCE_25);
0002ec  e3a01000          MOV      r1,#0
0002f0  e3a00054          MOV      r0,#0x54
0002f4  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;390        i32GPIO_EnablePullDown(PORT_QSPI0_CS0, GPIO_DISABLE);
0002f8  e3a01000          MOV      r1,#0
0002fc  e3a00054          MOV      r0,#0x54
000300  ebfffffe          BL       i32GPIO_EnablePullDown
;;;391    
;;;392        i32GPIO_EnableLatchFunction(PORT_QSPI0_SIO0, GPIO_DISABLE);
000304  e3a01000          MOV      r1,#0
000308  e3a00050          MOV      r0,#0x50
00030c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;393        i32GPIO_SetPinFunction(PORT_QSPI0_SIO0, PORT_QSPI0_SIO0_AS_QSPI0_SIO0);
000310  e3a01001          MOV      r1,#1
000314  e3a00050          MOV      r0,#0x50
000318  ebfffffe          BL       i32GPIO_SetPinFunction
;;;394        i32GPIO_SetOutputResistance(PORT_QSPI0_SIO0, GPIO_OUTPUT_RESISTANCE_25);
00031c  e3a01000          MOV      r1,#0
000320  e3a00050          MOV      r0,#0x50
000324  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;395        i32GPIO_EnablePullDown(PORT_QSPI0_SIO0, GPIO_DISABLE);
000328  e3a01000          MOV      r1,#0
00032c  e3a00050          MOV      r0,#0x50
000330  ebfffffe          BL       i32GPIO_EnablePullDown
;;;396    
;;;397        i32GPIO_EnableLatchFunction(PORT_QSPI0_SIO1, GPIO_DISABLE);
000334  e3a01000          MOV      r1,#0
000338  e3a00051          MOV      r0,#0x51
00033c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;398        i32GPIO_SetPinFunction(PORT_QSPI0_SIO1, PORT_QSPI0_SIO1_AS_QSPI0_SIO1);
000340  e3a01001          MOV      r1,#1
000344  e3a00051          MOV      r0,#0x51
000348  ebfffffe          BL       i32GPIO_SetPinFunction
;;;399        i32GPIO_SetOutputResistance(PORT_QSPI0_SIO1, GPIO_OUTPUT_RESISTANCE_25);
00034c  e3a01000          MOV      r1,#0
000350  e3a00051          MOV      r0,#0x51
000354  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;400        i32GPIO_EnablePullDown(PORT_QSPI0_SIO1, GPIO_DISABLE);
000358  e3a01000          MOV      r1,#0
00035c  e3a00051          MOV      r0,#0x51
000360  ebfffffe          BL       i32GPIO_EnablePullDown
;;;401    
;;;402        i32GPIO_EnableLatchFunction(PORT_QSPI0_SIO2, GPIO_DISABLE);
000364  e3a01000          MOV      r1,#0
000368  e3a00052          MOV      r0,#0x52
00036c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;403        i32GPIO_SetPinFunction(PORT_QSPI0_SIO2, PORT_QSPI0_SIO2_AS_QSPI0_SIO2);
000370  e3a01001          MOV      r1,#1
000374  e3a00052          MOV      r0,#0x52
000378  ebfffffe          BL       i32GPIO_SetPinFunction
;;;404        i32GPIO_SetOutputResistance(PORT_QSPI0_SIO2, GPIO_OUTPUT_RESISTANCE_25);
00037c  e3a01000          MOV      r1,#0
000380  e3a00052          MOV      r0,#0x52
000384  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;405        i32GPIO_EnablePullDown(PORT_QSPI0_SIO2, GPIO_DISABLE);
000388  e3a01000          MOV      r1,#0
00038c  e3a00052          MOV      r0,#0x52
000390  ebfffffe          BL       i32GPIO_EnablePullDown
;;;406    
;;;407        i32GPIO_EnableLatchFunction(PORT_QSPI0_SIO3, GPIO_DISABLE);
000394  e3a01000          MOV      r1,#0
000398  e3a00053          MOV      r0,#0x53
00039c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;408        i32GPIO_SetPinFunction(PORT_QSPI0_SIO3, PORT_QSPI0_SIO3_AS_QSPI0_SIO3);
0003a0  e3a01001          MOV      r1,#1
0003a4  e3a00053          MOV      r0,#0x53
0003a8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;409        i32GPIO_SetOutputResistance(PORT_QSPI0_SIO3, GPIO_OUTPUT_RESISTANCE_25);
0003ac  e3a01000          MOV      r1,#0
0003b0  e3a00053          MOV      r0,#0x53
0003b4  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;410        i32GPIO_EnablePullDown(PORT_QSPI0_SIO3, GPIO_DISABLE);
0003b8  e3a01000          MOV      r1,#0
0003bc  e3a00053          MOV      r0,#0x53
0003c0  ebfffffe          BL       i32GPIO_EnablePullDown
;;;411    }
0003c4  e28dd02c          ADD      sp,sp,#0x2c
0003c8  e49df004          POP      {pc}
;;;412    
                          ENDP

                  vBoardCfg PROC
;;;417    
;;;418    void vBoardCfg(void)
0003cc  e92d4010          PUSH     {r4,lr}
;;;419    {   
;;;420    #ifndef CAPBT_ROMEXEC
;;;421        /* Graphics need to be copied from QSPI, thus direct mapping is required */
;;;422        vConfigureQSPI0ReadAccess();
0003d0  ebfffffe          BL       vConfigureQSPI0ReadAccess
;;;423    #endif /* CAPBT_ROMEXEC */    
;;;424    
;;;425        vInterruptEnable();
0003d4  ebfffffe          BL       vInterruptEnable
;;;426    }
0003d8  e8bd8010          POP      {r4,pc}
;;;427    
                          ENDP

                  |L1.988|
                          DCD      FBuffRGBA_GDC0_A0
                  |L1.992|
                          DCD      FBuffRGBA_GDC0_A1
