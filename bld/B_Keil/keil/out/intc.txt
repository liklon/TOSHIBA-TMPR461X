; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\intc.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\intc.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\intc.crf ..\..\..\..\lldd\src\intc.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vINTC_GetVersion PROC
;;;87     
;;;88     void vINTC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
000000  e92d4070          PUSH     {r4-r6,lr}
;;;89                           uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
;;;90                           uint8_t** pau8IORevision, uint8_t** pau8IOTag)
;;;91     {
000004  e1cd41d0          LDRD     r4,r5,[sp,#0x10]
;;;92        *pau8ModuleRevision = &au8LLDD_INTC_C_REVISION[0];
000008  e59f6a98          LDR      r6,|L1.2728|
00000c  e5806000          STR      r6,[r0,#0]
;;;93        *pau8ModuleTag      = &au8LLDD_INTC_C_TAG[0];
000010  e59f6a94          LDR      r6,|L1.2732|
000014  e5816000          STR      r6,[r1,#0]
;;;94        *pau8HeaderRevision = &au8LLDD_INTC_H_REVISION[0];
000018  e59f6a90          LDR      r6,|L1.2736|
00001c  e5826000          STR      r6,[r2,#0]
;;;95        *pau8HeaderTag      = &au8LLDD_INTC_H_TAG[0];
000020  e59f6a8c          LDR      r6,|L1.2740|
000024  e5836000          STR      r6,[r3,#0]
;;;96        *pau8IORevision     = &au8LLDD_INTC_IO_H_REVISION[0];
000028  e59f6a88          LDR      r6,|L1.2744|
00002c  e5846000          STR      r6,[r4,#0]
;;;97        *pau8IOTag          = &au8LLDD_INTC_IO_H_TAG[0];
000030  e59f6a84          LDR      r6,|L1.2748|
000034  e5856000          STR      r6,[r5,#0]
;;;98     }
000038  e8bd8070          POP      {r4-r6,pc}
;;;99     
                          ENDP

                  vSetIR_ByIndex PROC
;;;102    
;;;103    void vSetIR_ByIndex(uint8_t u8SrcIx, uint8_t u8Value_write)
00003c  e92d40ff          PUSH     {r0-r7,lr}
;;;104    {
;;;105        uint16_t u16RegIx;
;;;106        uint16_t u16FieldOffs;
;;;107        uint32_t u32RegValue;
;;;108        uint32_t u32RegValueNew;
;;;109        uint32_t u32RegMask[4] = {0xFFFFFF00U, 0xFFFF00FFU, 0xFF00FFFFU, 0x00FFFFFFU};
000040  e59fea78          LDR      lr,|L1.2752|
000044  e89e5088          LDM      lr,{r3,r7,r12,lr}  ; <Data1>, <Data1>, <Data1>, <Data1>
000048  e88d5088          STM      sp,{r3,r7,r12,lr}
;;;110    
;;;111        /* find out which channel and which field (0..3) in related register */
;;;112        u16RegIx     = u8SrcIx >> 2;
00004c  e1a04140          ASR      r4,r0,#2
;;;113        u16FieldOffs = u8SrcIx % 4;
000050  e1a03000          MOV      r3,r0
000054  e1a07fc0          ASR      r7,r0,#31
000058  e0807f27          ADD      r7,r0,r7,LSR #30
00005c  e1a07147          ASR      r7,r7,#2
000060  e0407107          SUB      r7,r0,r7,LSL #2
000064  e6ff5077          UXTH     r5,r7
;;;114        
;;;115        /* read register */
;;;116        u32RegValue = u32GetIR(u16RegIx);
000068  e1a03104          LSL      r3,r4,#2
00006c  e24335ff          SUB      r3,r3,#0x3fc00000
000070  e24339be          SUB      r3,r3,#0x2f8000
000074  e5936000          LDR      r6,[r3,#0]
;;;117        /* mask related bits */
;;;118        u32RegValue &= u32RegMask[u16FieldOffs];
000078  e79d3105          LDR      r3,[sp,r5,LSL #2]
00007c  e0066003          AND      r6,r6,r3
;;;119        
;;;120        /* build 32 bit new value: */
;;;121        u32RegValueNew = (uint32_t)u8Value_write;
000080  e1a02001          MOV      r2,r1
;;;122        u32RegValueNew <<= (8*u16FieldOffs);    
000084  e1a03185          LSL      r3,r5,#3
000088  e1a02312          LSL      r2,r2,r3
;;;123        u32RegValueNew |= u32RegValue;
00008c  e1822006          ORR      r2,r2,r6
;;;124        
;;;125        /* write back value in register: */
;;;126        vSetIR(u16RegIx, u32RegValueNew);
000090  e1a03104          LSL      r3,r4,#2
000094  e24335ff          SUB      r3,r3,#0x3fc00000
000098  e24339be          SUB      r3,r3,#0x2f8000
00009c  e5832000          STR      r2,[r3,#0]
;;;127    }
0000a0  e8bd80ff          POP      {r0-r7,pc}
;;;128    
                          ENDP

                  vSetIR_EXT_ByIndex PROC
;;;131    
;;;132    void vSetIR_EXT_ByIndex(uint8_t u8SrcIx, uint8_t u8EXT)
0000a4  e92d4030          PUSH     {r4,r5,lr}
;;;133    {
0000a8  e1a02000          MOV      r2,r0
;;;134        uint16_t u16RegIx;
;;;135        uint16_t u16FieldOffs;
;;;136    
;;;137        /* find out which channel and which field (0..3) in related register */
;;;138        u16RegIx     = ((uint16_t) u8SrcIx) >> 2;
0000ac  e1a00142          ASR      r0,r2,#2
;;;139        u16FieldOffs = u8SrcIx % 4;
0000b0  e1a03002          MOV      r3,r2
0000b4  e1a05fc2          ASR      r5,r2,#31
0000b8  e0825f25          ADD      r5,r2,r5,LSR #30
0000bc  e1a05145          ASR      r5,r5,#2
0000c0  e0425105          SUB      r5,r2,r5,LSL #2
0000c4  e6ff4075          UXTH     r4,r5
;;;140        
;;;141        switch ( u16FieldOffs )
0000c8  e3540000          CMP      r4,#0
0000cc  0a000004          BEQ      |L1.228|
0000d0  e3540001          CMP      r4,#1
0000d4  0a00000d          BEQ      |L1.272|
0000d8  e3540002          CMP      r4,#2
0000dc  1a000021          BNE      |L1.360|
0000e0  ea000015          B        |L1.316|
                  |L1.228|
;;;142        {
;;;143            case 0:
0000e4  e320f000          NOP      
;;;144                vSetIR_EXT0(u16RegIx, u8EXT);
0000e8  e1a03100          LSL      r3,r0,#2
0000ec  e24335ff          SUB      r3,r3,#0x3fc00000
0000f0  e24339be          SUB      r3,r3,#0x2f8000
0000f4  e5933000          LDR      r3,[r3,#0]
0000f8  e7c23011          BFI      r3,r1,#0,#3
0000fc  e1a05100          LSL      r5,r0,#2
000100  e24555ff          SUB      r5,r5,#0x3fc00000
000104  e24559be          SUB      r5,r5,#0x2f8000
000108  e5853000          STR      r3,[r5,#0]
;;;145                break;
00010c  ea000020          B        |L1.404|
                  |L1.272|
;;;146    
;;;147            case 1:
000110  e320f000          NOP      
;;;148                vSetIR_EXT1(u16RegIx, u8EXT);
000114  e1a03100          LSL      r3,r0,#2
000118  e24335ff          SUB      r3,r3,#0x3fc00000
00011c  e24339be          SUB      r3,r3,#0x2f8000
000120  e5933000          LDR      r3,[r3,#0]
000124  e7ca3411          BFI      r3,r1,#8,#3
000128  e1a05100          LSL      r5,r0,#2
00012c  e24555ff          SUB      r5,r5,#0x3fc00000
000130  e24559be          SUB      r5,r5,#0x2f8000
000134  e5853000          STR      r3,[r5,#0]
;;;149                break;
000138  ea000015          B        |L1.404|
                  |L1.316|
;;;150    
;;;151            case 2:
00013c  e320f000          NOP      
;;;152                vSetIR_EXT2(u16RegIx, u8EXT);
000140  e1a03100          LSL      r3,r0,#2
000144  e24335ff          SUB      r3,r3,#0x3fc00000
000148  e24339be          SUB      r3,r3,#0x2f8000
00014c  e5933000          LDR      r3,[r3,#0]
000150  e7d23811          BFI      r3,r1,#16,#3
000154  e1a05100          LSL      r5,r0,#2
000158  e24555ff          SUB      r5,r5,#0x3fc00000
00015c  e24559be          SUB      r5,r5,#0x2f8000
000160  e5853000          STR      r3,[r5,#0]
;;;153                break;
000164  ea00000a          B        |L1.404|
                  |L1.360|
;;;154    
;;;155            default:
000168  e320f000          NOP      
;;;156                vSetIR_EXT3(u16RegIx, u8EXT);
00016c  e1a03100          LSL      r3,r0,#2
000170  e24335ff          SUB      r3,r3,#0x3fc00000
000174  e24339be          SUB      r3,r3,#0x2f8000
000178  e5933000          LDR      r3,[r3,#0]
00017c  e7da3c11          BFI      r3,r1,#24,#3
000180  e1a05100          LSL      r5,r0,#2
000184  e24555ff          SUB      r5,r5,#0x3fc00000
000188  e24559be          SUB      r5,r5,#0x2f8000
00018c  e5853000          STR      r3,[r5,#0]
;;;157                break;
000190  e320f000          NOP      
                  |L1.404|
000194  e320f000          NOP                            ;145
;;;158        }
;;;159        
;;;160        return;
;;;161    }
000198  e8bd8030          POP      {r4,r5,pc}
;;;162    
                          ENDP

                  vSetIR_DRS_ByIndex PROC
;;;165    
;;;166    void vSetIR_DRS_ByIndex(uint8_t u8SrcIx, uint8_t u8DRS)
00019c  e92d4030          PUSH     {r4,r5,lr}
;;;167    {
0001a0  e1a02000          MOV      r2,r0
;;;168        uint16_t u16RegIx;
;;;169        uint16_t u16FieldOffs;
;;;170    
;;;171        /* find out which channel and which field (0..3) in related register */
;;;172        u16RegIx     = ((uint16_t) u8SrcIx) >> 2;
0001a4  e1a00142          ASR      r0,r2,#2
;;;173        u16FieldOffs = u8SrcIx % 4;
0001a8  e1a03002          MOV      r3,r2
0001ac  e1a05fc2          ASR      r5,r2,#31
0001b0  e0825f25          ADD      r5,r2,r5,LSR #30
0001b4  e1a05145          ASR      r5,r5,#2
0001b8  e0425105          SUB      r5,r2,r5,LSL #2
0001bc  e6ff4075          UXTH     r4,r5
;;;174        
;;;175        switch ( u16FieldOffs )
0001c0  e3540000          CMP      r4,#0
0001c4  0a000004          BEQ      |L1.476|
0001c8  e3540001          CMP      r4,#1
0001cc  0a00000d          BEQ      |L1.520|
0001d0  e3540002          CMP      r4,#2
0001d4  1a000021          BNE      |L1.608|
0001d8  ea000015          B        |L1.564|
                  |L1.476|
;;;176        {
;;;177            case 0:
0001dc  e320f000          NOP      
;;;178                vSetIR_DRS0(u16RegIx, u8DRS);
0001e0  e1a03100          LSL      r3,r0,#2
0001e4  e24335ff          SUB      r3,r3,#0x3fc00000
0001e8  e24339be          SUB      r3,r3,#0x2f8000
0001ec  e5933000          LDR      r3,[r3,#0]
0001f0  e7c43211          BFI      r3,r1,#4,#1
0001f4  e1a05100          LSL      r5,r0,#2
0001f8  e24555ff          SUB      r5,r5,#0x3fc00000
0001fc  e24559be          SUB      r5,r5,#0x2f8000
000200  e5853000          STR      r3,[r5,#0]
;;;179                break;
000204  ea000020          B        |L1.652|
                  |L1.520|
;;;180    
;;;181            case 1:
000208  e320f000          NOP      
;;;182                vSetIR_DRS1(u16RegIx, u8DRS);
00020c  e1a03100          LSL      r3,r0,#2
000210  e24335ff          SUB      r3,r3,#0x3fc00000
000214  e24339be          SUB      r3,r3,#0x2f8000
000218  e5933000          LDR      r3,[r3,#0]
00021c  e7cc3611          BFI      r3,r1,#12,#1
000220  e1a05100          LSL      r5,r0,#2
000224  e24555ff          SUB      r5,r5,#0x3fc00000
000228  e24559be          SUB      r5,r5,#0x2f8000
00022c  e5853000          STR      r3,[r5,#0]
;;;183                break;
000230  ea000015          B        |L1.652|
                  |L1.564|
;;;184    
;;;185            case 2:
000234  e320f000          NOP      
;;;186                vSetIR_DRS2(u16RegIx, u8DRS);
000238  e1a03100          LSL      r3,r0,#2
00023c  e24335ff          SUB      r3,r3,#0x3fc00000
000240  e24339be          SUB      r3,r3,#0x2f8000
000244  e5933000          LDR      r3,[r3,#0]
000248  e7d43a11          BFI      r3,r1,#20,#1
00024c  e1a05100          LSL      r5,r0,#2
000250  e24555ff          SUB      r5,r5,#0x3fc00000
000254  e24559be          SUB      r5,r5,#0x2f8000
000258  e5853000          STR      r3,[r5,#0]
;;;187                break;
00025c  ea00000a          B        |L1.652|
                  |L1.608|
;;;188    
;;;189            default:
000260  e320f000          NOP      
;;;190                vSetIR_DRS3(u16RegIx, u8DRS);
000264  e1a03100          LSL      r3,r0,#2
000268  e24335ff          SUB      r3,r3,#0x3fc00000
00026c  e24339be          SUB      r3,r3,#0x2f8000
000270  e5933000          LDR      r3,[r3,#0]
000274  e7dc3e11          BFI      r3,r1,#28,#1
000278  e1a05100          LSL      r5,r0,#2
00027c  e24555ff          SUB      r5,r5,#0x3fc00000
000280  e24559be          SUB      r5,r5,#0x2f8000
000284  e5853000          STR      r3,[r5,#0]
;;;191                break;
000288  e320f000          NOP      
                  |L1.652|
00028c  e320f000          NOP                            ;179
;;;192        }
;;;193        
;;;194        return;
;;;195    }
000290  e8bd8030          POP      {r4,r5,pc}
;;;196    
                          ENDP

                  vSetIR_ACLR_ByIndex PROC
;;;199    
;;;200    void vSetIR_ACLR_ByIndex(uint8_t u8SrcIx, uint8_t u8ACLR)
000294  e92d4030          PUSH     {r4,r5,lr}
;;;201    {
000298  e1a02000          MOV      r2,r0
;;;202        uint16_t u16RegIx;
;;;203        uint16_t u16FieldOffs;
;;;204    
;;;205        /* find out which channel and which field (0..3) in related register */
;;;206        u16RegIx     = ((uint16_t) u8SrcIx) >> 2;
00029c  e1a00142          ASR      r0,r2,#2
;;;207        u16FieldOffs = u8SrcIx % 4;
0002a0  e1a03002          MOV      r3,r2
0002a4  e1a05fc2          ASR      r5,r2,#31
0002a8  e0825f25          ADD      r5,r2,r5,LSR #30
0002ac  e1a05145          ASR      r5,r5,#2
0002b0  e0425105          SUB      r5,r2,r5,LSL #2
0002b4  e6ff4075          UXTH     r4,r5
;;;208        
;;;209        switch ( u16FieldOffs )
0002b8  e3540000          CMP      r4,#0
0002bc  0a000004          BEQ      |L1.724|
0002c0  e3540001          CMP      r4,#1
0002c4  0a00000d          BEQ      |L1.768|
0002c8  e3540002          CMP      r4,#2
0002cc  1a000021          BNE      |L1.856|
0002d0  ea000015          B        |L1.812|
                  |L1.724|
;;;210        {
;;;211            case 0:
0002d4  e320f000          NOP      
;;;212                vSetIR_ACLR0(u16RegIx, u8ACLR);
0002d8  e1a03100          LSL      r3,r0,#2
0002dc  e24335ff          SUB      r3,r3,#0x3fc00000
0002e0  e24339be          SUB      r3,r3,#0x2f8000
0002e4  e5933000          LDR      r3,[r3,#0]
0002e8  e7c73391          BFI      r3,r1,#7,#1
0002ec  e1a05100          LSL      r5,r0,#2
0002f0  e24555ff          SUB      r5,r5,#0x3fc00000
0002f4  e24559be          SUB      r5,r5,#0x2f8000
0002f8  e5853000          STR      r3,[r5,#0]
;;;213                break;
0002fc  ea000020          B        |L1.900|
                  |L1.768|
;;;214    
;;;215            case 1:
000300  e320f000          NOP      
;;;216                vSetIR_ACLR1(u16RegIx, u8ACLR);
000304  e1a03100          LSL      r3,r0,#2
000308  e24335ff          SUB      r3,r3,#0x3fc00000
00030c  e24339be          SUB      r3,r3,#0x2f8000
000310  e5933000          LDR      r3,[r3,#0]
000314  e7cf3791          BFI      r3,r1,#15,#1
000318  e1a05100          LSL      r5,r0,#2
00031c  e24555ff          SUB      r5,r5,#0x3fc00000
000320  e24559be          SUB      r5,r5,#0x2f8000
000324  e5853000          STR      r3,[r5,#0]
;;;217                break;
000328  ea000015          B        |L1.900|
                  |L1.812|
;;;218    
;;;219            case 2:
00032c  e320f000          NOP      
;;;220                vSetIR_ACLR2(u16RegIx, u8ACLR);
000330  e1a03100          LSL      r3,r0,#2
000334  e24335ff          SUB      r3,r3,#0x3fc00000
000338  e24339be          SUB      r3,r3,#0x2f8000
00033c  e5933000          LDR      r3,[r3,#0]
000340  e7d73b91          BFI      r3,r1,#23,#1
000344  e1a05100          LSL      r5,r0,#2
000348  e24555ff          SUB      r5,r5,#0x3fc00000
00034c  e24559be          SUB      r5,r5,#0x2f8000
000350  e5853000          STR      r3,[r5,#0]
;;;221                break;
000354  ea00000a          B        |L1.900|
                  |L1.856|
;;;222    
;;;223            default:
000358  e320f000          NOP      
;;;224                vSetIR_ACLR3(u16RegIx, u8ACLR);
00035c  e1a03100          LSL      r3,r0,#2
000360  e24335ff          SUB      r3,r3,#0x3fc00000
000364  e24339be          SUB      r3,r3,#0x2f8000
000368  e5933000          LDR      r3,[r3,#0]
00036c  e7df3f91          BFI      r3,r1,#31,#1
000370  e1a05100          LSL      r5,r0,#2
000374  e24555ff          SUB      r5,r5,#0x3fc00000
000378  e24559be          SUB      r5,r5,#0x2f8000
00037c  e5853000          STR      r3,[r5,#0]
;;;225                break;
000380  e320f000          NOP      
                  |L1.900|
000384  e320f000          NOP                            ;213
;;;226        }
;;;227        
;;;228        return;
;;;229    }
000388  e8bd8030          POP      {r4,r5,pc}
;;;230    
                          ENDP

                  vSetIR_EIM_ByIndex PROC
;;;233    
;;;234    void vSetIR_EIM_ByIndex(uint8_t u8SrcIx, uint8_t u8EIM)
00038c  e92d4030          PUSH     {r4,r5,lr}
;;;235    {
000390  e1a02000          MOV      r2,r0
;;;236        uint16_t u16RegIx;
;;;237        uint16_t u16FieldOffs;
;;;238    
;;;239        /* find out which channel and which field (0..3) in related register */
;;;240        u16RegIx     = u8SrcIx >> 2;
000394  e1a00142          ASR      r0,r2,#2
;;;241        u16FieldOffs = u8SrcIx % 4;
000398  e1a03002          MOV      r3,r2
00039c  e1a05fc2          ASR      r5,r2,#31
0003a0  e0825f25          ADD      r5,r2,r5,LSR #30
0003a4  e1a05145          ASR      r5,r5,#2
0003a8  e0425105          SUB      r5,r2,r5,LSL #2
0003ac  e6ff4075          UXTH     r4,r5
;;;242        
;;;243        switch ( u16FieldOffs )
0003b0  e3540000          CMP      r4,#0
0003b4  0a000004          BEQ      |L1.972|
0003b8  e3540001          CMP      r4,#1
0003bc  0a00000d          BEQ      |L1.1016|
0003c0  e3540002          CMP      r4,#2
0003c4  1a000021          BNE      |L1.1104|
0003c8  ea000015          B        |L1.1060|
                  |L1.972|
;;;244        {
;;;245            case 0:
0003cc  e320f000          NOP      
;;;246                vSetIR_EIM0(u16RegIx, u8EIM);
0003d0  e1a03100          LSL      r3,r0,#2
0003d4  e24335ff          SUB      r3,r3,#0x3fc00000
0003d8  e24339be          SUB      r3,r3,#0x2f8000
0003dc  e5933000          LDR      r3,[r3,#0]
0003e0  e7c63291          BFI      r3,r1,#5,#2
0003e4  e1a05100          LSL      r5,r0,#2
0003e8  e24555ff          SUB      r5,r5,#0x3fc00000
0003ec  e24559be          SUB      r5,r5,#0x2f8000
0003f0  e5853000          STR      r3,[r5,#0]
;;;247                break;
0003f4  ea000020          B        |L1.1148|
                  |L1.1016|
;;;248    
;;;249            case 1:
0003f8  e320f000          NOP      
;;;250                vSetIR_EIM1(u16RegIx, u8EIM);
0003fc  e1a03100          LSL      r3,r0,#2
000400  e24335ff          SUB      r3,r3,#0x3fc00000
000404  e24339be          SUB      r3,r3,#0x2f8000
000408  e5933000          LDR      r3,[r3,#0]
00040c  e7ce3691          BFI      r3,r1,#13,#2
000410  e1a05100          LSL      r5,r0,#2
000414  e24555ff          SUB      r5,r5,#0x3fc00000
000418  e24559be          SUB      r5,r5,#0x2f8000
00041c  e5853000          STR      r3,[r5,#0]
;;;251                break;
000420  ea000015          B        |L1.1148|
                  |L1.1060|
;;;252    
;;;253            case 2:
000424  e320f000          NOP      
;;;254                vSetIR_EIM2(u16RegIx, u8EIM);
000428  e1a03100          LSL      r3,r0,#2
00042c  e24335ff          SUB      r3,r3,#0x3fc00000
000430  e24339be          SUB      r3,r3,#0x2f8000
000434  e5933000          LDR      r3,[r3,#0]
000438  e7d63a91          BFI      r3,r1,#21,#2
00043c  e1a05100          LSL      r5,r0,#2
000440  e24555ff          SUB      r5,r5,#0x3fc00000
000444  e24559be          SUB      r5,r5,#0x2f8000
000448  e5853000          STR      r3,[r5,#0]
;;;255                break;
00044c  ea00000a          B        |L1.1148|
                  |L1.1104|
;;;256    
;;;257            default:
000450  e320f000          NOP      
;;;258                vSetIR_EIM3(u16RegIx, u8EIM);
000454  e1a03100          LSL      r3,r0,#2
000458  e24335ff          SUB      r3,r3,#0x3fc00000
00045c  e24339be          SUB      r3,r3,#0x2f8000
000460  e5933000          LDR      r3,[r3,#0]
000464  e7de3e91          BFI      r3,r1,#29,#2
000468  e1a05100          LSL      r5,r0,#2
00046c  e24555ff          SUB      r5,r5,#0x3fc00000
000470  e24559be          SUB      r5,r5,#0x2f8000
000474  e5853000          STR      r3,[r5,#0]
;;;259                break;
000478  e320f000          NOP      
                  |L1.1148|
00047c  e320f000          NOP                            ;247
;;;260        }
;;;261        
;;;262        return;
;;;263    }
000480  e8bd8030          POP      {r4,r5,pc}
;;;264    
                          ENDP

                  i32INTC_SourceConfig PROC
;;;267    
;;;268    int32_t i32INTC_SourceConfig(intc_src_e eSrc, intc_drs_e eDst, intc_eim_e eMode, intc_ext_e eLevel, intc_aclr_e eAutoClear)
000484  e92d4ff0          PUSH     {r4-r11,lr}
;;;269    {
000488  e24dd014          SUB      sp,sp,#0x14
00048c  e1a05000          MOV      r5,r0
000490  e1a06001          MOV      r6,r1
000494  e1a04002          MOV      r4,r2
000498  e1a07003          MOV      r7,r3
00049c  e59db038          LDR      r11,[sp,#0x38]
;;;270        int32_t     i32Res = C_SUCCESS;
0004a0  e3a08000          MOV      r8,#0
;;;271        uint8_t     u8SrcIx;
;;;272        intc_eim_e  eSrcEim;
;;;273        uint8_t     u8Value_write;
;;;274        uint8_t     u8EIM_write, u8DRS_write, u8EXT_write, u8ACLR_write;
;;;275    
;;;276    
;;;277        u8SrcIx = (uint8_t)INTC_GET_ROFST(eSrc);
0004a4  e20500ff          AND      r0,r5,#0xff
0004a8  e58d0010          STR      r0,[sp,#0x10]
;;;278    
;;;279        /* Check the requested source */
;;;280        if( u8SrcIx > LAST_SRC_INDEX )
0004ac  e59d0010          LDR      r0,[sp,#0x10]
0004b0  e35000b2          CMP      r0,#0xb2
0004b4  9a000001          BLS      |L1.1216|
;;;281        {
;;;282            /* Invalid source */
;;;283            i32Res = C_FAILED;
0004b8  e3e08000          MVN      r8,#0
0004bc  ea000018          B        |L1.1316|
                  |L1.1216|
;;;284        }
;;;285        else
;;;286        {
;;;287            /* check valid parameters: */
;;;288            if( (eMode < INTC_NA) && (eLevel <= INTC_LEVEL_7) && (eAutoClear <= INTC_AUTO_CLEAR_ENABLE) && (eDst <= INTC_TO_DMA))
0004c0  e3540006          CMP      r4,#6
0004c4  aa000015          BGE      |L1.1312|
0004c8  e3570007          CMP      r7,#7
0004cc  ca000013          BGT      |L1.1312|
0004d0  e35b0001          CMP      r11,#1
0004d4  ca000011          BGT      |L1.1312|
0004d8  e3560001          CMP      r6,#1
0004dc  ca00000f          BGT      |L1.1312|
;;;289            {
;;;290                /* get source mode: */
;;;291                eSrcEim = (intc_eim_e) INTC_GET_MODE(eSrc);
0004e0  e7e39c55          UBFX     r9,r5,#24,#4
;;;292    
;;;293                /* Default mode was requested */
;;;294                if( INTC_RM_DEFAULT == eMode )
0004e4  e3540005          CMP      r4,#5
0004e8  1a000005          BNE      |L1.1284|
;;;295                {
;;;296                    /* Is there a valid default mode for this source */
;;;297                    if( INTC_NA == eSrcEim )
0004ec  e3590006          CMP      r9,#6
0004f0  1a000001          BNE      |L1.1276|
;;;298                    {
;;;299                        /* No default mode available, e.g. external interrupt source */
;;;300                        i32Res = C_FAILED;
0004f4  e3e08000          MVN      r8,#0
0004f8  ea000002          B        |L1.1288|
                  |L1.1276|
;;;301                    }
;;;302                    else
;;;303                    {
;;;304                        /* Use default recognition mode*/
;;;305                        u8EIM_write = (uint8_t) eSrcEim;
0004fc  e1a0a009          MOV      r10,r9
000500  ea000000          B        |L1.1288|
                  |L1.1284|
;;;306                    }
;;;307                }
;;;308                else
;;;309                {
;;;310                    /* Use given recognition mode */
;;;311                    u8EIM_write = (uint8_t) eMode;
000504  e1a0a004          MOV      r10,r4
                  |L1.1288|
;;;312                }
;;;313    
;;;314                if( C_SUCCESS == i32Res )
000508  e3580000          CMP      r8,#0
00050c  1a000004          BNE      |L1.1316|
;;;315                {
;;;316                    /* Destination set */
;;;317                    u8DRS_write = (uint8_t) eDst;
000510  e58d6008          STR      r6,[sp,#8]
;;;318    
;;;319                    /* IRQ Level/DMA channel */
;;;320                    u8EXT_write = (uint8_t) eLevel;
000514  e58d7004          STR      r7,[sp,#4]
;;;321    
;;;322                    /* Set Auto clear */
;;;323                    u8ACLR_write = (uint8_t) eAutoClear;
000518  e58db000          STR      r11,[sp,#0]
00051c  ea000000          B        |L1.1316|
                  |L1.1312|
;;;324                }
;;;325            }
;;;326            else
;;;327            {
;;;328                /* Invalid source */
;;;329                i32Res = C_FAILED;
000520  e3e08000          MVN      r8,#0
                  |L1.1316|
;;;330            }
;;;331        }
;;;332    
;;;333        if( C_SUCCESS == i32Res )
000524  e3580000          CMP      r8,#0
000528  1a00000b          BNE      |L1.1372|
;;;334        {
;;;335    
;;;336    #if defined(__GHS__) || defined(__ghs__)
;;;337    
;;;338      /* disable MISRA 2004 Rule 10.5 because for satisfaction this rule violation of rule 10.3 is required */
;;;339      #pragma ghs nowarning 1849
;;;340    
;;;341    #endif
;;;342            u8Value_write =  (u8ACLR_write << IR_ACRL_SHIFT) |(u8EIM_write<< IR_EIMR_SHIFT) | (u8DRS_write << IR_DRS_SHIFT) | (u8EXT_write);
00052c  e59d0000          LDR      r0,[sp,#0]
000530  e1a00380          LSL      r0,r0,#7
000534  e180128a          ORR      r1,r0,r10,LSL #5
000538  e59d0008          LDR      r0,[sp,#8]
00053c  e1811200          ORR      r1,r1,r0,LSL #4
000540  e59d0004          LDR      r0,[sp,#4]
000544  e1800001          ORR      r0,r0,r1
000548  e20000ff          AND      r0,r0,#0xff
00054c  e58d000c          STR      r0,[sp,#0xc]
;;;343    
;;;344    #if defined(__GHS__) || defined(__ghs__)
;;;345      #pragma ghs endnowarning
;;;346    #endif /* defined(__GHS__) || defined(__ghs__) */
;;;347    
;;;348            vSetIR_ByIndex(u8SrcIx, u8Value_write);
000550  e59d0010          LDR      r0,[sp,#0x10]
000554  e59d100c          LDR      r1,[sp,#0xc]
000558  ebfffffe          BL       vSetIR_ByIndex
                  |L1.1372|
;;;349        }
;;;350    
;;;351        return i32Res;
00055c  e1a00008          MOV      r0,r8
000560  e28dd014          ADD      sp,sp,#0x14
;;;352    }
000564  e8bd8ff0          POP      {r4-r11,pc}
;;;353    
                          ENDP

                  i32INTC_SetEIM_ByIndex PROC
;;;356    
;;;357    int32_t i32INTC_SetEIM_ByIndex(uint8_t u8SrcIx, intc_eim_e eMode)
000568  e92d4070          PUSH     {r4-r6,lr}
;;;358    {
00056c  e1a04000          MOV      r4,r0
000570  e1a05001          MOV      r5,r1
;;;359        int32_t  i32Res = C_SUCCESS;
000574  e3a06000          MOV      r6,#0
;;;360    
;;;361        /* Check the requested source */
;;;362        if( (u8SrcIx > LAST_SRC_INDEX) || (eMode>INTC_EDGE_RISE) )
000578  e35400b2          CMP      r4,#0xb2
00057c  8a000001          BHI      |L1.1416|
000580  e3550003          CMP      r5,#3
000584  da000001          BLE      |L1.1424|
                  |L1.1416|
;;;363        {
;;;364            /* Invalid source */
;;;365            i32Res = C_FAILED;
000588  e3e06000          MVN      r6,#0
00058c  ea000002          B        |L1.1436|
                  |L1.1424|
;;;366        }
;;;367        else
;;;368        {
;;;369            vSetIR_EIM_ByIndex(u8SrcIx, (uint8_t) eMode);
000590  e1a01005          MOV      r1,r5
000594  e1a00004          MOV      r0,r4
000598  ebfffffe          BL       vSetIR_EIM_ByIndex
                  |L1.1436|
;;;370        }
;;;371    
;;;372        return i32Res;
00059c  e1a00006          MOV      r0,r6
;;;373    }
0005a0  e8bd8070          POP      {r4-r6,pc}
;;;374    
                          ENDP

                  i32INTC_SetDrsByIndex PROC
;;;377    
;;;378    int32_t i32INTC_SetDrsByIndex(uint8_t u8SrcIx, intc_drs_e eDst)
0005a4  e92d4070          PUSH     {r4-r6,lr}
;;;379    {
0005a8  e1a04000          MOV      r4,r0
0005ac  e1a05001          MOV      r5,r1
;;;380        int32_t  i32Res = C_SUCCESS;
0005b0  e3a06000          MOV      r6,#0
;;;381    
;;;382        /* Check the requested source */
;;;383        if( (u8SrcIx > LAST_SRC_INDEX) || (eDst > INTC_TO_DMA) )
0005b4  e35400b2          CMP      r4,#0xb2
0005b8  8a000001          BHI      |L1.1476|
0005bc  e3550001          CMP      r5,#1
0005c0  da000001          BLE      |L1.1484|
                  |L1.1476|
;;;384        {
;;;385            /* Invalid source */
;;;386            i32Res = C_FAILED;
0005c4  e3e06000          MVN      r6,#0
0005c8  ea000002          B        |L1.1496|
                  |L1.1484|
;;;387        }
;;;388        else
;;;389        {
;;;390            vSetIR_DRS_ByIndex(u8SrcIx, (uint8_t) eDst);
0005cc  e1a01005          MOV      r1,r5
0005d0  e1a00004          MOV      r0,r4
0005d4  ebfffffe          BL       vSetIR_DRS_ByIndex
                  |L1.1496|
;;;391        }
;;;392    
;;;393        return i32Res;
0005d8  e1a00006          MOV      r0,r6
;;;394    }
0005dc  e8bd8070          POP      {r4-r6,pc}
;;;395    
                          ENDP

                  i32INTC_SetExtByIndex PROC
;;;398    
;;;399    int32_t i32INTC_SetExtByIndex(uint8_t u8SrcIx, intc_ext_e eLevel)
0005e0  e92d4070          PUSH     {r4-r6,lr}
;;;400    {
0005e4  e1a04000          MOV      r4,r0
0005e8  e1a05001          MOV      r5,r1
;;;401        int32_t  i32Res = C_SUCCESS;
0005ec  e3a06000          MOV      r6,#0
;;;402    
;;;403        /* Check the requested source */
;;;404        if( (u8SrcIx > LAST_SRC_INDEX) || (eLevel > INTC_LEVEL_7) )
0005f0  e35400b2          CMP      r4,#0xb2
0005f4  8a000001          BHI      |L1.1536|
0005f8  e3550007          CMP      r5,#7
0005fc  da000001          BLE      |L1.1544|
                  |L1.1536|
;;;405        {
;;;406            /* Invalid source */
;;;407            i32Res = C_FAILED;
000600  e3e06000          MVN      r6,#0
000604  ea000002          B        |L1.1556|
                  |L1.1544|
;;;408        }
;;;409        else
;;;410        {
;;;411            vSetIR_EXT_ByIndex(u8SrcIx, (uint8_t) eLevel);
000608  e1a01005          MOV      r1,r5
00060c  e1a00004          MOV      r0,r4
000610  ebfffffe          BL       vSetIR_EXT_ByIndex
                  |L1.1556|
;;;412        }
;;;413    
;;;414        return i32Res;
000614  e1a00006          MOV      r0,r6
;;;415    }
000618  e8bd8070          POP      {r4-r6,pc}
;;;416    
                          ENDP

                  i32INTC_SetAclrByIndex PROC
;;;419    
;;;420    int32_t i32INTC_SetAclrByIndex(uint8_t u8SrcIx, intc_aclr_e eAutoClear)
00061c  e92d4070          PUSH     {r4-r6,lr}
;;;421    {
000620  e1a04000          MOV      r4,r0
000624  e1a05001          MOV      r5,r1
;;;422        int32_t  i32Res = C_SUCCESS;
000628  e3a06000          MOV      r6,#0
;;;423    
;;;424        /* Check the requested source */
;;;425        if( (u8SrcIx > LAST_SRC_INDEX) || (eAutoClear > INTC_AUTO_CLEAR_ENABLE) )
00062c  e35400b2          CMP      r4,#0xb2
000630  8a000001          BHI      |L1.1596|
000634  e3550001          CMP      r5,#1
000638  da000001          BLE      |L1.1604|
                  |L1.1596|
;;;426        {
;;;427            /* Invalid source */
;;;428            i32Res = C_FAILED;
00063c  e3e06000          MVN      r6,#0
000640  ea000002          B        |L1.1616|
                  |L1.1604|
;;;429        }
;;;430        else
;;;431        {
;;;432            vSetIR_ACLR_ByIndex(u8SrcIx, (uint8_t) eAutoClear);
000644  e1a01005          MOV      r1,r5
000648  e1a00004          MOV      r0,r4
00064c  ebfffffe          BL       vSetIR_ACLR_ByIndex
                  |L1.1616|
;;;433        }
;;;434    
;;;435        return i32Res;
000650  e1a00006          MOV      r0,r6
;;;436    }
000654  e8bd8070          POP      {r4-r6,pc}
;;;437    
                          ENDP

                  i32INTC_SetVectBaseAddr PROC
;;;440    
;;;441    int32_t i32INTC_SetVectBaseAddr(uint32_t u32Addr)
000658  e1a01000          MOV      r1,r0
;;;442    {
;;;443        int32_t i32Res = C_SUCCESS;
00065c  e3a00000          MOV      r0,#0
000660  e1a02001          MOV      r2,r1
;;;444    
;;;445        /* Check if address is aligned */
;;;446        if( 0U == (u32Addr & INT_VECTOR_MASK) )
000664  e7df251f          BFC      r2,#10,#22
000668  e3520000          CMP      r2,#0
00066c  1a000002          BNE      |L1.1660|
;;;447        {
;;;448            vSetIVR( (uint32_t)u32Addr );
000670  e59f244c          LDR      r2,|L1.2756|
000674  e58210c0          STR      r1,[r2,#0xc0]
000678  ea000000          B        |L1.1664|
                  |L1.1660|
;;;449        }
;;;450        else
;;;451        {
;;;452            i32Res = C_FAILED;
00067c  e3e00000          MVN      r0,#0
                  |L1.1664|
;;;453        }
;;;454    
;;;455        return i32Res;
;;;456    }
000680  e12fff1e          BX       lr
;;;457    
                          ENDP

                  u32INTC_GetVectAddr PROC
;;;460    
;;;461    uint32_t u32INTC_GetVectAddr(void)
000684  e59f0438          LDR      r0,|L1.2756|
;;;462    {
;;;463        return u32GetIVR();
000688  e59000c0          LDR      r0,[r0,#0xc0]
;;;464    }
00068c  e12fff1e          BX       lr
;;;465    
                          ENDP

                  vINTC_ModifyIrqLevel PROC
;;;468    
;;;469    void vINTC_ModifyIrqLevel(intc_ilev_e eMode, intc_ext_e eLevel)
000690  e92d4010          PUSH     {r4,lr}
;;;470    {
;;;471        uint32_t u32ILEV;
;;;472    
;;;473        if(eMode == INTC_RESTORE_OLD)
000694  e3500000          CMP      r0,#0
000698  1a000003          BNE      |L1.1708|
;;;474        {
;;;475            /* To restore the old level we have to write 0 to the ILEV register */
;;;476            vSetILEV(0U);
00069c  e3a03000          MOV      r3,#0
0006a0  e59f441c          LDR      r4,|L1.2756|
0006a4  e58430c8          STR      r3,[r4,#0xc8]
0006a8  ea000004          B        |L1.1728|
                  |L1.1708|
;;;477        }
;;;478        else
;;;479        {
;;;480            /* Adjust the MLEV bit */
;;;481            u32ILEV = ((uint32_t)eMode << 31);
0006ac  e1a02f80          LSL      r2,r0,#31
;;;482            /* Update CMASK */
;;;483            u32ILEV = u32ILEV | ((uint32_t)eLevel & 0x07U);
0006b0  e2013007          AND      r3,r1,#7
0006b4  e1822003          ORR      r2,r2,r3
;;;484            vSetILEV(u32ILEV);
0006b8  e59f3404          LDR      r3,|L1.2756|
0006bc  e58320c8          STR      r2,[r3,#0xc8]
                  |L1.1728|
;;;485        }
;;;486    }
0006c0  e8bd8010          POP      {r4,pc}
;;;487    
                          ENDP

                  i32INTC_ClearIrq PROC
;;;490    
;;;491    int32_t i32INTC_ClearIrq(uint32_t u32Voffset)
0006c4  e92d4070          PUSH     {r4-r6,lr}
;;;492    {
0006c8  e1a04000          MOV      r4,r0
;;;493        int32_t i32Res = C_SUCCESS;
0006cc  e3a05000          MOV      r5,#0
0006d0  e1a00004          MOV      r0,r4
;;;494    
;;;495        /* Check if the offset is in range */
;;;496        if( (u32Voffset & INT_VECTOR_MASK) <= INTC_GET_VOFST(INTC_WAKEUP) )
0006d4  e7df051f          BFC      r0,#10,#22
0006d8  e3500fb2          CMP      r0,#0x2c8
0006dc  8a000005          BHI      |L1.1784|
0006e0  e1a00004          MOV      r0,r4
;;;497        {
;;;498            vSetICLR((uint32_t) (u32Voffset & INT_VECTOR_MASK));
0006e4  e7df051f          BFC      r0,#10,#22
0006e8  e59f13d4          LDR      r1,|L1.2756|
0006ec  e58100c4          STR      r0,[r1,#0xc4]
;;;499            /*
;;;500             *  Ensure that the interrupt is really cleared before
;;;501             *  returning. ARM data barrier replaces the MIPS "sync"
;;;502             */
;;;503            __DSB();
0006f0  ebfffffe          BL       __DSB
0006f4  ea000000          B        |L1.1788|
                  |L1.1784|
;;;504        }
;;;505        else
;;;506        {
;;;507            /* Offset out of range */
;;;508            i32Res = C_FAILED;
0006f8  e3e05000          MVN      r5,#0
                  |L1.1788|
;;;509        }
;;;510    
;;;511        return i32Res;
0006fc  e1a00005          MOV      r0,r5
;;;512    }
000700  e8bd8070          POP      {r4-r6,pc}
;;;513    
                          ENDP

                  vINTC_ClearDmaReq PROC
;;;516    
;;;517    void vINTC_ClearDmaReq(intc_irst_e eReqCh)
000704  e3500004          CMP      r0,#4
;;;518    {
;;;519        /* Clear the requested channel */
;;;520        switch ( eReqCh )
000708  0a000032          BEQ      |L1.2008|
00070c  ca000008          BGT      |L1.1844|
000710  e3500000          CMP      r0,#0
000714  0a00000f          BEQ      |L1.1880|
000718  e3500001          CMP      r0,#1
00071c  0a000015          BEQ      |L1.1912|
000720  e3500002          CMP      r0,#2
000724  0a00001b          BEQ      |L1.1944|
000728  e3500003          CMP      r0,#3
00072c  1a000049          BNE      |L1.2136|
000730  ea000020          B        |L1.1976|
                  |L1.1844|
000734  e3500005          CMP      r0,#5
000738  0a00002e          BEQ      |L1.2040|
00073c  e3500006          CMP      r0,#6
000740  0a000034          BEQ      |L1.2072|
000744  e3500007          CMP      r0,#7
000748  0a00003a          BEQ      |L1.2104|
00074c  e35000ff          CMP      r0,#0xff
000750  1a000040          BNE      |L1.2136|
000754  ea000041          B        |L1.2144|
                  |L1.1880|
;;;521        {
;;;522            case INTC_DMA_CH0:
000758  e320f000          NOP      
;;;523                vClrIRST_RDR0();
00075c  e59f1360          LDR      r1,|L1.2756|
000760  e5d110d0          LDRB     r1,[r1,#0xd0]
000764  e3c11001          BIC      r1,r1,#1
000768  e2811001          ADD      r1,r1,#1
00076c  e59f2350          LDR      r2,|L1.2756|
000770  e5c210d0          STRB     r1,[r2,#0xd0]
;;;524                break;
000774  ea00003d          B        |L1.2160|
                  |L1.1912|
;;;525    
;;;526            case INTC_DMA_CH1:
000778  e320f000          NOP      
;;;527                vClrIRST_RDR1();
00077c  e59f1340          LDR      r1,|L1.2756|
000780  e5d110d0          LDRB     r1,[r1,#0xd0]
000784  e3c11002          BIC      r1,r1,#2
000788  e2811002          ADD      r1,r1,#2
00078c  e59f2330          LDR      r2,|L1.2756|
000790  e5c210d0          STRB     r1,[r2,#0xd0]
;;;528                break;
000794  ea000035          B        |L1.2160|
                  |L1.1944|
;;;529    
;;;530            case INTC_DMA_CH2:
000798  e320f000          NOP      
;;;531                vClrIRST_RDR2();
00079c  e59f1320          LDR      r1,|L1.2756|
0007a0  e5d110d0          LDRB     r1,[r1,#0xd0]
0007a4  e3c11004          BIC      r1,r1,#4
0007a8  e2811004          ADD      r1,r1,#4
0007ac  e59f2310          LDR      r2,|L1.2756|
0007b0  e5c210d0          STRB     r1,[r2,#0xd0]
;;;532                break;
0007b4  ea00002d          B        |L1.2160|
                  |L1.1976|
;;;533    
;;;534            case INTC_DMA_CH3:
0007b8  e320f000          NOP      
;;;535                vClrIRST_RDR3();
0007bc  e59f1300          LDR      r1,|L1.2756|
0007c0  e5d110d0          LDRB     r1,[r1,#0xd0]
0007c4  e3c11008          BIC      r1,r1,#8
0007c8  e2811008          ADD      r1,r1,#8
0007cc  e59f22f0          LDR      r2,|L1.2756|
0007d0  e5c210d0          STRB     r1,[r2,#0xd0]
;;;536                break;
0007d4  ea000025          B        |L1.2160|
                  |L1.2008|
;;;537    
;;;538            case INTC_DMA_CH4:
0007d8  e320f000          NOP      
;;;539                vClrIRST_RDR4();
0007dc  e59f12e0          LDR      r1,|L1.2756|
0007e0  e5d110d0          LDRB     r1,[r1,#0xd0]
0007e4  e3c11010          BIC      r1,r1,#0x10
0007e8  e2811010          ADD      r1,r1,#0x10
0007ec  e59f22d0          LDR      r2,|L1.2756|
0007f0  e5c210d0          STRB     r1,[r2,#0xd0]
;;;540                break;
0007f4  ea00001d          B        |L1.2160|
                  |L1.2040|
;;;541    
;;;542            case INTC_DMA_CH5:
0007f8  e320f000          NOP      
;;;543                vClrIRST_RDR5();
0007fc  e59f12c0          LDR      r1,|L1.2756|
000800  e5d110d0          LDRB     r1,[r1,#0xd0]
000804  e3c11020          BIC      r1,r1,#0x20
000808  e2811020          ADD      r1,r1,#0x20
00080c  e59f22b0          LDR      r2,|L1.2756|
000810  e5c210d0          STRB     r1,[r2,#0xd0]
;;;544                break;
000814  ea000015          B        |L1.2160|
                  |L1.2072|
;;;545    
;;;546            case INTC_DMA_CH6:
000818  e320f000          NOP      
;;;547                vClrIRST_RDR6();
00081c  e59f12a0          LDR      r1,|L1.2756|
000820  e5d110d0          LDRB     r1,[r1,#0xd0]
000824  e3c11040          BIC      r1,r1,#0x40
000828  e2811040          ADD      r1,r1,#0x40
00082c  e59f2290          LDR      r2,|L1.2756|
000830  e5c210d0          STRB     r1,[r2,#0xd0]
;;;548                break;
000834  ea00000d          B        |L1.2160|
                  |L1.2104|
;;;549    
;;;550            case INTC_DMA_CH7:
000838  e320f000          NOP      
;;;551                vClrIRST_RDR7();
00083c  e59f1280          LDR      r1,|L1.2756|
000840  e5d110d0          LDRB     r1,[r1,#0xd0]
000844  e3c11080          BIC      r1,r1,#0x80
000848  e2811080          ADD      r1,r1,#0x80
00084c  e59f2270          LDR      r2,|L1.2756|
000850  e5c210d0          STRB     r1,[r2,#0xd0]
;;;552                break;
000854  ea000005          B        |L1.2160|
                  |L1.2136|
;;;553    
;;;554            case INTC_DMA_CH_ALL:
000858  e320f000          NOP      
00085c  e320f000          NOP      
                  |L1.2144|
;;;555    
;;;556            default:
;;;557                /* Clear all requests */
;;;558                vSetIRST(INTC_DMA_CH_ALL);
000860  e3a010ff          MOV      r1,#0xff
000864  e59f2258          LDR      r2,|L1.2756|
000868  e5c210d0          STRB     r1,[r2,#0xd0]
;;;559                break;
00086c  e320f000          NOP      
                  |L1.2160|
000870  e320f000          NOP                            ;524
;;;560        }
;;;561    }
000874  e12fff1e          BX       lr
;;;562    
                          ENDP

                  vINTC_BlockVectUpdate PROC
;;;565    
;;;566    void vINTC_BlockVectUpdate(void)
000878  e3a00000          MOV      r0,#0
;;;567    {
;;;568        /*
;;;569         *  Write access to IBLK prevents IVR from being updated
;;;570         *  until a write access to ICLR is performed
;;;571         */
;;;572        vSetIBLK(0);
00087c  e59f1240          LDR      r1,|L1.2756|
000880  e5c100cc          STRB     r0,[r1,#0xcc]
;;;573    }
000884  e12fff1e          BX       lr
;;;574    
                          ENDP

                  u8INTC_GetIrqLevel PROC
;;;577    
;;;578    uint8_t u8INTC_GetIrqLevel(intc_level_e eLevel)
000888  e1a02000          MOV      r2,r0
;;;579    {
;;;580        uint32_t u32IrqLevel;
;;;581    
;;;582        switch( eLevel )
00088c  e3520007          CMP      r2,#7
000890  308ff102          ADDCC    pc,pc,r2,LSL #2
000894  ea000024          B        |L1.2348|
000898  ea000025          B        |L1.2356|
00089c  ea000004          B        |L1.2228|
0008a0  ea000008          B        |L1.2248|
0008a4  ea00000c          B        |L1.2268|
0008a8  ea000010          B        |L1.2288|
0008ac  ea000014          B        |L1.2308|
0008b0  ea000018          B        |L1.2328|
                  |L1.2228|
;;;583        {
;;;584            case INTC_PREV0:
0008b4  e320f000          NOP      
;;;585                u32IrqLevel = biGetILEV_PMASK0();
0008b8  e59f0204          LDR      r0,|L1.2756|
0008bc  e59000c8          LDR      r0,[r0,#0xc8]
0008c0  e7e21250          UBFX     r1,r0,#4,#3
;;;586                break;
0008c4  ea00001e          B        |L1.2372|
                  |L1.2248|
;;;587    
;;;588            case INTC_PREV1:
0008c8  e320f000          NOP      
;;;589                u32IrqLevel = biGetILEV_PMASK1();
0008cc  e59f01f0          LDR      r0,|L1.2756|
0008d0  e59000c8          LDR      r0,[r0,#0xc8]
0008d4  e7e21450          UBFX     r1,r0,#8,#3
;;;590                break;
0008d8  ea000019          B        |L1.2372|
                  |L1.2268|
;;;591    
;;;592            case INTC_PREV2:
0008dc  e320f000          NOP      
;;;593                u32IrqLevel = biGetILEV_PMASK2();
0008e0  e59f01dc          LDR      r0,|L1.2756|
0008e4  e59000c8          LDR      r0,[r0,#0xc8]
0008e8  e7e21650          UBFX     r1,r0,#12,#3
;;;594                break;
0008ec  ea000014          B        |L1.2372|
                  |L1.2288|
;;;595    
;;;596            case INTC_PREV3:
0008f0  e320f000          NOP      
;;;597                u32IrqLevel = biGetILEV_PMASK3();
0008f4  e59f01c8          LDR      r0,|L1.2756|
0008f8  e59000c8          LDR      r0,[r0,#0xc8]
0008fc  e7e21850          UBFX     r1,r0,#16,#3
;;;598                break;
000900  ea00000f          B        |L1.2372|
                  |L1.2308|
;;;599    
;;;600            case INTC_PREV4:
000904  e320f000          NOP      
;;;601                u32IrqLevel = biGetILEV_PMASK4();
000908  e59f01b4          LDR      r0,|L1.2756|
00090c  e59000c8          LDR      r0,[r0,#0xc8]
000910  e7e21a50          UBFX     r1,r0,#20,#3
;;;602                break;
000914  ea00000a          B        |L1.2372|
                  |L1.2328|
;;;603    
;;;604            case INTC_PREV5:
000918  e320f000          NOP      
;;;605                u32IrqLevel = biGetILEV_PMASK5();
00091c  e59f01a0          LDR      r0,|L1.2756|
000920  e59000c8          LDR      r0,[r0,#0xc8]
000924  e7e21c50          UBFX     r1,r0,#24,#3
;;;606                break;
000928  ea000005          B        |L1.2372|
                  |L1.2348|
;;;607    
;;;608            case INTC_CURRENT:
00092c  e320f000          NOP      
000930  e320f000          NOP      
                  |L1.2356|
;;;609    
;;;610            default:
;;;611                /* Current IRQ Level */
;;;612                u32IrqLevel = biGetILEV_CMASK();
000934  e59f0188          LDR      r0,|L1.2756|
000938  e59000c8          LDR      r0,[r0,#0xc8]
00093c  e2001007          AND      r1,r0,#7
;;;613                break;
000940  e320f000          NOP      
                  |L1.2372|
000944  e320f000          NOP                            ;586
;;;614        }
;;;615    
;;;616        return (uint8_t)u32IrqLevel;
000948  e20100ff          AND      r0,r1,#0xff
;;;617    }
00094c  e12fff1e          BX       lr
;;;618    
                          ENDP

                  u32INTC_GetIrqStatus PROC
;;;621    
;;;622    uint32_t u32INTC_GetIrqStatus(intc_src_e eSrc)
000950  e92d4070          PUSH     {r4-r6,lr}
;;;623    {
000954  e1a03000          MOV      r3,r0
;;;624        uint32_t u32IntNumber, u32IRREST, u32BitNumber, u32Ret;
;;;625    
;;;626        /* Get the vector offset of the interrupt source */
;;;627        u32IntNumber = INTC_GET_VOFST(eSrc);
000958  e7e91453          UBFX     r1,r3,#8,#10
;;;628    
;;;629        /* Calculate the interrupt number [vector offset divided by 4] */
;;;630        u32IntNumber = u32IntNumber >> 2;
00095c  e1a01121          LSR      r1,r1,#2
;;;631    
;;;632        /* Find out the status register [IRREST] to be used (divide by 32) */
;;;633        u32IRREST = (u32IntNumber >> 5) + 1;
000960  e3a05001          MOV      r5,#1
000964  e08522a1          ADD      r2,r5,r1,LSR #5
;;;634    
;;;635        /* Calculate the corresponding bit number */
;;;636        u32BitNumber = u32IntNumber - (32 * (u32IRREST - 1));
000968  e2425001          SUB      r5,r2,#1
00096c  e3a06020          MOV      r6,#0x20
000970  e0641596          MLS      r4,r6,r5,r1
;;;637    
;;;638        /* Retrieve the entire status register */
;;;639        switch( u32IRREST )
000974  e3520007          CMP      r2,#7
000978  308ff102          ADDCC    pc,pc,r2,LSL #2
00097c  ea00001e          B        |L1.2556|
000980  ea00001d          B        |L1.2556|
000984  ea000004          B        |L1.2460|
000988  ea000007          B        |L1.2476|
00098c  ea00000a          B        |L1.2492|
000990  ea00000d          B        |L1.2508|
000994  ea000010          B        |L1.2524|
000998  ea000013          B        |L1.2540|
                  |L1.2460|
;;;640        {
;;;641            case 1:
00099c  e320f000          NOP      
;;;642                u32Ret = u32GetIRREST0();
0009a0  e59f511c          LDR      r5,|L1.2756|
0009a4  e59500d4          LDR      r0,[r5,#0xd4]
;;;643                break;
0009a8  ea000016          B        |L1.2568|
                  |L1.2476|
;;;644    
;;;645            case 2:
0009ac  e320f000          NOP      
;;;646                u32Ret = u32GetIRREST1();
0009b0  e59f510c          LDR      r5,|L1.2756|
0009b4  e59500d8          LDR      r0,[r5,#0xd8]
;;;647                break;
0009b8  ea000012          B        |L1.2568|
                  |L1.2492|
;;;648    
;;;649            case 3:
0009bc  e320f000          NOP      
;;;650                u32Ret = u32GetIRREST2();
0009c0  e59f50fc          LDR      r5,|L1.2756|
0009c4  e59500dc          LDR      r0,[r5,#0xdc]
;;;651                break;
0009c8  ea00000e          B        |L1.2568|
                  |L1.2508|
;;;652    
;;;653            case 4:
0009cc  e320f000          NOP      
;;;654                u32Ret = u32GetIRREST3();
0009d0  e59f50ec          LDR      r5,|L1.2756|
0009d4  e59500e0          LDR      r0,[r5,#0xe0]
;;;655                break;
0009d8  ea00000a          B        |L1.2568|
                  |L1.2524|
;;;656    
;;;657            case 5:
0009dc  e320f000          NOP      
;;;658                u32Ret = u32GetIRREST4();
0009e0  e59f50dc          LDR      r5,|L1.2756|
0009e4  e59500e4          LDR      r0,[r5,#0xe4]
;;;659                break;
0009e8  ea000006          B        |L1.2568|
                  |L1.2540|
;;;660    
;;;661            case 6:
0009ec  e320f000          NOP      
;;;662                u32Ret = u32GetIRREST5();
0009f0  e59f50cc          LDR      r5,|L1.2756|
0009f4  e59500e8          LDR      r0,[r5,#0xe8]
;;;663                break;
0009f8  ea000002          B        |L1.2568|
                  |L1.2556|
;;;664    
;;;665            /* On not existing source simply return not pending */
;;;666            default:
0009fc  e320f000          NOP      
;;;667                u32Ret = 0;
000a00  e3a00000          MOV      r0,#0
;;;668                break;
000a04  e320f000          NOP      
                  |L1.2568|
000a08  e320f000          NOP                            ;643
;;;669        }
;;;670    
;;;671        /* mask out the corresponding bit */
;;;672        u32Ret = u32Ret << ( 31 - u32BitNumber);
000a0c  e264501f          RSB      r5,r4,#0x1f
000a10  e1a00510          LSL      r0,r0,r5
;;;673        u32Ret = u32Ret >> 31;
000a14  e1a00fa0          LSR      r0,r0,#31
;;;674    
;;;675        return u32Ret;
;;;676    }
000a18  e8bd8070          POP      {r4-r6,pc}
;;;677    
                          ENDP

                  vINTC_EnableInterrupts PROC
;;;680    
;;;681    void vINTC_EnableInterrupts(intc_enable_e eEnable)
000a1c  e59f10a0          LDR      r1,|L1.2756|
;;;682    {
;;;683        vSetIWPERR_IWPNTEN(eEnable);
000a20  e1d11ebc          LDRH     r1,[r1,#0xec]
000a24  e7c01010          BFI      r1,r0,#0,#1
000a28  e59f2094          LDR      r2,|L1.2756|
000a2c  e1c21ebc          STRH     r1,[r2,#0xec]
;;;684    }
000a30  e12fff1e          BX       lr
;;;685    
                          ENDP

                  eINTC_GetEnabled PROC
;;;688    
;;;689    intc_enable_e eINTC_GetEnabled( void )
000a34  e59f1088          LDR      r1,|L1.2756|
;;;690    {
;;;691        intc_enable_e eEnable;
;;;692    
;;;693        if (0 < biGetIWPERR_IWPNTEN())
000a38  e1d11ebc          LDRH     r1,[r1,#0xec]
000a3c  e2011001          AND      r1,r1,#1
000a40  e3510000          CMP      r1,#0
000a44  da000001          BLE      |L1.2640|
;;;694        {
;;;695            eEnable = INTC_ENABLE;
000a48  e3a00001          MOV      r0,#1
000a4c  ea000000          B        |L1.2644|
                  |L1.2640|
;;;696        }
;;;697        else
;;;698        {
;;;699            eEnable = INTC_DISABLE;
000a50  e3a00000          MOV      r0,#0
                  |L1.2644|
;;;700        }
;;;701        return eEnable;
;;;702    
;;;703    }
000a54  e12fff1e          BX       lr
;;;704    
                          ENDP

                  vINTC_ClearInterrupt PROC
;;;707    
;;;708    void vINTC_ClearInterrupt(void)
000a58  e59f0064          LDR      r0,|L1.2756|
;;;709    {
;;;710        vSetIWPERR_IWPINTCLR(0x1);
000a5c  e1d00ebc          LDRH     r0,[r0,#0xec]
000a60  e3c00c01          BIC      r0,r0,#0x100
000a64  e2800c01          ADD      r0,r0,#0x100
000a68  e59f1054          LDR      r1,|L1.2756|
000a6c  e1c10ebc          STRH     r0,[r1,#0xec]
;;;711    }
000a70  e12fff1e          BX       lr
;;;712    
                          ENDP

                  vINTC_SetISRStartAddress PROC
;;;715    
;;;716    void vINTC_SetISRStartAddress(intc_src_e eSrc, uint32_t u32Address)
000a74  e1a02c00          LSL      r2,r0,#24
;;;717    {
;;;718        vSetISRADDR(INTC_GET_ROFST(eSrc), u32Address);
000a78  e1a02b22          LSR      r2,r2,#22
000a7c  e24225ff          SUB      r2,r2,#0x3fc00000
000a80  e24229be          SUB      r2,r2,#0x2f8000
000a84  e5821200          STR      r1,[r2,#0x200]
;;;719    }
000a88  e12fff1e          BX       lr
;;;720    
                          ENDP

                  u32INTC_GetISRStartAddress PROC
;;;723    
;;;724    uint32_t u32INTC_GetISRStartAddress(intc_src_e eSrc)
000a8c  e1a01000          MOV      r1,r0
;;;725    {
;;;726        return u32GetISRADDR(INTC_GET_ROFST(eSrc));
000a90  e1a00c01          LSL      r0,r1,#24
000a94  e1a00b20          LSR      r0,r0,#22
000a98  e24005ff          SUB      r0,r0,#0x3fc00000
000a9c  e24009be          SUB      r0,r0,#0x2f8000
000aa0  e5900200          LDR      r0,[r0,#0x200]
;;;727    }
000aa4  e12fff1e          BX       lr
;;;728    
                          ENDP

                  |L1.2728|
                          DCD      au8LLDD_INTC_C_REVISION
                  |L1.2732|
                          DCD      au8LLDD_INTC_C_TAG
                  |L1.2736|
                          DCD      au8LLDD_INTC_H_REVISION
                  |L1.2740|
                          DCD      au8LLDD_INTC_H_TAG
                  |L1.2744|
                          DCD      au8LLDD_INTC_IO_H_REVISION
                  |L1.2748|
                          DCD      au8LLDD_INTC_IO_H_TAG
                  |L1.2752|
                          DCD      ||.constdata||
                  |L1.2756|
                          DCD      0xc0108000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0xffffff00
                          DCD      0xffff00ff
                          DCD      0xff00ffff
                          DCD      0x00ffffff

                          AREA ||.data||, DATA, ALIGN=0

                  au8LLDD_INTC_C_REVISION
000000  24526576          DCB      0x24,0x52,0x65,0x76
000004  6973696f          DCB      0x69,0x73,0x69,0x6f
000008  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
00000c  2e313820          DCB      0x2e,0x31,0x38,0x20
000010  2400              DCB      0x24,0x00
                  au8LLDD_INTC_C_TAG
000012  244e              DCB      0x24,0x4e
000014  616d653a          DCB      0x61,0x6d,0x65,0x3a
000018  204c4c44          DCB      0x20,0x4c,0x4c,0x44
00001c  445f315f          DCB      0x44,0x5f,0x31,0x5f
000020  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_INTC_H_REVISION
000024  24526576          DCB      0x24,0x52,0x65,0x76
000028  6973696f          DCB      0x69,0x73,0x69,0x6f
00002c  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000030  2e313220          DCB      0x2e,0x31,0x32,0x20
000034  2400              DCB      0x24,0x00
                  au8LLDD_INTC_H_TAG
000036  244e              DCB      0x24,0x4e
000038  616d653a          DCB      0x61,0x6d,0x65,0x3a
00003c  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000040  445f315f          DCB      0x44,0x5f,0x31,0x5f
000044  36202400          DCB      0x36,0x20,0x24,0x00
                  au8LLDD_INTC_IO_H_REVISION
000048  24526576          DCB      0x24,0x52,0x65,0x76
00004c  6973696f          DCB      0x69,0x73,0x69,0x6f
000050  6e3a2031          DCB      0x6e,0x3a,0x20,0x31
000054  2e313220          DCB      0x2e,0x31,0x32,0x20
000058  2400              DCB      0x24,0x00
                  au8LLDD_INTC_IO_H_TAG
00005a  244e              DCB      0x24,0x4e
00005c  616d653a          DCB      0x61,0x6d,0x65,0x3a
000060  204c4c44          DCB      0x20,0x4c,0x4c,0x44
000064  445f315f          DCB      0x44,0x5f,0x31,0x5f
000068  36202400          DCB      0x36,0x20,0x24,0x00
