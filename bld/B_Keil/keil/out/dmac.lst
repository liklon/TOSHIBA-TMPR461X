L 1 "..\..\..\..\lldd\src\dmac.c"
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : DMAC low level driver
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : DMAC
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.16 $
N*   DATE        : $Date: 2015/05/04 09:07:15 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "dmac_io.h"                   /* DMAC registers, bits and access macros defintion */
L 1 "..\..\..\..\lldd\hdr\dmac_io.h" 1
N
N/*##########################################################################    
N/  AUTOMATICALLY GENERATED FROM A REG_XML-FILE 
N/  Module                       : DMAC 
N/  Date of creation (y-m-d:time): 2014-12-18+01:00  :  11:47:29.455+01:00
N/  Excel2XML Tool ver.          : XLS2XML Converter 2.6.2
N/  Stylesheet  ver              : $Revision: 1.11 $ 
N/  Excel Sheet ver.             : vv1.2
N/  Excel Sheet date             : 2014-Sep-12
N/  Excel Sheet author           : ZUL
N/##########################################################################*/
N
N/****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH,
N*   European LSI Design and Engineering Centre (ELDEC)
N*****************************************************************************
N*   DESCRIPTION :
N*****************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      :
N*   LIBRARIES   :
N*****************************************************************************
N*   VERSION     : $Revision: 1.11 $
N*   DATE        : $Date: 2015/05/04 09:07:16 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary and Confidential
N*****************************************************************************/
N#ifndef DMACIO_H
N#define DMACIO_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N/* Following include file(s) needed for proper operation: */
N#include "captypes.h"   /* Core specific primitive type definitions */
L 1 "..\..\..\..\common\inc\captypes.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : Standard core definitions
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : Capricorn standard C types
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.6 $
N*   DATE        : $Date: 2015/05/04 09:07:19 $
N*   TAG         : $Name:  $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef CAPTYPES_H
N#define CAPTYPES_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N
N/*********************************************/
N
N
N/**********************************************
N*                Definitions                  *
N**********************************************/
N/* Simple error codes */
N#define C_SUCCESS                           (0)
N#define C_FAILED                            (-1)
N
N/* Simple boolean value */
N#define C_FALSE                             (0)
N#define C_TRUE                              (1)
N
N/* NULL pointer definition */
N#define C_NULL                              ((void*)0)
N
N/* NULL pointer definition */
N#define TYPES_NULL_PTR   ((void *)0UL)
N
N/*********************************************/
N
N
N/**********************************************
N*            Primitive data types             *
N**********************************************/
N
N/*
N *  MISRA-C & ELDEC MPU/MCU software coding
N *  guideline compliant type definitions
N */
Ntypedef signed char int8_t;                 /* 1 byte,  prefix i8 */
Ntypedef signed short int16_t;               /* 2 bytes, prefix i16 */
Ntypedef signed int int32_t;                 /* 4 bytes, prefix i32 */
Ntypedef signed long long int64_t;           /* 8 bytes, prefix i64 */
Ntypedef unsigned char uint8_t;              /* 1 byte,  prefix u8 */
Ntypedef unsigned short uint16_t;            /* 2 bytes, prefix u16 */
Ntypedef unsigned int uint32_t;              /* 4 bytes, prefix u32 */
Ntypedef unsigned long long uint64_t;        /* 8 bytes, prefix u64 */
Ntypedef int bool_t;                         /* 4 bytes, prefix bo */
Ntypedef float float32_t;                    /* 4 bytes, prefix f32 */
Ntypedef double float64_t;                   /* 8 bytes, prefix f64 */
N
N/*********************************************/
N/*
N Definition for Cortex R4 32-bit memory/registers */
N#define TYPES_REG32 (volatile int32_t*)
N/*
N Definition for Cortex R4 16-bit memory/registers */
N#define TYPES_REG16 (volatile uint16_t*)
N/*
N Definition for Cortex R4 8-bit memory/registers */
N#define TYPES_REG8 (volatile uint8_t*)
N
N
N#endif /* CAPTYPES_H */
N
N/***************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 38 "..\..\..\..\lldd\hdr\dmac_io.h" 2
N
N
N/*********************************************
N*         Disable Misra Warnings/Rules       *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs nowarning 1840 /* Rule  5.7 [A] : 	 [A] No reuse of identifiers */
N#endif
N
N
N/*********************************************/
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_DMAC_IO_H_REVISION     "$Revision: 1.11 $"
N#define LLDD_DMAC_IO_H_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N
N
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACIntStatus                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C000                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACIntStatus_REG__       0xC010C000U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   IntStatus	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACIntStatus_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACIntStatus_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACIntStatus()     ((volatile DMACIntStatus_bit_view_st *)\
N(DMACIntStatus_REG__ ))
X#define pst_bitDMACIntStatus()     ((volatile DMACIntStatus_bit_view_st *)(DMACIntStatus_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACIntStatus()     ((volatile u32DMACIntStatus_word_view *)\
N(DMACIntStatus_REG__ ))
X#define pu32DMACIntStatus()     ((volatile u32DMACIntStatus_word_view *)(DMACIntStatus_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACIntStatus_IntStatus() (pst_bitDMACIntStatus() -> IntStatus)            
N            
N           
N/* Word access */
N
N#define u32GetDMACIntStatus()  (*pu32DMACIntStatus() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACIntTCStatus                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C004                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACIntTCStatus_REG__       0xC010C004U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   IntTCStatus	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACIntTCStatus_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACIntTCStatus_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACIntTCStatus()     ((volatile DMACIntTCStatus_bit_view_st *)\
N(DMACIntTCStatus_REG__ ))
X#define pst_bitDMACIntTCStatus()     ((volatile DMACIntTCStatus_bit_view_st *)(DMACIntTCStatus_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACIntTCStatus()     ((volatile u32DMACIntTCStatus_word_view *)\
N(DMACIntTCStatus_REG__ ))
X#define pu32DMACIntTCStatus()     ((volatile u32DMACIntTCStatus_word_view *)(DMACIntTCStatus_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACIntTCStatus_IntTCStatus() (pst_bitDMACIntTCStatus() -> IntTCStatus)            
N            
N            
N/* Word access */
N
N#define u32GetDMACIntTCStatus()  (*pu32DMACIntTCStatus() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACIntTCClear                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C008                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACIntTCClear_REG__       0xC010C008U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   IntTCClear	:8; 	 /* 0..7  bit(s) W */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) W */                    
N} DMACIntTCClear_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACIntTCClear_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACIntTCClear()     ((volatile DMACIntTCClear_bit_view_st *)\
N(DMACIntTCClear_REG__ ))
X#define pst_bitDMACIntTCClear()     ((volatile DMACIntTCClear_bit_view_st *)(DMACIntTCClear_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACIntTCClear()     ((volatile u32DMACIntTCClear_word_view *)\
N(DMACIntTCClear_REG__ ))
X#define pu32DMACIntTCClear()     ((volatile u32DMACIntTCClear_word_view *)(DMACIntTCClear_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */ 
N#define vSetDMACIntTCClear_IntTCClear(ParValue) (pst_bitDMACIntTCClear() -> IntTCClear=(ParValue)) 
N            
N/* Word access */
N#define vSetDMACIntTCClear(ParValue)  (*pu32DMACIntTCClear() = (ParValue))
N#define u32GetDMACIntTCClear()  (*pu32DMACIntTCClear() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACIntErrorStatus                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C00C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACIntErrorStatus_REG__       0xC010C00CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   IntErrorStatus	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACIntErrorStatus_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACIntErrorStatus_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACIntErrorStatus()     ((volatile DMACIntErrorStatus_bit_view_st *)\
N(DMACIntErrorStatus_REG__ ))
X#define pst_bitDMACIntErrorStatus()     ((volatile DMACIntErrorStatus_bit_view_st *)(DMACIntErrorStatus_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACIntErrorStatus()     ((volatile u32DMACIntErrorStatus_word_view *)\
N(DMACIntErrorStatus_REG__ ))
X#define pu32DMACIntErrorStatus()     ((volatile u32DMACIntErrorStatus_word_view *)(DMACIntErrorStatus_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACIntErrorStatus_IntErrorStatus() (pst_bitDMACIntErrorStatus() -> IntErrorStatus)            
N            
N/* Word access */
N
N#define u32GetDMACIntErrorStatus()  (*pu32DMACIntErrorStatus() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACIntErrClr                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C010                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACIntErrClr_REG__       0xC010C010U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   IntErrClr	:8; 	 /* 0..7  bit(s) W */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) W */                    
N} DMACIntErrClr_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACIntErrClr_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACIntErrClr()     ((volatile DMACIntErrClr_bit_view_st *)\
N(DMACIntErrClr_REG__ ))
X#define pst_bitDMACIntErrClr()     ((volatile DMACIntErrClr_bit_view_st *)(DMACIntErrClr_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACIntErrClr()     ((volatile u32DMACIntErrClr_word_view *)\
N(DMACIntErrClr_REG__ ))
X#define pu32DMACIntErrClr()     ((volatile u32DMACIntErrClr_word_view *)(DMACIntErrClr_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */ 
N#define vSetDMACIntErrClr_IntErrClr(ParValue) (pst_bitDMACIntErrClr() -> IntErrClr=(ParValue)) 
N            
N/* Word access */
N#define vSetDMACIntErrClr(ParValue)  (*pu32DMACIntErrClr() = (ParValue))
N#define u32GetDMACIntErrClr()  (*pu32DMACIntErrClr() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACRawIntTCStatus                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C014                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACRawIntTCStatus_REG__       0xC010C014U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   RawIntTCStatus	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACRawIntTCStatus_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACRawIntTCStatus_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACRawIntTCStatus()     ((volatile DMACRawIntTCStatus_bit_view_st *)\
N(DMACRawIntTCStatus_REG__ ))
X#define pst_bitDMACRawIntTCStatus()     ((volatile DMACRawIntTCStatus_bit_view_st *)(DMACRawIntTCStatus_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACRawIntTCStatus()     ((volatile u32DMACRawIntTCStatus_word_view *)\
N(DMACRawIntTCStatus_REG__ ))
X#define pu32DMACRawIntTCStatus()     ((volatile u32DMACRawIntTCStatus_word_view *)(DMACRawIntTCStatus_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACRawIntTCStatus_RawIntTCStatus() (pst_bitDMACRawIntTCStatus() -> RawIntTCStatus)            
N            
N/* Word access */
N
N#define u32GetDMACRawIntTCStatus()  (*pu32DMACRawIntTCStatus() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACRawIntErrorStatus                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C018                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACRawIntErrorStatus_REG__       0xC010C018U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   RawIntErrorStatus	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACRawIntErrorStatus_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACRawIntErrorStatus_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACRawIntErrorStatus()     ((volatile DMACRawIntErrorStatus_bit_view_st *)\
N(DMACRawIntErrorStatus_REG__ ))
X#define pst_bitDMACRawIntErrorStatus()     ((volatile DMACRawIntErrorStatus_bit_view_st *)(DMACRawIntErrorStatus_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACRawIntErrorStatus()     ((volatile u32DMACRawIntErrorStatus_word_view *)\
N(DMACRawIntErrorStatus_REG__ ))
X#define pu32DMACRawIntErrorStatus()     ((volatile u32DMACRawIntErrorStatus_word_view *)(DMACRawIntErrorStatus_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACRawIntErrorStatus_RawIntErrorStatus() (pst_bitDMACRawIntErrorStatus() -> RawIntErrorStatus)            
N            
N/* Word access */
N
N#define u32GetDMACRawIntErrorStatus()  (*pu32DMACRawIntErrorStatus() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACEnbldChns                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C01C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACEnbldChns_REG__       0xC010C01CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   EnabledChannels	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACEnbldChns_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACEnbldChns_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACEnbldChns()     ((volatile DMACEnbldChns_bit_view_st *)\
N(DMACEnbldChns_REG__ ))
X#define pst_bitDMACEnbldChns()     ((volatile DMACEnbldChns_bit_view_st *)(DMACEnbldChns_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACEnbldChns()     ((volatile u32DMACEnbldChns_word_view *)\
N(DMACEnbldChns_REG__ ))
X#define pu32DMACEnbldChns()     ((volatile u32DMACEnbldChns_word_view *)(DMACEnbldChns_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACEnbldChns_EnabledChannels() (pst_bitDMACEnbldChns() -> EnabledChannels)            
N            
N/* Word access */
N
N#define u32GetDMACEnbldChns()  (*pu32DMACEnbldChns() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACSoftBReq                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C020                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACSoftBReq_REG__       0xC010C020U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SoftBReq	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACSoftBReq_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACSoftBReq_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACSoftBReq()     ((volatile DMACSoftBReq_bit_view_st *)\
N(DMACSoftBReq_REG__ ))
X#define pst_bitDMACSoftBReq()     ((volatile DMACSoftBReq_bit_view_st *)(DMACSoftBReq_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACSoftBReq()     ((volatile u32DMACSoftBReq_word_view *)\
N(DMACSoftBReq_REG__ ))
X#define pu32DMACSoftBReq()     ((volatile u32DMACSoftBReq_word_view *)(DMACSoftBReq_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACSoftBReq_SoftBReq() (pst_bitDMACSoftBReq() -> SoftBReq)
N#define vSetDMACSoftBReq_SoftBReq(ParValue)  (pst_bitDMACSoftBReq() -> SoftBReq=(ParValue))            
N            
N/* Word access */
N#define vSetDMACSoftBReq(ParValue)  (*pu32DMACSoftBReq() = (ParValue))
N#define u32GetDMACSoftBReq()  (*pu32DMACSoftBReq() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACSoftSReq                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C024                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACSoftSReq_REG__       0xC010C024U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SoftSReq	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACSoftSReq_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACSoftSReq_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACSoftSReq()     ((volatile DMACSoftSReq_bit_view_st *)\
N(DMACSoftSReq_REG__ ))
X#define pst_bitDMACSoftSReq()     ((volatile DMACSoftSReq_bit_view_st *)(DMACSoftSReq_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACSoftSReq()     ((volatile u32DMACSoftSReq_word_view *)\
N(DMACSoftSReq_REG__ ))
X#define pu32DMACSoftSReq()     ((volatile u32DMACSoftSReq_word_view *)(DMACSoftSReq_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACSoftSReq_SoftSReq() (pst_bitDMACSoftSReq() -> SoftSReq)
N#define vSetDMACSoftSReq_SoftSReq(ParValue)  (pst_bitDMACSoftSReq() -> SoftSReq=(ParValue))            
N            
N/* Word access */
N#define vSetDMACSoftSReq(ParValue)  (*pu32DMACSoftSReq() = (ParValue))
N#define u32GetDMACSoftSReq()  (*pu32DMACSoftSReq() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACSoftLBReq                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C028                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACSoftLBReq_REG__       0xC010C028U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SoftLBReq	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACSoftLBReq_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACSoftLBReq_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACSoftLBReq()     ((volatile DMACSoftLBReq_bit_view_st *)\
N(DMACSoftLBReq_REG__ ))
X#define pst_bitDMACSoftLBReq()     ((volatile DMACSoftLBReq_bit_view_st *)(DMACSoftLBReq_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACSoftLBReq()     ((volatile u32DMACSoftLBReq_word_view *)\
N(DMACSoftLBReq_REG__ ))
X#define pu32DMACSoftLBReq()     ((volatile u32DMACSoftLBReq_word_view *)(DMACSoftLBReq_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACSoftLBReq_SoftLBReq() (pst_bitDMACSoftLBReq() -> SoftLBReq)
N#define vSetDMACSoftLBReq_SoftLBReq(ParValue)  (pst_bitDMACSoftLBReq() -> SoftLBReq=(ParValue))            
N            
N/* Word access */
N#define vSetDMACSoftLBReq(ParValue)  (*pu32DMACSoftLBReq() = (ParValue))
N#define u32GetDMACSoftLBReq()  (*pu32DMACSoftLBReq() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACSoftLSReq                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C02C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACSoftLSReq_REG__       0xC010C02CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   SoftLSReq	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACSoftLSReq_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACSoftLSReq_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACSoftLSReq()     ((volatile DMACSoftLSReq_bit_view_st *)\
N(DMACSoftLSReq_REG__ ))
X#define pst_bitDMACSoftLSReq()     ((volatile DMACSoftLSReq_bit_view_st *)(DMACSoftLSReq_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACSoftLSReq()     ((volatile u32DMACSoftLSReq_word_view *)\
N(DMACSoftLSReq_REG__ ))
X#define pu32DMACSoftLSReq()     ((volatile u32DMACSoftLSReq_word_view *)(DMACSoftLSReq_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACSoftLSReq_SoftLSReq() (pst_bitDMACSoftLSReq() -> SoftLSReq)
N#define vSetDMACSoftLSReq_SoftLSReq(ParValue)  (pst_bitDMACSoftLSReq() -> SoftLSReq=(ParValue))            
N            
N/* Word access */
N#define vSetDMACSoftLSReq(ParValue)  (*pu32DMACSoftLSReq() = (ParValue))
N#define u32GetDMACSoftLSReq()  (*pu32DMACSoftLSReq() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACConfig                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C030                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACConfig_REG__       0xC010C030U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   E	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   M1	:1; 	 /* 1..1  bit(s) R/W */
N  uint32_t   M2	:1; 	 /* 2..2  bit(s) R/W */ 
N  uint32_t   Reserved	:29; 	 /* 3..31  bit(s) R */                    
N} DMACConfig_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACConfig_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACConfig()     ((volatile DMACConfig_bit_view_st *)\
N(DMACConfig_REG__ ))
X#define pst_bitDMACConfig()     ((volatile DMACConfig_bit_view_st *)(DMACConfig_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACConfig()     ((volatile u32DMACConfig_word_view *)\
N(DMACConfig_REG__ ))
X#define pu32DMACConfig()     ((volatile u32DMACConfig_word_view *)(DMACConfig_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACConfig_E() (pst_bitDMACConfig() -> E)
N#define vSetDMACConfig_E(ParValue)  (pst_bitDMACConfig() -> E=(ParValue))
N#define biGetDMACConfig_M1() (pst_bitDMACConfig() -> M1)
N#define vSetDMACConfig_M1(ParValue)  (pst_bitDMACConfig() -> M1=(ParValue))
N#define biGetDMACConfig_M2() (pst_bitDMACConfig() -> M2)
N#define vSetDMACConfig_M2(ParValue)  (pst_bitDMACConfig() -> M2=(ParValue))            
N            
N/* Word access */
N#define vSetDMACConfig(ParValue)  (*pu32DMACConfig() = (ParValue))
N#define u32GetDMACConfig()  (*pu32DMACConfig() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACSync                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C034                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACSync_REG__       0xC010C034U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACSync	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACSync_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACSync_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACSync()     ((volatile DMACSync_bit_view_st *)\
N(DMACSync_REG__ ))
X#define pst_bitDMACSync()     ((volatile DMACSync_bit_view_st *)(DMACSync_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACSync()     ((volatile u32DMACSync_word_view *)\
N(DMACSync_REG__ ))
X#define pu32DMACSync()     ((volatile u32DMACSync_word_view *)(DMACSync_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACSync_DMACSync() (pst_bitDMACSync() -> DMACSync)
N#define vSetDMACSync_DMACSync(ParValue)  (pst_bitDMACSync() -> DMACSync=(ParValue))            
N            
N/* Word access */
N#define vSetDMACSync(ParValue)  (*pu32DMACSync() = (ParValue))
N#define u32GetDMACSync()  (*pu32DMACSync() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACC0SrcAddr                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C100                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACC0SrcAddr_REG__       0xC010C100U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   SrcAddr	:32; 	 /* 0..31  bit(s) R/W */                    
N} DMACC0SrcAddr_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACC0SrcAddr_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACC0SrcAddr(ch)     ((volatile DMACC0SrcAddr_bit_view_st *)\
N(DMACC0SrcAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pst_bitDMACC0SrcAddr(ch)     ((volatile DMACC0SrcAddr_bit_view_st *)(DMACC0SrcAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACC0SrcAddr(ch)     ((volatile u32DMACC0SrcAddr_word_view *)\
N(DMACC0SrcAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pu32DMACC0SrcAddr(ch)     ((volatile u32DMACC0SrcAddr_word_view *)(DMACC0SrcAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACC0SrcAddr_SrcAddr(ch) (pst_bitDMACC0SrcAddr(ch) -> SrcAddr)
N#define vSetDMACC0SrcAddr_SrcAddr(ch,ParValue)  (pst_bitDMACC0SrcAddr(ch) -> SrcAddr=(ParValue))
N            
N/* Word access */
N#define vSetDMACC0SrcAddr(ch,ParValue)  (*pu32DMACC0SrcAddr(ch) = (ParValue))
N#define u32GetDMACC0SrcAddr(ch)  (*pu32DMACC0SrcAddr(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACC0DestAddr                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C104                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACC0DestAddr_REG__       0xC010C104U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{ 
N  uint32_t   DestAddr	:32; 	 /* 0..31  bit(s) R/W */                    
N} DMACC0DestAddr_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACC0DestAddr_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACC0DestAddr(ch)     ((volatile DMACC0DestAddr_bit_view_st *)\
N(DMACC0DestAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pst_bitDMACC0DestAddr(ch)     ((volatile DMACC0DestAddr_bit_view_st *)(DMACC0DestAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACC0DestAddr(ch)     ((volatile u32DMACC0DestAddr_word_view *)\
N(DMACC0DestAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pu32DMACC0DestAddr(ch)     ((volatile u32DMACC0DestAddr_word_view *)(DMACC0DestAddr_REG__  + ((uint16_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACC0DestAddr_DestAddr(ch) (pst_bitDMACC0DestAddr(ch) -> DestAddr)
N#define vSetDMACC0DestAddr_DestAddr(ch,ParValue)  (pst_bitDMACC0DestAddr(ch) -> DestAddr=(ParValue))
N            
N/* Word access */
N#define vSetDMACC0DestAddr(ch,ParValue)  (*pu32DMACC0DestAddr(ch) = (ParValue))
N#define u32GetDMACC0DestAddr(ch)  (*pu32DMACC0DestAddr(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACC0LLI                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C108                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACC0LLI_REG__       0xC010C108U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   LM	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   	:1; 	 /* 1..1  bit(s) R */ 
N  uint32_t   LLI	:30; 	 /* 2..31  bit(s) R/W */                    
N} DMACC0LLI_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACC0LLI_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACC0LLI(ch)     ((volatile DMACC0LLI_bit_view_st *)\
N(DMACC0LLI_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pst_bitDMACC0LLI(ch)     ((volatile DMACC0LLI_bit_view_st *)(DMACC0LLI_REG__  + ((uint16_t)(ch) * 0x020U)))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACC0LLI(ch)     ((volatile u32DMACC0LLI_word_view *)\
N(DMACC0LLI_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pu32DMACC0LLI(ch)     ((volatile u32DMACC0LLI_word_view *)(DMACC0LLI_REG__  + ((uint16_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACC0LLI_LM(ch) (pst_bitDMACC0LLI(ch) -> LM)
N#define vSetDMACC0LLI_LM(ch,ParValue)  (pst_bitDMACC0LLI(ch) -> LM=(ParValue))
N#define biGetDMACC0LLI_LLI(ch) (pst_bitDMACC0LLI(ch) -> LLI)
N#define vSetDMACC0LLI_LLI(ch,ParValue)  (pst_bitDMACC0LLI(ch) -> LLI=(ParValue))
N            
N/* Word access */
N#define vSetDMACC0LLI(ch,ParValue)  (*pu32DMACC0LLI(ch) = (ParValue))
N#define u32GetDMACC0LLI(ch)  (*pu32DMACC0LLI(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACC0Control                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C10C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACC0Control_REG__       0xC010C10CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   TransferSize	:12; 	 /* 0..11  bit(s) R/W */
N  uint32_t   SBSize	:3; 	 /* 12..14  bit(s) R/W */
N  uint32_t   DBSize	:3; 	 /* 15..17  bit(s) R/W */
N  uint32_t   SWidth	:3; 	 /* 18..20  bit(s) R/W */
N  uint32_t   DWidth	:3; 	 /* 21..23  bit(s) R/W */
N  uint32_t   S	:1; 	 /* 24..24  bit(s) R/W */
N  uint32_t   D	:1; 	 /* 25..25  bit(s) R/W */
N  uint32_t   SI	:1; 	 /* 26..26  bit(s) R/W */
N  uint32_t   DI	:1; 	 /* 27..27  bit(s) R/W */
N  uint32_t   Prot	:3; 	 /* 28..30  bit(s) R/W */ 
N  uint32_t   I	:1; 	 /* 31..31  bit(s) R/W */                    
N} DMACC0Control_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACC0Control_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACC0Control(ch)     ((volatile DMACC0Control_bit_view_st *)\
N(DMACC0Control_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pst_bitDMACC0Control(ch)     ((volatile DMACC0Control_bit_view_st *)(DMACC0Control_REG__  + ((uint16_t)(ch) * 0x020U)))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACC0Control(ch)     ((volatile u32DMACC0Control_word_view *)\
N(DMACC0Control_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pu32DMACC0Control(ch)     ((volatile u32DMACC0Control_word_view *)(DMACC0Control_REG__  + ((uint16_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACC0Control_TransferSize(ch) (pst_bitDMACC0Control(ch) -> TransferSize)
N#define vSetDMACC0Control_TransferSize(ch,ParValue)  (pst_bitDMACC0Control(ch) -> TransferSize=(ParValue))
N#define biGetDMACC0Control_SBSize(ch) (pst_bitDMACC0Control(ch) -> SBSize)
N#define vSetDMACC0Control_SBSize(ch,ParValue)  (pst_bitDMACC0Control(ch) -> SBSize=(ParValue))
N#define biGetDMACC0Control_DBSize(ch) (pst_bitDMACC0Control(ch) -> DBSize)
N#define vSetDMACC0Control_DBSize(ch,ParValue)  (pst_bitDMACC0Control(ch) -> DBSize=(ParValue))
N#define biGetDMACC0Control_SWidth(ch) (pst_bitDMACC0Control(ch) -> SWidth)
N#define vSetDMACC0Control_SWidth(ch,ParValue)  (pst_bitDMACC0Control(ch) -> SWidth=(ParValue))
N#define biGetDMACC0Control_DWidth(ch) (pst_bitDMACC0Control(ch) -> DWidth)
N#define vSetDMACC0Control_DWidth(ch,ParValue)  (pst_bitDMACC0Control(ch) -> DWidth=(ParValue))
N#define biGetDMACC0Control_S(ch) (pst_bitDMACC0Control(ch) -> S)
N#define vSetDMACC0Control_S(ch,ParValue)  (pst_bitDMACC0Control(ch) -> S=(ParValue))
N#define biGetDMACC0Control_D(ch) (pst_bitDMACC0Control(ch) -> D)
N#define vSetDMACC0Control_D(ch,ParValue)  (pst_bitDMACC0Control(ch) -> D=(ParValue))
N#define biGetDMACC0Control_SI(ch) (pst_bitDMACC0Control(ch) -> SI)
N#define vSetDMACC0Control_SI(ch,ParValue)  (pst_bitDMACC0Control(ch) -> SI=(ParValue))
N#define biGetDMACC0Control_DI(ch) (pst_bitDMACC0Control(ch) -> DI)
N#define vSetDMACC0Control_DI(ch,ParValue)  (pst_bitDMACC0Control(ch) -> DI=(ParValue))
N#define biGetDMACC0Control_Prot(ch) (pst_bitDMACC0Control(ch) -> Prot)
N#define vSetDMACC0Control_Prot(ch,ParValue)  (pst_bitDMACC0Control(ch) -> Prot=(ParValue))
N#define biGetDMACC0Control_I(ch) (pst_bitDMACC0Control(ch) -> I)
N#define vSetDMACC0Control_I(ch,ParValue)  (pst_bitDMACC0Control(ch) -> I=(ParValue))
N            
N/* Word access */
N#define vSetDMACC0Control(ch,ParValue)  (*pu32DMACC0Control(ch) = (ParValue))
N#define u32GetDMACC0Control(ch)  (*pu32DMACC0Control(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACC0Config                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C110                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACC0Config_REG__       0xC010C110U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   E	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   SrcPeripherala	:4; 	 /* 1..4  bit(s) R/W */
N  uint32_t   	:1; 	 /* 5..5  bit(s) R */
N  uint32_t   DestPeripherala	:4; 	 /* 6..9  bit(s) R/W */
N  uint32_t   	:1; 	 /* 10..10  bit(s) R */
N  uint32_t   FlowCntrl	:3; 	 /* 11..13  bit(s) R/W */
N  uint32_t   IE	:1; 	 /* 14..14  bit(s) R/W */
N  uint32_t   ITC	:1; 	 /* 15..15  bit(s) R/W */
N  uint32_t   L	:1; 	 /* 16..16  bit(s) R/W */
N  uint32_t   A	:1; 	 /* 17..17  bit(s) R */
N  uint32_t   H	:1; 	 /* 18..18  bit(s) R/W */ 
N  uint32_t   Reserved	:13; 	 /* 19..31  bit(s) R */                    
N} DMACC0Config_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACC0Config_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACC0Config(ch)     ((volatile DMACC0Config_bit_view_st *)\
N(DMACC0Config_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pst_bitDMACC0Config(ch)     ((volatile DMACC0Config_bit_view_st *)(DMACC0Config_REG__  + ((uint16_t)(ch) * 0x020U)))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACC0Config(ch)     ((volatile u32DMACC0Config_word_view *)\
N(DMACC0Config_REG__  + ((uint16_t)(ch) * 0x020U)))
X#define pu32DMACC0Config(ch)     ((volatile u32DMACC0Config_word_view *)(DMACC0Config_REG__  + ((uint16_t)(ch) * 0x020U)))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACC0Config_E(ch) (pst_bitDMACC0Config(ch) -> E)
N#define vSetDMACC0Config_E(ch,ParValue)  (pst_bitDMACC0Config(ch) -> E=(ParValue))
N#define biGetDMACC0Config_SrcPeripherala(ch) (pst_bitDMACC0Config(ch) -> SrcPeripherala)
N#define vSetDMACC0Config_SrcPeripherala(ch,ParValue)  (pst_bitDMACC0Config(ch) -> SrcPeripherala=(ParValue))
N#define biGetDMACC0Config_DestPeripherala(ch) (pst_bitDMACC0Config(ch) -> DestPeripherala)
N#define vSetDMACC0Config_DestPeripherala(ch,ParValue)  (pst_bitDMACC0Config(ch) -> DestPeripherala=(ParValue))
N#define biGetDMACC0Config_FlowCntrl(ch) (pst_bitDMACC0Config(ch) -> FlowCntrl)
N#define vSetDMACC0Config_FlowCntrl(ch,ParValue)  (pst_bitDMACC0Config(ch) -> FlowCntrl=(ParValue))
N#define biGetDMACC0Config_IE(ch) (pst_bitDMACC0Config(ch) -> IE)
N#define vSetDMACC0Config_IE(ch,ParValue)  (pst_bitDMACC0Config(ch) -> IE=(ParValue))
N#define biGetDMACC0Config_ITC(ch) (pst_bitDMACC0Config(ch) -> ITC)
N#define vSetDMACC0Config_ITC(ch,ParValue)  (pst_bitDMACC0Config(ch) -> ITC=(ParValue))
N#define biGetDMACC0Config_L(ch) (pst_bitDMACC0Config(ch) -> L)
N#define vSetDMACC0Config_L(ch,ParValue)  (pst_bitDMACC0Config(ch) -> L=(ParValue))
N#define biGetDMACC0Config_A(ch) (pst_bitDMACC0Config(ch) -> A)
N#define biGetDMACC0Config_H(ch) (pst_bitDMACC0Config(ch) -> H)
N#define vSetDMACC0Config_H(ch,ParValue)  (pst_bitDMACC0Config(ch) -> H=(ParValue))            
N            
N/* Word access */
N#define vSetDMACC0Config(ch,ParValue)  (*pu32DMACC0Config(ch) = (ParValue))
N#define u32GetDMACC0Config(ch)  (*pu32DMACC0Config(ch) )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPeriID0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFE0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPeriID0_REG__       0xC010CFE0U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PartNumber0	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPeriID0_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPeriID0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPeriID0()     ((volatile DMACPeriID0_bit_view_st *)\
N(DMACPeriID0_REG__ ))
X#define pst_bitDMACPeriID0()     ((volatile DMACPeriID0_bit_view_st *)(DMACPeriID0_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPeriID0()     ((volatile u32DMACPeriID0_word_view *)\
N(DMACPeriID0_REG__ ))
X#define pu32DMACPeriID0()     ((volatile u32DMACPeriID0_word_view *)(DMACPeriID0_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPeriID0_PartNumber0() (pst_bitDMACPeriID0() -> PartNumber0)            
N            
N/* Word access */
N
N#define u32GetDMACPeriID0()  (*pu32DMACPeriID0() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPeriID1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFE4                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPeriID1_REG__       0xC010CFE4U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   PartNumber1	:4; 	 /* 0..3  bit(s) R */
N  uint32_t   Designer0	:4; 	 /* 4..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPeriID1_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPeriID1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPeriID1()     ((volatile DMACPeriID1_bit_view_st *)\
N(DMACPeriID1_REG__ ))
X#define pst_bitDMACPeriID1()     ((volatile DMACPeriID1_bit_view_st *)(DMACPeriID1_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPeriID1()     ((volatile u32DMACPeriID1_word_view *)\
N(DMACPeriID1_REG__ ))
X#define pu32DMACPeriID1()     ((volatile u32DMACPeriID1_word_view *)(DMACPeriID1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPeriID1_PartNumber1() (pst_bitDMACPeriID1() -> PartNumber1)            
N#define biGetDMACPeriID1_Designer0() (pst_bitDMACPeriID1() -> Designer0)            
N            
N/* Word access */
N
N#define u32GetDMACPeriID1()  (*pu32DMACPeriID1() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPeriID2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFE8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPeriID2_REG__       0xC010CFE8U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   Designer1	:4; 	 /* 0..3  bit(s) R */
N  uint32_t   Revision	:4; 	 /* 4..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPeriID2_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPeriID2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPeriID2()     ((volatile DMACPeriID2_bit_view_st *)\
N(DMACPeriID2_REG__ ))
X#define pst_bitDMACPeriID2()     ((volatile DMACPeriID2_bit_view_st *)(DMACPeriID2_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPeriID2()     ((volatile u32DMACPeriID2_word_view *)\
N(DMACPeriID2_REG__ ))
X#define pu32DMACPeriID2()     ((volatile u32DMACPeriID2_word_view *)(DMACPeriID2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPeriID2_Designer1() (pst_bitDMACPeriID2() -> Designer1)            
N#define biGetDMACPeriID2_Revision() (pst_bitDMACPeriID2() -> Revision)            
N            
N/* Word access */
N
N#define u32GetDMACPeriID2()  (*pu32DMACPeriID2() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPeriID3                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFEC                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPeriID3_REG__       0xC010CFECU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   Designer1	:3; 	 /* 0..2  bit(s) R */
N  uint32_t   Revision	:1; 	 /* 3..3  bit(s) R */
N  uint32_t   Reserved1	:3; 	 /* 4..6  bit(s) R */
N  uint32_t   Reserved2	:1; 	 /* 7..7  bit(s) R */ 
N  uint32_t   Reserved3	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPeriID3_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPeriID3_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPeriID3()     ((volatile DMACPeriID3_bit_view_st *)\
N(DMACPeriID3_REG__ ))
X#define pst_bitDMACPeriID3()     ((volatile DMACPeriID3_bit_view_st *)(DMACPeriID3_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPeriID3()     ((volatile u32DMACPeriID3_word_view *)\
N(DMACPeriID3_REG__ ))
X#define pu32DMACPeriID3()     ((volatile u32DMACPeriID3_word_view *)(DMACPeriID3_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPeriID3_Designer1() (pst_bitDMACPeriID3() -> Designer1)            
N#define biGetDMACPeriID3_Revision() (pst_bitDMACPeriID3() -> Revision)            
N            
N/* Word access */
N
N#define u32GetDMACPeriID3()  (*pu32DMACPeriID3() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPCellID0                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFF0                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPCellID0_REG__       0xC010CFF0U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACPCellID0	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPCellID0_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPCellID0_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPCellID0()     ((volatile DMACPCellID0_bit_view_st *)\
N(DMACPCellID0_REG__ ))
X#define pst_bitDMACPCellID0()     ((volatile DMACPCellID0_bit_view_st *)(DMACPCellID0_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPCellID0()     ((volatile u32DMACPCellID0_word_view *)\
N(DMACPCellID0_REG__ ))
X#define pu32DMACPCellID0()     ((volatile u32DMACPCellID0_word_view *)(DMACPCellID0_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPCellID0_DMACPCellID0() (pst_bitDMACPCellID0() -> DMACPCellID0)
N            
N/* Word access */
N
N#define u32GetDMACPCellID0()  (*pu32DMACPCellID0() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPCellID1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFF4                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPCellID1_REG__       0xC010CFF4U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACPCellID1	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPCellID1_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPCellID1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPCellID1()     ((volatile DMACPCellID1_bit_view_st *)\
N(DMACPCellID1_REG__ ))
X#define pst_bitDMACPCellID1()     ((volatile DMACPCellID1_bit_view_st *)(DMACPCellID1_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPCellID1()     ((volatile u32DMACPCellID1_word_view *)\
N(DMACPCellID1_REG__ ))
X#define pu32DMACPCellID1()     ((volatile u32DMACPCellID1_word_view *)(DMACPCellID1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPCellID1_DMACPCellID1() (pst_bitDMACPCellID1() -> DMACPCellID1)            
N            
N/* Word access */
N
N#define u32GetDMACPCellID1()  (*pu32DMACPCellID1() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPCellID2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFF8                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPCellID2_REG__       0xC010CFF8U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACPCellID2	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPCellID2_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPCellID2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPCellID2()     ((volatile DMACPCellID2_bit_view_st *)\
N(DMACPCellID2_REG__ ))
X#define pst_bitDMACPCellID2()     ((volatile DMACPCellID2_bit_view_st *)(DMACPCellID2_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPCellID2()     ((volatile u32DMACPCellID2_word_view *)\
N(DMACPCellID2_REG__ ))
X#define pu32DMACPCellID2()     ((volatile u32DMACPCellID2_word_view *)(DMACPCellID2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPCellID2_DMACPCellID2() (pst_bitDMACPCellID2() -> DMACPCellID2)            
N            
N/* Word access */
N
N#define u32GetDMACPCellID2()  (*pu32DMACPCellID2() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACPCellID3                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010CFFC                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACPCellID3_REG__       0xC010CFFCU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACPCellID3	:8; 	 /* 0..7  bit(s) R */ 
N  uint32_t   Reserved	:24; 	 /* 8..31  bit(s) R */                    
N} DMACPCellID3_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACPCellID3_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACPCellID3()     ((volatile DMACPCellID3_bit_view_st *)\
N(DMACPCellID3_REG__ ))
X#define pst_bitDMACPCellID3()     ((volatile DMACPCellID3_bit_view_st *)(DMACPCellID3_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACPCellID3()     ((volatile u32DMACPCellID3_word_view *)\
N(DMACPCellID3_REG__ ))
X#define pu32DMACPCellID3()     ((volatile u32DMACPCellID3_word_view *)(DMACPCellID3_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */            
N#define biGetDMACPCellID3_DMACPCellID3() (pst_bitDMACPCellID3() -> DMACPCellID3)            
N            
N/* Word access */
N
N#define u32GetDMACPCellID3()  (*pu32DMACPCellID3() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACITCR                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C500                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACITCR_REG__       0xC010C500U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   T	:1; 	 /* 0..0  bit(s) R/W */ 
N  uint32_t   Reserved	:31; 	 /* 1..31  bit(s) R */                    
N} DMACITCR_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACITCR_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACITCR()     ((volatile DMACITCR_bit_view_st *)\
N(DMACITCR_REG__ ))
X#define pst_bitDMACITCR()     ((volatile DMACITCR_bit_view_st *)(DMACITCR_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACITCR()     ((volatile u32DMACITCR_word_view *)\
N(DMACITCR_REG__ ))
X#define pu32DMACITCR()     ((volatile u32DMACITCR_word_view *)(DMACITCR_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACITCR_T() (pst_bitDMACITCR() -> T)
N#define vSetDMACITCR_T(ParValue)  (pst_bitDMACITCR() -> T=(ParValue))            
N            
N/* Word access */
N#define vSetDMACITCR(ParValue)  (*pu32DMACITCR() = (ParValue))
N#define u32GetDMACITCR()  (*pu32DMACITCR() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACITOP1                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C504                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACITOP1_REG__       0xC010C504U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACCLR	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACITOP1_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACITOP1_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACITOP1()     ((volatile DMACITOP1_bit_view_st *)\
N(DMACITOP1_REG__ ))
X#define pst_bitDMACITOP1()     ((volatile DMACITOP1_bit_view_st *)(DMACITOP1_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACITOP1()     ((volatile u32DMACITOP1_word_view *)\
N(DMACITOP1_REG__ ))
X#define pu32DMACITOP1()     ((volatile u32DMACITOP1_word_view *)(DMACITOP1_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACITOP1_DMACCLR() (pst_bitDMACITOP1() -> DMACCLR)
N#define vSetDMACITOP1_DMACCLR(ParValue)  (pst_bitDMACITOP1() -> DMACCLR=(ParValue))            
N            
N/* Word access */
N#define vSetDMACITOP1(ParValue)  (*pu32DMACITOP1() = (ParValue))
N#define u32GetDMACITOP1()  (*pu32DMACITOP1() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACITOP2                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C508                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACITOP2_REG__       0xC010C508U
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   DMACTC	:16; 	 /* 0..15  bit(s) R/W */ 
N  uint32_t   Reserved	:16; 	 /* 16..31  bit(s) R */                    
N} DMACITOP2_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACITOP2_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACITOP2()     ((volatile DMACITOP2_bit_view_st *)\
N(DMACITOP2_REG__ ))
X#define pst_bitDMACITOP2()     ((volatile DMACITOP2_bit_view_st *)(DMACITOP2_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACITOP2()     ((volatile u32DMACITOP2_word_view *)\
N(DMACITOP2_REG__ ))
X#define pu32DMACITOP2()     ((volatile u32DMACITOP2_word_view *)(DMACITOP2_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACITOP2_DMACTC() (pst_bitDMACITOP2() -> DMACTC)
N#define vSetDMACITOP2_DMACTC(ParValue)  (pst_bitDMACITOP2() -> DMACTC=(ParValue))            
N            
N/* Word access */
N#define vSetDMACITOP2(ParValue)  (*pu32DMACITOP2() = (ParValue))
N#define u32GetDMACITOP2()  (*pu32DMACITOP2() )
N                 
N    
N/****************************************************************************   
N*                                                                               
N*       REGISTER: DMACITOP3                                
N*       SIZE    : 32-bits                        
N*       ADDRESS : 0xC010C50C                             
N*       ACCESS  : 8, 16, 32, BIT-level                       
N*                                                                               
N*****************************************************************************/
N/* Assign Register address: */
N#define DMACITOP3_REG__       0xC010C50CU
N     
N/************************       STRUCTURES        ***************************/
N         
N        
N/* BIT View */
Ntypedef struct{
N  uint32_t   TC	:1; 	 /* 0..0  bit(s) R/W */
N  uint32_t   E	:1; 	 /* 1..1  bit(s) R */ 
N  uint32_t   Reserved	:30; 	 /* 2..31  bit(s) R */                    
N} DMACITOP3_bit_view_st;
N        
N
N/* WORD View */
Ntypedef uint32_t u32DMACITOP3_word_view;
N                 
N
N
N/************************     ACCESS POINTERS    ****************************/
N        
N/* Pointer to BIT-struct */
N#define pst_bitDMACITOP3()     ((volatile DMACITOP3_bit_view_st *)\
N(DMACITOP3_REG__ ))
X#define pst_bitDMACITOP3()     ((volatile DMACITOP3_bit_view_st *)(DMACITOP3_REG__ ))
N        
N/* Pointer to WORD  */ 
N#define pu32DMACITOP3()     ((volatile u32DMACITOP3_word_view *)\
N(DMACITOP3_REG__ ))
X#define pu32DMACITOP3()     ((volatile u32DMACITOP3_word_view *)(DMACITOP3_REG__ ))
N                 
N
N/************************ REGISTER ACCESS MACROS ****************************/
N            
N/* ACCESS MACROS - ATTENTION: REGISTER SHADOW TECHNIQUE MIGHT BE APPLIED */
N/* Bit-struct access */
N#define biGetDMACITOP3_TC() (pst_bitDMACITOP3() -> TC)
N#define vSetDMACITOP3_TC(ParValue)  (pst_bitDMACITOP3() -> TC=(ParValue))            
N#define biGetDMACITOP3_E() (pst_bitDMACITOP3() -> E)            
N            
N/* Word access */
N#define vSetDMACITOP3(ParValue)  (*pu32DMACITOP3() = (ParValue))
N#define u32GetDMACITOP3()  (*pu32DMACITOP3() )
N            
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S  #pragma ghs endnowarning /* enable Rule 3.5 [R] : derived  disable warnings for nonstandard type for a bit field */
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N
N#endif /* _DMACIO_H */
N
N/************************** BEGIN of DISCLAIMER   *************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products. Nevertheless, semiconductor devices in general can
N  malfunction or fail due to their inherent electrical sensitivity and
N  vulnerability to physical stress. It is the responsibility of the buyer,
N  when utilizing TOSHIBA products, to comply with the standards of safety
N  in making a safe design for the entire system, and to avoid situations in
N  which a malfunction or failure of such TOSHIBA products could cause loss of
N  human life, bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications.
N  Also, please keep in mind the precautions and conditions set forth in the
N  Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment, office
N  equipment, measuring equipment, industrial robotics, domestic appliances,
N  etc.).
N  These Toshiba products are neither intended nor warranted for usage in
N  equipment that requires extraordinarily high quality and/or reliability or
N  a malfunction or failure of which may cause loss of human life or bodily
N  injury (Unintended Usage). Unintended Usage include atomic energy control
N  instruments, airplane or spaceship instruments, transportation instruments,
N  traffic signal instruments, combustion control instruments, medical
N  instruments, all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be
N  made at the customers own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring
N  from the use of, or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
L 23 "..\..\..\..\lldd\src\dmac.c" 2
N#include "dmac.h"                      /* Own definitions */
L 1 "..\..\..\..\lldd\inc\dmac.h" 1
N/*****************************************************************************
N*   This software is copyright protected. All rights reserved
N*   Toshiba Electronics Europe GmbH
N*   European LSI Design and Engineering Center (ELDEC)
N******************************************************************************
N*   DESCRIPTION : DMAC low level driver header file
N******************************************************************************
N*   PLATFORM    : TMPR46xXBG-300
N*   PROJECT     :
N*   MODULE      : DMAC
N*   LIBRARIES   : None
N******************************************************************************
N*   VERSION     : $Revision: 1.18 $
N*   DATE        : $Date: 2015/05/04 09:07:14 $
N*   TAG         : $Name: LLDD_1_6 $
N*   RELEASE     : Preliminary & Confidential
N*****************************************************************************/
N#ifndef DMAC_H
N#define DMAC_H
N
N/**********************************************
N*                Include files                *
N**********************************************/
N#include "captypes.h"
N
N/*********************************************/
N
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_DMAC_H_REVISION     "$Revision: 1.18 $"
N#define LLDD_DMAC_H_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N
N
N/**********************************************
N*               Enumerations                  *
N**********************************************/
N
N/**
N* @brief DMAC enable and disable
N*/
Ntypedef enum tag_dmac_enable_e
N{
N    DMAC_DISABLE = 0,                  /*!< Disable */
N    DMAC_ENABLE  = 1                   /*!< Enable */
N} dmac_enable_e;
N
N
N/**
N* @brief DMAC channels
N*/
Ntypedef enum tag_dmac_channel_e
N{
N    DMAC_CHANNEL_0 = 0x0,              /*!< DMA channel 0 */
N    DMAC_CHANNEL_1 = 0x1,              /*!< DMA channel 1 */
N    DMAC_CHANNEL_2 = 0x2,              /*!< DMA channel 2 */
N    DMAC_CHANNEL_3 = 0x3,              /*!< DMA channel 3 */
N    DMAC_CHANNEL_4 = 0x4,              /*!< DMA channel 4 */
N    DMAC_CHANNEL_5 = 0x5,              /*!< DMA channel 5 */
N    DMAC_CHANNEL_6 = 0x6,              /*!< DMA channel 6 */
N    DMAC_CHANNEL_7 = 0x7               /*!< DMA channel 7 */
N} dmac_channel_e;
N
N
N/**
N* @brief DMAC requests
N*/
Ntypedef enum tag_dmac_request_e
N{
N    DMAC_REQUEST_0  = 0x0001,          /*!< DMA request 0 */
N    DMAC_REQUEST_1  = 0x0002,          /*!< DMA request 1 */
N    DMAC_REQUEST_2  = 0x0004,          /*!< DMA request 2 */
N    DMAC_REQUEST_3  = 0x0008,          /*!< DMA request 3 */
N    DMAC_REQUEST_4  = 0x0010,          /*!< DMA request 4 */
N    DMAC_REQUEST_5  = 0x0020,          /*!< DMA request 5 */
N    DMAC_REQUEST_6  = 0x0040,          /*!< DMA request 6 */
N    DMAC_REQUEST_7  = 0x0080,          /*!< DMA request 7 */
N    DMAC_REQUEST_8  = 0x0100,          /*!< DMA request 8 */
N    DMAC_REQUEST_9  = 0x0200,          /*!< DMA request 9 */
N    DMAC_REQUEST_10 = 0x0400,          /*!< DMA request 10 */
N    DMAC_REQUEST_11 = 0x0800,          /*!< DMA request 11 */
N    DMAC_REQUEST_12 = 0x1000,          /*!< DMA request 12 */
N    DMAC_REQUEST_13 = 0x2000,          /*!< DMA request 13 */
N    DMAC_REQUEST_14 = 0x4000,          /*!< DMA request 14 */
N    DMAC_REQUEST_15 = 0x8000           /*!< DMA request 15 */
N} dmac_request_e;
N
N
N/**
N* @brief DMAC burst length
N*/
Ntypedef enum tag_dmac_burst_length_e
N{
N    DMAC_BURST_LENGTH_1   = 0x0,         /*!< DMA burst length 1   */
N    DMAC_BURST_LENGTH_4   = 0x1,         /*!< DMA burst length 4   */
N    DMAC_BURST_LENGTH_8   = 0x2,         /*!< DMA burst length 8   */
N    DMAC_BURST_LENGTH_16  = 0x3,         /*!< DMA burst length 16  */
N    DMAC_BURST_LENGTH_32  = 0x4,         /*!< DMA burst length 32  */
N    DMAC_BURST_LENGTH_64  = 0x5,         /*!< DMA burst length 64  */
N    DMAC_BURST_LENGTH_128 = 0x6,         /*!< DMA burst length 128 */
N    DMAC_BURST_LENGTH_256 = 0x7          /*!< DMA burst length 256 */
N} dmac_burst_length_e;
N
N
N/**
N* @brief DMAC transfer width
N*/
Ntypedef enum tag_dmac_transfer_width_e
N{
N    DMAC_TRANSFER_BYTE      = 0x0,     /*!< DMA transfer bytewise */
N    DMAC_TRANSFER_HALF_WORD = 0x1,     /*!< DMA transfer half word wise */
N    DMAC_TRANSFER_WORD      = 0x2      /*!< DMA transfer word wise */
N} dmac_transfer_width_e;
N
N
N/**
N* @brief DMAC AHB master select
N*/
Ntypedef enum tag_dmac_AHB_master_sel_e
N{
N    DMAC_SELECT_AHB_MASTER_1 = 0x0,    /*!< DMA AHB master select 1 */
N    DMAC_SELECT_AHB_MASTER_2 = 0x1     /*!< DMA AHB master select 2 */
N} dmac_AHB_master_sel_e;
N
N
N/**
N* @brief DMAC incrementation
N*/
Ntypedef enum tag_dmac_address_inc_e
N{
N    DMAC_NO_ADDRESS_INCREMENT = 0x0,   /*!< DMA address is not incremented */
N    DMAC_ADDRESS_INCREMENT    = 0x1    /*!< DMA address is incremented */
N} dmac_address_inc_e;
N
N
N/**
N* @brief DMAC access mode
N*/
Ntypedef enum tag_dmac_access_mode_e
N{
N    DMAC_USER_MODE        = 0x0,       /*!< DMA user mode */
N    DMAC_PRIVILEDGED_MODE = 0x1        /*!< DMA priviledged mode */
N} dmac_access_mode_e;
N
N
N/**
N* @brief DMAC access is bufferable or not
N*/
Ntypedef enum tag_dmac_bufferable_e
N{
N    DMAC_NON_BUFFERABLE = 0x0,         /*!< DMA non bufferable access */
N    DMAC_BUFFERABLE     = 0x2          /*!< DMA bufferable access */
N} dmac_bufferable_e;
N
N
N/**
N* @brief DMAC access is cacheable or not
N*/
Ntypedef enum tag_dmac_cacheable_e
N{
N    DMAC_NON_CACHEABLE = 0x0,          /*!< DMA non cacheable access */
N    DMAC_CACHEABLE     = 0x4           /*!< DMA cacheable access */
N} dmac_cacheable_e;
N
N
N/**
N* @brief DMAC access is bufferable or not
N*/
Ntypedef enum tag_dmac_flow_control_e
N{
N    DMAC_MEMORY_TO_MEMORY_BY_DMA                   = 0x0,    /*!< DMA transfer from memory to memory by DMA conroller */
N    DMAC_MEMORY_TO_PERIPHERAL_BY_DMA               = 0x1,    /*!< DMA transfer from memory to peripheral by DMA conroller */
N    DMAC_PERIPHERAL_TO_MEMORY_BY_DMA               = 0x2,    /*!< DMA transfer from peripheral to memory by DMA conroller */
N    DMAC_SPERIPHERAL_TO_DPERIPHERAL_BY_DMA         = 0x3,    /*!< DMA transfer from source peripheral to destination peripheral by DMA conroller */
N    DMAC_SPERIPHERAL_TO_DPERIPHERAL_BY_DPERIPHERAL = 0x4,    /*!< DMA transfer from source peripheral to destination peripheral by destination peripheral */
N    DMAC_MEMORY_TO_PERIPHERAL_BY_PERIPHERAL        = 0x5,    /*!< DMA transfer from memory to peripheral by peripheral */
N    DMAC_PERIPHERAL_TO_MEMORY_BY_PERIPHERAL        = 0x6,    /*!< DMA transfer from peripheral to memory by peripheral */
N    DMAC_SPERIPHERAL_TO_DPERIPHERAL_BY_SPERIPHERAL = 0x7     /*!< DMA transfer from source peripheral to destination peripheral by source peripheral */
N} dmac_flow_control_e;
N
N
N/**
N* @brief DMAC stop or continue transmission
N*/
Ntypedef enum tag_dmac_halt_e
N{
N    DMAC_CONTINUE = 0,                 /*!< continue transmission */
N    DMAC_HALT     = 1                  /*!< stop transmission */
N} dmac_halt_e;
N
N
N/*********************************************/
N
N
N/**********************************************
N*                 Structures                  *
N**********************************************/
N
N/**
N* @brief DMA link list description structure
N*/
Ntypedef struct tag_dmac_linklistitem_st
N{
N    uint32_t               u32LLIAddress;             /*!< Link list item address */
N    dmac_AHB_master_sel_e  eAHBMasterSelect;          /*!< AHB selection for link list loading */
N} dmac_linklistitem_st;
N
N
N/**
N* @brief DMA control structure
N*/
Ntypedef struct tag_dmac_control_st
N{
N    dmac_enable_e          eTCInterruptEnable;        /*!< Terminal count interrupt enable bit */
N    uint8_t                u8Protection;              /*!< transfer protection */
N    dmac_address_inc_e     eDstInc;                   /*!< Destination increment */
N    dmac_address_inc_e     eSourceInc;                /*!< Source increment */
N    dmac_AHB_master_sel_e  eDstAHBMasterSelect;       /*!< Destination AHB-master selection */
N    dmac_AHB_master_sel_e  eSourceAHBMasterSelect;    /*!< Source AHB-master selection */
N    dmac_transfer_width_e  eDstTransferWidth;         /*!< Destination transfer width */
N    dmac_transfer_width_e  eSourceTransferWidth;      /*!< Source transfer width */
N    dmac_burst_length_e    eDstBurstLength;           /*!< Destination burst length */
N    dmac_burst_length_e    eSourceBurstLength;        /*!< Source burst length */
N    uint16_t               u16TransferSize;           /*!< Size of transfers */
N} dmac_control_st;
N
N
N/**
N* @brief DMA configuration structure
N*/
Ntypedef struct tag_dmac_config_st
N{
N    dmac_enable_e        eHalt;                       /*!< Halt a transfer */
N    dmac_enable_e        eActive;                     /*!< Channel working or not */
N    dmac_enable_e        eLockedTransfer;             /*!< Enable or disable locked transfers */
N    dmac_enable_e        eMaskTCInterrupt;            /*!< Terminal count interrupt mask */
N    dmac_enable_e        eMaskErrorInterrupt;         /*!< Interrupt error mask */
N    dmac_flow_control_e  eFlowControl;                /*!< Flow control and transfer type */
N    uint8_t              u8DstPeripheral;             /*!< Specify destination peripheral */
N    uint8_t              u8SourcePeripheral;          /*!< Specify source peripheral */
N} dmac_config_st;
N
N/*********************************************/
N
N
N/**********************************************
N*            Forward declarations             *
N**********************************************/
N
N
N/*********************************************/
N
N
N/**********************************************
N*        Exported function prototypes         *
N**********************************************/
N
N/**
N* @brief Implementation of function vDMAC_GetVersion
N*
N* Retrieve pointers to module and header revision and tag string
N*
N* @note No Limitations
N*
N* @param[in,out] pau8ModuleRevision - pointer to module revision string
N* @param[in,out] pau8ModuleTag      - pointer to module tag string
N* @param[in,out] pau8HeaderRevision - pointer to header revision string
N* @param[in,out] pau8HeaderTag      - pointer to header tag string
N* @param[in,out] pau8IORevision     - pointer to IO header revision string
N* @param[in,out] pau8IOTag          - pointer to IO header tag string
N*
N* @return void
N*/
Nvoid vDMAC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                      uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                      uint8_t** pau8IORevision, uint8_t** pau8IOTag);
N
N
N/**
N* @brief Implementation of function u8DMAC_GetInterruptStatusAll
N*
N* Read status of all interrupts
N*
N* @note No Limitations
N*
N* @return Status of all interrupts
N*/
Nuint8_t u8DMAC_GetInterruptStatusAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetInterruptStatus
N*
N* Read status of single interrupt
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if interrupt of channel is set
N* @return DMAC_DISABLE if interrupt of channel is not set
N*/
Ndmac_enable_e eDMAC_GetInterruptStatus(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function u8DMAC_GetInterruptTCStatusAll
N*
N* Read status of all terminal count interrupts
N*
N* @note No Limitations
N*
N* @return Status of all interrupts
N*/
Nuint8_t u8DMAC_GetInterruptTCStatusAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetInterruptTCStatus
N*
N* Read status of single terminal count interrupt
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if interrupt of channel is set
N* @return DMAC_DISABLE if interrupt of channel is not set
N*/
Ndmac_enable_e eDMAC_GetInterruptTCStatus(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function vDMAC_ClearInterruptTCStatusAll
N*
N* Clear all terminal count interrupts
N*
N* @note No Limitations
N*
N* @return void
N*/
Nvoid vDMAC_ClearInterruptTCStatusAll(void);
N
N
N/**
N* @brief Implementation of function vDMAC_ClearInterruptTCStatus
N*
N* Clear single terminal count interrupt
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return void
N*/
Nvoid vDMAC_ClearInterruptTCStatus(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function u8DMAC_GetInterruptErrorStatusAll
N*
N* Read error status of all interrupts
N*
N* @note No Limitations
N*
N* @return Error status of all interrupts
N*/
Nuint8_t u8DMAC_GetInterruptErrorStatusAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetInterruptErrorStatus
N*
N* Read error status of single interrupt
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if interrupt error of channel is set
N* @return DMAC_DISABLE if interrupt error of channel is not set
N*/
Ndmac_enable_e eDMAC_GetInterruptErrorStatus(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function vDMAC_ClearInterruptErrorAll
N*
N* Clear all interrupt errors
N*
N* @note No Limitations
N*
N* @return void
N*/
Nvoid vDMAC_ClearInterruptErrorAll(void);
N
N
N/**
N* @brief Implementation of function vDMAC_ClearInterruptError
N*
N* Clear single interrupt error
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return void
N*/
Nvoid vDMAC_ClearInterruptError(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function u8DMAC_GetRawInterruptTCStatusAll
N*
N* Read status of all raw terminal count interrupts
N*
N* @note No Limitations
N*
N* @return Status of all interrupts
N*/
Nuint8_t u8DMAC_GetRawInterruptTCStatusAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetRawInterruptTCStatus
N*
N* Read status of single raw terminal count interrupt
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if interrupt of channel is set
N* @return DMAC_DISABLE if interrupt of channel is not set
N*/
Ndmac_enable_e eDMAC_GetRawInterruptTCStatus(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function u8DMAC_GetRawInterruptErrorStatusAll
N*
N* Read raw error status of all interrupts
N*
N* @note No Limitations
N*
N* @return Error status of all interrupts
N*/
Nuint8_t u8DMAC_GetRawInterruptErrorStatusAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetRawInterruptErrorStatus
N*
N* Read raw error status of single interrupt
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if interrupt error of channel is set
N* @return DMAC_DISABLE if interrupt error of channel is not set
N*/
Ndmac_enable_e eDMAC_GetRawInterruptErrorStatus(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function u8DMAC_GetEnabledChannelAll
N*
N* Read all enabled channels
N*
N* @note No Limitations
N*
N* @return Pattern of enabled/disabled channels
N*/
Nuint8_t u8DMAC_GetEnabledChannelAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetEnabledChannel
N*
N* Check if single channel is enabled
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if channel is enabled
N* @return DMAC_DISABLE if channel is not enabled
N*/
Ndmac_enable_e eDMAC_GetEnabledChannel(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareBurstRequestAll
N*
N* Enable all software burst requests
N*
N* @note No Limitations
N*
N* @param[in] u16Value - requests to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareBurstRequestAll(uint16_t u16Value);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareBurstRequest
N*
N* Enable single software burst request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - request to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareBurstRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function u16DMAC_GetEnabledSoftwareBurstRequestAll
N*
N* Read all enabled software burst requests
N*
N* @note No Limitations
N*
N* @return Status of all software burst requests
N*/
Nuint16_t u16DMAC_GetEnabledSoftwareBurstRequestAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetEnabledSoftwareBurstRequest
N*
N* Read single enabled software burst request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - DMA request number
N*
N* @return DMAC_ENABLE if software burst is enabled
N* @return DMAC_DISABLE if software burst is not enabled
N*/
Ndmac_enable_e eDMAC_GetEnabledSoftwareBurstRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareSingleRequestAll
N*
N* Enable all software single requests
N*
N* @note No Limitations
N*
N* @param[in] u16Value - requests to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareSingleRequestAll(uint16_t u16Value);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareBurstRequest
N*
N* Enable single software single request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - request to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareSingleRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function u16DMAC_GetEnabledSoftwareSingleRequestAll
N*
N* Read single enabled software single requests
N*
N* @note No Limitations
N*
N* @return status of all software single requests
N*/
Nuint16_t u16DMAC_GetEnabledSoftwareSingleRequestAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetEnabledSoftwareSingleRequest
N*
N* Read single enabled software single request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - DMA request number
N*
N* @return DMAC_ENABLE if software single is enabled
N* @return DMAC_DISABLE if software single is not enabled
N*/
Ndmac_enable_e eDMAC_GetEnabledSoftwareSingleRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareLastBurstRequestAll
N*
N* Enable all software burst requests
N*
N* @note No Limitations
N*
N* @param[in] u16Value - requests to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareLastBurstRequestAll(uint16_t u16Value);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareLastBurstRequest
N*
N* Enable single software burst request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - request to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareLastBurstRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function u16DMAC_GetEnabledSoftwareLastBurstRequestAll
N*
N* Read all enabled software burst requests
N*
N* @note No Limitations
N*
N* @return status of all software burst requests
N*/
Nuint16_t u16DMAC_GetEnabledSoftwareLastBurstRequestAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetEnabledSoftwareLastBurstRequest
N*
N* Read single enabled software burst request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - DMA request number
N*
N* @return DMAC_ENABLE if software last burst is enabled
N* @return DMAC_DISABLE if software last burst is not enabled
N*/
Ndmac_enable_e eDMAC_GetEnabledSoftwareLastBurstRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareLastSingleRequestAll
N*
N* Enable all software single requests
N*
N* @note No Limitations
N*
N* @param[in] u16Value - requests to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareLastSingleRequestAll(uint16_t u16Value);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSoftwareLastSingleRequest
N*
N* Enable single software single request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - request to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSoftwareLastSingleRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function u16DMAC_GetEnabledSoftwareLastSingleRequestAll
N*
N* Read single enabled software single requests
N*
N* @note No Limitations
N*
N* @return status of all software single requests
N*/
Nuint16_t u16DMAC_GetEnabledSoftwareLastSingleRequestAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetEnabledSoftwareLastSingleRequest
N*
N* Read single enabled software single request
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - DMA request number
N*
N* @return DMAC_ENABLE if software last single request is enabled
N* @return DMAC_DISABLE if software last single request is not enabled
N*/
Ndmac_enable_e eDMAC_GetEnabledSoftwareLastSingleRequest(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function vDMAC_Enable
N*
N* Enable or disable the DMA-controller
N*
N* @note No Limitations
N*
N* @param[in] eEnable - DMAC_ENABLE/DMAC_DISABLE
N*
N* @return void
N*/
Nvoid vDMAC_Enable(dmac_enable_e eEnable);
N
N/**
N* @brief Implementation of function eDMAC_GetEnabled
N*
N* get the actual status of the DMA-controller
N*
N* @note No Limitations
N*
N* @param[in] void
N*
N* @return eEnable - DMAC_ENABLE/DMAC_DISABLE
N*/
Ndmac_enable_e eDMAC_GetEnabled( void );
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSynchronisationAll
N*
N* Enable synchronisation logic for all request signals
N*
N* @note No Limitations
N*
N* @param[in] u16Value - requests to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSynchronisationAll(uint16_t u16Value);
N
N
N/**
N* @brief Implementation of function vDMAC_EnableSynchronisation
N*
N* Enable synchronisation logic for single request signal
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - request to be set
N*
N* @return void
N*/
Nvoid vDMAC_EnableSynchronisation(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function u16DMAC_GetSynchronisationAll
N*
N* Read synchronisation logic enable status for all request signals
N*
N* @note No Limitations
N*
N* @return status of all software single requests
N*/
Nuint16_t u16DMAC_GetSynchronisationAll(void);
N
N
N/**
N* @brief Implementation of function eDMAC_GetSynchronisation
N*
N* Read synchronisation logic enable status for single request signals
N*
N* @note No Limitations
N*
N* @param[in] eDMARequest - DMA request number
N*
N* @return DMAC_ENABLE if synchronisation logic is enabled
N* @return DMAC_DISABLE if synchrinisation logic is not enabled
N*/
Ndmac_enable_e eDMAC_GetSynchronisation(dmac_request_e eDMARequest);
N
N
N/**
N* @brief Implementation of function vDMAC_SetSourceAddress
N*
N* Set source address
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N* @param[in] u32Address  - source address
N*
N* @return void
N*/
Nvoid vDMAC_SetSourceAddress(dmac_channel_e eDMAChannel, uint32_t u32Address);
N
N
N/**
N* @brief Implementation of function u32DMAC_GetSourceAddress
N*
N* Read source address
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return source address
N*/
Nuint32_t u32DMAC_GetSourceAddress(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function vDMAC_SetDestinationAddress
N*
N* Set destination address
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N* @param[in] u32Address  - destination address
N*
N* @return void
N*/
Nvoid vDMAC_SetDestinationAddress(dmac_channel_e eDMAChannel, uint32_t u32Address);
N
N
N/**
N* @brief Implementation of function u32DMAC_GetDestinationAddress
N*
N* Read destination address
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return Destination address
N*/
Nuint32_t u32DMAC_GetDestinationAddress(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function vDMAC_SetLinkListItem
N*
N* Set DMA link list configuration
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel    - DMA channel
N* @param[in] stLinkListItem - Pointer to link list configuration
N*
N* @return void
N*/
Nvoid vDMAC_SetLinkListItem(dmac_channel_e eDMAChannel, dmac_linklistitem_st * stLinkListItem);
N
N
N/**
N* @brief Implementation of function vDMAC_GetLinkListItem
N*
N* Get DMA link list configuration
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @param[in,out] stLinkListItem - Pointer to link list configuration
N*
N* @return void
N*/
Nvoid vDMAC_GetLinkListItem(dmac_channel_e eDMAChannel, dmac_linklistitem_st * stLinkListItem);
N
N
N/**
N* @brief Implementation of function vDMAC_SetControl
N*
N* Set DMA control configuration
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N* @param[in] stControl   - Pointer to DMA channel control configuration
N*
N* @return void
N*/
Nvoid vDMAC_SetControl(dmac_channel_e eDMAChannel, dmac_control_st * stControl);
N
N
N/**
N* @brief Implementation of function vDMAC_SetTransferSize
N*
N* Set dma transfer size for specific channel
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N* @param[in] u16TransferSize - transfer size
N*
N* @return void
N*/
Nvoid vDMAC_SetTransferSize(dmac_channel_e eDMAChannel, uint16_t u16TransferSize);
N
N
N/**
N* @brief Implementation of function u32DMAC_GenerateControlValue
N*
N* Combine DMA control configuration to one 32-Bit value
N*
N* @note No Limitations
N*
N* @param[in] stControl - Pointer to DMA channel control configuration
N*
N* @return DMAC-control register value
N*/
Nuint32_t u32DMAC_GenerateControlValue(dmac_control_st * stControl);
N
N
N/**
N* @brief Implementation of function vDMAC_GetControl
N*
N* Get DMA control configuration
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @param[in,out] stControl - Pointer to DMA channel control configuration
N*
N* @return C_TRUE or C_FALSE (if channel is not disbaled, information cannot be valid)
N*/
Nbool_t boDMAC_GetControl(dmac_channel_e eDMAChannel, dmac_control_st * stControl);
N
N
N/**
N* @brief Implementation of function vDMAC_SetConfiguration
N*
N* Set DMA configuration
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N* @param[in] stConfiguration - Pointer to DMA channel configuration
N*
N* @return void
N*/
Nvoid vDMAC_SetConfiguration(dmac_channel_e eDMAChannel, dmac_config_st * stConfiguration);
N
N
N/**
N* @brief Implementation of function u32DMAC_GenerateConfigurationValue
N*
N* Combine DMA configuration to one 32-Bit value
N*
N* @note No Limitations
N*
N* @param[in] stConfiguration - Pointer to DMA channel configuration
N*
N* @return DMAC-configuration register value
N*/
Nuint32_t u32DMAC_GenerateConfigurationValue(dmac_config_st * stConfiguration);
N
N
N/**
N* @brief Implementation of function vDMAC_GetConfiguration
N*
N* Get DMA configuration
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @param[in,out] stConfiguration - Pointer to DMA channel configuration
N*
N* @return void
N*/
Nvoid vDMAC_GetConfiguration(dmac_channel_e eDMAChannel, dmac_config_st * stConfiguration);
N
N
N/**
N* @brief Implementation of function vDMAC_HoldChannel
N*
N* Hold or continuer a DMA channel
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N* @param[in] eHalt       - Stop or continue transmission
N*
N* @return void
N*/
Nvoid vDMAC_HoldChannel(dmac_channel_e eDMAChannel, dmac_halt_e eHalt);
N
N
N/**
N* @brief Implementation of function vDMAC_StartTransfer
N*
N* Start transfer
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return void
N*/
Nvoid vDMAC_StartTransfer(dmac_channel_e eDMAChannel);
N
N
N/**
N* @brief Implementation of function vDMAC_StopTransfer
N*
N* Stop transfer, any data in the fifo is lost
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return void
N*/
Nvoid vDMAC_StopTransfer(dmac_channel_e eDMAChannel);
N
N/**
N* @brief Implementation of function eDMACTransferStarted
N*
N* Check if DMA transfer waas started
N*
N* @note No Limitations
N*
N* @param[in] eDMAChannel - DMA channel
N*
N* @return DMAC_ENABLE if transfer is started
N* @return DMAC_DISABLE if transfer is not satarted
N*/
Ndmac_enable_e eDMACTransferStarted(dmac_channel_e eDMAChannel);
N
N
N/****************************************************************************/
N
N
N#endif /* DMAC_H*/
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER  *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER****************************/
N
L 24 "..\..\..\..\lldd\src\dmac.c" 2
N
N/*********************************************
N*         Disable Misra Warnings/Rules       *
N**********************************************/
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S
S  #pragma ghs nowarning 1723    /* Rule 5.6 [A] :  No identifiers with the same name in different name spaces except 
S                                                   for struct and union members                                           */
S  #pragma ghs nowarning 1834    /* Rule 11.3 [A] : No casting between pointer and integral types                          */
S  #pragma ghs nowarning 1853    /* Rule 12.6 [A] : Operands of logical operators must be Boolean, and Boolean expressions 
S                                                   may not be used as operands of other operators                         */
S  #pragma ghs nowarning 1855    /* Rule 13.2 [A] : Explicit test of a value against zero unless the expression is Boolean */
S  #pragma ghs nowarning 1864    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1865    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1866    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1867    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S  #pragma ghs nowarning 1868    /* Rule 10.1 [R] : Restrict implicit conversions for integer type expressions */
S
S  #pragma ghs nowarning 1847    /* Rule 10.3 [R] : 	Restrict explicit casts for integer type expressions */
S  #pragma ghs nowarning 1848    /* Rule 10.3 [R] : 	Restrict explicit casts for integer type expressions */
S  #pragma ghs nowarning 1879    /* Rule 10.3 [R] : 	Restrict explicit casts for integer type expressions */
S
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N
N/**********************************************
N*                 Constants                   *
N**********************************************/
N
N#define LLDD_DMAC_C_REVISION     "$Revision: 1.16 $"
N#define LLDD_DMAC_C_TAG          "$Name: LLDD_1_6 $"
N
N/*********************************************/
N
N
N/**********************************************
N*  Static variables and forward declarations  *
N**********************************************/
N
Nstatic uint8_t au8LLDD_DMAC_C_REVISION[]    = LLDD_DMAC_C_REVISION;
Xstatic uint8_t au8LLDD_DMAC_C_REVISION[]    = "$Revision: 1.16 $";
Nstatic uint8_t au8LLDD_DMAC_C_TAG[]         = LLDD_DMAC_C_TAG;
Xstatic uint8_t au8LLDD_DMAC_C_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_DMAC_H_REVISION[]    = LLDD_DMAC_H_REVISION;
Xstatic uint8_t au8LLDD_DMAC_H_REVISION[]    = "$Revision: 1.18 $";
Nstatic uint8_t au8LLDD_DMAC_H_TAG[]         = LLDD_DMAC_H_TAG;
Xstatic uint8_t au8LLDD_DMAC_H_TAG[]         = "$Name: LLDD_1_6 $";
Nstatic uint8_t au8LLDD_DMAC_IO_H_REVISION[] = LLDD_DMAC_IO_H_REVISION;
Xstatic uint8_t au8LLDD_DMAC_IO_H_REVISION[] = "$Revision: 1.11 $";
Nstatic uint8_t au8LLDD_DMAC_IO_H_TAG[]      = LLDD_DMAC_IO_H_TAG;
Xstatic uint8_t au8LLDD_DMAC_IO_H_TAG[]      = "$Name: LLDD_1_6 $";
N
N/*********************************************/
N
N
N/**********************************************
N*              Global variables               *
N**********************************************/
Nstatic uint8_t u8ChannelMask[8] = {0x01U,
N                            0x02U,
N                            0x04U,
N                            0x08U,
N                            0x10U,
N                            0x20U,
N                            0x40U,
N                            0x80U};
N
N/*********************************************/
N
N
N/**********************************************
N*             Function definition             *
N**********************************************/
N
Nvoid vDMAC_GetVersion(uint8_t** pau8ModuleRevision, uint8_t** pau8ModuleTag,
N                      uint8_t** pau8HeaderRevision, uint8_t** pau8HeaderTag,
N                      uint8_t** pau8IORevision, uint8_t** pau8IOTag)
N{
N   *pau8ModuleRevision = &au8LLDD_DMAC_C_REVISION[0];
N   *pau8ModuleTag      = &au8LLDD_DMAC_C_TAG[0];
N   *pau8HeaderRevision = &au8LLDD_DMAC_H_REVISION[0];
N   *pau8HeaderTag      = &au8LLDD_DMAC_H_TAG[0];
N   *pau8IORevision     = &au8LLDD_DMAC_IO_H_REVISION[0];
N   *pau8IOTag          = &au8LLDD_DMAC_IO_H_TAG[0];
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8DMAC_GetInterruptStatusAll(void)
N{
N    return ( (uint8_t)biGetDMACIntStatus_IntStatus() );
X    return ( (uint8_t)(((volatile DMACIntStatus_bit_view_st *)(0xC010C000U )) -> IntStatus) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetInterruptStatus(dmac_channel_e eDMAChannel)
N{
N    uint8_t u8Status;
N    dmac_enable_e eDmacStatus;
N
N
N    u8Status = (uint8_t)biGetDMACIntStatus_IntStatus();
X    u8Status = (uint8_t)(((volatile DMACIntStatus_bit_view_st *)(0xC010C000U )) -> IntStatus);
N    u8Status = u8Status & u8ChannelMask[eDMAChannel];
N    if (u8Status > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8DMAC_GetInterruptTCStatusAll(void)
N{
N    return ( (uint8_t)biGetDMACIntTCStatus_IntTCStatus() ); 
X    return ( (uint8_t)(((volatile DMACIntTCStatus_bit_view_st *)(0xC010C004U )) -> IntTCStatus) ); 
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetInterruptTCStatus(dmac_channel_e eDMAChannel)
N{
N    uint8_t u8Status;
N    dmac_enable_e eDmacStatus;
N
N    u8Status = (uint8_t)biGetDMACIntTCStatus_IntTCStatus();
X    u8Status = (uint8_t)(((volatile DMACIntTCStatus_bit_view_st *)(0xC010C004U )) -> IntTCStatus);
N    u8Status = u8Status & u8ChannelMask[eDMAChannel];
N    if (u8Status > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_ClearInterruptTCStatusAll(void)
N{
N    vSetDMACIntTCClear(0xFFU);
X    (*((volatile u32DMACIntTCClear_word_view *)(0xC010C008U )) = (0xFFU));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_ClearInterruptTCStatus(dmac_channel_e eDMAChannel)
N{
N    vSetDMACIntTCClear(u8ChannelMask[eDMAChannel]);
X    (*((volatile u32DMACIntTCClear_word_view *)(0xC010C008U )) = (u8ChannelMask[eDMAChannel]));
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8DMAC_GetInterruptErrorStatusAll(void)
N{
N    return ( (uint8_t)biGetDMACIntErrorStatus_IntErrorStatus() );
X    return ( (uint8_t)(((volatile DMACIntErrorStatus_bit_view_st *)(0xC010C00CU )) -> IntErrorStatus) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetInterruptErrorStatus(dmac_channel_e eDMAChannel)
N{
N    uint8_t u8Status;
N    dmac_enable_e eDmacStatus;
N
N    u8Status = (uint8_t)biGetDMACIntErrorStatus_IntErrorStatus();
X    u8Status = (uint8_t)(((volatile DMACIntErrorStatus_bit_view_st *)(0xC010C00CU )) -> IntErrorStatus);
N    u8Status = u8Status & u8ChannelMask[eDMAChannel];
N    if (u8Status > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_ClearInterruptErrorAll(void)
N{
N    vSetDMACIntErrClr(0xFFU);
X    (*((volatile u32DMACIntErrClr_word_view *)(0xC010C010U )) = (0xFFU));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_ClearInterruptError(dmac_channel_e eDMAChannel)
N{
N    vSetDMACIntErrClr(u8ChannelMask[eDMAChannel]);
X    (*((volatile u32DMACIntErrClr_word_view *)(0xC010C010U )) = (u8ChannelMask[eDMAChannel]));
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8DMAC_GetRawInterruptTCStatusAll(void)
N{
N    return ( (uint8_t)biGetDMACRawIntTCStatus_RawIntTCStatus() );
X    return ( (uint8_t)(((volatile DMACRawIntTCStatus_bit_view_st *)(0xC010C014U )) -> RawIntTCStatus) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetRawInterruptTCStatus(dmac_channel_e eDMAChannel)
N{
N    uint8_t u8Status;
N    dmac_enable_e eDmacStatus;
N
N    u8Status = (uint8_t)biGetDMACRawIntTCStatus_RawIntTCStatus();
X    u8Status = (uint8_t)(((volatile DMACRawIntTCStatus_bit_view_st *)(0xC010C014U )) -> RawIntTCStatus);
N    u8Status = u8Status & u8ChannelMask[eDMAChannel];
N    if (u8Status > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8DMAC_GetRawInterruptErrorStatusAll(void)
N{
N    return ( (uint8_t)biGetDMACRawIntErrorStatus_RawIntErrorStatus() );
X    return ( (uint8_t)(((volatile DMACRawIntErrorStatus_bit_view_st *)(0xC010C018U )) -> RawIntErrorStatus) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetRawInterruptErrorStatus(dmac_channel_e eDMAChannel)
N{
N    uint8_t u8Status;
N    dmac_enable_e eDmacStatus;
N
N    u8Status = (uint8_t)biGetDMACRawIntErrorStatus_RawIntErrorStatus();
X    u8Status = (uint8_t)(((volatile DMACRawIntErrorStatus_bit_view_st *)(0xC010C018U )) -> RawIntErrorStatus);
N    u8Status = u8Status & u8ChannelMask[eDMAChannel];
N    if (u8Status > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N
N}
N
N
N/****************************************************************************/
N
Nuint8_t u8DMAC_GetEnabledChannelAll(void)
N{
N    return ( (uint8_t)biGetDMACEnbldChns_EnabledChannels() );
X    return ( (uint8_t)(((volatile DMACEnbldChns_bit_view_st *)(0xC010C01CU )) -> EnabledChannels) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetEnabledChannel(dmac_channel_e eDMAChannel)
N{
N    uint8_t u8Status;
N    dmac_enable_e eDmacStatus;
N
N    u8Status = (uint8_t)biGetDMACEnbldChns_EnabledChannels();
X    u8Status = (uint8_t)(((volatile DMACEnbldChns_bit_view_st *)(0xC010C01CU )) -> EnabledChannels);
N    u8Status = u8Status & u8ChannelMask[eDMAChannel];
N    if (u8Status > 0U)
N    {
N         eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetEnabled( void )
N{
N    dmac_enable_e eEnable;
N
N    if ( biGetDMACConfig_E () )
X    if ( (((volatile DMACConfig_bit_view_st *)(0xC010C030U )) -> E) )
N    {
N        eEnable = DMAC_ENABLE;
N    }
N    else
N    {
N        eEnable = DMAC_DISABLE;
N    }
N    return eEnable;
N}
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareBurstRequestAll(uint16_t u16Value)
N{
N    vSetDMACSoftBReq(u16Value);
X    (*((volatile u32DMACSoftBReq_word_view *)(0xC010C020U )) = (u16Value));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareBurstRequest(dmac_request_e eDMARequest)
N{
N    vSetDMACSoftBReq_SoftBReq((uint32_t)eDMARequest);
X    (((volatile DMACSoftBReq_bit_view_st *)(0xC010C020U )) -> SoftBReq=((uint32_t)eDMARequest));
N}
N
N
N/****************************************************************************/
N
Nuint16_t u16DMAC_GetEnabledSoftwareBurstRequestAll(void)
N{
N    return ( (uint16_t)biGetDMACSoftBReq_SoftBReq() );
X    return ( (uint16_t)(((volatile DMACSoftBReq_bit_view_st *)(0xC010C020U )) -> SoftBReq) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetEnabledSoftwareBurstRequest(dmac_request_e eDMARequest)
N{
N    uint16_t u16Request;
N    dmac_enable_e eDmacStatus;
N
N    u16Request = (uint16_t)biGetDMACSoftBReq_SoftBReq();
X    u16Request = (uint16_t)(((volatile DMACSoftBReq_bit_view_st *)(0xC010C020U )) -> SoftBReq);
N    u16Request = u16Request & (uint16_t)eDMARequest;
N    if (u16Request > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareSingleRequestAll(uint16_t u16Value)
N{
N    vSetDMACSoftSReq_SoftSReq(u16Value);
X    (((volatile DMACSoftSReq_bit_view_st *)(0xC010C024U )) -> SoftSReq=(u16Value));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareSingleRequest(dmac_request_e eDMARequest)
N{
N    vSetDMACSoftSReq_SoftSReq((uint16_t)eDMARequest);
X    (((volatile DMACSoftSReq_bit_view_st *)(0xC010C024U )) -> SoftSReq=((uint16_t)eDMARequest));
N}
N
N
N/****************************************************************************/
N
Nuint16_t u16DMAC_GetEnabledSoftwareSingleRequestAll(void)
N{
N    return ( (uint16_t)biGetDMACSoftSReq_SoftSReq() );
X    return ( (uint16_t)(((volatile DMACSoftSReq_bit_view_st *)(0xC010C024U )) -> SoftSReq) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetEnabledSoftwareSingleRequest(dmac_request_e eDMARequest)
N{
N    uint16_t u16Request;
N    dmac_enable_e eDmacStatus;
N
N    u16Request = (uint16_t)biGetDMACSoftSReq_SoftSReq();
X    u16Request = (uint16_t)(((volatile DMACSoftSReq_bit_view_st *)(0xC010C024U )) -> SoftSReq);
N    u16Request = u16Request & (uint16_t)eDMARequest;
N    if (u16Request > 0U)
N    {
N         eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareLastBurstRequestAll(uint16_t u16Value)
N{
N    vSetDMACSoftLBReq_SoftLBReq(u16Value);
X    (((volatile DMACSoftLBReq_bit_view_st *)(0xC010C028U )) -> SoftLBReq=(u16Value));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareLastBurstRequest(dmac_request_e eDMARequest)
N{
N    vSetDMACSoftLBReq_SoftLBReq((uint16_t)eDMARequest);
X    (((volatile DMACSoftLBReq_bit_view_st *)(0xC010C028U )) -> SoftLBReq=((uint16_t)eDMARequest));
N}
N
N
N/****************************************************************************/
N
Nuint16_t u16DMAC_GetEnabledSoftwareLastBurstRequestAll(void)
N{
N    return ( (uint16_t)biGetDMACSoftLBReq_SoftLBReq() );
X    return ( (uint16_t)(((volatile DMACSoftLBReq_bit_view_st *)(0xC010C028U )) -> SoftLBReq) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetEnabledSoftwareLastBurstRequest(dmac_request_e eDMARequest)
N{
N    uint16_t u16Request;
N    dmac_enable_e eDmacStatus;
N
N    u16Request = (uint16_t)biGetDMACSoftLBReq_SoftLBReq();
X    u16Request = (uint16_t)(((volatile DMACSoftLBReq_bit_view_st *)(0xC010C028U )) -> SoftLBReq);
N    u16Request = u16Request & (uint16_t)eDMARequest;
N    if (u16Request > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareLastSingleRequestAll(uint16_t u16Value)
N{
N    vSetDMACSoftLSReq_SoftLSReq(u16Value);
X    (((volatile DMACSoftLSReq_bit_view_st *)(0xC010C02CU )) -> SoftLSReq=(u16Value));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSoftwareLastSingleRequest(dmac_request_e eDMARequest)
N{
N    vSetDMACSoftLSReq_SoftLSReq((uint16_t)eDMARequest);
X    (((volatile DMACSoftLSReq_bit_view_st *)(0xC010C02CU )) -> SoftLSReq=((uint16_t)eDMARequest));
N}
N
N
N/****************************************************************************/
N
Nuint16_t u16DMAC_GetEnabledSoftwareLastSingleRequestAll(void)
N{
N    return ( (uint16_t)biGetDMACSoftLSReq_SoftLSReq() );
X    return ( (uint16_t)(((volatile DMACSoftLSReq_bit_view_st *)(0xC010C02CU )) -> SoftLSReq) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetEnabledSoftwareLastSingleRequest(dmac_request_e eDMARequest)
N{
N    uint16_t u16Request;
N    dmac_enable_e eDmacStatus;
N
N    u16Request = (uint16_t)biGetDMACSoftLSReq_SoftLSReq();
X    u16Request = (uint16_t)(((volatile DMACSoftLSReq_bit_view_st *)(0xC010C02CU )) -> SoftLSReq);
N    u16Request = u16Request & (uint16_t)eDMARequest;
N    if (u16Request > 0U)
N    {
N         eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_Enable(dmac_enable_e eEnable)
N{
N    uint8_t u8Channel;
N    uint8_t u8Mask = 0x1U;
N    uint8_t u8Loop;
N
N    if (eEnable == DMAC_ENABLE)
N    {
N        vSetDMACConfig_E((uint32_t)DMAC_ENABLE);
X        (((volatile DMACConfig_bit_view_st *)(0xC010C030U )) -> E=((uint32_t)DMAC_ENABLE));
N    }
N    else
N    {
N        for (u8Loop=0; u8Loop < 8U; u8Loop++)
N        {
N            /* read if a DMA channel is enabled */
N            u8Channel = ((uint8_t)biGetDMACEnbldChns_EnabledChannels()) & u8Mask;
X            u8Channel = ((uint8_t)(((volatile DMACEnbldChns_bit_view_st *)(0xC010C01CU )) -> EnabledChannels)) & u8Mask;
N
N            if (u8Channel != 0U)
N            {
N                /* halt channel */
N                vSetDMACC0Config_H(u8Loop, DMAC_DISABLE);
X                (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(u8Loop) * 0x020U))) -> H=(DMAC_DISABLE));
N
N                /* poll till channel is halted */
N                while (1U == (uint32_t) biGetDMACC0Config_A(u8Loop))
X                while (1U == (uint32_t) (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(u8Loop) * 0x020U))) -> A))
N                {
N                    ;
N                }
N
N                /* disable channel */
N                vSetDMACC0Config_E(u8Loop, DMAC_DISABLE);
X                (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(u8Loop) * 0x020U))) -> E=(DMAC_DISABLE));
N            }
N
N            u8Mask = (uint8_t)(u8Mask << 1);
N        }
N
N        vSetDMACConfig_E((uint32_t)DMAC_DISABLE);
X        (((volatile DMACConfig_bit_view_st *)(0xC010C030U )) -> E=((uint32_t)DMAC_DISABLE));
N    }
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSynchronisationAll(uint16_t u16Value)
N{
N    vSetDMACSync(u16Value);
X    (*((volatile u32DMACSync_word_view *)(0xC010C034U )) = (u16Value));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_EnableSynchronisation(dmac_request_e eDMARequest)
N{
N    vSetDMACSync((uint16_t)eDMARequest);
X    (*((volatile u32DMACSync_word_view *)(0xC010C034U )) = ((uint16_t)eDMARequest));
N}
N
N
N/****************************************************************************/
N
Nuint16_t u16DMAC_GetSynchronisationAll(void)
N{
N    return ( (uint16_t)biGetDMACSync_DMACSync() );
X    return ( (uint16_t)(((volatile DMACSync_bit_view_st *)(0xC010C034U )) -> DMACSync) );
N}
N
N
N/****************************************************************************/
N
Ndmac_enable_e eDMAC_GetSynchronisation(dmac_request_e eDMARequest)
N{
N    uint16_t u16Sync;
N    dmac_enable_e eDmacStatus;
N
N    u16Sync = (uint16_t)biGetDMACSync_DMACSync();
X    u16Sync = (uint16_t)(((volatile DMACSync_bit_view_st *)(0xC010C034U )) -> DMACSync);
N    u16Sync = u16Sync & (uint16_t)eDMARequest;
N    if (u16Sync > 0U)
N    {
N        eDmacStatus = DMAC_ENABLE;
N    }
N    else
N    {
N        eDmacStatus = DMAC_DISABLE;
N    }
N    return eDmacStatus;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_SetSourceAddress(dmac_channel_e eDMAChannel, uint32_t u32Address)
N{
N    vSetDMACC0SrcAddr(eDMAChannel, u32Address);
X    (*((volatile u32DMACC0SrcAddr_word_view *)(0xC010C100U + ((uint16_t)(eDMAChannel) * 0x020U))) = (u32Address));
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32DMAC_GetSourceAddress(dmac_channel_e eDMAChannel)
N{
N    return u32GetDMACC0SrcAddr(eDMAChannel);
X    return (*((volatile u32DMACC0SrcAddr_word_view *)(0xC010C100U + ((uint16_t)(eDMAChannel) * 0x020U))) );
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_SetDestinationAddress(dmac_channel_e eDMAChannel, uint32_t u32Address)
N{
N    vSetDMACC0DestAddr(eDMAChannel, u32Address);
X    (*((volatile u32DMACC0DestAddr_word_view *)(0xC010C104U + ((uint16_t)(eDMAChannel) * 0x020U))) = (u32Address));
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32DMAC_GetDestinationAddress(dmac_channel_e eDMAChannel)
N{
N    return u32GetDMACC0DestAddr(eDMAChannel);
X    return (*((volatile u32DMACC0DestAddr_word_view *)(0xC010C104U + ((uint16_t)(eDMAChannel) * 0x020U))) );
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_SetLinkListItem(dmac_channel_e eDMAChannel, dmac_linklistitem_st * stLinkListItem)
N{
N    vSetDMACC0LLI_LM(eDMAChannel, stLinkListItem->eAHBMasterSelect);
X    (((volatile DMACC0LLI_bit_view_st *)(0xC010C108U + ((uint16_t)(eDMAChannel) * 0x020U))) -> LM=(stLinkListItem->eAHBMasterSelect));
N    vSetDMACC0LLI_LLI(eDMAChannel, (stLinkListItem->u32LLIAddress>>2));
X    (((volatile DMACC0LLI_bit_view_st *)(0xC010C108U + ((uint16_t)(eDMAChannel) * 0x020U))) -> LLI=((stLinkListItem->u32LLIAddress>>2)));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_GetLinkListItem(dmac_channel_e eDMAChannel, dmac_linklistitem_st * stLinkListItem)
N{
N    stLinkListItem->eAHBMasterSelect = (dmac_AHB_master_sel_e)biGetDMACC0LLI_LM(eDMAChannel);
X    stLinkListItem->eAHBMasterSelect = (dmac_AHB_master_sel_e)(((volatile DMACC0LLI_bit_view_st *)(0xC010C108U + ((uint16_t)(eDMAChannel) * 0x020U))) -> LM);
N    stLinkListItem->u32LLIAddress    = (uint32_t)biGetDMACC0LLI_LLI(eDMAChannel);
X    stLinkListItem->u32LLIAddress    = (uint32_t)(((volatile DMACC0LLI_bit_view_st *)(0xC010C108U + ((uint16_t)(eDMAChannel) * 0x020U))) -> LLI);
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_SetControl(dmac_channel_e eDMAChannel, dmac_control_st * stControl)
N{
N    vSetDMACC0Control_I(eDMAChannel, stControl->eTCInterruptEnable);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> I=(stControl->eTCInterruptEnable));
N    vSetDMACC0Control_Prot(eDMAChannel, stControl->u8Protection);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> Prot=(stControl->u8Protection));
N    vSetDMACC0Control_DI(eDMAChannel, stControl->eDstInc);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> DI=(stControl->eDstInc));
N    vSetDMACC0Control_SI(eDMAChannel, stControl->eSourceInc);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> SI=(stControl->eSourceInc));
N    vSetDMACC0Control_D(eDMAChannel, stControl->eDstAHBMasterSelect);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> D=(stControl->eDstAHBMasterSelect));
N    vSetDMACC0Control_S(eDMAChannel, stControl->eSourceAHBMasterSelect);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> S=(stControl->eSourceAHBMasterSelect));
N    vSetDMACC0Control_DWidth(eDMAChannel, stControl->eDstTransferWidth);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> DWidth=(stControl->eDstTransferWidth));
N    vSetDMACC0Control_SWidth(eDMAChannel, stControl->eSourceTransferWidth);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> SWidth=(stControl->eSourceTransferWidth));
N    vSetDMACC0Control_DBSize(eDMAChannel, stControl->eDstBurstLength);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> DBSize=(stControl->eDstBurstLength));
N    vSetDMACC0Control_SBSize(eDMAChannel, stControl->eSourceBurstLength);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> SBSize=(stControl->eSourceBurstLength));
N    vSetDMACC0Control_TransferSize(eDMAChannel, stControl->u16TransferSize);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> TransferSize=(stControl->u16TransferSize));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_SetTransferSize(dmac_channel_e eDMAChannel, uint16_t u16TransferSize)
N{
N    vSetDMACC0Control_TransferSize(eDMAChannel, u16TransferSize);
X    (((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> TransferSize=(u16TransferSize));
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32DMAC_GenerateControlValue(dmac_control_st * stControl)
N{
N    uint32_t u32Value;
N
N    u32Value = (((uint32_t) (stControl->eTCInterruptEnable)<<31));
N
N    u32Value = (((uint32_t)stControl->eTCInterruptEnable)<<31) + ((uint32_t)(stControl->u8Protection)<<28) + (((uint32_t)stControl->eDstInc)<<27) + (((uint32_t)stControl->eSourceInc)<<26) +
N               ((uint32_t)(stControl->eDstAHBMasterSelect) <<25) + (((uint32_t)stControl->eSourceAHBMasterSelect)<<24) + (((uint32_t)stControl->eDstTransferWidth)<<21) +
N               ((uint32_t)(stControl->eSourceTransferWidth)<<18) + ((uint32_t)(stControl->eDstBurstLength)<<15) + (((uint32_t)stControl->eSourceBurstLength)<<12) + stControl->u16TransferSize;
N
N    return u32Value;
N}
N
N
N/****************************************************************************/
N
Nbool_t boDMAC_GetControl(dmac_channel_e eDMAChannel, dmac_control_st * stControl)
N{
N    bool_t  boResult = C_FALSE;
X    bool_t  boResult = (0);
N    uint8_t u8Channel;
N    
N    /* read if related DMA channel is enabled */
N    u8Channel = ((uint8_t)biGetDMACEnbldChns_EnabledChannels()) & u8ChannelMask[eDMAChannel];
X    u8Channel = ((uint8_t)(((volatile DMACEnbldChns_bit_view_st *)(0xC010C01CU )) -> EnabledChannels)) & u8ChannelMask[eDMAChannel];
N    /* register data can be read only if channel is disabled: */
N    if (u8Channel == 0U)
N    {
N        stControl->u16TransferSize        = (uint16_t)biGetDMACC0Control_TransferSize(eDMAChannel);
X        stControl->u16TransferSize        = (uint16_t)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> TransferSize);
N        stControl->eSourceBurstLength     = (dmac_burst_length_e)biGetDMACC0Control_SBSize(eDMAChannel);
X        stControl->eSourceBurstLength     = (dmac_burst_length_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> SBSize);
N        stControl->eDstBurstLength        = (dmac_burst_length_e)biGetDMACC0Control_DBSize(eDMAChannel);
X        stControl->eDstBurstLength        = (dmac_burst_length_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> DBSize);
N        stControl->eSourceTransferWidth   = (dmac_transfer_width_e)biGetDMACC0Control_SWidth(eDMAChannel);
X        stControl->eSourceTransferWidth   = (dmac_transfer_width_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> SWidth);
N        stControl->eDstTransferWidth      = (dmac_transfer_width_e)biGetDMACC0Control_DWidth(eDMAChannel);
X        stControl->eDstTransferWidth      = (dmac_transfer_width_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> DWidth);
N        stControl->eSourceAHBMasterSelect = (dmac_AHB_master_sel_e)biGetDMACC0Control_S(eDMAChannel);
X        stControl->eSourceAHBMasterSelect = (dmac_AHB_master_sel_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> S);
N        stControl->eDstAHBMasterSelect    = (dmac_AHB_master_sel_e)biGetDMACC0Control_D(eDMAChannel);
X        stControl->eDstAHBMasterSelect    = (dmac_AHB_master_sel_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> D);
N        stControl->eSourceInc             = (dmac_address_inc_e)biGetDMACC0Control_SI(eDMAChannel);
X        stControl->eSourceInc             = (dmac_address_inc_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> SI);
N        stControl->eDstInc                = (dmac_address_inc_e)biGetDMACC0Control_DI(eDMAChannel);
X        stControl->eDstInc                = (dmac_address_inc_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> DI);
N        stControl->u8Protection           = (uint8_t)biGetDMACC0Control_Prot(eDMAChannel);
X        stControl->u8Protection           = (uint8_t)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> Prot);
N        stControl->eTCInterruptEnable     = (dmac_enable_e)biGetDMACC0Control_I(eDMAChannel);
X        stControl->eTCInterruptEnable     = (dmac_enable_e)(((volatile DMACC0Control_bit_view_st *)(0xC010C10CU + ((uint16_t)(eDMAChannel) * 0x020U))) -> I);
N        
N        boResult = C_TRUE;
X        boResult = (1);
N    }
N    return boResult;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_SetConfiguration(dmac_channel_e eDMAChannel, dmac_config_st * stConfiguration)
N{
N    vSetDMACC0Config_SrcPeripherala(eDMAChannel, stConfiguration->u8SourcePeripheral);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> SrcPeripherala=(stConfiguration->u8SourcePeripheral));
N    vSetDMACC0Config_DestPeripherala(eDMAChannel, stConfiguration->u8DstPeripheral);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> DestPeripherala=(stConfiguration->u8DstPeripheral));
N    vSetDMACC0Config_FlowCntrl(eDMAChannel, stConfiguration->eFlowControl);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> FlowCntrl=(stConfiguration->eFlowControl));
N    vSetDMACC0Config_IE(eDMAChannel, stConfiguration->eMaskErrorInterrupt);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> IE=(stConfiguration->eMaskErrorInterrupt));
N    vSetDMACC0Config_ITC(eDMAChannel, stConfiguration->eMaskTCInterrupt);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> ITC=(stConfiguration->eMaskTCInterrupt));
N    vSetDMACC0Config_L(eDMAChannel, stConfiguration->eLockedTransfer);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> L=(stConfiguration->eLockedTransfer));
N    vSetDMACC0Config_H(eDMAChannel, stConfiguration->eHalt);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> H=(stConfiguration->eHalt));
N}
N
N
N/****************************************************************************/
N
Nuint32_t u32DMAC_GenerateConfigurationValue(dmac_config_st * stConfiguration)
N{
N    uint32_t u32Value;
N
N    u32Value = (((uint32_t)stConfiguration->eHalt)<<18) + (((uint32_t)stConfiguration->eActive)<<17) + (((uint32_t)stConfiguration->eLockedTransfer)<<16) +
N               ((uint32_t)(stConfiguration->eMaskTCInterrupt)<<15) + ((uint32_t)(stConfiguration->eMaskErrorInterrupt)<<14) + ((uint32_t)(stConfiguration->eFlowControl)<<11) +
N               ((uint32_t)(stConfiguration->u8DstPeripheral)<<6) + ((uint32_t)(stConfiguration->u8SourcePeripheral)<<1);
N
N    return u32Value;
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_GetConfiguration(dmac_channel_e eDMAChannel, dmac_config_st * stConfiguration)
N{
N    stConfiguration->u8SourcePeripheral  = (uint8_t)biGetDMACC0Config_SrcPeripherala(eDMAChannel);
X    stConfiguration->u8SourcePeripheral  = (uint8_t)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> SrcPeripherala);
N    stConfiguration->u8DstPeripheral     = (uint8_t)biGetDMACC0Config_DestPeripherala(eDMAChannel);
X    stConfiguration->u8DstPeripheral     = (uint8_t)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> DestPeripherala);
N    stConfiguration->eFlowControl        = (dmac_flow_control_e)biGetDMACC0Config_FlowCntrl(eDMAChannel);
X    stConfiguration->eFlowControl        = (dmac_flow_control_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> FlowCntrl);
N    stConfiguration->eMaskErrorInterrupt = (dmac_enable_e)biGetDMACC0Config_IE(eDMAChannel);
X    stConfiguration->eMaskErrorInterrupt = (dmac_enable_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> IE);
N    stConfiguration->eMaskTCInterrupt    = (dmac_enable_e)biGetDMACC0Config_ITC(eDMAChannel);
X    stConfiguration->eMaskTCInterrupt    = (dmac_enable_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> ITC);
N    stConfiguration->eLockedTransfer     = (dmac_enable_e)biGetDMACC0Config_L(eDMAChannel);
X    stConfiguration->eLockedTransfer     = (dmac_enable_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> L);
N    stConfiguration->eActive             = (dmac_enable_e)biGetDMACC0Config_A(eDMAChannel);
X    stConfiguration->eActive             = (dmac_enable_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> A);
N    stConfiguration->eHalt               = (dmac_enable_e)biGetDMACC0Config_H(eDMAChannel);
X    stConfiguration->eHalt               = (dmac_enable_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> H);
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_HoldChannel(dmac_channel_e eDMAChannel, dmac_halt_e eHalt)
N{
N    vSetDMACC0Config_H(eDMAChannel, eHalt);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> H=(eHalt));
N}
N
N
N/****************************************************************************/
N
Nvoid vDMAC_StartTransfer(dmac_channel_e eDMAChannel)
N{
N    vSetDMACC0Config_E(eDMAChannel, 0x1);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> E=(0x1));
N}
N
N/****************************************************************************/
N
Nvoid vDMAC_StopTransfer(dmac_channel_e eDMAChannel)
N{
N    vSetDMACC0Config_E(eDMAChannel, 0x0);
X    (((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> E=(0x0));
N}
N
N/****************************************************************************/
N
Ndmac_enable_e eDMACTransferStarted(dmac_channel_e eDMAChannel)
N{
N    return (dmac_enable_e)biGetDMACC0Config_E(eDMAChannel);
X    return (dmac_enable_e)(((volatile DMACC0Config_bit_view_st *)(0xC010C110U + ((uint16_t)(eDMAChannel) * 0x020U))) -> E);
N}
N
N#if defined(__GHS__) || defined(__ghs__)
X#if 0L || 0L
S/* enable warnings for Misra 10.1 & 10.3 */
S#pragma ghs endnowarning
N#endif /* defined(__GHS__) || defined(__ghs__) */
N
N/****************************************************************************/
N
N
N/***********************  BEGIN of DISCLAIMER   *****************************
N
N- TOSHIBA is continually working to improve the quality and reliability of
N  its products.
N  Nevertheless, semiconductor devices in general can malfunction or fail
N  due to their inherent electrical sensitivity and vulnerability to physical
N  stress. It is the responsibility of the buyer, when utilizing TOSHIBA
N  products, to comply with the standards of safety in making a safe design
N  for the entire system, and to avoid situations in which a malfunction or
N  failure of such TOSHIBA products could cause loss of human life,
N  bodily injury or damage to property.
N
N  In developing your designs, please ensure that TOSHIBA products are used
N  within specified operating ranges as set forth in the most recent TOSHIBA
N  products specifications. Also, please keep in mind the precautions and
N  conditions set forth in the “Handling Guide for Semiconductor Devices, or
N  TOSHIBA Semiconductor Reliability Handbook etc..
N
N- The Toshiba products listed in this document are intended for usage in
N  general electronics applications (computer, personal equipment,
N  office equipment, measuring equipment,industrial robotics, domestic
N  appliances, etc.). These Toshiba products are neither intended nor
N  warranted for usage in equipment that requires extraordinarily high quality
N  and/or reliability or a malfunction or failure of which may cause loss
N  of human life or bodily injury (“Unintended Usage).
N  Unintended Usage include atomic energy control instruments, airplane or
N  spaceship instruments, transportation instruments, traffic signal
N  instruments, combustion control instruments, medical instruments,
N  all types of safety devices, etc..
N  Unintended Usage of Toshiba products listed in this document shall be made
N  at the customer’s own risk.
N
N- Toshiba assumes no liability for any damage or losses (including but not
N  limited to, loss of business profit,business interruption, loss of business
N  information,and other pecuniary losses) occurring from the use of,
N  or inability to use, this product.
N
N- The products described in this document are subject to the foreign exchange
N  and foreign trade laws.
N
N- The products described in this document contain components made in the
N  United States and subject to export control of the U.S. authorities.
N  Diversion contrary to the U.S. law is prohibited.
N
N- The information contained herein is presented only as a guide for the
N  applications of our products.
N  No responsibility is assumed by TOSHIBA CORPORATION for any infringements
N  of intellectual property or other rights of the third parties which may
N  result from its use.
N  No license is granted by implication or otherwise under any intellectual
N  property or other rights of TOSHIBA CORPORATION or others.
N
N- The information contained herein is subject to change without notice.
N
N****************************  END of DISCLAIMER ****************************/
N
