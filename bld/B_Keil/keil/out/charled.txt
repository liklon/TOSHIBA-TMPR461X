; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\charled.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\charled.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\charled.crf ..\..\..\..\hldd\src\charled.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  setNORflash_interface_gdc1 PROC
;;;361    
;;;362    void setNORflash_interface_gdc1()
000000  e92d4010          PUSH     {r4,lr}
;;;363    {
;;;364        // EBIF_AD00 
;;;365        i32GPIO_EnableLatchFunction(PORT_D1RGB5, GPIO_DISABLE);
000004  e3a01000          MOV      r1,#0
000008  e3a000a1          MOV      r0,#0xa1
00000c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;366        i32GPIO_SetPinFunction(PORT_D1RGB5, PORT_D1RGB5_AS_EBIF_AD00);
000010  e3a01002          MOV      r1,#2
000014  e3a000a1          MOV      r0,#0xa1
000018  ebfffffe          BL       i32GPIO_SetPinFunction
;;;367        i32GPIO_EnablePullUp(PORT_D1RGB5, GPIO_DISABLE);
00001c  e3a01000          MOV      r1,#0
000020  e3a000a1          MOV      r0,#0xa1
000024  ebfffffe          BL       i32GPIO_EnablePullUp
;;;368        i32GPIO_SetOutputResistance(PORT_D1RGB5, GPIO_OUTPUT_RESISTANCE_50);
000028  e3a01001          MOV      r1,#1
00002c  e3a000a1          MOV      r0,#0xa1
000030  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;369        // EBIF_AD01 
;;;370        i32GPIO_EnableLatchFunction(PORT_D1RGB6, GPIO_DISABLE);
000034  e3a01000          MOV      r1,#0
000038  e3a000a2          MOV      r0,#0xa2
00003c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;371        i32GPIO_SetPinFunction(PORT_D1RGB6, PORT_D1RGB6_AS_EBIF_AD01);
000040  e3a01002          MOV      r1,#2
000044  e3a000a2          MOV      r0,#0xa2
000048  ebfffffe          BL       i32GPIO_SetPinFunction
;;;372        i32GPIO_EnablePullUp(PORT_D1RGB6, GPIO_DISABLE);
00004c  e3a01000          MOV      r1,#0
000050  e3a000a2          MOV      r0,#0xa2
000054  ebfffffe          BL       i32GPIO_EnablePullUp
;;;373        i32GPIO_SetOutputResistance(PORT_D1RGB6, GPIO_OUTPUT_RESISTANCE_50);
000058  e3a01001          MOV      r1,#1
00005c  e3a000a2          MOV      r0,#0xa2
000060  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;374        // EBIF_AD02 
;;;375        i32GPIO_EnableLatchFunction(PORT_D1RGB7, GPIO_DISABLE);
000064  e3a01000          MOV      r1,#0
000068  e3a000a3          MOV      r0,#0xa3
00006c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;376        i32GPIO_SetPinFunction(PORT_D1RGB7, PORT_D1RGB7_AS_EBIF_AD02);
000070  e3a01002          MOV      r1,#2
000074  e3a000a3          MOV      r0,#0xa3
000078  ebfffffe          BL       i32GPIO_SetPinFunction
;;;377        i32GPIO_EnablePullUp(PORT_D1RGB7, GPIO_DISABLE);
00007c  e3a01000          MOV      r1,#0
000080  e3a000a3          MOV      r0,#0xa3
000084  ebfffffe          BL       i32GPIO_EnablePullUp
;;;378        i32GPIO_SetOutputResistance(PORT_D1RGB7, GPIO_OUTPUT_RESISTANCE_50);
000088  e3a01001          MOV      r1,#1
00008c  e3a000a3          MOV      r0,#0xa3
000090  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;379        // EBIF_AD03 
;;;380        i32GPIO_EnableLatchFunction(PORT_D1RGB8, GPIO_DISABLE);
000094  e3a01000          MOV      r1,#0
000098  e3a000a4          MOV      r0,#0xa4
00009c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;381        i32GPIO_SetPinFunction(PORT_D1RGB8, PORT_D1RGB8_AS_EBIF_AD03);
0000a0  e3a01002          MOV      r1,#2
0000a4  e3a000a4          MOV      r0,#0xa4
0000a8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;382        i32GPIO_EnablePullUp(PORT_D1RGB8, GPIO_DISABLE);
0000ac  e3a01000          MOV      r1,#0
0000b0  e3a000a4          MOV      r0,#0xa4
0000b4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;383        i32GPIO_SetOutputResistance(PORT_D1RGB8, GPIO_OUTPUT_RESISTANCE_50);
0000b8  e3a01001          MOV      r1,#1
0000bc  e3a000a4          MOV      r0,#0xa4
0000c0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;384        // EBIF_AD04
;;;385        i32GPIO_EnableLatchFunction(PORT_D1RGB9, GPIO_DISABLE);
0000c4  e3a01000          MOV      r1,#0
0000c8  e3a000a5          MOV      r0,#0xa5
0000cc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;386        i32GPIO_SetPinFunction(PORT_D1RGB9, PORT_D1RGB9_AS_EBIF_AD04);
0000d0  e3a01002          MOV      r1,#2
0000d4  e3a000a5          MOV      r0,#0xa5
0000d8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;387        i32GPIO_EnablePullUp(PORT_D1RGB9, GPIO_DISABLE);
0000dc  e3a01000          MOV      r1,#0
0000e0  e3a000a5          MOV      r0,#0xa5
0000e4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;388        i32GPIO_SetOutputResistance(PORT_D1RGB9, GPIO_OUTPUT_RESISTANCE_50);
0000e8  e3a01001          MOV      r1,#1
0000ec  e3a000a5          MOV      r0,#0xa5
0000f0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;389        // EBIF_AD05
;;;390        i32GPIO_EnableLatchFunction(PORT_D1RGB10, GPIO_DISABLE);
0000f4  e3a01000          MOV      r1,#0
0000f8  e3a000a6          MOV      r0,#0xa6
0000fc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;391        i32GPIO_SetPinFunction(PORT_D1RGB10, PORT_D1RGB10_AS_EBIF_AD05);
000100  e3a01002          MOV      r1,#2
000104  e3a000a6          MOV      r0,#0xa6
000108  ebfffffe          BL       i32GPIO_SetPinFunction
;;;392        i32GPIO_EnablePullUp(PORT_D1RGB10, GPIO_DISABLE);
00010c  e3a01000          MOV      r1,#0
000110  e3a000a6          MOV      r0,#0xa6
000114  ebfffffe          BL       i32GPIO_EnablePullUp
;;;393        i32GPIO_SetOutputResistance(PORT_D1RGB10, GPIO_OUTPUT_RESISTANCE_50);
000118  e3a01001          MOV      r1,#1
00011c  e3a000a6          MOV      r0,#0xa6
000120  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;394        // EBIF_AD06
;;;395        i32GPIO_EnableLatchFunction(PORT_D1RGB11, GPIO_DISABLE);
000124  e3a01000          MOV      r1,#0
000128  e3a000a7          MOV      r0,#0xa7
00012c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;396        i32GPIO_SetPinFunction(PORT_D1RGB11, PORT_D1RGB11_AS_EBIF_AD06);
000130  e3a01002          MOV      r1,#2
000134  e3a000a7          MOV      r0,#0xa7
000138  ebfffffe          BL       i32GPIO_SetPinFunction
;;;397        i32GPIO_EnablePullUp(PORT_D1RGB11, GPIO_DISABLE);
00013c  e3a01000          MOV      r1,#0
000140  e3a000a7          MOV      r0,#0xa7
000144  ebfffffe          BL       i32GPIO_EnablePullUp
;;;398        i32GPIO_SetOutputResistance(PORT_D1RGB11, GPIO_OUTPUT_RESISTANCE_50);
000148  e3a01001          MOV      r1,#1
00014c  e3a000a7          MOV      r0,#0xa7
000150  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;399        // EBIF_AD07
;;;400        i32GPIO_EnableLatchFunction(PORT_D1RGB12, GPIO_DISABLE);
000154  e3a01000          MOV      r1,#0
000158  e3a000a8          MOV      r0,#0xa8
00015c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;401        i32GPIO_SetPinFunction(PORT_D1RGB12, PORT_D1RGB12_AS_EBIF_AD07);
000160  e3a01002          MOV      r1,#2
000164  e3a000a8          MOV      r0,#0xa8
000168  ebfffffe          BL       i32GPIO_SetPinFunction
;;;402        i32GPIO_EnablePullUp(PORT_D1RGB12, GPIO_DISABLE);
00016c  e3a01000          MOV      r1,#0
000170  e3a000a8          MOV      r0,#0xa8
000174  ebfffffe          BL       i32GPIO_EnablePullUp
;;;403        i32GPIO_SetOutputResistance(PORT_D1RGB12, GPIO_OUTPUT_RESISTANCE_50);
000178  e3a01001          MOV      r1,#1
00017c  e3a000a8          MOV      r0,#0xa8
000180  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;404        // EBIF_AD08
;;;405        i32GPIO_EnableLatchFunction(PORT_D1RGB13, GPIO_DISABLE);
000184  e3a01000          MOV      r1,#0
000188  e3a000a9          MOV      r0,#0xa9
00018c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;406        i32GPIO_SetPinFunction(PORT_D1RGB13, PORT_D1RGB13_AS_EBIF_AD08);
000190  e3a01002          MOV      r1,#2
000194  e3a000a9          MOV      r0,#0xa9
000198  ebfffffe          BL       i32GPIO_SetPinFunction
;;;407        i32GPIO_EnablePullUp(PORT_D1RGB13, GPIO_DISABLE);
00019c  e3a01000          MOV      r1,#0
0001a0  e3a000a9          MOV      r0,#0xa9
0001a4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;408        i32GPIO_SetOutputResistance(PORT_D1RGB13, GPIO_OUTPUT_RESISTANCE_50);
0001a8  e3a01001          MOV      r1,#1
0001ac  e3a000a9          MOV      r0,#0xa9
0001b0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;409        // EBIF_AD09
;;;410        i32GPIO_EnableLatchFunction(PORT_D1RGB14, GPIO_DISABLE);
0001b4  e3a01000          MOV      r1,#0
0001b8  e3a000aa          MOV      r0,#0xaa
0001bc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;411        i32GPIO_SetPinFunction(PORT_D1RGB14, PORT_D1RGB14_AS_EBIF_AD09);
0001c0  e3a01002          MOV      r1,#2
0001c4  e3a000aa          MOV      r0,#0xaa
0001c8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;412        i32GPIO_EnablePullUp(PORT_D1RGB14, GPIO_DISABLE);
0001cc  e3a01000          MOV      r1,#0
0001d0  e3a000aa          MOV      r0,#0xaa
0001d4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;413        i32GPIO_SetOutputResistance(PORT_D1RGB14, GPIO_OUTPUT_RESISTANCE_50);
0001d8  e3a01001          MOV      r1,#1
0001dc  e3a000aa          MOV      r0,#0xaa
0001e0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;414        // EBIF_AD10
;;;415        i32GPIO_EnableLatchFunction(PORT_D1RGB15, GPIO_DISABLE);
0001e4  e3a01000          MOV      r1,#0
0001e8  e3a000ab          MOV      r0,#0xab
0001ec  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;416        i32GPIO_SetPinFunction(PORT_D1RGB15, PORT_D1RGB15_AS_EBIF_AD10);
0001f0  e3a01002          MOV      r1,#2
0001f4  e3a000ab          MOV      r0,#0xab
0001f8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;417        i32GPIO_EnablePullUp(PORT_D1RGB15, GPIO_DISABLE);
0001fc  e3a01000          MOV      r1,#0
000200  e3a000ab          MOV      r0,#0xab
000204  ebfffffe          BL       i32GPIO_EnablePullUp
;;;418        i32GPIO_SetOutputResistance(PORT_D1RGB15, GPIO_OUTPUT_RESISTANCE_50);
000208  e3a01001          MOV      r1,#1
00020c  e3a000ab          MOV      r0,#0xab
000210  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;419        // EBIF_AD11
;;;420        i32GPIO_EnableLatchFunction(PORT_D1RGB16, GPIO_DISABLE);
000214  e3a01000          MOV      r1,#0
000218  e3a000ac          MOV      r0,#0xac
00021c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;421        i32GPIO_SetPinFunction(PORT_D1RGB16, PORT_D1RGB16_AS_EBIF_AD11);
000220  e3a01002          MOV      r1,#2
000224  e3a000ac          MOV      r0,#0xac
000228  ebfffffe          BL       i32GPIO_SetPinFunction
;;;422        i32GPIO_EnablePullUp(PORT_D1RGB16, GPIO_DISABLE);
00022c  e3a01000          MOV      r1,#0
000230  e3a000ac          MOV      r0,#0xac
000234  ebfffffe          BL       i32GPIO_EnablePullUp
;;;423        i32GPIO_SetOutputResistance(PORT_D1RGB16, GPIO_OUTPUT_RESISTANCE_50);
000238  e3a01001          MOV      r1,#1
00023c  e3a000ac          MOV      r0,#0xac
000240  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;424        // EBIF_AD12
;;;425        i32GPIO_EnableLatchFunction(PORT_D1RGB17, GPIO_DISABLE);
000244  e3a01000          MOV      r1,#0
000248  e3a000ad          MOV      r0,#0xad
00024c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;426        i32GPIO_SetPinFunction(PORT_D1RGB17, PORT_D1RGB17_AS_EBIF_AD12);
000250  e3a01002          MOV      r1,#2
000254  e3a000ad          MOV      r0,#0xad
000258  ebfffffe          BL       i32GPIO_SetPinFunction
;;;427        i32GPIO_EnablePullUp(PORT_D1RGB17, GPIO_DISABLE);
00025c  e3a01000          MOV      r1,#0
000260  e3a000ad          MOV      r0,#0xad
000264  ebfffffe          BL       i32GPIO_EnablePullUp
;;;428        i32GPIO_SetOutputResistance(PORT_D1RGB17, GPIO_OUTPUT_RESISTANCE_50);
000268  e3a01001          MOV      r1,#1
00026c  e3a000ad          MOV      r0,#0xad
000270  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;429        // EBIF_AD13
;;;430        i32GPIO_EnableLatchFunction(PORT_D1RGB18, GPIO_DISABLE);
000274  e3a01000          MOV      r1,#0
000278  e3a000ae          MOV      r0,#0xae
00027c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;431        i32GPIO_SetPinFunction(PORT_D1RGB18, PORT_D1RGB18_AS_EBIF_AD13);
000280  e3a01002          MOV      r1,#2
000284  e3a000ae          MOV      r0,#0xae
000288  ebfffffe          BL       i32GPIO_SetPinFunction
;;;432        i32GPIO_EnablePullUp(PORT_D1RGB18, GPIO_DISABLE);
00028c  e3a01000          MOV      r1,#0
000290  e3a000ae          MOV      r0,#0xae
000294  ebfffffe          BL       i32GPIO_EnablePullUp
;;;433        i32GPIO_SetOutputResistance(PORT_D1RGB18, GPIO_OUTPUT_RESISTANCE_50);
000298  e3a01001          MOV      r1,#1
00029c  e3a000ae          MOV      r0,#0xae
0002a0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;434        // EBIF_AD14
;;;435        i32GPIO_EnableLatchFunction(PORT_D1RGB19, GPIO_DISABLE);
0002a4  e3a01000          MOV      r1,#0
0002a8  e3a000af          MOV      r0,#0xaf
0002ac  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;436        i32GPIO_SetPinFunction(PORT_D1RGB19, PORT_D1RGB19_AS_EBIF_AD14);
0002b0  e3a01002          MOV      r1,#2
0002b4  e3a000af          MOV      r0,#0xaf
0002b8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;437        i32GPIO_EnablePullUp(PORT_D1RGB19, GPIO_DISABLE);
0002bc  e3a01000          MOV      r1,#0
0002c0  e3a000af          MOV      r0,#0xaf
0002c4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;438        i32GPIO_SetOutputResistance(PORT_D1RGB19, GPIO_OUTPUT_RESISTANCE_50);
0002c8  e3a01001          MOV      r1,#1
0002cc  e3a000af          MOV      r0,#0xaf
0002d0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;439        // EBIF_AD15
;;;440        i32GPIO_EnableLatchFunction(PORT_D1RGB20, GPIO_DISABLE);
0002d4  e3a01000          MOV      r1,#0
0002d8  e3a000b0          MOV      r0,#0xb0
0002dc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;441        i32GPIO_SetPinFunction(PORT_D1RGB20, PORT_D1RGB20_AS_EBIF_AD15);
0002e0  e3a01002          MOV      r1,#2
0002e4  e3a000b0          MOV      r0,#0xb0
0002e8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;442        i32GPIO_EnablePullUp(PORT_D1RGB20, GPIO_DISABLE);
0002ec  e3a01000          MOV      r1,#0
0002f0  e3a000b0          MOV      r0,#0xb0
0002f4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;443        i32GPIO_SetOutputResistance(PORT_D1RGB20, GPIO_OUTPUT_RESISTANCE_50);
0002f8  e3a01001          MOV      r1,#1
0002fc  e3a000b0          MOV      r0,#0xb0
000300  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;444        // EBIF_AEX0
;;;445        i32GPIO_EnableLatchFunction(PORT_D1RGB21, GPIO_DISABLE);
000304  e3a01000          MOV      r1,#0
000308  e3a000b1          MOV      r0,#0xb1
00030c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;446        i32GPIO_SetPinFunction(PORT_D1RGB21, PORT_D1RGB21_AS_EBIF_AEX0);
000310  e3a01002          MOV      r1,#2
000314  e3a000b1          MOV      r0,#0xb1
000318  ebfffffe          BL       i32GPIO_SetPinFunction
;;;447        i32GPIO_EnablePullUp(PORT_D1RGB21, GPIO_DISABLE);
00031c  e3a01000          MOV      r1,#0
000320  e3a000b1          MOV      r0,#0xb1
000324  ebfffffe          BL       i32GPIO_EnablePullUp
;;;448        i32GPIO_SetOutputResistance(PORT_D1RGB21, GPIO_OUTPUT_RESISTANCE_50);
000328  e3a01001          MOV      r1,#1
00032c  e3a000b1          MOV      r0,#0xb1
000330  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;449        // EBIF_AEX1
;;;450        i32GPIO_EnableLatchFunction(PORT_D1RGB22, GPIO_DISABLE);
000334  e3a01000          MOV      r1,#0
000338  e3a000b2          MOV      r0,#0xb2
00033c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;451        i32GPIO_SetPinFunction(PORT_D1RGB22, PORT_D1RGB22_AS_EBIF_AEX1);
000340  e3a01002          MOV      r1,#2
000344  e3a000b2          MOV      r0,#0xb2
000348  ebfffffe          BL       i32GPIO_SetPinFunction
;;;452        i32GPIO_EnablePullUp(PORT_D1RGB22, GPIO_DISABLE);
00034c  e3a01000          MOV      r1,#0
000350  e3a000b2          MOV      r0,#0xb2
000354  ebfffffe          BL       i32GPIO_EnablePullUp
;;;453        i32GPIO_SetOutputResistance(PORT_D1RGB22, GPIO_OUTPUT_RESISTANCE_50);
000358  e3a01001          MOV      r1,#1
00035c  e3a000b2          MOV      r0,#0xb2
000360  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;454        // EBIF_AEX2
;;;455        i32GPIO_EnableLatchFunction(PORT_D1RGB23, GPIO_DISABLE);
000364  e3a01000          MOV      r1,#0
000368  e3a000b3          MOV      r0,#0xb3
00036c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;456        i32GPIO_SetPinFunction(PORT_D1RGB23, PORT_D1RGB23_AS_EBIF_AEX2);
000370  e3a01002          MOV      r1,#2
000374  e3a000b3          MOV      r0,#0xb3
000378  ebfffffe          BL       i32GPIO_SetPinFunction
;;;457        i32GPIO_EnablePullUp(PORT_D1RGB23, GPIO_DISABLE);
00037c  e3a01000          MOV      r1,#0
000380  e3a000b3          MOV      r0,#0xb3
000384  ebfffffe          BL       i32GPIO_EnablePullUp
;;;458        i32GPIO_SetOutputResistance(PORT_D1RGB23, GPIO_OUTPUT_RESISTANCE_50);
000388  e3a01001          MOV      r1,#1
00038c  e3a000b3          MOV      r0,#0xb3
000390  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;459        // EBIF_AEX3
;;;460        i32GPIO_EnableLatchFunction(PORT_D1HDISP, GPIO_DISABLE);
000394  e3a01000          MOV      r1,#0
000398  e3a00098          MOV      r0,#0x98
00039c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;461        i32GPIO_SetPinFunction(PORT_D1HDISP, PORT_D1HDISP_AS_EBIF_AEX3);
0003a0  e3a01002          MOV      r1,#2
0003a4  e3a00098          MOV      r0,#0x98
0003a8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;462        i32GPIO_EnablePullUp(PORT_D1HDISP, GPIO_DISABLE);
0003ac  e3a01000          MOV      r1,#0
0003b0  e3a00098          MOV      r0,#0x98
0003b4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;463        i32GPIO_SetOutputResistance(PORT_D1HDISP, GPIO_OUTPUT_RESISTANCE_50);
0003b8  e3a01001          MOV      r1,#1
0003bc  e3a00098          MOV      r0,#0x98
0003c0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;464        // EBIF_AEX4
;;;465        i32GPIO_EnableLatchFunction(PORT_D1HSYNC, GPIO_DISABLE);
0003c4  e3a01000          MOV      r1,#0
0003c8  e3a00099          MOV      r0,#0x99
0003cc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;466        i32GPIO_SetPinFunction(PORT_D1HSYNC, PORT_D1HSYNC_AS_EBIF_AEX4);
0003d0  e3a01002          MOV      r1,#2
0003d4  e3a00099          MOV      r0,#0x99
0003d8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;467        i32GPIO_EnablePullUp(PORT_D1HSYNC, GPIO_DISABLE);
0003dc  e3a01000          MOV      r1,#0
0003e0  e3a00099          MOV      r0,#0x99
0003e4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;468        i32GPIO_SetOutputResistance(PORT_D1HSYNC, GPIO_OUTPUT_RESISTANCE_50);
0003e8  e3a01001          MOV      r1,#1
0003ec  e3a00099          MOV      r0,#0x99
0003f0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;469        // EBIF_AEX5
;;;470        i32GPIO_EnableLatchFunction(PORT_D1VSYNC, GPIO_DISABLE);
0003f4  e3a01000          MOV      r1,#0
0003f8  e3a0009a          MOV      r0,#0x9a
0003fc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;471        i32GPIO_SetPinFunction(PORT_D1VSYNC, PORT_D1VSYNC_AS_EBIF_AEX5);
000400  e3a01002          MOV      r1,#2
000404  e3a0009a          MOV      r0,#0x9a
000408  ebfffffe          BL       i32GPIO_SetPinFunction
;;;472        i32GPIO_EnablePullUp(PORT_D1VSYNC, GPIO_DISABLE);
00040c  e3a01000          MOV      r1,#0
000410  e3a0009a          MOV      r0,#0x9a
000414  ebfffffe          BL       i32GPIO_EnablePullUp
;;;473        i32GPIO_SetOutputResistance(PORT_D1VSYNC, GPIO_OUTPUT_RESISTANCE_50);
000418  e3a01001          MOV      r1,#1
00041c  e3a0009a          MOV      r0,#0x9a
000420  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;474        // EBIF_ALE
;;;475        i32GPIO_EnableLatchFunction(PORT_D1RGB0, GPIO_DISABLE);
000424  e3a01000          MOV      r1,#0
000428  e3a0009c          MOV      r0,#0x9c
00042c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;476        i32GPIO_SetPinFunction(PORT_D1RGB0, PORT_D1RGB0_AS_EBIF_ALE);
000430  e3a01003          MOV      r1,#3
000434  e3a0009c          MOV      r0,#0x9c
000438  ebfffffe          BL       i32GPIO_SetPinFunction
;;;477        i32GPIO_EnablePullUp(PORT_D1RGB0, GPIO_DISABLE);
00043c  e3a01000          MOV      r1,#0
000440  e3a0009c          MOV      r0,#0x9c
000444  ebfffffe          BL       i32GPIO_EnablePullUp
;;;478        i32GPIO_SetOutputResistance(PORT_D1RGB0, GPIO_OUTPUT_RESISTANCE_50);
000448  e3a01001          MOV      r1,#1
00044c  e3a0009c          MOV      r0,#0x9c
000450  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;479        // EBIF_CS0
;;;480        i32GPIO_EnableLatchFunction(PORT_D1RGB1, GPIO_DISABLE);
000454  e3a01000          MOV      r1,#0
000458  e3a0009d          MOV      r0,#0x9d
00045c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;481        i32GPIO_SetPinFunction(PORT_D1RGB1, PORT_D1RGB1_AS_EBIF_CS0);
000460  e3a01002          MOV      r1,#2
000464  e3a0009d          MOV      r0,#0x9d
000468  ebfffffe          BL       i32GPIO_SetPinFunction
;;;482        i32GPIO_EnablePullUp(PORT_D1RGB1, GPIO_DISABLE);
00046c  e3a01000          MOV      r1,#0
000470  e3a0009d          MOV      r0,#0x9d
000474  ebfffffe          BL       i32GPIO_EnablePullUp
;;;483        i32GPIO_SetOutputResistance(PORT_D1RGB1, GPIO_OUTPUT_RESISTANCE_50);
000478  e3a01001          MOV      r1,#1
00047c  e3a0009d          MOV      r0,#0x9d
000480  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;484        // EBIF_OE
;;;485        i32GPIO_EnableLatchFunction(PORT_D1RGB3, GPIO_DISABLE);
000484  e3a01000          MOV      r1,#0
000488  e3a0009f          MOV      r0,#0x9f
00048c  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;486        i32GPIO_SetPinFunction(PORT_D1RGB3, PORT_D1RGB3_AS_EBIF_OE);
000490  e3a01002          MOV      r1,#2
000494  e3a0009f          MOV      r0,#0x9f
000498  ebfffffe          BL       i32GPIO_SetPinFunction
;;;487        i32GPIO_EnablePullUp(PORT_D1RGB3, GPIO_DISABLE);
00049c  e3a01000          MOV      r1,#0
0004a0  e3a0009f          MOV      r0,#0x9f
0004a4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;488        i32GPIO_SetOutputResistance(PORT_D1RGB3, GPIO_OUTPUT_RESISTANCE_50);
0004a8  e3a01001          MOV      r1,#1
0004ac  e3a0009f          MOV      r0,#0x9f
0004b0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;489        // EBIF_WE
;;;490        i32GPIO_EnableLatchFunction(PORT_D1RGB4, GPIO_DISABLE);
0004b4  e3a01000          MOV      r1,#0
0004b8  e3a000a0          MOV      r0,#0xa0
0004bc  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;491        i32GPIO_SetPinFunction(PORT_D1RGB4, PORT_D1RGB4_AS_EBIF_WE);
0004c0  e3a01002          MOV      r1,#2
0004c4  e3a000a0          MOV      r0,#0xa0
0004c8  ebfffffe          BL       i32GPIO_SetPinFunction
;;;492        i32GPIO_EnablePullUp(PORT_D1RGB4, GPIO_DISABLE);
0004cc  e3a01000          MOV      r1,#0
0004d0  e3a000a0          MOV      r0,#0xa0
0004d4  ebfffffe          BL       i32GPIO_EnablePullUp
;;;493        i32GPIO_SetOutputResistance(PORT_D1RGB4, GPIO_OUTPUT_RESISTANCE_50);
0004d8  e3a01001          MOV      r1,#1
0004dc  e3a000a0          MOV      r0,#0xa0
0004e0  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;494        // EBIF_WAITN
;;;495        i32GPIO_EnableLatchFunction(PORT_D1RGB2, GPIO_DISABLE);
0004e4  e3a01000          MOV      r1,#0
0004e8  e3a0009e          MOV      r0,#0x9e
0004ec  ebfffffe          BL       i32GPIO_EnableLatchFunction
;;;496        i32GPIO_EnablePullUp(PORT_D1RGB2, GPIO_DISABLE);
0004f0  e3a01000          MOV      r1,#0
0004f4  e3a0009e          MOV      r0,#0x9e
0004f8  ebfffffe          BL       i32GPIO_EnablePullUp
;;;497        i32GPIO_SetOutputResistance(PORT_D1RGB2, GPIO_OUTPUT_RESISTANCE_50);
0004fc  e3a01001          MOV      r1,#1
000500  e3a0009e          MOV      r0,#0x9e
000504  ebfffffe          BL       i32GPIO_SetOutputResistance
;;;498    }
000508  e8bd8010          POP      {r4,pc}
;;;499    
                          ENDP

                  initCLED PROC
;;;92     
;;;93     void initCLED(void)
00050c  e92d4ef0          PUSH     {r4-r7,r9-r11,lr}
;;;94     {
000510  e24dd028          SUB      sp,sp,#0x28
;;;95         unsigned long long ReadVal32;
;;;96         volatile unsigned long  *pWord;
;;;97         unsigned long  wrWord;
;;;98         unsigned long set_burst_align;
;;;99         unsigned long set_bls;
;;;100        unsigned long set_adv;
;;;101        unsigned long set_baa;
;;;102        unsigned long set_wr_bl;
;;;103        unsigned long set_wr_sync;
;;;104        unsigned long set_rd_bl;
;;;105        unsigned long set_rd_sync;
;;;106        unsigned long set_mw;
;;;107      
;;;108        unsigned long chip_select;
;;;109        unsigned long cmd_type;
;;;110        unsigned long set_cre;
;;;111        unsigned long cmd_addr_match;
;;;112    
;;;113        // setup Interface GDC1 for NOR Flash
;;;114        setNORflash_interface_gdc1();
000514  ebfffffe          BL       setNORflash_interface_gdc1
;;;115    
;;;116        // All chip select must be configured otherwise reset ("0") values will generate
;;;117        // chip select constantly
;;;118        //Program Interface 0 CCR with 2 chips selects. Chip0 -> first 256Mbit, 
;;;119        //Chip1 -> second 256Mbit
;;;120    
;;;121        CCR_KEYR  = 0xA5C0F17B; // unlock SYSC registers
000518  e59f0534          LDR      r0,|L1.2644|
00051c  e3a01103          MOV      r1,#0xc0000000
000520  e5810000          STR      r0,[r1,#0]
;;;122        //CCR Match and MASK to interface 0
;;;123        pWord    =  (volatile unsigned long *) CCR_GENERIC_REG2;  
000524  e281406c          ADD      r4,r1,#0x6c
;;;124        wrWord   = NOR_MATCH0_1 + NOR_MASK0_1 + NOR_MATCH0_0 + NOR_MASK0_0; 
000528  e59f5528          LDR      r5,|L1.2648|
;;;125        *pWord   = wrWord; 
00052c  e5845000          STR      r5,[r4,#0]
;;;126    
;;;127        //Program Interface 1 CCR with 2 chips selects. 
;;;128        //with valid values
;;;129        CCR_KEYR = 0xA5C0F17B; // unlock SYSC registers
000530  e5810000          STR      r0,[r1,#0]
;;;130        //CCR Match and MASK to interface 1
;;;131        pWord  = (volatile unsigned long *) CCR_GENERIC_REG3;  
000534  e2814070          ADD      r4,r1,#0x70
;;;132        wrWord = NAND_MATCH1_1 + NAND_MASK1_1 + NAND_MATCH1_0 + NAND_MASK1_0; 
000538  e59f551c          LDR      r5,|L1.2652|
;;;133        *pWord = wrWord; 
00053c  e5845000          STR      r5,[r4,#0]
;;;134    
;;;135        // reconfigure reserved_m clock to 
;;;136        *(volatile unsigned int*)(SYSC) = 0xA5C0F17B;
000540  e5810000          STR      r0,[r1,#0]
;;;137        *(volatile unsigned short*)(SYSC+0x000E) = 1024;
000544  e3000400          MOVW     r0,#0x400
000548  e1c100be          STRH     r0,[r1,#0xe]
;;;138    
;;;139        //SRAM_CYCLES0_0 
;;;140        pWord     = (volatile unsigned long *) (PL353 + NOR_CHIP0);
00054c  e59f450c          LDR      r4,|L1.2656|
;;;141        ReadVal32 = *pWord;
000550  e5947000          LDR      r7,[r4,#0]
000554  e2400eb1          SUB      r0,r0,#0xb10
000558  e0071000          AND      r1,r7,r0
00055c  e300010f          MOV      r0,#0x10f
000560  e1800001          ORR      r0,r0,r1
;;;142        SET_CYCLE  = (ReadVal32 & 0xFFFFF8F0) | 0x0000010F; // we_time = 0, t_ceoe = 1, t_rc = 15
000564  e2441c01          SUB      r1,r4,#0x100
000568  e5810014          STR      r0,[r1,#0x14]
;;;143      
;;;144        // user_status
;;;145        pWord     = (volatile unsigned long *) (PL353 + 0x200);
00056c  e2814c02          ADD      r4,r1,#0x200
;;;146        ReadVal32 = *pWord;
000570  e5940000          LDR      r0,[r4,#0]
;;;147    
;;;148        //            set_burst_align set_bls set_adv set_baa set_wr_bl set_wr_sync set_rd_bl set_rd_sync  mw
;;;149        //set_opmode {[15:13],        [12],   [11],   [10],   [9:7],    [6],        [5:3],    [2],         [1:0]},
;;;150        set_burst_align =  0x0000 << 13;
000574  e3a00000          MOV      r0,#0
000578  e58d0024          STR      r0,[sp,#0x24]
;;;151        set_bls         =  0x0000 << 12;
00057c  e58d0020          STR      r0,[sp,#0x20]
;;;152        set_adv         =  0x0000 << 11;  // a MUST
000580  e58d001c          STR      r0,[sp,#0x1c]
;;;153        set_baa         =  0x0000 << 10;
000584  e58d0018          STR      r0,[sp,#0x18]
;;;154        set_wr_bl       =  0x0000 << 7;
000588  e58d0014          STR      r0,[sp,#0x14]
;;;155        set_wr_sync     =  0x0000 << 6;
00058c  e58d0010          STR      r0,[sp,#0x10]
;;;156        set_rd_bl       =  0x0000 << 3;
000590  e58d000c          STR      r0,[sp,#0xc]
;;;157        set_rd_sync     =  0x0000 << 2;    // QPSIO _CLK gets clk_out when set 1 (eyeball this once and it worked along with fb_clk) 
000594  e58d0008          STR      r0,[sp,#8]
;;;158        set_mw          =  0x0001; 
000598  e3a00001          MOV      r0,#1
00059c  e58d0004          STR      r0,[sp,#4]
;;;159        SET_OPMODE_REG  =  set_burst_align + set_bls + set_adv + set_baa + set_wr_bl + set_wr_sync + set_rd_bl + set_rd_sync + set_mw; 
0005a0  e59d0024          LDR      r0,[sp,#0x24]
0005a4  e59d1020          LDR      r1,[sp,#0x20]
0005a8  e0811000          ADD      r1,r1,r0
0005ac  e59d001c          LDR      r0,[sp,#0x1c]
0005b0  e0811000          ADD      r1,r1,r0
0005b4  e59d0018          LDR      r0,[sp,#0x18]
0005b8  e0811000          ADD      r1,r1,r0
0005bc  e59d0014          LDR      r0,[sp,#0x14]
0005c0  e0811000          ADD      r1,r1,r0
0005c4  e59d0010          LDR      r0,[sp,#0x10]
0005c8  e0811000          ADD      r1,r1,r0
0005cc  e59d000c          LDR      r0,[sp,#0xc]
0005d0  e0811000          ADD      r1,r1,r0
0005d4  e59d0008          LDR      r0,[sp,#8]
0005d8  e0811000          ADD      r1,r1,r0
0005dc  e59d0004          LDR      r0,[sp,#4]
0005e0  e0800001          ADD      r0,r0,r1
0005e4  e2441c02          SUB      r1,r4,#0x200
0005e8  e5810018          STR      r0,[r1,#0x18]
;;;160    
;;;161        //program direct commmand register to update opmode settings 
;;;162        chip_select    = 0x0000 << 23;  // interface 0 chip 0
0005ec  e3a06000          MOV      r6,#0
;;;163        cmd_type       = 0x0002 << 21;  // UpdateReg
0005f0  e3a09501          MOV      r9,#0x400000
;;;164        set_cre        = 0x0000 << 20;  // NA
0005f4  e3a0a000          MOV      r10,#0
;;;165        cmd_addr_match = 0x0000;        // NA in UpdateReg
0005f8  e3a0b000          MOV      r11,#0
;;;166    
;;;167        SET_DIRECT_CMD_REG = chip_select + cmd_type + set_cre + cmd_addr_match;
0005fc  e0860009          ADD      r0,r6,r9
000600  e080000a          ADD      r0,r0,r10
000604  e080000b          ADD      r0,r0,r11
000608  e5810010          STR      r0,[r1,#0x10]
;;;168    
;;;169        //SRAM_CYCLES0_1 
;;;170        pWord     = (volatile unsigned long *) (PL353 + NOR_CHIP1);
00060c  e2814e12          ADD      r4,r1,#0x120
;;;171        ReadVal32 = *pWord;
000610  e5947000          LDR      r7,[r4,#0]
000614  e2460e71          SUB      r0,r6,#0x710
000618  e0000007          AND      r0,r0,r7
00061c  e300110f          MOV      r1,#0x10f
000620  e1800001          ORR      r0,r0,r1
;;;172        SET_CYCLE = (ReadVal32 & 0xFFFFF8F0) | 0x0000010F; // we_time = 0, t_ceoe = 1, t_rc = 15
000624  e1c41281          BIC      r1,r4,r1,LSL #5
000628  e5810014          STR      r0,[r1,#0x14]
;;;173    
;;;174        chip_select = 0x0001 << 23;  // interface 0 chip 1
00062c  e3a06502          MOV      r6,#0x800000
;;;175        SET_DIRECT_CMD_REG = chip_select + cmd_type + set_cre + cmd_addr_match;
000630  e0860009          ADD      r0,r6,r9
000634  e080000a          ADD      r0,r0,r10
000638  e080000b          ADD      r0,r0,r11
00063c  e5810010          STR      r0,[r1,#0x10]
;;;176    
;;;177        //opmode0_0 
;;;178        pWord     = (volatile unsigned long *) (PL353 + NOR_CHIP0 + 4);
000640  e2814f41          ADD      r4,r1,#0x104
;;;179        ReadVal32 = *pWord;
000644  e5940000          LDR      r0,[r4,#0]
;;;180       
;;;181        //opmode0_1 
;;;182        pWord     = (volatile unsigned long *) (PL353 + NOR_CHIP1 + 4);
000648  e2814f49          ADD      r4,r1,#0x124
;;;183        ReadVal32 = *pWord;
00064c  e5940000          LDR      r0,[r4,#0]
;;;184    }
000650  e28dd028          ADD      sp,sp,#0x28
000654  e8bd8ef0          POP      {r4-r7,r9-r11,pc}
;;;185    
                          ENDP

                  setCLED PROC
;;;188    
;;;189    void setCLED(char *text)
000658  e92d4070          PUSH     {r4-r6,lr}
;;;190    {
00065c  e1a05000          MOV      r5,r0
;;;191        int i=0;
000660  e3a04000          MOV      r4,#0
;;;192        int size = strlen(text);
000664  e1a00005          MOV      r0,r5
000668  ebfffffe          BL       strlen
00066c  e1a06000          MOV      r6,r0
;;;193        if(size>8) size = 8;
000670  e3560008          CMP      r6,#8
000674  da000000          BLE      |L1.1660|
000678  e3a06008          MOV      r6,#8
                  |L1.1660|
;;;194    
;;;195        // blank display
;;;196        for(i=0;i<8;i++)
00067c  e3a04000          MOV      r4,#0
000680  ea000006          B        |L1.1696|
                  |L1.1668|
;;;197        {
;;;198            *(volatile unsigned short*) (CHIP0_ADDRESS + (0x38 + i << 1)) = ' ';
000684  e3a00020          MOV      r0,#0x20
000688  e2841038          ADD      r1,r4,#0x38
00068c  e1a01081          LSL      r1,r1,#1
000690  e2811203          ADD      r1,r1,#0x30000000
000694  e1c100b0          STRH     r0,[r1,#0]
;;;199            __DSB();
000698  ebfffffe          BL       __DSB
00069c  e2844001          ADD      r4,r4,#1              ;196
                  |L1.1696|
0006a0  e3540008          CMP      r4,#8                 ;196
0006a4  bafffff6          BLT      |L1.1668|
;;;200        }
;;;201    
;;;202        // put text on display right handed
;;;203        for(i=0;i<size;i++)
0006a8  e3a04000          MOV      r4,#0
0006ac  ea000006          B        |L1.1740|
                  |L1.1712|
;;;204        {
;;;205            *(volatile unsigned short*) (CHIP0_ADDRESS + (0x38 + i << 1)) = text[i];
0006b0  e7d50004          LDRB     r0,[r5,r4]
0006b4  e2841038          ADD      r1,r4,#0x38
0006b8  e1a01081          LSL      r1,r1,#1
0006bc  e2811203          ADD      r1,r1,#0x30000000
0006c0  e1c100b0          STRH     r0,[r1,#0]
;;;206            __DSB();
0006c4  ebfffffe          BL       __DSB
0006c8  e2844001          ADD      r4,r4,#1              ;203
                  |L1.1740|
0006cc  e1540006          CMP      r4,r6                 ;203
0006d0  bafffff6          BLT      |L1.1712|
;;;207        }
;;;208    }
0006d4  e8bd8070          POP      {r4-r6,pc}
;;;209    
                          ENDP

                  hexCLED PROC
;;;212    
;;;213    void hexCLED(unsigned long number)
0006d8  e1a02000          MOV      r2,r0
;;;214    {
;;;215        unsigned short i=0;
0006dc  e3a00000          MOV      r0,#0
;;;216        unsigned short charnum = 0;
0006e0  e3a01000          MOV      r1,#0
;;;217    
;;;218        // put number on display right handed
;;;219        for(i=0;i<8;i++)
0006e4  e320f000          NOP      
0006e8  ea00000e          B        |L1.1832|
                  |L1.1772|
;;;220        {
;;;221            charnum = ((number>>(28-i*4)) & 0x0000000f)+48;
0006ec  e3a0301c          MOV      r3,#0x1c
0006f0  e0433100          SUB      r3,r3,r0,LSL #2
0006f4  e1a03332          LSR      r3,r2,r3
0006f8  e203300f          AND      r3,r3,#0xf
0006fc  e2831030          ADD      r1,r3,#0x30
;;;222            if(charnum>48+9) charnum +=7;
000700  e3510039          CMP      r1,#0x39
000704  da000001          BLE      |L1.1808|
000708  e2813007          ADD      r3,r1,#7
00070c  e6ff1073          UXTH     r1,r3
                  |L1.1808|
;;;223            *(volatile unsigned short*) (CHIP0_ADDRESS + (0x38 + i << 1)) = charnum;
000710  e2803038          ADD      r3,r0,#0x38
000714  e1a03083          LSL      r3,r3,#1
000718  e2833203          ADD      r3,r3,#0x30000000
00071c  e1c310b0          STRH     r1,[r3,#0]
000720  e2803001          ADD      r3,r0,#1              ;219
000724  e6ff0073          UXTH     r0,r3                 ;219
                  |L1.1832|
000728  e3500008          CMP      r0,#8                 ;219
00072c  baffffee          BLT      |L1.1772|
;;;224        }
;;;225    }
000730  e12fff1e          BX       lr
;;;226    
                          ENDP

                  decCLED PROC
;;;229    
;;;230    void decCLED (unsigned long long text)
000734  e92d41f0          PUSH     {r4-r8,lr}
;;;231    {
000738  e1a04000          MOV      r4,r0
00073c  e1a05001          MOV      r5,r1
;;;232        int i=0;
000740  e3a06000          MOV      r6,#0
;;;233        unsigned int number = 0;
000744  e3a07000          MOV      r7,#0
;;;234        unsigned int unit = 112;    // "p"
000748  e3a08070          MOV      r8,#0x70
00074c  e59f0310          LDR      r0,|L1.2660|
000750  e0500004          SUBS     r0,r0,r4
000754  e2f50000          RSCS     r0,r5,#0
;;;235    
;;;236        if (text > 1000000000)
000758  2a000008          BCS      |L1.1920|
00075c  e59f2300          LDR      r2,|L1.2660|
000760  e3a03000          MOV      r3,#0
;;;237        {
;;;238            text = text / 1000000000;
000764  e1a00004          MOV      r0,r4
000768  e1a01005          MOV      r1,r5
00076c  ebfffffe          BL       __aeabi_uldivmod
000770  e1a04000          MOV      r4,r0
000774  e1a05001          MOV      r5,r1
;;;239            unit = 109;             // "m"
000778  e3a0806d          MOV      r8,#0x6d
00077c  ea000017          B        |L1.2016|
                  |L1.1920|
000780  e59f02e0          LDR      r0,|L1.2664|
000784  e0500004          SUBS     r0,r0,r4
000788  e2f50000          RSCS     r0,r5,#0
;;;240        }
;;;241        else if (text > 1000000)
00078c  2a000008          BCS      |L1.1972|
000790  e59f22d0          LDR      r2,|L1.2664|
000794  e3a03000          MOV      r3,#0
;;;242        {
;;;243            text = text / 1000000;
000798  e1a00004          MOV      r0,r4
00079c  e1a01005          MOV      r1,r5
0007a0  ebfffffe          BL       __aeabi_uldivmod
0007a4  e1a04000          MOV      r4,r0
0007a8  e1a05001          MOV      r5,r1
;;;244            unit = 117;             // "u"
0007ac  e3a08075          MOV      r8,#0x75
0007b0  ea00000a          B        |L1.2016|
                  |L1.1972|
0007b4  e2740ffa          RSBS     r0,r4,#0x3e8
0007b8  e2f50000          RSCS     r0,r5,#0
;;;245        }
;;;246        else if (text > 1000)
0007bc  2a000007          BCS      |L1.2016|
0007c0  e30023e8          MOVW     r2,#0x3e8
0007c4  e3a03000          MOV      r3,#0
;;;247        {
;;;248            text = text / 1000;
0007c8  e1a00004          MOV      r0,r4
0007cc  e1a01005          MOV      r1,r5
0007d0  ebfffffe          BL       __aeabi_uldivmod
0007d4  e1a04000          MOV      r4,r0
0007d8  e1a05001          MOV      r5,r1
;;;249            unit = 110;             // "n"
0007dc  e3a0806e          MOV      r8,#0x6e
                  |L1.2016|
;;;250        }
;;;251    
;;;252        *(volatile unsigned short*) (CHIP0_ADDRESS + (0x38 + 7 << 1)) = unit;
0007e0  e3a01203          MOV      r1,#0x30000000
0007e4  e1c187be          STRH     r8,[r1,#0x7e]
;;;253    
;;;254        // put text on display right-handed
;;;255        for(i=0;i<7;i++)
0007e8  e3a06000          MOV      r6,#0
0007ec  ea00001b          B        |L1.2144|
                  |L1.2032|
;;;256        {
;;;257            if (i == 0)
0007f0  e3560000          CMP      r6,#0
0007f4  1a000006          BNE      |L1.2068|
0007f8  e3a0200a          MOV      r2,#0xa
0007fc  e3a03000          MOV      r3,#0
;;;258                number = text % 10;
000800  e1a00004          MOV      r0,r4
000804  e1a01005          MOV      r1,r5
000808  ebfffffe          BL       __aeabi_uldivmod
00080c  e1a07002          MOV      r7,r2
000810  ea00000c          B        |L1.2120|
                  |L1.2068|
000814  e3a0200a          MOV      r2,#0xa
000818  e3a03000          MOV      r3,#0
;;;259            else
;;;260            {
;;;261                text = text / 10;
00081c  e1a00004          MOV      r0,r4
000820  e1a01005          MOV      r1,r5
000824  ebfffffe          BL       __aeabi_uldivmod
000828  e1a04000          MOV      r4,r0
00082c  e1a05001          MOV      r5,r1
000830  e3a0200a          MOV      r2,#0xa
000834  e3a03000          MOV      r3,#0
;;;262                number = text % 10;
000838  e1a00004          MOV      r0,r4
00083c  e1a01005          MOV      r1,r5
000840  ebfffffe          BL       __aeabi_uldivmod
000844  e1a07002          MOV      r7,r2
                  |L1.2120|
;;;263            }
;;;264    
;;;265            *(volatile unsigned short*) (CHIP0_ADDRESS + (0x38 + (6-i) << 1)) = number + 48;
000848  e2870030          ADD      r0,r7,#0x30
00084c  e266103e          RSB      r1,r6,#0x3e
000850  e1a01081          LSL      r1,r1,#1
000854  e2811203          ADD      r1,r1,#0x30000000
000858  e1c100b0          STRH     r0,[r1,#0]
00085c  e2866001          ADD      r6,r6,#1              ;255
                  |L1.2144|
000860  e3560007          CMP      r6,#7                 ;255
000864  baffffe1          BLT      |L1.2032|
;;;266        }
;;;267    }
000868  e8bd81f0          POP      {r4-r8,pc}
;;;268    
                          ENDP

                  disp_rtc_time_on_CLED PROC
;;;271    
;;;272    void disp_rtc_time_on_CLED (void)
00086c  e92d41f0          PUSH     {r4-r8,lr}
;;;273    {
;;;274         unsigned short   tt;
;;;275         unsigned char  read_val_8b, tt_c;
;;;276         unsigned long   time_1, time_2;
;;;277    
;;;278          //Read the timer 2 times and process only if both times got the same value
;;;279          time_1 = *(volatile unsigned long *) (0xC0001000);
000870  e59f01f4          LDR      r0,|L1.2668|
000874  e5908000          LDR      r8,[r0,#0]
;;;280          time_2 = *(volatile unsigned long *) (0xC0001000);
000878  e5907000          LDR      r7,[r0,#0]
;;;281          while (time_1 != time_2)
00087c  ea000002          B        |L1.2188|
                  |L1.2176|
;;;282          {
;;;283            time_1 = *(volatile unsigned long *) (0xC0001000);
000880  e59f01e4          LDR      r0,|L1.2668|
000884  e5908000          LDR      r8,[r0,#0]
;;;284            time_2 = *(volatile unsigned long *) (0xC0001000);
000888  e5907000          LDR      r7,[r0,#0]
                  |L1.2188|
00088c  e1580007          CMP      r8,r7                 ;281
000890  1afffffa          BNE      |L1.2176|
;;;285          } 
;;;286    
;;;287          //1. Display the seconds data
;;;288          tt=0;
000894  e3a04000          MOV      r4,#0
;;;289          //read_val_8b = *(volatile unsigned char *) (0xC0001000 + 0x00);
;;;290          read_val_8b = time_2;
000898  e20750ff          AND      r5,r7,#0xff
;;;291    
;;;292          tt = tt + (((read_val_8b >> 0) & 0x1 ) * 1 ) ;
00089c  e2050001          AND      r0,r5,#1
0008a0  e0844000          ADD      r4,r4,r0
;;;293          tt = tt + (((read_val_8b >> 1) & 0x1 ) * 2 ) ;
0008a4  e7e000d5          UBFX     r0,r5,#1,#1
0008a8  e0844080          ADD      r4,r4,r0,LSL #1
;;;294          tt = tt + (((read_val_8b >> 2) & 0x1 ) * 4 ) ;
0008ac  e7e00155          UBFX     r0,r5,#2,#1
0008b0  e0844100          ADD      r4,r4,r0,LSL #2
;;;295          tt = tt + (((read_val_8b >> 3) & 0x1 ) * 8 ) ;
0008b4  e7e001d5          UBFX     r0,r5,#3,#1
0008b8  e0844180          ADD      r4,r4,r0,LSL #3
;;;296          tt = tt + (((read_val_8b >> 4) & 0x1 ) * 10 ) ;
0008bc  e7e00255          UBFX     r0,r5,#4,#1
0008c0  e0800100          ADD      r0,r0,r0,LSL #2
0008c4  e0844080          ADD      r4,r4,r0,LSL #1
;;;297          tt = tt + (((read_val_8b >> 5) & 0x1 ) * 20 ) ;
0008c8  e7e002d5          UBFX     r0,r5,#5,#1
0008cc  e0800100          ADD      r0,r0,r0,LSL #2
0008d0  e0844100          ADD      r4,r4,r0,LSL #2
;;;298          tt = tt + (((read_val_8b >> 6) & 0x1 ) * 40 ) ;
0008d4  e7e00355          UBFX     r0,r5,#6,#1
0008d8  e0800100          ADD      r0,r0,r0,LSL #2
0008dc  e0844180          ADD      r4,r4,r0,LSL #3
;;;299    
;;;300          //--Print upper char
;;;301          tt_c = (tt/10) + 48;
0008e0  e3a0100a          MOV      r1,#0xa
0008e4  e1a00004          MOV      r0,r4
0008e8  ebfffffe          BL       __aeabi_idiv
0008ec  e2800030          ADD      r0,r0,#0x30
0008f0  e20060ff          AND      r6,r0,#0xff
;;;302          *(volatile unsigned short*) (0x30000000 + (0x38 + 6 << 1)) = tt_c;
0008f4  e3a00203          MOV      r0,#0x30000000
0008f8  e1c067bc          STRH     r6,[r0,#0x7c]
;;;303            
;;;304          //--Print lowar char
;;;305          tt_c = (tt/10) ;
0008fc  e3a0100a          MOV      r1,#0xa
000900  e1a00004          MOV      r0,r4
000904  ebfffffe          BL       __aeabi_idiv
000908  e20060ff          AND      r6,r0,#0xff
;;;306          tt_c = tt - (tt_c*10) + 48;
00090c  e0860106          ADD      r0,r6,r6,LSL #2
000910  e0440080          SUB      r0,r4,r0,LSL #1
000914  e2800030          ADD      r0,r0,#0x30
000918  e20060ff          AND      r6,r0,#0xff
;;;307          *(volatile unsigned short*) (0x30000000 + (0x38 + 7 << 1)) = tt_c;
00091c  e3a00203          MOV      r0,#0x30000000
000920  e1c067be          STRH     r6,[r0,#0x7e]
;;;308    
;;;309          //--Display the '-'
;;;310          *(volatile unsigned short*) (0x30000000 + (0x38 + 5 << 1)) = ':';
000924  e3a0003a          MOV      r0,#0x3a
000928  e3a01203          MOV      r1,#0x30000000
00092c  e1c107ba          STRH     r0,[r1,#0x7a]
;;;311    
;;;312          //2. Display the minutes data
;;;313          tt=0;
000930  e3a04000          MOV      r4,#0
;;;314          //read_val_8b = *(volatile unsigned char *) (0xC0001000 + 0x01);
;;;315          read_val_8b = (time_2 >> 8);
000934  e7e75457          UBFX     r5,r7,#8,#8
;;;316    
;;;317          tt = tt + (((read_val_8b >> 0) & 0x1 ) * 1 ) ;
000938  e2050001          AND      r0,r5,#1
00093c  e0844000          ADD      r4,r4,r0
;;;318          tt = tt + (((read_val_8b >> 1) & 0x1 ) * 2 ) ;
000940  e7e000d5          UBFX     r0,r5,#1,#1
000944  e0844080          ADD      r4,r4,r0,LSL #1
;;;319          tt = tt + (((read_val_8b >> 2) & 0x1 ) * 4 ) ;
000948  e7e00155          UBFX     r0,r5,#2,#1
00094c  e0844100          ADD      r4,r4,r0,LSL #2
;;;320          tt = tt + (((read_val_8b >> 3) & 0x1 ) * 8 ) ;
000950  e7e001d5          UBFX     r0,r5,#3,#1
000954  e0844180          ADD      r4,r4,r0,LSL #3
;;;321          tt = tt + (((read_val_8b >> 4) & 0x1 ) * 10 ) ;
000958  e7e00255          UBFX     r0,r5,#4,#1
00095c  e0800100          ADD      r0,r0,r0,LSL #2
000960  e0844080          ADD      r4,r4,r0,LSL #1
;;;322          tt = tt + (((read_val_8b >> 5) & 0x1 ) * 20 ) ;
000964  e7e002d5          UBFX     r0,r5,#5,#1
000968  e0800100          ADD      r0,r0,r0,LSL #2
00096c  e0844100          ADD      r4,r4,r0,LSL #2
;;;323          tt = tt + (((read_val_8b >> 6) & 0x1 ) * 40 ) ;
000970  e7e00355          UBFX     r0,r5,#6,#1
000974  e0800100          ADD      r0,r0,r0,LSL #2
000978  e0844180          ADD      r4,r4,r0,LSL #3
;;;324    
;;;325          //--Print upper char
;;;326          tt_c = (tt/10) + 48;
00097c  e3a0100a          MOV      r1,#0xa
000980  e1a00004          MOV      r0,r4
000984  ebfffffe          BL       __aeabi_idiv
000988  e2800030          ADD      r0,r0,#0x30
00098c  e20060ff          AND      r6,r0,#0xff
;;;327          *(volatile unsigned short*) (0x30000000 + (0x38 + 3 << 1)) = tt_c;
000990  e3a00203          MOV      r0,#0x30000000
000994  e1c067b6          STRH     r6,[r0,#0x76]
;;;328            
;;;329          //--Print lowar char
;;;330          tt_c = (tt/10) ;
000998  e3a0100a          MOV      r1,#0xa
00099c  e1a00004          MOV      r0,r4
0009a0  ebfffffe          BL       __aeabi_idiv
0009a4  e20060ff          AND      r6,r0,#0xff
;;;331          tt_c = tt - (tt_c*10) + 48;
0009a8  e0860106          ADD      r0,r6,r6,LSL #2
0009ac  e0440080          SUB      r0,r4,r0,LSL #1
0009b0  e2800030          ADD      r0,r0,#0x30
0009b4  e20060ff          AND      r6,r0,#0xff
;;;332          *(volatile unsigned short*) (0x30000000 + (0x38 + 4 << 1)) = tt_c;
0009b8  e3a00203          MOV      r0,#0x30000000
0009bc  e1c067b8          STRH     r6,[r0,#0x78]
;;;333    
;;;334          //--Display the '-'
;;;335          *(volatile unsigned short*) (0x30000000 + (0x38 + 2 << 1)) = ':';
0009c0  e3a0003a          MOV      r0,#0x3a
0009c4  e3a01203          MOV      r1,#0x30000000
0009c8  e1c107b4          STRH     r0,[r1,#0x74]
;;;336    
;;;337          //3. Display the hours data
;;;338          tt=0;
0009cc  e3a04000          MOV      r4,#0
;;;339          //read_val_8b = *(volatile unsigned char *) (0xC0001002 + 0x00);
;;;340          read_val_8b = (time_2 >> 16);
0009d0  e7e75857          UBFX     r5,r7,#16,#8
;;;341    
;;;342          tt = tt + (((read_val_8b >> 0) & 0x1 ) * 1 ) ;
0009d4  e2050001          AND      r0,r5,#1
0009d8  e0844000          ADD      r4,r4,r0
;;;343          tt = tt + (((read_val_8b >> 1) & 0x1 ) * 2 ) ;
0009dc  e7e000d5          UBFX     r0,r5,#1,#1
0009e0  e0844080          ADD      r4,r4,r0,LSL #1
;;;344          tt = tt + (((read_val_8b >> 2) & 0x1 ) * 4 ) ;
0009e4  e7e00155          UBFX     r0,r5,#2,#1
0009e8  e0844100          ADD      r4,r4,r0,LSL #2
;;;345          tt = tt + (((read_val_8b >> 3) & 0x1 ) * 8 ) ;
0009ec  e7e001d5          UBFX     r0,r5,#3,#1
0009f0  e0844180          ADD      r4,r4,r0,LSL #3
;;;346          tt = tt + (((read_val_8b >> 4) & 0x1 ) * 10 ) ;
0009f4  e7e00255          UBFX     r0,r5,#4,#1
0009f8  e0800100          ADD      r0,r0,r0,LSL #2
0009fc  e0844080          ADD      r4,r4,r0,LSL #1
;;;347          tt = tt + (((read_val_8b >> 5) & 0x1 ) * 20 ) ;
000a00  e7e002d5          UBFX     r0,r5,#5,#1
000a04  e0800100          ADD      r0,r0,r0,LSL #2
000a08  e0844100          ADD      r4,r4,r0,LSL #2
;;;348    
;;;349          //--Print upper char
;;;350          tt_c = (tt/10) + 48;
000a0c  e3a0100a          MOV      r1,#0xa
000a10  e1a00004          MOV      r0,r4
000a14  ebfffffe          BL       __aeabi_idiv
000a18  e2800030          ADD      r0,r0,#0x30
000a1c  e20060ff          AND      r6,r0,#0xff
;;;351          *(volatile unsigned short*) (0x30000000 + (0x38 + 0 << 1)) = tt_c;
000a20  e3a00203          MOV      r0,#0x30000000
000a24  e1c067b0          STRH     r6,[r0,#0x70]
;;;352            
;;;353          //--Print lowar char
;;;354          tt_c = (tt/10) ;
000a28  e3a0100a          MOV      r1,#0xa
000a2c  e1a00004          MOV      r0,r4
000a30  ebfffffe          BL       __aeabi_idiv
000a34  e20060ff          AND      r6,r0,#0xff
;;;355          tt_c = tt - (tt_c*10) + 48;
000a38  e0860106          ADD      r0,r6,r6,LSL #2
000a3c  e0440080          SUB      r0,r4,r0,LSL #1
000a40  e2800030          ADD      r0,r0,#0x30
000a44  e20060ff          AND      r6,r0,#0xff
;;;356          *(volatile unsigned short*) (0x30000000 + (0x38 + 1 << 1)) = tt_c;
000a48  e3a00203          MOV      r0,#0x30000000
000a4c  e1c067b2          STRH     r6,[r0,#0x72]
;;;357    }
000a50  e8bd81f0          POP      {r4-r8,pc}
;;;358    
                          ENDP

                  |L1.2644|
                          DCD      0xa5c0f17b
                  |L1.2648|
                          DCD      0x22fe30ff
                  |L1.2652|
                          DCD      0x25ff24ff
                  |L1.2656|
                          DCD      0xc0200100
                  |L1.2660|
                          DCD      0x3b9aca00
                  |L1.2664|
                          DCD      0x000f4240
                  |L1.2668|
                          DCD      0xc0001000
