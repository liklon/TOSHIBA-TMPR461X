; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\pl353nor.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\pl353nor.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\pl353nor.crf ..\..\..\..\lldd\src\pl353nor.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  eNorF_ConfigVerify PROC
;;;72     /* TESTED */
;;;73     static NorFlashStatus_e eNorF_ConfigVerify (const NorFlashCfg_st *
000000  e1a01000          MOV      r1,r0
;;;74                                                 const pstNorCfg)
;;;75     {
;;;76        NorFlashStatus_e eResult;
;;;77     
;;;78        /* check cycles settings */
;;;79        if ((pstNorCfg->u32ReadCycleTime < (NORFLASH_RD_CYCLE_MIN)) ||
000004  e5912014          LDR      r2,[r1,#0x14]
000008  e3520002          CMP      r2,#2
00000c  3a000020          BCC      |L1.148|
;;;80            (pstNorCfg->u32ReadCycleTime > (NORFLASH_RD_CYCLE_MAX)) ||
000010  e5912014          LDR      r2,[r1,#0x14]
000014  e352000f          CMP      r2,#0xf
000018  8a00001d          BHI      |L1.148|
;;;81            (pstNorCfg->u32WriteCycleTime < (NORFLASH_WR_CYCLE_MIN)) ||
00001c  e5912010          LDR      r2,[r1,#0x10]
000020  e3520002          CMP      r2,#2
000024  3a00001a          BCC      |L1.148|
;;;82            (pstNorCfg->u32WriteCycleTime > (NORFLASH_WR_CYCLE_MAX)) ||
000028  e5912010          LDR      r2,[r1,#0x10]
00002c  e352000f          CMP      r2,#0xf
000030  8a000017          BHI      |L1.148|
;;;83            (pstNorCfg->u32AssertDelayOeN < (NORFLASH_ASSERT_OEN_MIN)) ||
000034  e5912020          LDR      r2,[r1,#0x20]
000038  e3520000          CMP      r2,#0
00003c  0a000014          BEQ      |L1.148|
;;;84            (pstNorCfg->u32AssertDelayOeN > (NORFLASH_ASSERT_OEN_MAX)) ||
000040  e5912020          LDR      r2,[r1,#0x20]
000044  e3520007          CMP      r2,#7
000048  8a000011          BHI      |L1.148|
;;;85            (pstNorCfg->u32AssertDelayWeN < (NORFLASH_ASSERT_WEN_MIN)) ||
00004c  e591201c          LDR      r2,[r1,#0x1c]
000050  e3520000          CMP      r2,#0
000054  0a00000e          BEQ      |L1.148|
;;;86            (pstNorCfg->u32AssertDelayWeN > (NORFLASH_ASSERT_WEN_MAX)) ||
000058  e591201c          LDR      r2,[r1,#0x1c]
00005c  e3520007          CMP      r2,#7
000060  8a00000b          BHI      |L1.148|
;;;87            (pstNorCfg->u32PageCycleTime < (NORFLASH_PAGE_CYCLE_MIN)) ||
000064  e591200c          LDR      r2,[r1,#0xc]
000068  e3520000          CMP      r2,#0
00006c  0a000008          BEQ      |L1.148|
;;;88            (pstNorCfg->u32PageCycleTime > (NORFLASH_PAGE_CYCLE_MAX)) ||
000070  e591200c          LDR      r2,[r1,#0xc]
000074  e3520007          CMP      r2,#7
000078  8a000005          BHI      |L1.148|
;;;89            (pstNorCfg->u32TurnaroundTime < (NORFLASH_TURNAROUND_MIN)) ||
00007c  e5912008          LDR      r2,[r1,#8]
000080  e3520000          CMP      r2,#0
000084  0a000002          BEQ      |L1.148|
;;;90            (pstNorCfg->u32TurnaroundTime > (NORFLASH_TURNAROUND_MAX)))
000088  e5912008          LDR      r2,[r1,#8]
00008c  e3520007          CMP      r2,#7
000090  9a000001          BLS      |L1.156|
                  |L1.148|
;;;91        {
;;;92     /***
;;;93     * MESSAGE: MISRA-C:2004 Rule 14.1 This statement is unreachable.
;;;94     
;;;95     * DESC   : Not applicable: In case of wrong run-time value (see comment above)
;;;96     *          it could happen that some of values above are out-of-range.
;;;97     ****/
;;;98           eResult = NORFLASH_STATUS_CFG_ERR;    /* Invalid Parameter(s)! */
000094  e3a00003          MOV      r0,#3
000098  ea00000e          B        |L1.216|
                  |L1.156|
;;;99        }
;;;100       else
;;;101       {
;;;102          /*
;;;103             Verify also (to be done after PL353 HW config is fixed): For read
;;;104             transfers, the maximum memory burst length on the memory interface is
;;;105             the depth of the read data FIFO. For writes, the maximum burst length
;;;106             is dependent on: - the beat size of the AXI transfer, asize - the
;;;107             memory data bus width, mw - the depth of the write data FIFO depth,
;;;108             wfifo_depth. The formula to determine the maximum memory write burst
;;;109             length is: Memory write burst length = ((1<<asize) x wfifo_depth) /
;;;110             (1<<mw) */
;;;111          /* check opmode settings */
;;;112    /***
;;;113    * MESSAGE: MISRA-C:2004 Rule 13.7 The result of this logical operation is always
;;;114    *          'false'.
;;;115    *
;;;116    * DESC   : The check below is required for enum types since structure members
;;;117    *          might contain values (after C cast operation) specified at the
;;;118    *          "run-time", whicjh could be by out-of-range of the respective
;;;119    *          enumeration type.
;;;120    ****/
;;;121          if ((pstNorCfg->eBusWidth != (NORFLASH_BUS_WIDTH_16)) ||           /* PRQA S 3356 */
00009c  e5d12006          LDRB     r2,[r1,#6]
0000a0  e3520001          CMP      r2,#1
0000a4  1a000008          BNE      |L1.204|
;;;122              (pstNorCfg->eRdBursLen >= (NORFLASH_BURST_LEN_CNTS)) ||        /* PRQA S 3356 */
0000a8  e5d12005          LDRB     r2,[r1,#5]
0000ac  e3520005          CMP      r2,#5
0000b0  aa000005          BGE      |L1.204|
;;;123              (pstNorCfg->eWrBursLen >= (NORFLASH_BURST_LEN_CNTS)) ||        /* PRQA S 3356 */ /* PRQA S 3359 */
0000b4  e5d12004          LDRB     r2,[r1,#4]
0000b8  e3520005          CMP      r2,#5
0000bc  aa000002          BGE      |L1.204|
;;;124              (pstNorCfg->eBurstAlign > (NORFLASH_BURST_ALGN_CROSS_256)))    /* PRQA S 3356 */
0000c0  e5d1201a          LDRB     r2,[r1,#0x1a]
0000c4  e3520004          CMP      r2,#4
0000c8  da000001          BLE      |L1.212|
                  |L1.204|
;;;125          {    /* PRQA S 3201 */
;;;126             eResult = NORFLASH_STATUS_CFG_ERR; /* Invalid Parameter(s)! */
0000cc  e3a00003          MOV      r0,#3
0000d0  ea000000          B        |L1.216|
                  |L1.212|
;;;127          }
;;;128          else
;;;129          {
;;;130             eResult = NORFLASH_STATUS_OK;      /* All Parameters OK */
0000d4  e3a00000          MOV      r0,#0
                  |L1.216|
;;;131          }
;;;132       }
;;;133       return eResult;
;;;134    }
0000d8  e12fff1e          BX       lr
;;;135    
                          ENDP

                  vNorF_CopyConfigToRegs PROC
;;;137    /* TESTED */
;;;138    static void vNorF_CopyConfigToRegs (NorFlashCfg_st * const pstNorCfg)
0000dc  e1a01000          MOV      r1,r0
;;;139    {
;;;140       uint32_t u32Cfg;
;;;141    
;;;142       /* copy cycles/opmode data from the configuration structure to registers */
;;;143       u32Cfg = 0U;
0000e0  e3a00000          MOV      r0,#0
;;;144       u32Cfg = u32Cfg | ((pstNorCfg->u32ReadCycleTime) << (MEMCTRL_SET_T0_SFT));
0000e4  e5912014          LDR      r2,[r1,#0x14]
0000e8  e1800002          ORR      r0,r0,r2
;;;145       u32Cfg = u32Cfg | ((pstNorCfg->u32WriteCycleTime) << (MEMCTRL_SET_T1_SFT));
0000ec  e5912010          LDR      r2,[r1,#0x10]
0000f0  e1800202          ORR      r0,r0,r2,LSL #4
;;;146       u32Cfg = u32Cfg | ((pstNorCfg->u32AssertDelayOeN) << (MEMCTRL_SET_T2_SFT));
0000f4  e5912020          LDR      r2,[r1,#0x20]
0000f8  e1800402          ORR      r0,r0,r2,LSL #8
;;;147       u32Cfg = u32Cfg | ((pstNorCfg->u32AssertDelayWeN) << (MEMCTRL_SET_T3_SFT));
0000fc  e591201c          LDR      r2,[r1,#0x1c]
000100  e1800582          ORR      r0,r0,r2,LSL #11
;;;148       u32Cfg = u32Cfg | ((pstNorCfg->u32PageCycleTime) << (MEMCTRL_SET_T4_SFT));
000104  e591200c          LDR      r2,[r1,#0xc]
000108  e1800702          ORR      r0,r0,r2,LSL #14
;;;149       u32Cfg = u32Cfg | ((pstNorCfg->u32TurnaroundTime) << (MEMCTRL_SET_T5_SFT));
00010c  e1d120b8          LDRH     r2,[r1,#8]
000110  e1800882          ORR      r0,r0,r2,LSL #17
;;;150       /*
;;;151          we_time */
;;;152       if (pstNorCfg->eWeTime == NORFLASH_WE_TIME_CFG_WEN_TOGETHER)
000114  e5d1201b          LDRB     r2,[r1,#0x1b]
000118  e3520001          CMP      r2,#1
00011c  1a000000          BNE      |L1.292|
;;;153       {
;;;154          u32Cfg = u32Cfg | (MEMCTRL_SET_SRAM_T6_MSK);
000120  e3800601          ORR      r0,r0,#0x100000
                  |L1.292|
;;;155       }
;;;156       /*
;;;157          Update register */
;;;158       MEMCTRL_SET_CYCLES = u32Cfg;
000124  e59f2798          LDR      r2,|L1.2244|
000128  e5820014          STR      r0,[r2,#0x14]
;;;159       pstNorCfg->u32set_cycles = u32Cfg;       /* store content of set_cycles */
00012c  e5810028          STR      r0,[r1,#0x28]
;;;160    
;;;161       u32Cfg = 0U;
000130  e3a00000          MOV      r0,#0
;;;162       /* u32Cfg value must be "0", otherwise settings below will be incorrect */
;;;163       /*
;;;164          Bus Width is always the same */
;;;165       u32Cfg = (u32Cfg | (MEMCTRL_SET_MW_16_BITS));
000134  e3800001          ORR      r0,r0,#1
;;;166    
;;;167       /*
;;;168          Read Mode */
;;;169       if (pstNorCfg->eRdMode == NORFLASH_SYNC_MODE)
000138  e5d12019          LDRB     r2,[r1,#0x19]
00013c  e3520001          CMP      r2,#1
000140  1a000000          BNE      |L1.328|
;;;170       {
;;;171          u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_SYNC_MSK));
000144  e3800004          ORR      r0,r0,#4
                  |L1.328|
;;;172       }
;;;173       /*
;;;174          Read Burst Length */
;;;175       switch (pstNorCfg->eRdBursLen)
000148  e5d12005          LDRB     r2,[r1,#5]
00014c  e3520005          CMP      r2,#5
000150  308ff102          ADDCC    pc,pc,r2,LSL #2
000154  ea000013          B        |L1.424|
000158  ea000003          B        |L1.364|
00015c  ea000005          B        |L1.376|
000160  ea000007          B        |L1.388|
000164  ea000009          B        |L1.400|
000168  ea00000b          B        |L1.412|
                  |L1.364|
;;;176       {
;;;177          case NORFLASH_BURST_LEN_1:
00016c  e320f000          NOP      
;;;178          {
;;;179             u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_BL_1_BITS));
000170  e320f000          NOP      
;;;180          }
;;;181             break;
000174  ea00000e          B        |L1.436|
                  |L1.376|
;;;182          case NORFLASH_BURST_LEN_4:
000178  e320f000          NOP      
;;;183          {
;;;184             u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_BL_4_BITS));
00017c  e3800008          ORR      r0,r0,#8
;;;185          }
;;;186             break;
000180  ea00000b          B        |L1.436|
                  |L1.388|
;;;187          case NORFLASH_BURST_LEN_8:
000184  e320f000          NOP      
;;;188          {
;;;189             u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_BL_8_BITS));
000188  e3800010          ORR      r0,r0,#0x10
;;;190          }
;;;191             break;
00018c  ea000008          B        |L1.436|
                  |L1.400|
;;;192          case NORFLASH_BURST_LEN_16:
000190  e320f000          NOP      
;;;193          {
;;;194             u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_BL_16_BITS));
000194  e3800018          ORR      r0,r0,#0x18
;;;195          }
;;;196             break;
000198  ea000005          B        |L1.436|
                  |L1.412|
;;;197          case NORFLASH_BURST_LEN_32:
00019c  e320f000          NOP      
;;;198          {
;;;199             u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_BL_32_BITS));
0001a0  e3800020          ORR      r0,r0,#0x20
;;;200          }
;;;201             break;
0001a4  ea000002          B        |L1.436|
                  |L1.424|
;;;202          default:                             /* NORFLASH_BURST_LEN_CNTS */
0001a8  e320f000          NOP      
;;;203          {
;;;204             u32Cfg = (u32Cfg | (MEMCTRL_SET_RD_BL_CNTS_BITS));
0001ac  e3800028          ORR      r0,r0,#0x28
;;;205          }
;;;206             break;
0001b0  e320f000          NOP      
                  |L1.436|
0001b4  e320f000          NOP                            ;181
;;;207       }
;;;208       /*
;;;209          Write Mode */
;;;210       if (pstNorCfg->eWrMode == NORFLASH_SYNC_MODE)
0001b8  e5d12018          LDRB     r2,[r1,#0x18]
0001bc  e3520001          CMP      r2,#1
0001c0  1a000000          BNE      |L1.456|
;;;211       {
;;;212          u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_SYNC_MSK));
0001c4  e3800040          ORR      r0,r0,#0x40
                  |L1.456|
;;;213       }
;;;214       /*
;;;215          Write Burst Length */
;;;216       switch (pstNorCfg->eWrBursLen)
0001c8  e5d12004          LDRB     r2,[r1,#4]
0001cc  e3520005          CMP      r2,#5
0001d0  308ff102          ADDCC    pc,pc,r2,LSL #2
0001d4  ea000013          B        |L1.552|
0001d8  ea000003          B        |L1.492|
0001dc  ea000005          B        |L1.504|
0001e0  ea000007          B        |L1.516|
0001e4  ea000009          B        |L1.528|
0001e8  ea00000b          B        |L1.540|
                  |L1.492|
;;;217       {
;;;218          case NORFLASH_BURST_LEN_1:
0001ec  e320f000          NOP      
;;;219          {
;;;220             u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_BL_1_BITS));
0001f0  e320f000          NOP      
;;;221          }
;;;222             break;
0001f4  ea00000e          B        |L1.564|
                  |L1.504|
;;;223          case NORFLASH_BURST_LEN_4:
0001f8  e320f000          NOP      
;;;224          {
;;;225             u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_BL_4_BITS));
0001fc  e3800080          ORR      r0,r0,#0x80
;;;226          }
;;;227             break;
000200  ea00000b          B        |L1.564|
                  |L1.516|
;;;228          case NORFLASH_BURST_LEN_8:
000204  e320f000          NOP      
;;;229          {
;;;230             u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_BL_8_BITS));
000208  e3800c01          ORR      r0,r0,#0x100
;;;231          }
;;;232             break;
00020c  ea000008          B        |L1.564|
                  |L1.528|
;;;233          case NORFLASH_BURST_LEN_16:
000210  e320f000          NOP      
;;;234          {
;;;235             u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_BL_16_BITS));
000214  e3800d06          ORR      r0,r0,#0x180
;;;236          }
;;;237             break;
000218  ea000005          B        |L1.564|
                  |L1.540|
;;;238          case NORFLASH_BURST_LEN_32:
00021c  e320f000          NOP      
;;;239          {
;;;240             u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_BL_32_BITS));
000220  e3800c02          ORR      r0,r0,#0x200
;;;241          }
;;;242             break;
000224  ea000002          B        |L1.564|
                  |L1.552|
;;;243          default:                             /* NORFLASH_BURST_LEN_CNTS */
000228  e320f000          NOP      
;;;244          {
;;;245             u32Cfg = (u32Cfg | (MEMCTRL_SET_WR_BL_CNTS_BITS));
00022c  e3800d0a          ORR      r0,r0,#0x280
;;;246          }
;;;247             break;
000230  e320f000          NOP      
                  |L1.564|
000234  e320f000          NOP                            ;222
;;;248       }
;;;249       /*
;;;250          Burst Address Advance Signal */
;;;251       if (pstNorCfg->eBurstAdrAdvSig == NORFLASH_USE_ADV_SIG)
000238  e5d12026          LDRB     r2,[r1,#0x26]
00023c  e3520001          CMP      r2,#1
000240  1a000000          BNE      |L1.584|
;;;252       {
;;;253          u32Cfg = (u32Cfg | (MEMCTRL_SET_BAA_MSK));
000244  e3800b01          ORR      r0,r0,#0x400
                  |L1.584|
;;;254       }
;;;255       /*
;;;256          Address Advance Signal */
;;;257       if (pstNorCfg->eAdrAdvSig == NORFLASH_USE_ADV_SIG)
000248  e5d12025          LDRB     r2,[r1,#0x25]
00024c  e3520001          CMP      r2,#1
000250  1a000000          BNE      |L1.600|
;;;258       {
;;;259          u32Cfg = (u32Cfg | (MEMCTRL_SET_ADV_MSK));
000254  e3800b02          ORR      r0,r0,#0x800
                  |L1.600|
;;;260       }
;;;261       /*
;;;262          Byte Lane Strobe */
;;;263       if (pstNorCfg->eByteLane == NORFLASH_BYTE_LANE_AS_WEN)
000258  e5d12024          LDRB     r2,[r1,#0x24]
00025c  e3520001          CMP      r2,#1
000260  1a000000          BNE      |L1.616|
;;;264       {
;;;265          u32Cfg = (u32Cfg | (MEMCTRL_SET_BLS_MSK));
000264  e3800a01          ORR      r0,r0,#0x1000
                  |L1.616|
;;;266       }
;;;267       /*
;;;268          Burst Align */
;;;269       switch (pstNorCfg->eBurstAlign)
000268  e5d1201a          LDRB     r2,[r1,#0x1a]
00026c  e3520000          CMP      r2,#0
000270  0a000006          BEQ      |L1.656|
000274  e3520001          CMP      r2,#1
000278  0a000007          BEQ      |L1.668|
00027c  e3520002          CMP      r2,#2
000280  0a000008          BEQ      |L1.680|
000284  e3520003          CMP      r2,#3
000288  1a00000c          BNE      |L1.704|
00028c  ea000008          B        |L1.692|
                  |L1.656|
;;;270       {
;;;271          case NORFLASH_BURST_ALGN_CROSS_ANY:
000290  e320f000          NOP      
;;;272          {
;;;273             u32Cfg = (u32Cfg | (MEMCTRL_SET_BRST_CR_ANY_BITS));
000294  e320f000          NOP      
;;;274          }
;;;275             break;
000298  ea00000b          B        |L1.716|
                  |L1.668|
;;;276          case NORFLASH_BURST_ALGN_CROSS_32:
00029c  e320f000          NOP      
;;;277          {
;;;278             u32Cfg = (u32Cfg | (MEMCTRL_SET_BRST_CR_32_BITS));
0002a0  e3800a02          ORR      r0,r0,#0x2000
;;;279          }
;;;280             break;
0002a4  ea000008          B        |L1.716|
                  |L1.680|
;;;281          case NORFLASH_BURST_ALGN_CROSS_64:
0002a8  e320f000          NOP      
;;;282          {
;;;283             u32Cfg = (u32Cfg | (MEMCTRL_SET_BRST_CR_64_BITS));
0002ac  e3800901          ORR      r0,r0,#0x4000
;;;284          }
;;;285             break;
0002b0  ea000005          B        |L1.716|
                  |L1.692|
;;;286          case NORFLASH_BURST_ALGN_CROSS_128:
0002b4  e320f000          NOP      
;;;287          {
;;;288             u32Cfg = (u32Cfg | (MEMCTRL_SET_BRST_CR_128_BITS));
0002b8  e3800a06          ORR      r0,r0,#0x6000
;;;289          }
;;;290             break;
0002bc  ea000002          B        |L1.716|
                  |L1.704|
;;;291          default:                             /* NORFLASH_BURST_ALGN_CROSS_256 */
0002c0  e320f000          NOP      
;;;292          {
;;;293             u32Cfg = (u32Cfg | (MEMCTRL_SET_BRST_CR_256_BITS));
0002c4  e3800902          ORR      r0,r0,#0x8000
;;;294          }
;;;295             break;
0002c8  e320f000          NOP      
                  |L1.716|
0002cc  e320f000          NOP                            ;275
;;;296       }
;;;297       /*
;;;298          Update register */
;;;299       MEMCTRL_SET_OPMODE = u32Cfg;
0002d0  e59f25ec          LDR      r2,|L1.2244|
0002d4  e5820018          STR      r0,[r2,#0x18]
;;;300       pstNorCfg->u32set_opmode = u32Cfg;       /* store content of set_opmode */
0002d8  e581002c          STR      r0,[r1,#0x2c]
;;;301    }
0002dc  e12fff1e          BX       lr
;;;302    
                          ENDP

                  eNorFlash_GetHwConfig PROC
;;;310    /* TESTED */
;;;311    NorFlashStatus_e eNorFlash_GetHwConfig (NorFlashCfg_st * pstNorCfg)
0002e0  e92d4070          PUSH     {r4-r6,lr}
;;;312    {
0002e4  e1a04000          MOV      r4,r0
;;;313       NorFlashStatus_e eResult;
;;;314    
;;;315       /* Initialize the NOR memory region Base Address */
;;;316       pstNorCfg->u32NorChipAdr = NORFLASH_BASE_ADDRESS;
0002e8  e3a00202          MOV      r0,#0x20000000
0002ec  e5840000          STR      r0,[r4,#0]
;;;317    
;;;318       if (pstNorCfg != TYPES_NULL_PTR)
0002f0  e3540000          CMP      r4,#0
0002f4  0a0000ab          BEQ      |L1.1448|
;;;319       {
;;;320          uint32_t u32RdCfg;
;;;321    
;;;322          /* copy cycles data from SRAM register to the configuration structure */
;;;323          u32RdCfg = MEMCTRL_SRAM_CYCLES;
0002f8  e59f05c4          LDR      r0,|L1.2244|
0002fc  e5905100          LDR      r5,[r0,#0x100]
;;;324          pstNorCfg->u32ReadCycleTime =
000300  e205000f          AND      r0,r5,#0xf
000304  e5840014          STR      r0,[r4,#0x14]
;;;325             ((u32RdCfg & (MEMCTRL_SET_T0_MSK)) >> (MEMCTRL_SET_T0_SFT));
;;;326          pstNorCfg->u32WriteCycleTime =
000308  e7e30255          UBFX     r0,r5,#4,#4
00030c  e5840010          STR      r0,[r4,#0x10]
;;;327             ((u32RdCfg & (MEMCTRL_SET_T1_MSK)) >> (MEMCTRL_SET_T1_SFT));
;;;328          pstNorCfg->u32AssertDelayOeN =
000310  e7e20455          UBFX     r0,r5,#8,#3
000314  e5840020          STR      r0,[r4,#0x20]
;;;329             ((u32RdCfg & (MEMCTRL_SET_T2_MSK)) >> (MEMCTRL_SET_T2_SFT));
;;;330          pstNorCfg->u32AssertDelayWeN =
000318  e7e205d5          UBFX     r0,r5,#11,#3
00031c  e584001c          STR      r0,[r4,#0x1c]
;;;331             ((u32RdCfg & (MEMCTRL_SET_T3_MSK)) >> (MEMCTRL_SET_T3_SFT));
;;;332          pstNorCfg->u32PageCycleTime =
000320  e7e20755          UBFX     r0,r5,#14,#3
000324  e584000c          STR      r0,[r4,#0xc]
;;;333             ((u32RdCfg & (MEMCTRL_SET_T4_MSK)) >> (MEMCTRL_SET_T4_SFT));
;;;334          pstNorCfg->u32TurnaroundTime =
000328  e7e208d5          UBFX     r0,r5,#17,#3
00032c  e5840008          STR      r0,[r4,#8]
;;;335             ((u32RdCfg & (MEMCTRL_SET_T5_MSK)) >> (MEMCTRL_SET_T5_SFT));
;;;336    
;;;337          if (((u32RdCfg & (MEMCTRL_SET_SRAM_T6_MSK)) == (MEMCTRL_SET_SRAM_T6_MSK)))
000330  e2050601          AND      r0,r5,#0x100000
000334  e3500601          CMP      r0,#0x100000
000338  1a000002          BNE      |L1.840|
;;;338          {
;;;339             /* bit is 1: we_n and cs_n assert together */
;;;340             pstNorCfg->eWeTime = NORFLASH_WE_TIME_CFG_WEN_TOGETHER;
00033c  e3a00001          MOV      r0,#1
000340  e5c4001b          STRB     r0,[r4,#0x1b]
000344  ea000001          B        |L1.848|
                  |L1.840|
;;;341          }
;;;342          else
;;;343          {
;;;344             /* bit is 0: we_n 2 mclk cycles after cs_n */
;;;345             pstNorCfg->eWeTime = NORFLASH_WE_TIME_CFG_WEN_AFTER;
000348  e3a00000          MOV      r0,#0
00034c  e5c4001b          STRB     r0,[r4,#0x1b]
                  |L1.848|
;;;346          }
;;;347    
;;;348          /* copy operation mode data from register to the configuration structure */
;;;349          u32RdCfg = (0x0000FFFFU & MEMCTRL_SRAM_OPMODE);
000350  e59f056c          LDR      r0,|L1.2244|
000354  e5900104          LDR      r0,[r0,#0x104]
000358  e6ff5070          UXTH     r5,r0
;;;350          /*
;;;351             mw bits: BUS WIDTH is fixed to 16-bits always! */
;;;352          pstNorCfg->eBusWidth = NORFLASH_BUS_WIDTH_16;
00035c  e3a00001          MOV      r0,#1
000360  e5c40006          STRB     r0,[r4,#6]
;;;353          /*
;;;354             rd_sync bit */
;;;355          if ((u32RdCfg & (MEMCTRL_SET_RD_SYNC_MSK)) == (MEMCTRL_SET_RD_SYNC_MSK))
000364  e2050004          AND      r0,r5,#4
000368  e3500004          CMP      r0,#4
00036c  1a000002          BNE      |L1.892|
;;;356          {
;;;357             pstNorCfg->eRdMode = NORFLASH_SYNC_MODE;
000370  e3a00001          MOV      r0,#1
000374  e5c40019          STRB     r0,[r4,#0x19]
000378  ea000001          B        |L1.900|
                  |L1.892|
;;;358          }
;;;359          else
;;;360          {
;;;361             pstNorCfg->eRdMode = NORFLASH_NOSYNC_MODE;
00037c  e3a00000          MOV      r0,#0
000380  e5c40019          STRB     r0,[r4,#0x19]
                  |L1.900|
;;;362          }
;;;363          /*
;;;364             rd_bl bit */
;;;365          switch ((u32RdCfg & (MEMCTRL_SET_RD_BL_MSK)))
000384  e2050038          AND      r0,r5,#0x38
000388  e3500010          CMP      r0,#0x10
00038c  0a000012          BEQ      |L1.988|
000390  ca000004          BGT      |L1.936|
000394  e3500000          CMP      r0,#0
000398  0a000007          BEQ      |L1.956|
00039c  e3500008          CMP      r0,#8
0003a0  1a000019          BNE      |L1.1036|
0003a4  ea000008          B        |L1.972|
                  |L1.936|
0003a8  e3500018          CMP      r0,#0x18
0003ac  0a00000e          BEQ      |L1.1004|
0003b0  e3500020          CMP      r0,#0x20
0003b4  1a000014          BNE      |L1.1036|
0003b8  ea00000f          B        |L1.1020|
                  |L1.956|
;;;366          {
;;;367             case MEMCTRL_SET_RD_BL_1_BITS:
0003bc  e320f000          NOP      
;;;368             {
;;;369                pstNorCfg->eRdBursLen = NORFLASH_BURST_LEN_1;
0003c0  e3a00000          MOV      r0,#0
0003c4  e5c40005          STRB     r0,[r4,#5]
;;;370             }
;;;371                break;
0003c8  ea000013          B        |L1.1052|
                  |L1.972|
;;;372             case MEMCTRL_SET_RD_BL_4_BITS:
0003cc  e320f000          NOP      
;;;373             {
;;;374                pstNorCfg->eRdBursLen = NORFLASH_BURST_LEN_4;
0003d0  e3a00001          MOV      r0,#1
0003d4  e5c40005          STRB     r0,[r4,#5]
;;;375             }
;;;376                break;
0003d8  ea00000f          B        |L1.1052|
                  |L1.988|
;;;377             case MEMCTRL_SET_RD_BL_8_BITS:
0003dc  e320f000          NOP      
;;;378             {
;;;379                pstNorCfg->eRdBursLen = NORFLASH_BURST_LEN_8;
0003e0  e3a00002          MOV      r0,#2
0003e4  e5c40005          STRB     r0,[r4,#5]
;;;380             }
;;;381                break;
0003e8  ea00000b          B        |L1.1052|
                  |L1.1004|
;;;382             case MEMCTRL_SET_RD_BL_16_BITS:
0003ec  e320f000          NOP      
;;;383             {
;;;384                pstNorCfg->eRdBursLen = NORFLASH_BURST_LEN_16;
0003f0  e3a00003          MOV      r0,#3
0003f4  e5c40005          STRB     r0,[r4,#5]
;;;385             }
;;;386                break;
0003f8  ea000007          B        |L1.1052|
                  |L1.1020|
;;;387             case MEMCTRL_SET_RD_BL_32_BITS:
0003fc  e320f000          NOP      
;;;388             {
;;;389                pstNorCfg->eRdBursLen = NORFLASH_BURST_LEN_32;
000400  e3a00004          MOV      r0,#4
000404  e5c40005          STRB     r0,[r4,#5]
;;;390             }
;;;391                break;
000408  ea000003          B        |L1.1052|
                  |L1.1036|
;;;392             default:
00040c  e320f000          NOP      
;;;393             {
;;;394                /* for all other values use "continuous" */
;;;395                pstNorCfg->eRdBursLen = NORFLASH_BURST_LEN_CNTS;
000410  e3a00005          MOV      r0,#5
000414  e5c40005          STRB     r0,[r4,#5]
;;;396             }
;;;397                break;
000418  e320f000          NOP      
                  |L1.1052|
00041c  e320f000          NOP                            ;371
;;;398          }
;;;399          /*
;;;400             wr_sync bit */
;;;401          if ((u32RdCfg & (MEMCTRL_SET_WR_SYNC_MSK)) == (MEMCTRL_SET_WR_SYNC_MSK))
000420  e2050040          AND      r0,r5,#0x40
000424  e3500040          CMP      r0,#0x40
000428  1a000002          BNE      |L1.1080|
;;;402          {
;;;403             pstNorCfg->eWrMode = NORFLASH_SYNC_MODE;
00042c  e3a00001          MOV      r0,#1
000430  e5c40018          STRB     r0,[r4,#0x18]
000434  ea000001          B        |L1.1088|
                  |L1.1080|
;;;404          }
;;;405          else
;;;406          {
;;;407             pstNorCfg->eWrMode = NORFLASH_NOSYNC_MODE;
000438  e3a00000          MOV      r0,#0
00043c  e5c40018          STRB     r0,[r4,#0x18]
                  |L1.1088|
;;;408          }
;;;409          /*
;;;410             wr_bl bit */
;;;411          switch ((u32RdCfg & (MEMCTRL_SET_WR_BL_MSK)))
000440  e2050d0e          AND      r0,r5,#0x380
000444  e3500c01          CMP      r0,#0x100
000448  0a000012          BEQ      |L1.1176|
00044c  ca000004          BGT      |L1.1124|
000450  e3500000          CMP      r0,#0
000454  0a000007          BEQ      |L1.1144|
000458  e3500080          CMP      r0,#0x80
00045c  1a000019          BNE      |L1.1224|
000460  ea000008          B        |L1.1160|
                  |L1.1124|
000464  e3500d06          CMP      r0,#0x180
000468  0a00000e          BEQ      |L1.1192|
00046c  e3500c02          CMP      r0,#0x200
000470  1a000014          BNE      |L1.1224|
000474  ea00000f          B        |L1.1208|
                  |L1.1144|
;;;412          {
;;;413             case MEMCTRL_SET_WR_BL_1_BITS:
000478  e320f000          NOP      
;;;414             {
;;;415                pstNorCfg->eWrBursLen = NORFLASH_BURST_LEN_1;
00047c  e3a00000          MOV      r0,#0
000480  e5c40004          STRB     r0,[r4,#4]
;;;416             }
;;;417                break;
000484  ea000013          B        |L1.1240|
                  |L1.1160|
;;;418             case MEMCTRL_SET_WR_BL_4_BITS:
000488  e320f000          NOP      
;;;419             {
;;;420                pstNorCfg->eWrBursLen = NORFLASH_BURST_LEN_4;
00048c  e3a00001          MOV      r0,#1
000490  e5c40004          STRB     r0,[r4,#4]
;;;421             }
;;;422                break;
000494  ea00000f          B        |L1.1240|
                  |L1.1176|
;;;423             case MEMCTRL_SET_WR_BL_8_BITS:
000498  e320f000          NOP      
;;;424             {
;;;425                pstNorCfg->eWrBursLen = NORFLASH_BURST_LEN_8;
00049c  e3a00002          MOV      r0,#2
0004a0  e5c40004          STRB     r0,[r4,#4]
;;;426             }
;;;427                break;
0004a4  ea00000b          B        |L1.1240|
                  |L1.1192|
;;;428             case MEMCTRL_SET_WR_BL_16_BITS:
0004a8  e320f000          NOP      
;;;429             {
;;;430                pstNorCfg->eWrBursLen = NORFLASH_BURST_LEN_16;
0004ac  e3a00003          MOV      r0,#3
0004b0  e5c40004          STRB     r0,[r4,#4]
;;;431             }
;;;432                break;
0004b4  ea000007          B        |L1.1240|
                  |L1.1208|
;;;433             case MEMCTRL_SET_WR_BL_32_BITS:
0004b8  e320f000          NOP      
;;;434             {
;;;435                pstNorCfg->eWrBursLen = NORFLASH_BURST_LEN_32;
0004bc  e3a00004          MOV      r0,#4
0004c0  e5c40004          STRB     r0,[r4,#4]
;;;436             }
;;;437                break;
0004c4  ea000003          B        |L1.1240|
                  |L1.1224|
;;;438             default:
0004c8  e320f000          NOP      
;;;439             {
;;;440                /* for all other values use "continuous" */
;;;441                pstNorCfg->eWrBursLen = NORFLASH_BURST_LEN_CNTS;
0004cc  e3a00005          MOV      r0,#5
0004d0  e5c40004          STRB     r0,[r4,#4]
;;;442             }
;;;443                break;
0004d4  e320f000          NOP      
                  |L1.1240|
0004d8  e320f000          NOP                            ;417
;;;444          }
;;;445          /*
;;;446             adv bit */
;;;447          if ((u32RdCfg & (MEMCTRL_SET_ADV_MSK)) == (MEMCTRL_SET_ADV_MSK))
0004dc  e2050b02          AND      r0,r5,#0x800
0004e0  e3500b02          CMP      r0,#0x800
0004e4  1a000002          BNE      |L1.1268|
;;;448          {
;;;449             pstNorCfg->eAdrAdvSig = NORFLASH_USE_ADV_SIG;
0004e8  e3a00001          MOV      r0,#1
0004ec  e5c40025          STRB     r0,[r4,#0x25]
0004f0  ea000001          B        |L1.1276|
                  |L1.1268|
;;;450          }
;;;451          else
;;;452          {
;;;453             pstNorCfg->eAdrAdvSig = NORFLASH_NO_ADV_SIG;
0004f4  e3a00000          MOV      r0,#0
0004f8  e5c40025          STRB     r0,[r4,#0x25]
                  |L1.1276|
;;;454          }
;;;455          /*
;;;456             bls bit */
;;;457          if ((u32RdCfg & (MEMCTRL_SET_BLS_MSK)) == (MEMCTRL_SET_BLS_MSK))
0004fc  e2050a01          AND      r0,r5,#0x1000
000500  e3500a01          CMP      r0,#0x1000
000504  1a000002          BNE      |L1.1300|
;;;458          {
;;;459             pstNorCfg->eByteLane = NORFLASH_BYTE_LANE_AS_WEN;
000508  e3a00001          MOV      r0,#1
00050c  e5c40024          STRB     r0,[r4,#0x24]
000510  ea000001          B        |L1.1308|
                  |L1.1300|
;;;460          }
;;;461          else
;;;462          {
;;;463             pstNorCfg->eByteLane = NORFLASH_BYTE_LANE_AS_CS;
000514  e3a00000          MOV      r0,#0
000518  e5c40024          STRB     r0,[r4,#0x24]
                  |L1.1308|
;;;464          }
;;;465          /*
;;;466             burst_allign bits */
;;;467          switch ((u32RdCfg & (MEMCTRL_SET_BRST_ALIGN_MSK)))
00051c  e2050a0e          AND      r0,r5,#0xe000
000520  e3500000          CMP      r0,#0
000524  0a000006          BEQ      |L1.1348|
000528  e3500a02          CMP      r0,#0x2000
00052c  0a000008          BEQ      |L1.1364|
000530  e3500901          CMP      r0,#0x4000
000534  0a00000a          BEQ      |L1.1380|
000538  e3500a06          CMP      r0,#0x6000
00053c  1a000010          BNE      |L1.1412|
000540  ea00000b          B        |L1.1396|
                  |L1.1348|
;;;468          {
;;;469             case MEMCTRL_SET_BRST_CR_ANY_BITS:
000544  e320f000          NOP      
;;;470             {
;;;471                pstNorCfg->eBurstAlign = NORFLASH_BURST_ALGN_CROSS_ANY;
000548  e3a00000          MOV      r0,#0
00054c  e5c4001a          STRB     r0,[r4,#0x1a]
;;;472             }
;;;473                break;
000550  ea00000f          B        |L1.1428|
                  |L1.1364|
;;;474             case MEMCTRL_SET_BRST_CR_32_BITS:
000554  e320f000          NOP      
;;;475             {
;;;476                pstNorCfg->eBurstAlign = NORFLASH_BURST_ALGN_CROSS_32;
000558  e3a00001          MOV      r0,#1
00055c  e5c4001a          STRB     r0,[r4,#0x1a]
;;;477             }
;;;478                break;
000560  ea00000b          B        |L1.1428|
                  |L1.1380|
;;;479             case MEMCTRL_SET_BRST_CR_64_BITS:
000564  e320f000          NOP      
;;;480             {
;;;481                pstNorCfg->eBurstAlign = NORFLASH_BURST_ALGN_CROSS_64;
000568  e3a00002          MOV      r0,#2
00056c  e5c4001a          STRB     r0,[r4,#0x1a]
;;;482             }
;;;483                break;
000570  ea000007          B        |L1.1428|
                  |L1.1396|
;;;484             case MEMCTRL_SET_BRST_CR_128_BITS:
000574  e320f000          NOP      
;;;485             {
;;;486                pstNorCfg->eBurstAlign = NORFLASH_BURST_ALGN_CROSS_128;
000578  e3a00003          MOV      r0,#3
00057c  e5c4001a          STRB     r0,[r4,#0x1a]
;;;487             }
;;;488                break;
000580  ea000003          B        |L1.1428|
                  |L1.1412|
;;;489             default:
000584  e320f000          NOP      
;;;490             {
;;;491                /* other including reserved set to MEMCTRL_SET_BRST_CR_256_BITS */
;;;492                pstNorCfg->eBurstAlign = NORFLASH_BURST_ALGN_CROSS_256;
000588  e3a00004          MOV      r0,#4
00058c  e5c4001a          STRB     r0,[r4,#0x1a]
;;;493             }
;;;494                break;
000590  e320f000          NOP      
                  |L1.1428|
000594  e320f000          NOP                            ;473
;;;495          }
;;;496          /* Check all settings */
;;;497          eResult = eNorF_ConfigVerify (pstNorCfg);
000598  e1a00004          MOV      r0,r4
00059c  ebfffffe          BL       eNorF_ConfigVerify
0005a0  e1a06000          MOV      r6,r0
;;;498       }
0005a4  ea000000          B        |L1.1452|
                  |L1.1448|
;;;499       else
;;;500       {
;;;501          eResult = NORFLASH_STATUS_PTR_ERR;
0005a8  e3a06002          MOV      r6,#2
                  |L1.1452|
;;;502       }
;;;503       return eResult;
0005ac  e1a00006          MOV      r0,r6
;;;504    }
0005b0  e8bd8070          POP      {r4-r6,pc}
;;;505    
                          ENDP

                  eNorFlash_Initialize PROC
;;;507    /* TESTED */
;;;508    NorFlashStatus_e eNorFlash_Initialize (NorFlashCfg_st * pstNorCfg)
0005b4  e92d41f0          PUSH     {r4-r8,lr}
;;;509    {
0005b8  e1a04000          MOV      r4,r0
;;;510    /***
;;;511    * MESSAGE: Msg(3:3197) The initialiser for 'eResult' is always modified before
;;;512    *          being used.
;;;513    *
;;;514    * DESC   : To detect that eResult is updated every time within this complex
;;;515    *          function the initial value NANDFLASH_STATUS_UNKNOWN is used.
;;;516    ****/
;;;517       NorFlashStatus_e eResult = NORFLASH_STATUS_UNKNOWN;    /* PRQA S 3197 */
0005bc  e3a06001          MOV      r6,#1
;;;518    
;;;519       uint32_t u32TryCnt = 0;                  /* Register-update retry counter */
0005c0  e3a07000          MOV      r7,#0
;;;520    
;;;521       /*
;;;522          Initialize the NOR memory region Base Address. This init is done already
;;;523          in eNorFlash_GetHwConfig() function, but is repeated here in case, if the
;;;524          mentioned function would never be called. */
;;;525       pstNorCfg->u32NorChipAdr = NORFLASH_BASE_ADDRESS;
0005c4  e3a00202          MOV      r0,#0x20000000
0005c8  e5840000          STR      r0,[r4,#0]
;;;526    
;;;527       if (pstNorCfg != TYPES_NULL_PTR)
0005cc  e3540000          CMP      r4,#0
0005d0  0a000029          BEQ      |L1.1660|
;;;528       {
;;;529          eResult = eNorF_ConfigVerify (pstNorCfg); /* Settings correct? */
0005d4  e1a00004          MOV      r0,r4
0005d8  ebfffffe          BL       eNorF_ConfigVerify
0005dc  e1a06000          MOV      r6,r0
;;;530    
;;;531          if (eResult == NORFLASH_STATUS_OK)
0005e0  e3560000          CMP      r6,#0
0005e4  1a000025          BNE      |L1.1664|
;;;532          {
;;;533             uint32_t u32DirCmdVal = 0U;        /* to construct a direct_cmd
0005e8  e3a05000          MOV      r5,#0
;;;534                                                   register value */
;;;535             uint32_t u32MatchData = 0U;        /* Match data Value ? */
0005ec  e3a08000          MOV      r8,#0
;;;536    
;;;537             /*
;;;538                Bus Width should be fixed to 16-bit for NOR flash always. */
;;;539             pstNorCfg->eBusWidth = NORFLASH_BUS_WIDTH_16;
0005f0  e3a00001          MOV      r0,#1
0005f4  e5c40006          STRB     r0,[r4,#6]
;;;540    
;;;541             vNorF_CopyConfigToRegs (pstNorCfg);
0005f8  e1a00004          MOV      r0,r4
0005fc  ebfffffe          BL       vNorF_CopyConfigToRegs
;;;542             /*
;;;543                The configuration is now within set_cycles and set_opmode
;;;544                registers. To update the timing within the SMC for a NOR device it
;;;545                is required to specify: an UpdateRegs and AXI cmd_type within the
;;;546                direct_cmd register. */
;;;547             /* Set Match Data Value for UpdateRegs and AXI command */
;;;548             /*
;;;549                Perform the required sequence of memory accesses, the Last Access
;;;550                Containing the Match Data Value. This is memory device specific
;;;551                area. Currently nothing to be written -so use:
;;;552                MEMCTRL_CMD_TYPE_UPD_REGS_MSK instead of
;;;553                MEMCTRL_CMD_TYPE_UPD_REGS_AXI_MSK. */
;;;554             u32DirCmdVal = u32DirCmdVal | MEMCTRL_NOR_CHIP_SEL_MSK;
000600  e320f000          NOP      
;;;555             u32DirCmdVal = u32DirCmdVal | MEMCTRL_CMD_TYPE_UPD_REGS_MSK;
000604  e3855501          ORR      r5,r5,#0x400000
;;;556             u32DirCmdVal = u32DirCmdVal | u32MatchData;
000608  e1855008          ORR      r5,r5,r8
;;;557             MEMCTRL_DIRECT_CMD = u32DirCmdVal; /* Update registers */
00060c  e59f02b0          LDR      r0,|L1.2244|
000610  e5805010          STR      r5,[r0,#0x10]
;;;558             /*
;;;559                Verify the new timings and operation mode: - check for correct
;;;560                sram_cycles register - check for correct opmode register. Try to
;;;561                Update Cyclec and Opmode registers upto 4 times */
;;;562             eResult = NORFLASH_STATUS_UNKNOWN; /* reuse eResult for this loop */
000614  e3a06001          MOV      r6,#1
;;;563             do
000618  e320f000          NOP      
                  |L1.1564|
;;;564             {
;;;565                uint32_t u32Cyc = MEMCTRL_SRAM_CYCLES;
00061c  e59f22a0          LDR      r2,|L1.2244|
000620  e5921100          LDR      r1,[r2,#0x100]
;;;566    
;;;567                uint32_t u32Mod = (0x0000FFFFU & MEMCTRL_SRAM_OPMODE);
000624  e5922104          LDR      r2,[r2,#0x104]
000628  e6ff0072          UXTH     r0,r2
;;;568    
;;;569                if ((u32Cyc == pstNorCfg->u32set_cycles) &&
00062c  e5942028          LDR      r2,[r4,#0x28]
000630  e1520001          CMP      r2,r1
000634  1a000004          BNE      |L1.1612|
;;;570                    (u32Mod == pstNorCfg->u32set_opmode))
000638  e594202c          LDR      r2,[r4,#0x2c]
00063c  e1520000          CMP      r2,r0
000640  1a000001          BNE      |L1.1612|
;;;571                {
;;;572                   eResult = NORFLASH_STATUS_OK;
000644  e3a06000          MOV      r6,#0
000648  ea000006          B        |L1.1640|
                  |L1.1612|
;;;573                }
;;;574                else
;;;575                {
;;;576                   if (u32TryCnt < 4U)
00064c  e3570004          CMP      r7,#4
000650  2a000003          BCS      |L1.1636|
;;;577                   {
;;;578                      MEMCTRL_DIRECT_CMD = u32DirCmdVal;
000654  e59f2268          LDR      r2,|L1.2244|
000658  e5825010          STR      r5,[r2,#0x10]
;;;579                      u32TryCnt++;
00065c  e2877001          ADD      r7,r7,#1
000660  ea000000          B        |L1.1640|
                  |L1.1636|
;;;580                   }
;;;581                   else
;;;582                   {
;;;583                      eResult = NORFLASH_STATUS_OPERATION_ERR; /* update failed */
000664  e3a06004          MOV      r6,#4
                  |L1.1640|
;;;584                   }
;;;585                }
;;;586             }
;;;587             while (!
000668  e3560000          CMP      r6,#0
00066c  0a000001          BEQ      |L1.1656|
000670  e3560004          CMP      r6,#4
000674  1affffe8          BNE      |L1.1564|
                  |L1.1656|
;;;588                    ((eResult == (NORFLASH_STATUS_OK)) ||
;;;589                     (eResult == (NORFLASH_STATUS_OPERATION_ERR))));
;;;590          }
000678  ea000000          B        |L1.1664|
                  |L1.1660|
;;;591       }
;;;592       else
;;;593       {
;;;594          eResult = NORFLASH_STATUS_PTR_ERR;
00067c  e3a06002          MOV      r6,#2
                  |L1.1664|
;;;595       }
;;;596       return eResult;
000680  e1a00006          MOV      r0,r6
;;;597    }
000684  e8bd81f0          POP      {r4-r8,pc}
;;;598    
                          ENDP

                  eNorFlash_SetBurstLength PROC
;;;600    /* TESTED */
;;;601    NorFlashStatus_e eNorFlash_SetBurstLength (NorFlashCfg_st * pstNorCfg,
000688  e1a03000          MOV      r3,r0
;;;602                                               NorFlashBurstLength_e eWrBrstLen,
;;;603                                               NorFlashBurstLength_e eRdBrstLen)
;;;604    {
;;;605       NorFlashStatus_e eResult;
;;;606    
;;;607       if (pstNorCfg != TYPES_NULL_PTR)
00068c  e3530000          CMP      r3,#0
000690  0a000003          BEQ      |L1.1700|
;;;608       {
;;;609          pstNorCfg->eWrBursLen = eWrBrstLen;
000694  e5c31004          STRB     r1,[r3,#4]
;;;610          pstNorCfg->eRdBursLen = eRdBrstLen;
000698  e5c32005          STRB     r2,[r3,#5]
;;;611          eResult = NORFLASH_STATUS_OK;
00069c  e3a00000          MOV      r0,#0
0006a0  ea000000          B        |L1.1704|
                  |L1.1700|
;;;612       }
;;;613       else
;;;614       {
;;;615          eResult = NORFLASH_STATUS_PTR_ERR;
0006a4  e3a00002          MOV      r0,#2
                  |L1.1704|
;;;616       }
;;;617       return eResult;
;;;618    }
0006a8  e12fff1e          BX       lr
;;;619    
                          ENDP

                  eNorFlash_SetBusTiming PROC
;;;621    /* TESTED */
;;;622    NorFlashStatus_e eNorFlash_SetBusTiming (NorFlashCfg_st * pstNorCfg,
0006ac  e92d4070          PUSH     {r4-r6,lr}
;;;623                                             uint32_t u32TurnaroundTime,
;;;624                                             uint32_t u32PageCycleTime,
;;;625                                             uint32_t u32WriteCycleTime,
;;;626                                             uint32_t u32ReadCycleTime)
;;;627    {
0006b0  e1a04000          MOV      r4,r0
0006b4  e59d5010          LDR      r5,[sp,#0x10]
;;;628       NorFlashStatus_e eResult;
;;;629    
;;;630       if (pstNorCfg != TYPES_NULL_PTR)
0006b8  e3540000          CMP      r4,#0
0006bc  0a00001f          BEQ      |L1.1856|
;;;631       {
;;;632          if ((pstNorCfg->u32ReadCycleTime < (NORFLASH_RD_CYCLE_MIN)) ||
0006c0  e5946014          LDR      r6,[r4,#0x14]
0006c4  e3560002          CMP      r6,#2
0006c8  3a000014          BCC      |L1.1824|
;;;633              (pstNorCfg->u32ReadCycleTime > (NORFLASH_RD_CYCLE_MAX)) ||
0006cc  e5946014          LDR      r6,[r4,#0x14]
0006d0  e356000f          CMP      r6,#0xf
0006d4  8a000011          BHI      |L1.1824|
;;;634              (pstNorCfg->u32WriteCycleTime < (NORFLASH_WR_CYCLE_MIN)) ||
0006d8  e5946010          LDR      r6,[r4,#0x10]
0006dc  e3560002          CMP      r6,#2
0006e0  3a00000e          BCC      |L1.1824|
;;;635              (pstNorCfg->u32WriteCycleTime > (NORFLASH_WR_CYCLE_MAX)) ||
0006e4  e5946010          LDR      r6,[r4,#0x10]
0006e8  e356000f          CMP      r6,#0xf
0006ec  8a00000b          BHI      |L1.1824|
;;;636              (pstNorCfg->u32PageCycleTime < (NORFLASH_PAGE_CYCLE_MIN)) ||
0006f0  e594600c          LDR      r6,[r4,#0xc]
0006f4  e3560000          CMP      r6,#0
0006f8  0a000008          BEQ      |L1.1824|
;;;637              (pstNorCfg->u32PageCycleTime > (NORFLASH_PAGE_CYCLE_MAX)) ||
0006fc  e594600c          LDR      r6,[r4,#0xc]
000700  e3560007          CMP      r6,#7
000704  8a000005          BHI      |L1.1824|
;;;638              (pstNorCfg->u32TurnaroundTime < (NORFLASH_TURNAROUND_MIN)) ||
000708  e5946008          LDR      r6,[r4,#8]
00070c  e3560000          CMP      r6,#0
000710  0a000002          BEQ      |L1.1824|
;;;639              (pstNorCfg->u32TurnaroundTime > (NORFLASH_TURNAROUND_MAX)))
000714  e5946008          LDR      r6,[r4,#8]
000718  e3560007          CMP      r6,#7
00071c  9a000001          BLS      |L1.1832|
                  |L1.1824|
;;;640          {
;;;641             eResult = NORFLASH_STATUS_CFG_ERR;
000720  e3a00003          MOV      r0,#3
000724  ea000006          B        |L1.1860|
                  |L1.1832|
;;;642          }
;;;643          else
;;;644          {
;;;645             pstNorCfg->u32TurnaroundTime = u32TurnaroundTime;
000728  e5841008          STR      r1,[r4,#8]
;;;646             pstNorCfg->u32PageCycleTime = u32PageCycleTime;
00072c  e584200c          STR      r2,[r4,#0xc]
;;;647             pstNorCfg->u32WriteCycleTime = u32WriteCycleTime;
000730  e5843010          STR      r3,[r4,#0x10]
;;;648             pstNorCfg->u32ReadCycleTime = u32ReadCycleTime;
000734  e5845014          STR      r5,[r4,#0x14]
;;;649             eResult = NORFLASH_STATUS_OK;
000738  e3a00000          MOV      r0,#0
00073c  ea000000          B        |L1.1860|
                  |L1.1856|
;;;650          }
;;;651    
;;;652       }
;;;653       else
;;;654       {
;;;655          eResult = NORFLASH_STATUS_PTR_ERR;
000740  e3a00002          MOV      r0,#2
                  |L1.1860|
;;;656       }
;;;657       return eResult;
;;;658    }
000744  e8bd8070          POP      {r4-r6,pc}
;;;659    
                          ENDP

                  eNorFlash_SetReadWriteSyncMode PROC
;;;661    /* TESTED */
;;;662    NorFlashStatus_e eNorFlash_SetReadWriteSyncMode (NorFlashCfg_st * pstNorCfg,
000748  e92d4010          PUSH     {r4,lr}
;;;663                                                     NorFlashRdWrMode_e eWrMode,
;;;664                                                     NorFlashRdWrMode_e eRdMode,
;;;665                                                     NorFlashBurstAlign_e
;;;666                                                     eBurstAlign)
;;;667    {
00074c  e1a04000          MOV      r4,r0
;;;668       NorFlashStatus_e eResult;
;;;669    
;;;670       if (pstNorCfg != TYPES_NULL_PTR)
000750  e3540000          CMP      r4,#0
000754  0a000004          BEQ      |L1.1900|
;;;671       {
;;;672          pstNorCfg->eWrMode = eWrMode;
000758  e5c41018          STRB     r1,[r4,#0x18]
;;;673          pstNorCfg->eRdMode = eRdMode;
00075c  e5c42019          STRB     r2,[r4,#0x19]
;;;674          pstNorCfg->eBurstAlign = eBurstAlign;
000760  e5c4301a          STRB     r3,[r4,#0x1a]
;;;675          eResult = NORFLASH_STATUS_OK;
000764  e3a00000          MOV      r0,#0
000768  ea000000          B        |L1.1904|
                  |L1.1900|
;;;676       }
;;;677       else
;;;678       {
;;;679          eResult = NORFLASH_STATUS_PTR_ERR;
00076c  e3a00002          MOV      r0,#2
                  |L1.1904|
;;;680       }
;;;681       return eResult;
;;;682    }
000770  e8bd8010          POP      {r4,pc}
;;;683    
                          ENDP

                  eNorFlash_SetSignalsAssertDelays PROC
;;;685    /* TESTED */
;;;686    NorFlashStatus_e eNorFlash_SetSignalsAssertDelays (NorFlashCfg_st * pstNorCfg,
000774  e92d4030          PUSH     {r4,r5,lr}
;;;687                                                       NorFlashWeTimeCfg_e eWeTime,
;;;688                                                       uint32_t u32AssertDelayWeN,
;;;689                                                       uint32_t u32AssertDelayOeN)
;;;690    {
000778  e1a04000          MOV      r4,r0
;;;691       NorFlashStatus_e eResult;
;;;692    
;;;693       if (pstNorCfg != TYPES_NULL_PTR)
00077c  e3540000          CMP      r4,#0
000780  0a000012          BEQ      |L1.2000|
;;;694       {
;;;695          if ((pstNorCfg->u32AssertDelayOeN < (NORFLASH_ASSERT_OEN_MIN)) ||
000784  e5945020          LDR      r5,[r4,#0x20]
000788  e3550000          CMP      r5,#0
00078c  0a000008          BEQ      |L1.1972|
;;;696              (pstNorCfg->u32AssertDelayOeN > (NORFLASH_ASSERT_OEN_MAX)) ||
000790  e5945020          LDR      r5,[r4,#0x20]
000794  e3550007          CMP      r5,#7
000798  8a000005          BHI      |L1.1972|
;;;697              (pstNorCfg->u32AssertDelayWeN < (NORFLASH_ASSERT_WEN_MIN)) ||
00079c  e594501c          LDR      r5,[r4,#0x1c]
0007a0  e3550000          CMP      r5,#0
0007a4  0a000002          BEQ      |L1.1972|
;;;698              (pstNorCfg->u32AssertDelayWeN > (NORFLASH_ASSERT_WEN_MAX)))
0007a8  e594501c          LDR      r5,[r4,#0x1c]
0007ac  e3550007          CMP      r5,#7
0007b0  9a000001          BLS      |L1.1980|
                  |L1.1972|
;;;699          {
;;;700             eResult = NORFLASH_STATUS_CFG_ERR;
0007b4  e3a00003          MOV      r0,#3
0007b8  ea000005          B        |L1.2004|
                  |L1.1980|
;;;701          }
;;;702          else
;;;703          {
;;;704             pstNorCfg->eWeTime = eWeTime;
0007bc  e5c4101b          STRB     r1,[r4,#0x1b]
;;;705             pstNorCfg->u32AssertDelayWeN = u32AssertDelayWeN;
0007c0  e584201c          STR      r2,[r4,#0x1c]
;;;706             pstNorCfg->u32AssertDelayOeN = u32AssertDelayOeN;
0007c4  e5843020          STR      r3,[r4,#0x20]
;;;707             eResult = NORFLASH_STATUS_OK;
0007c8  e3a00000          MOV      r0,#0
0007cc  ea000000          B        |L1.2004|
                  |L1.2000|
;;;708          }
;;;709       }
;;;710       else
;;;711       {
;;;712          eResult = NORFLASH_STATUS_PTR_ERR;
0007d0  e3a00002          MOV      r0,#2
                  |L1.2004|
;;;713       }
;;;714       return eResult;
;;;715    }
0007d4  e8bd8030          POP      {r4,r5,pc}
;;;716    
                          ENDP

                  eNorFlash_SetSignalsConfig PROC
;;;718    /* TESTED */
;;;719    NorFlashStatus_e eNorFlash_SetSignalsConfig (NorFlashCfg_st * pstNorCfg,
0007d8  e92d4010          PUSH     {r4,lr}
;;;720                                                 NorFlashByteLane_e eByteLane,
;;;721                                                 NorFlashAdvanceSignal_e eAdrAdvSig,
;;;722                                                 NorFlashAdvanceSignal_e
;;;723                                                 eBurstAdrAdvSig)
;;;724    {
0007dc  e1a04000          MOV      r4,r0
;;;725       NorFlashStatus_e eResult;
;;;726    
;;;727       if (pstNorCfg != TYPES_NULL_PTR)
0007e0  e3540000          CMP      r4,#0
0007e4  0a000004          BEQ      |L1.2044|
;;;728       {
;;;729          pstNorCfg->eByteLane = eByteLane;
0007e8  e5c41024          STRB     r1,[r4,#0x24]
;;;730          pstNorCfg->eAdrAdvSig = eAdrAdvSig;
0007ec  e5c42025          STRB     r2,[r4,#0x25]
;;;731          pstNorCfg->eBurstAdrAdvSig = eBurstAdrAdvSig;
0007f0  e5c43026          STRB     r3,[r4,#0x26]
;;;732          eResult = NORFLASH_STATUS_OK;
0007f4  e3a00000          MOV      r0,#0
0007f8  ea000000          B        |L1.2048|
                  |L1.2044|
;;;733       }
;;;734       else
;;;735       {
;;;736          eResult = NORFLASH_STATUS_PTR_ERR;
0007fc  e3a00002          MOV      r0,#2
                  |L1.2048|
;;;737       }
;;;738       return eResult;
;;;739    }
000800  e8bd8010          POP      {r4,pc}
;;;740    
                          ENDP

                  eNorFlash_Reset PROC
;;;742    /* TESTED */
;;;743    NorFlashStatus_e eNorFlash_Reset (const NorFlashCfg_st * const pstNorCfg)
000804  e1a01000          MOV      r1,r0
;;;744    {
;;;745       NorFlashStatus_e eResult;
;;;746    
;;;747       if (pstNorCfg != TYPES_NULL_PTR)
000808  e3510000          CMP      r1,#0
00080c  0a000004          BEQ      |L1.2084|
;;;748       {
;;;749          uint32_t u32NorBase = pstNorCfg->u32NorChipAdr;
000810  e5912000          LDR      r2,[r1,#0]
;;;750    
;;;751          /* NORFLASH_BUS_WIDTH_16 */
;;;752          NORFLASH_WORD_ACCESS (u32NorBase, 0x00UL) = (uint16_t)NORFLASH_CMD_RESET;
000814  e3a030f0          MOV      r3,#0xf0
000818  e1c230b0          STRH     r3,[r2,#0]
;;;753          eResult = NORFLASH_STATUS_OK;
00081c  e3a00000          MOV      r0,#0
;;;754       }
000820  ea000000          B        |L1.2088|
                  |L1.2084|
;;;755       else
;;;756       {
;;;757          eResult = NORFLASH_STATUS_PTR_ERR;
000824  e3a00002          MOV      r0,#2
                  |L1.2088|
;;;758       }
;;;759       return eResult;
;;;760    }
000828  e12fff1e          BX       lr
;;;761    
                          ENDP

                  eNorFlash_Read16bitWords PROC
;;;763    /* TESTED */
;;;764    NorFlashStatus_e eNorFlash_Read16bitWords (const NorFlashCfg_st *
00082c  e92d40f0          PUSH     {r4-r7,lr}
;;;765                                               const pstNorCfg, uint32_t u32SrcAdr,
;;;766                                               uint16_t pu16DstBuf[],
;;;767                                               uint32_t u32BufferLen)
;;;768    {
000830  e1a04000          MOV      r4,r0
000834  e1a05001          MOV      r5,r1
;;;769       NorFlashStatus_e eResult;
;;;770    
;;;771       if (pstNorCfg != TYPES_NULL_PTR)
000838  e3540000          CMP      r4,#0
00083c  0a00000b          BEQ      |L1.2160|
;;;772       {
;;;773          uint32_t u32Idx;
;;;774    
;;;775          uint16_t *pu16Address;
;;;776    
;;;777    /***
;;;778    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;779    *          integral type.
;;;780    *
;;;781    * DESC   : Thes message is undestood, but the pointer cast is required
;;;782    *          to maintian properly the position within the 16-bit buffer.
;;;783    ****/
;;;784          /* Modify a source pointer */
;;;785          pu16Address = (uint16_t *)u32SrcAdr;    /* PRQA S 0306 */
000840  e1a06005          MOV      r6,r5
;;;786          for (u32Idx = 0U; u32Idx < u32BufferLen; u32Idx++)
000844  e3a00000          MOV      r0,#0
000848  ea000004          B        |L1.2144|
                  |L1.2124|
;;;787          {
;;;788             pu16DstBuf[u32Idx] = pu16Address[u32Idx]; /* Destination <- Source */
00084c  e0867080          ADD      r7,r6,r0,LSL #1
000850  e1d770b0          LDRH     r7,[r7,#0]
000854  e082c080          ADD      r12,r2,r0,LSL #1
000858  e1cc70b0          STRH     r7,[r12,#0]
00085c  e2800001          ADD      r0,r0,#1              ;786
                  |L1.2144|
000860  e1500003          CMP      r0,r3                 ;786
000864  3afffff8          BCC      |L1.2124|
;;;789          }
;;;790          eResult = NORFLASH_STATUS_OK;
000868  e3a01000          MOV      r1,#0
;;;791       }
00086c  ea000000          B        |L1.2164|
                  |L1.2160|
;;;792       else
;;;793       {
;;;794          eResult = NORFLASH_STATUS_PTR_ERR;
000870  e3a01002          MOV      r1,#2
                  |L1.2164|
;;;795       }
;;;796       return eResult;
000874  e1a00001          MOV      r0,r1
;;;797    }
000878  e8bd80f0          POP      {r4-r7,pc}
;;;798    
                          ENDP

                  eNorFlash_Read32bitWords PROC
;;;800    /* TESTED */
;;;801    NorFlashStatus_e eNorFlash_Read32bitWords (const NorFlashCfg_st *
00087c  e92d40f0          PUSH     {r4-r7,lr}
;;;802                                               const pstNorCfg, uint32_t u32SrcAdr,
;;;803                                               uint32_t pu32DstBuf[],
;;;804                                               uint32_t u32BufferLen)
;;;805    {
000880  e1a04000          MOV      r4,r0
000884  e1a05001          MOV      r5,r1
;;;806       NorFlashStatus_e eResult;
;;;807    
;;;808       /*
;;;809          Assume the MemCtrl is converting a 32-bit access to the appropriate
;;;810          number of bus accesses for 8-bit and 16-bit devices? The reading is very
;;;811          simple operation: copy a content from the location indicated by the
;;;812          source pointer and store it at the destination. */
;;;813       if (pstNorCfg != TYPES_NULL_PTR)
000888  e3540000          CMP      r4,#0
00088c  0a000009          BEQ      |L1.2232|
;;;814       {
;;;815          uint32_t u32Idx;
;;;816    
;;;817          uint32_t *pu32Address;
;;;818    
;;;819    /***
;;;820    * MESSAGE: MISRA-C:2004 Rule 11.3 [I] Cast between a pointer to object and an
;;;821    *          integral type.
;;;822    *
;;;823    * DESC   : Thes message is undestood, but the pointer cast is required
;;;824    *          to maintian properly the position within the buffer.
;;;825    ****/
;;;826          /* Modify a source pointer */
;;;827          pu32Address = (uint32_t *)u32SrcAdr;    /* PRQA S 0306 */
000890  e1a06005          MOV      r6,r5
;;;828          for (u32Idx = 0U; u32Idx < u32BufferLen; u32Idx++)
000894  e3a00000          MOV      r0,#0
000898  ea000002          B        |L1.2216|
                  |L1.2204|
;;;829          {
;;;830             pu32DstBuf[u32Idx] = pu32Address[u32Idx]; /* Destination <- Source */
00089c  e7967100          LDR      r7,[r6,r0,LSL #2]
0008a0  e7827100          STR      r7,[r2,r0,LSL #2]
0008a4  e2800001          ADD      r0,r0,#1              ;828
                  |L1.2216|
0008a8  e1500003          CMP      r0,r3                 ;828
0008ac  3afffffa          BCC      |L1.2204|
;;;831          }
;;;832          eResult = NORFLASH_STATUS_OK;
0008b0  e3a01000          MOV      r1,#0
;;;833       }
0008b4  ea000000          B        |L1.2236|
                  |L1.2232|
;;;834       else
;;;835       {
;;;836          eResult = NORFLASH_STATUS_PTR_ERR;
0008b8  e3a01002          MOV      r1,#2
                  |L1.2236|
;;;837       }
;;;838       return eResult;
0008bc  e1a00001          MOV      r0,r1
;;;839    }
0008c0  e8bd80f0          POP      {r4-r7,pc}
;;;840    
                          ENDP

                  |L1.2244|
                          DCD      0xc0200000
