; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\pl353_nandflash.o --asm_dir=..\out\ --list_dir=..\out\ --depend=..\out\pl353_nandflash.d --cpu=Cortex-R4 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\inc -I..\..\usecases\inc -I..\..\..\..\common\inc -I..\..\..\..\cortex_r4_keil\inc -I..\..\..\..\freetype\inc -I..\..\..\..\hldd\inc -I..\..\..\..\lldd\inc -I..\..\..\..\lldd\hdr -I..\..\..\..\mw\inc -I..\..\usecases\images\inc -I..\..\..\..\cortex_r4\inc -I..\..\src -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=516 -D__KEIL__ -DMEASURE_TX --omf_browse=..\out\pl353_nandflash.crf ..\..\..\..\hldd\src\pl353_nandflash.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vNF_CmdPhaseAxiBlockSelect PROC
;;;74     /* TESTED */
;;;75     static void vNF_CmdPhaseAxiBlockSelect (const NandFlashCfg_st *
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;76                                             const pstNandCfg, uint32_t u32BlockNo,
;;;77                                             uint32_t u32StartCommand,
;;;78                                             uint32_t u32EndCmdValid,
;;;79                                             uint32_t u32EndCommand)
;;;80     {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
000014  e59da028          LDR      r10,[sp,#0x28]
;;;81        uint32_t u32CmdPh;                       /* to be send within a cmd phase */
;;;82     
;;;83        uint32_t *pu32CmdPhDest;
;;;84     
;;;85        uint32_t u32Data;
;;;86     
;;;87        NANDFLASH_CLEAR_READY_IRQ ();
000018  e3a00010          MOV      r0,#0x10
00001c  e59f1b80          LDR      r1,|L1.2980|
000020  e581000c          STR      r0,[r1,#0xc]
;;;88        /*
;;;89           WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;90           already.
;;;91     
;;;92           u32NoOfAddrCycles is most probably NOT the same as MEMCTRL_BASE! This
;;;93           needs to be clarified!
;;;94     
;;;95           u32NoOfAddrCycles is DEVICE-dependent and can be calculated based on the
;;;96           total size of the device (page size, number of pages in a block and
;;;97           number of blocks). Use 3 address cycles for ERASE. */
;;;98        u32CmdPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
000024  e5950000          LDR      r0,[r5,#0]
000028  e20044ff          AND      r4,r0,#0xff000000
;;;99        u32CmdPh = (u32CmdPh | (3U << (MEMCTRL_AXI_ADDRES_CYCLES_SFT)));
00002c  e3844606          ORR      r4,r4,#0x600000
;;;100       u32CmdPh = (u32CmdPh | (u32EndCmdValid << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
000030  e1844a08          ORR      r4,r4,r8,LSL #20
;;;101       u32CmdPh =
000034  e320f000          NOP      
;;;102          (u32CmdPh | (NF_PAR_CMD_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;103       u32CmdPh = (u32CmdPh | (u32EndCommand << (MEMCTRL_AXI_END_COMMAND_SFT)));
000038  e184458a          ORR      r4,r4,r10,LSL #11
;;;104       u32CmdPh = (u32CmdPh | (u32StartCommand << (MEMCTRL_AXI_START_COMMAND_SFT)));
00003c  e1844187          ORR      r4,r4,r7,LSL #3
;;;105       pu32CmdPhDest = (uint32_t *)u32CmdPh;
000040  e1a0b004          MOV      r11,r4
;;;106    
;;;107       /* Construct Command-Phase Data Re-formatted address */
;;;108       u32Data = (0x00U);                       /* Page is ignored / not shifted */
000044  e3a09000          MOV      r9,#0
;;;109       u32Data = u32Data | ((u32BlockNo) << 6); /* Block is shifted by 6 bits */
000048  e1899306          ORR      r9,r9,r6,LSL #6
;;;110       *pu32CmdPhDest = u32Data;                /* write it */
00004c  e58b9000          STR      r9,[r11,#0]
;;;111       NF_uSecWait (3);
000050  e3a00003          MOV      r0,#3
000054  ebfffffe          BL       NF_uSecWait
;;;112    }
000058  e8bd9ff0          POP      {r4-r12,pc}
;;;113    
                          ENDP

                  vNF_DataPhaseAxiWrMultiBytes PROC
;;;115    /* TESTED on silicon */
;;;116    static void vNF_DataPhaseAxiWrMultiBytes (const NandFlashCfg_st *
00005c  e92d4ff8          PUSH     {r3-r11,lr}
;;;117                                              const pstNandCfg,
;;;118                                              uint32_t u32BufferLen,
;;;119                                              const uint8_t pu8SrcBuf[],
;;;120                                              uint32_t u32EccLast,
;;;121                                              const uint8_t pu8ExtrBuf[])
;;;122    {
000060  e1a07000          MOV      r7,r0
000064  e1a0a001          MOV      r10,r1
000068  e1a0b002          MOV      r11,r2
00006c  e1a09003          MOV      r9,r3
;;;123       uint32_t u32DatPh;                       /* Word to be send within a command
;;;124                                                   phase */
;;;125       uint32_t u32Idx;
;;;126    
;;;127       uint32_t u32TmpLen;
;;;128    
;;;129       uint32_t *pu32WrData;   
;;;130    
;;;131       /*
;;;132          WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;133          already... */
;;;134       u32DatPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
000070  e5970000          LDR      r0,[r7,#0]
000074  e20054ff          AND      r5,r0,#0xff000000
;;;135       u32DatPh = (u32DatPh | (NF_PAR_CS_ACTIV << (MEMCTRL_AXI_CLEAR_CS_SFT)));
000078  e320f000          NOP      
;;;136       u32DatPh =
00007c  e3855702          ORR      r5,r5,#0x80000
;;;137          (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;138       u32DatPh = (u32DatPh | (NF_PAR_ECC_CALC << (MEMCTRL_AXI_ECC_LAST_SFT)));
000080  e320f000          NOP      
;;;139    
;;;140       u32TmpLen = (u32BufferLen >> 2);         /* 4 bytes per access */
000084  e1a0012a          LSR      r0,r10,#2
000088  e58d0000          STR      r0,[sp,#0]
;;;141    
;;;142       pu32WrData = (uint32_t *)pu8SrcBuf;      /* Write to device */
00008c  e1a0600b          MOV      r6,r11
;;;143    
;;;144       if (pstNandCfg->eExtraBlockCfg == NANDFLASH_EXTRA_BLOCK_DISABLED)
000090  e5d70006          LDRB     r0,[r7,#6]
000094  e3500000          CMP      r0,#0
000098  1a00001a          BNE      |L1.264|
;;;145       {
;;;146          /* Without Extra Block simply write Page data */
;;;147          for (u32Idx = 0U; u32Idx < (u32TmpLen - 2U); u32Idx+=2)
00009c  e3a04000          MOV      r4,#0
0000a0  ea000006          B        |L1.192|
                  |L1.164|
;;;148          {
;;;149             /* Write to device */
;;;150             vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
0000a4  e2840001          ADD      r0,r4,#1
0000a8  e7962100          LDR      r2,[r6,r0,LSL #2]
0000ac  e7961104          LDR      r1,[r6,r4,LSL #2]
0000b0  e1a00005          MOV      r0,r5
0000b4  ebfffffe          BL       vNF_AddrBrstWr
;;;151             __DSB();
0000b8  ebfffffe          BL       __DSB
0000bc  e2844002          ADD      r4,r4,#2              ;147
                  |L1.192|
0000c0  e59d0000          LDR      r0,[sp,#0]            ;147
0000c4  e2400002          SUB      r0,r0,#2              ;147
0000c8  e1500004          CMP      r0,r4                 ;147
0000cc  8afffff4          BHI      |L1.164|
;;;152          }
;;;153          /* Chip select must be finished in the last transfer. ECC calculation End
;;;154             depends on the u32EccLast parameter value. */
;;;155          u32DatPh =
0000d0  e5970000          LDR      r0,[r7,#0]
0000d4  e20054ff          AND      r5,r0,#0xff000000
;;;156             ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
;;;157          u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
0000d8  e3855602          ORR      r5,r5,#0x200000
;;;158          /* check if END command is required for programming? */
;;;159          u32DatPh =
0000dc  e3855601          ORR      r5,r5,#0x100000
;;;160             (u32DatPh | (NF_PAR_END_VALID << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
;;;161          u32DatPh =
0000e0  e3855702          ORR      r5,r5,#0x80000
;;;162             (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;163          u32DatPh =
0000e4  e3855902          ORR      r5,r5,#0x8000
;;;164             (u32DatPh |
;;;165              (NANDFLASH_CMD_PROGRAM_END << (MEMCTRL_AXI_END_COMMAND_SFT)));
;;;166          u32DatPh = (u32DatPh | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
0000e8  e1855509          ORR      r5,r5,r9,LSL #10
;;;167    
;;;168          vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
0000ec  e2840001          ADD      r0,r4,#1
0000f0  e7962100          LDR      r2,[r6,r0,LSL #2]
0000f4  e7961104          LDR      r1,[r6,r4,LSL #2]
0000f8  e1a00005          MOV      r0,r5
0000fc  ebfffffe          BL       vNF_AddrBrstWr
;;;169          __DSB();
000100  ebfffffe          BL       __DSB
000104  ea000034          B        |L1.476|
                  |L1.264|
;;;170       }
;;;171       else
;;;172       {
;;;173          uint32_t u32ExtrBufLen;
;;;174    
;;;175          /* With Extra Block write Page data ... */
;;;176          for (u32Idx = 0U; u32Idx < u32TmpLen; u32Idx+=2)
000108  e3a04000          MOV      r4,#0
00010c  ea000006          B        |L1.300|
                  |L1.272|
;;;177          {
;;;178            vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
000110  e2840001          ADD      r0,r4,#1
000114  e7962100          LDR      r2,[r6,r0,LSL #2]
000118  e7961104          LDR      r1,[r6,r4,LSL #2]
00011c  e1a00005          MOV      r0,r5
000120  ebfffffe          BL       vNF_AddrBrstWr
;;;179            __DSB();
000124  ebfffffe          BL       __DSB
000128  e2844002          ADD      r4,r4,#2              ;176
                  |L1.300|
00012c  e59d0000          LDR      r0,[sp,#0]            ;176
000130  e1540000          CMP      r4,r0                 ;176
000134  3afffff5          BCC      |L1.272|
;;;180          }
;;;181          /* ... and continue with Extra data */
;;;182          switch (pstNandCfg->eExtraBlockCfg)
000138  e5d70006          LDRB     r0,[r7,#6]
00013c  e3500002          CMP      r0,#2
000140  0a000003          BEQ      |L1.340|
000144  e3500003          CMP      r0,#3
000148  1a000004          BNE      |L1.352|
;;;183          {
;;;184                /* find out the extra buffer size */
;;;185             case NANDFLASH_EXTRA_BLOCK_32_BYTES:
;;;186             {
;;;187                u32ExtrBufLen = (32U >> 2);     /* 4 bytes per access */
00014c  e3a08008          MOV      r8,#8
;;;188             }
;;;189                break;
000150  ea000005          B        |L1.364|
                  |L1.340|
;;;190             case NANDFLASH_EXTRA_BLOCK_16_BYTES:
000154  e320f000          NOP      
;;;191             {
;;;192                u32ExtrBufLen = (16U >> 2);     /* 4 bytes per access */
000158  e3a08004          MOV      r8,#4
;;;193             }
;;;194             break;
00015c  ea000002          B        |L1.364|
                  |L1.352|
;;;195             default:                          /* NANDFLASH_EXTRA_BLOCK_8_BYTES */
000160  e320f000          NOP      
;;;196             {
;;;197                 u32ExtrBufLen = (8U >> 2);      /* 4 bytes per access */
000164  e3a08002          MOV      r8,#2
;;;198             }
;;;199                break;
000168  e320f000          NOP      
                  |L1.364|
00016c  e320f000          NOP                            ;189
;;;200          }
;;;201          pu32WrData = (uint32_t *)pu8ExtrBuf;  /* Write to device */
000170  e59d6028          LDR      r6,[sp,#0x28]
;;;202    
;;;203          for (u32Idx = 0U; u32Idx < (u32ExtrBufLen - 2); u32Idx+=2)
000174  e3a04000          MOV      r4,#0
000178  ea000006          B        |L1.408|
                  |L1.380|
;;;204          {
;;;205             vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
00017c  e2840001          ADD      r0,r4,#1
000180  e7962100          LDR      r2,[r6,r0,LSL #2]
000184  e7961104          LDR      r1,[r6,r4,LSL #2]
000188  e1a00005          MOV      r0,r5
00018c  ebfffffe          BL       vNF_AddrBrstWr
;;;206             __DSB();
000190  ebfffffe          BL       __DSB
000194  e2844002          ADD      r4,r4,#2              ;203
                  |L1.408|
000198  e2480002          SUB      r0,r8,#2              ;203
00019c  e1500004          CMP      r0,r4                 ;203
0001a0  8afffff5          BHI      |L1.380|
;;;207          }
;;;208          /* Chip select must be finished in the last transfer. ECC calculation End
;;;209             depends on the u32EccLast parameter value. */
;;;210          u32DatPh =
0001a4  e5970000          LDR      r0,[r7,#0]
0001a8  e20054ff          AND      r5,r0,#0xff000000
;;;211             ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
;;;212          u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
0001ac  e3855602          ORR      r5,r5,#0x200000
;;;213          /* check if END command is required for programming? */
;;;214          u32DatPh =
0001b0  e3855601          ORR      r5,r5,#0x100000
;;;215             (u32DatPh | (NF_PAR_END_VALID << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
;;;216          u32DatPh =
0001b4  e3855702          ORR      r5,r5,#0x80000
;;;217             (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;218          u32DatPh =
0001b8  e3855902          ORR      r5,r5,#0x8000
;;;219             (u32DatPh |
;;;220              (NANDFLASH_CMD_PROGRAM_END << (MEMCTRL_AXI_END_COMMAND_SFT)));
;;;221          u32DatPh = (u32DatPh | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
0001bc  e1855509          ORR      r5,r5,r9,LSL #10
;;;222          vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx],pu32WrData[u32Idx+1]);
0001c0  e2840001          ADD      r0,r4,#1
0001c4  e7962100          LDR      r2,[r6,r0,LSL #2]
0001c8  e7961104          LDR      r1,[r6,r4,LSL #2]
0001cc  e1a00005          MOV      r0,r5
0001d0  ebfffffe          BL       vNF_AddrBrstWr
;;;223          
;;;224          __DSB();
0001d4  ebfffffe          BL       __DSB
;;;225       }
0001d8  e320f000          NOP      
                  |L1.476|
;;;226    }
0001dc  e8bd8ff8          POP      {r3-r11,pc}
;;;227    
                          ENDP

                  vNF_DataPhaseAxiWrMulti16Bits PROC
;;;345    /* TESTED on silicon */
;;;346    static void vNF_DataPhaseAxiWrMulti16Bits (const NandFlashCfg_st *
0001e0  e92d4ff8          PUSH     {r3-r11,lr}
;;;347                                               const pstNandCfg,
;;;348                                               uint32_t u32BufferLen,
;;;349                                               const uint16_t pu16SrcBuf[],
;;;350                                               uint32_t u32EccLast,
;;;351                                               const uint16_t pu16ExtrBuf[])
;;;352    {
0001e4  e1a07000          MOV      r7,r0
0001e8  e1a0a001          MOV      r10,r1
0001ec  e1a0b002          MOV      r11,r2
0001f0  e1a09003          MOV      r9,r3
;;;353       uint32_t u32DatPh;                       /* Word to be send within a command
;;;354                                                   phase */
;;;355       uint32_t u32Idx;
;;;356    
;;;357       uint32_t u32TmpLen;
;;;358    
;;;359       uint32_t *pu32WrData;
;;;360    
;;;361    
;;;362       /*
;;;363          WARNINGS: u32NandChipAddress should be stored in cfg structure shifted
;;;364          already... */
;;;365       u32DatPh = ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
0001f4  e5970000          LDR      r0,[r7,#0]
0001f8  e20054ff          AND      r5,r0,#0xff000000
;;;366       u32DatPh = (u32DatPh | (NF_PAR_CS_ACTIV << (MEMCTRL_AXI_CLEAR_CS_SFT)));
0001fc  e320f000          NOP      
;;;367    
;;;368       u32DatPh =
000200  e3855702          ORR      r5,r5,#0x80000
;;;369          (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;370       u32DatPh = (u32DatPh | (NF_PAR_ECC_CALC << (MEMCTRL_AXI_ECC_LAST_SFT)));
000204  e320f000          NOP      
;;;371    
;;;372       u32TmpLen = (u32BufferLen >> 1);         /* 2 words per access */
000208  e1a000aa          LSR      r0,r10,#1
00020c  e58d0000          STR      r0,[sp,#0]
;;;373    
;;;374       pu32WrData = (uint32_t *)pu16SrcBuf;     /* Write to device */
000210  e1a0600b          MOV      r6,r11
;;;375    
;;;376       if (pstNandCfg->eExtraBlockCfg == NANDFLASH_EXTRA_BLOCK_DISABLED)
000214  e5d70006          LDRB     r0,[r7,#6]
000218  e3500000          CMP      r0,#0
00021c  1a00001a          BNE      |L1.652|
;;;377       {
;;;378          /* Without Extra Block simply write Page data */
;;;379          for (u32Idx = 0U; u32Idx < (u32TmpLen - 2U); u32Idx+=2)
000220  e3a04000          MOV      r4,#0
000224  ea000006          B        |L1.580|
                  |L1.552|
;;;380          {
;;;381             vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
000228  e2840001          ADD      r0,r4,#1
00022c  e7962100          LDR      r2,[r6,r0,LSL #2]
000230  e7961104          LDR      r1,[r6,r4,LSL #2]
000234  e1a00005          MOV      r0,r5
000238  ebfffffe          BL       vNF_AddrBrstWr
;;;382             __DSB();
00023c  ebfffffe          BL       __DSB
000240  e2844002          ADD      r4,r4,#2              ;379
                  |L1.580|
000244  e59d0000          LDR      r0,[sp,#0]            ;379
000248  e2400002          SUB      r0,r0,#2              ;379
00024c  e1500004          CMP      r0,r4                 ;379
000250  8afffff4          BHI      |L1.552|
;;;383          }
;;;384          /*
;;;385             Chip select must be finished in the last transfer. ECC calculation End
;;;386             depends on the u32EccLast parameter value. */
;;;387          u32DatPh =
000254  e5970000          LDR      r0,[r7,#0]
000258  e20054ff          AND      r5,r0,#0xff000000
;;;388             ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
;;;389          u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
00025c  e3855602          ORR      r5,r5,#0x200000
;;;390          /* check if END command is required for programming */
;;;391          u32DatPh =
000260  e3855601          ORR      r5,r5,#0x100000
;;;392             (u32DatPh | (NF_PAR_END_VALID << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
;;;393          u32DatPh =
000264  e3855702          ORR      r5,r5,#0x80000
;;;394             (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;395          u32DatPh =
000268  e3855902          ORR      r5,r5,#0x8000
;;;396             (u32DatPh |
;;;397              (NANDFLASH_CMD_PROGRAM_END << (MEMCTRL_AXI_END_COMMAND_SFT)));
;;;398          u32DatPh = (u32DatPh | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
00026c  e1855509          ORR      r5,r5,r9,LSL #10
;;;399    
;;;400          vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
000270  e2840001          ADD      r0,r4,#1
000274  e7962100          LDR      r2,[r6,r0,LSL #2]
000278  e7961104          LDR      r1,[r6,r4,LSL #2]
00027c  e1a00005          MOV      r0,r5
000280  ebfffffe          BL       vNF_AddrBrstWr
;;;401          __DSB();
000284  ebfffffe          BL       __DSB
000288  ea000033          B        |L1.860|
                  |L1.652|
;;;402       }
;;;403       else
;;;404       {
;;;405          uint32_t u32ExtrBufLen;
;;;406    
;;;407          /* With Extra Block write Page data ... */
;;;408          for (u32Idx = 0U; u32Idx < u32TmpLen; u32Idx+=2)
00028c  e3a04000          MOV      r4,#0
000290  ea000005          B        |L1.684|
                  |L1.660|
;;;409          {
;;;410             vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
000294  e2840001          ADD      r0,r4,#1
000298  e7962100          LDR      r2,[r6,r0,LSL #2]
00029c  e7961104          LDR      r1,[r6,r4,LSL #2]
0002a0  e1a00005          MOV      r0,r5
0002a4  ebfffffe          BL       vNF_AddrBrstWr
0002a8  e2844002          ADD      r4,r4,#2              ;408
                  |L1.684|
0002ac  e59d0000          LDR      r0,[sp,#0]            ;408
0002b0  e1540000          CMP      r4,r0                 ;408
0002b4  3afffff6          BCC      |L1.660|
;;;411          }
;;;412          /* ... and continue with Extra data */
;;;413          switch (pstNandCfg->eExtraBlockCfg)
0002b8  e5d70006          LDRB     r0,[r7,#6]
0002bc  e3500002          CMP      r0,#2
0002c0  0a000003          BEQ      |L1.724|
0002c4  e3500003          CMP      r0,#3
0002c8  1a000004          BNE      |L1.736|
;;;414          {
;;;415                /* find out the extra buffer size */
;;;416             case NANDFLASH_EXTRA_BLOCK_32_BYTES:
;;;417             {
;;;418                u32ExtrBufLen = (32U >> 2);     /* 4 bytes per access */
0002cc  e3a08008          MOV      r8,#8
;;;419             }
;;;420                break;
0002d0  ea000005          B        |L1.748|
                  |L1.724|
;;;421             case NANDFLASH_EXTRA_BLOCK_16_BYTES:
0002d4  e320f000          NOP      
;;;422             {
;;;423                u32ExtrBufLen = (16U >> 2);     /* 4 bytes per access */
0002d8  e3a08004          MOV      r8,#4
;;;424             }
;;;425                break;
0002dc  ea000002          B        |L1.748|
                  |L1.736|
;;;426            default: 
0002e0  e320f000          NOP      
;;;427             {
;;;428                u32ExtrBufLen = (8U >> 2);      /* 4 bytes per access */
0002e4  e3a08002          MOV      r8,#2
;;;429             }
;;;430             break;         
0002e8  e320f000          NOP      
                  |L1.748|
0002ec  e320f000          NOP                            ;420
;;;431          }
;;;432          pu32WrData = (uint32_t *)pu16ExtrBuf; /* Write to device */
0002f0  e59d6028          LDR      r6,[sp,#0x28]
;;;433          for (u32Idx = 0U; u32Idx < (u32ExtrBufLen - 2); u32Idx+=2)
0002f4  e3a04000          MOV      r4,#0
0002f8  ea000006          B        |L1.792|
                  |L1.764|
;;;434          {
;;;435            vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
0002fc  e2840001          ADD      r0,r4,#1
000300  e7962100          LDR      r2,[r6,r0,LSL #2]
000304  e7961104          LDR      r1,[r6,r4,LSL #2]
000308  e1a00005          MOV      r0,r5
00030c  ebfffffe          BL       vNF_AddrBrstWr
;;;436            __DSB();
000310  ebfffffe          BL       __DSB
000314  e2844002          ADD      r4,r4,#2              ;433
                  |L1.792|
000318  e2480002          SUB      r0,r8,#2              ;433
00031c  e1500004          CMP      r0,r4                 ;433
000320  8afffff5          BHI      |L1.764|
;;;437          }
;;;438          /* Chip select must be finished in the last transfer. ECC calculation End
;;;439             depends on the u32EccLast parameter value. */
;;;440          u32DatPh =
000324  e5970000          LDR      r0,[r7,#0]
000328  e20054ff          AND      r5,r0,#0xff000000
;;;441             ((pstNandCfg->u32NandChipAddress) & (MEMCTRL_AXI_BASE_ADDR_MASK));
;;;442          u32DatPh = (u32DatPh | (NF_PAR_CS_CLEAR << (MEMCTRL_AXI_CLEAR_CS_SFT)));
00032c  e3855602          ORR      r5,r5,#0x200000
;;;443          /* check if END command is required for programming? */
;;;444          u32DatPh =
000330  e3855601          ORR      r5,r5,#0x100000
;;;445             (u32DatPh | (NF_PAR_END_VALID << (MEMCTRL_AXI_END_CMD_VALID_SFT)));
;;;446          u32DatPh =
000334  e3855702          ORR      r5,r5,#0x80000
;;;447             (u32DatPh | (NF_PAR_DATA_PHASE << (MEMCTRL_AXI_CMD_DATA_SELECT_SFT)));
;;;448          u32DatPh =
000338  e3855902          ORR      r5,r5,#0x8000
;;;449             (u32DatPh |
;;;450              (NANDFLASH_CMD_PROGRAM_END << (MEMCTRL_AXI_END_COMMAND_SFT)));
;;;451          u32DatPh = (u32DatPh | (u32EccLast << (MEMCTRL_AXI_ECC_LAST_SFT)));
00033c  e1855509          ORR      r5,r5,r9,LSL #10
;;;452    
;;;453          /* Last Write to device */
;;;454          vNF_AddrBrstWr(u32DatPh, pu32WrData[u32Idx], pu32WrData[u32Idx+1]);
000340  e2840001          ADD      r0,r4,#1
000344  e7962100          LDR      r2,[r6,r0,LSL #2]
000348  e7961104          LDR      r1,[r6,r4,LSL #2]
00034c  e1a00005          MOV      r0,r5
000350  ebfffffe          BL       vNF_AddrBrstWr
;;;455          __DSB();
000354  ebfffffe          BL       __DSB
;;;456       }
000358  e320f000          NOP      
                  |L1.860|
;;;457    }
00035c  e8bd8ff8          POP      {r3-r11,pc}
;;;458    
                          ENDP

                  eIplPrgNand_Configure PROC
;;;577    /* TESTED */
;;;578    NandFlashStatus_e eIplPrgNand_Configure (NandFlashCfg_st * pstCfg,
000360  e92d5ffc          PUSH     {r2-r12,lr}
;;;579                                             NandFlashDeviceType_e eDevice,
;;;580                                             NandFlashExtraBlock_e eExtraBlkCfg)
;;;581    {
000364  e1a05000          MOV      r5,r0
000368  e1a06001          MOV      r6,r1
00036c  e1a04002          MOV      r4,r2
;;;582       NandFlashStatus_e eNfFinalRslt = NANDFLASH_STATUS_UNKNOWN;
000370  e3a00001          MOV      r0,#1
000374  e58d0004          STR      r0,[sp,#4]
;;;583    
;;;584       NandFlashStatus_e eNfRslt0 = NANDFLASH_STATUS_UNKNOWN;
000378  e3a07001          MOV      r7,#1
;;;585    
;;;586       NandFlashStatus_e eNfRslt1 = NANDFLASH_STATUS_UNKNOWN;
00037c  e3a08001          MOV      r8,#1
;;;587    
;;;588       NandFlashStatus_e eNfRslt2 = NANDFLASH_STATUS_UNKNOWN;
000380  e3a09001          MOV      r9,#1
;;;589    
;;;590       NandFlashStatus_e eNfRslt3 = NANDFLASH_STATUS_UNKNOWN;
000384  e3a0a001          MOV      r10,#1
;;;591    
;;;592       NandFlashStatus_e eNfRslt4 = NANDFLASH_STATUS_UNKNOWN;
000388  e3a0b001          MOV      r11,#1
;;;593    
;;;594    
;;;595       /* Load HW settings from registers to config structure. */
;;;596       eNfRslt0 = eNandFlash_GetHwConfig (pstCfg);
00038c  e1a00005          MOV      r0,r5
000390  ebfffffe          BL       eNandFlash_GetHwConfig
000394  e1a07000          MOV      r7,r0
;;;597    
;;;598       /* eExtraBlkCfg selection comes from boot options / XLS file */
;;;599       eNfRslt1 = eNandFlash_SetExtraBlock (pstCfg, eExtraBlkCfg);
000398  e1a01004          MOV      r1,r4
00039c  e1a00005          MOV      r0,r5
0003a0  ebfffffe          BL       eNandFlash_SetExtraBlock
0003a4  e1a08000          MOV      r8,r0
;;;600       /* Modify to max. values: u32IdRdTime u32StatusRdTime u32WriteCycleTime
;;;601          u32ReadCycleTime */
;;;602       /* Modify to max. values: u32BusyCycleToReN u32DeAssertDelayWeN
;;;603          u32AssertDelayReN */
;;;604    
;;;605     /* Set timing parameters */
;;;606        eNfRslt2 = eNandFlash_SetBusTiming(pstCfg,
0003a8  e3a00007          MOV      r0,#7
0003ac  e58d0000          STR      r0,[sp,#0]
0003b0  e1a03000          MOV      r3,r0
0003b4  e3a02002          MOV      r2,#2
0003b8  e1a01002          MOV      r1,r2
0003bc  e1a00005          MOV      r0,r5
0003c0  ebfffffe          BL       eNandFlash_SetBusTiming
0003c4  e1a09000          MOV      r9,r0
;;;607                                             0x2U,  /* NAND_ID_RD_TIME */
;;;608                                             0x2U,   /* NAND_STATUS_RD_TIME */
;;;609                                             0x7U,   /* write CycTime. was 0x7U */
;;;610                                             0x7U);  /* read CycTime. was 0x7U */
;;;611        /* Set cycle assert delays */
;;;612        eNfRslt3 = eNandFlash_SetCycleAssertDelays (pstCfg,
0003c8  e3a03003          MOV      r3,#3
0003cc  e3a02005          MOV      r2,#5
0003d0  e3a01002          MOV      r1,#2
0003d4  e1a00005          MOV      r0,r5
0003d8  ebfffffe          BL       eNandFlash_SetCycleAssertDelays
0003dc  e1a0a000          MOV      r10,r0
;;;613                                                     0x2U,  /* NAND_BUSY_CYCLE_TO_R_EN */
;;;614                                                     0x5U,   /* NAND_DEASSERT_DELAY_W_EN */
;;;615                                                     0x3U);   /* NAND_ASSERT_DELAY_R_EN */
;;;616    
;;;617       eNfRslt4 = eNandFlash_Initialize (pstCfg, eDevice);
0003e0  e1a01006          MOV      r1,r6
0003e4  e1a00005          MOV      r0,r5
0003e8  ebfffffe          BL       eNandFlash_Initialize
0003ec  e1a0b000          MOV      r11,r0
;;;618    
;;;619       if ((eNfRslt0 == NANDFLASH_STATUS_OK) && (eNfRslt1 == NANDFLASH_STATUS_OK) &&
0003f0  e3570000          CMP      r7,#0
0003f4  1a00000a          BNE      |L1.1060|
0003f8  e3580000          CMP      r8,#0
0003fc  1a000008          BNE      |L1.1060|
;;;620           (eNfRslt2 == NANDFLASH_STATUS_OK) && (eNfRslt3 == NANDFLASH_STATUS_OK) &&
000400  e3590000          CMP      r9,#0
000404  1a000006          BNE      |L1.1060|
000408  e35a0000          CMP      r10,#0
00040c  1a000004          BNE      |L1.1060|
;;;621           (eNfRslt4 == NANDFLASH_STATUS_OK))
000410  e35b0000          CMP      r11,#0
000414  1a000002          BNE      |L1.1060|
;;;622       {
;;;623          eNfFinalRslt = NANDFLASH_STATUS_OK;
000418  e3a00000          MOV      r0,#0
00041c  e58d0004          STR      r0,[sp,#4]
000420  ea000001          B        |L1.1068|
                  |L1.1060|
;;;624       }
;;;625       else
;;;626       {
;;;627          eNfFinalRslt = NANDFLASH_STATUS_CFG_ERR;
000424  e3a00005          MOV      r0,#5
000428  e58d0004          STR      r0,[sp,#4]
                  |L1.1068|
;;;628       }
;;;629    
;;;630       return eNfFinalRslt;
00042c  e59d0004          LDR      r0,[sp,#4]
;;;631    }
000430  e8bd9ffc          POP      {r2-r12,pc}
;;;632    
                          ENDP

                  eNandFlash_EraseBlock PROC
;;;821    /* TESTED */
;;;822    NandFlashStatus_e eNandFlash_EraseBlock (NandFlashCfg_st * pstNandCfg,
000434  e92d40f8          PUSH     {r3-r7,lr}
;;;823                                             uint32_t u32BlockNumber)
;;;824    {
000438  e1a05000          MOV      r5,r0
00043c  e1a06001          MOV      r6,r1
;;;825       NandFlashStatus_e eResult;
;;;826    
;;;827       if (pstNandCfg == TYPES_NULL_PTR)
000440  e3550000          CMP      r5,#0
000444  1a000001          BNE      |L1.1104|
;;;828       {
;;;829          eResult = NANDFLASH_STATUS_PTR_ERR;
000448  e3a04004          MOV      r4,#4
00044c  ea000009          B        |L1.1144|
                  |L1.1104|
;;;830       }
;;;831       else
;;;832       {
;;;833          vNF_CmdPhaseAxiBlockSelect (pstNandCfg, u32BlockNumber,
000450  e3a000d0          MOV      r0,#0xd0
000454  e3a03001          MOV      r3,#1
000458  e3a02060          MOV      r2,#0x60
00045c  e1a01006          MOV      r1,r6
000460  e58d0000          STR      r0,[sp,#0]
000464  e1a00005          MOV      r0,r5
000468  ebfffffe          BL       vNF_CmdPhaseAxiBlockSelect
;;;834                                      NANDFLASH_CMD_ERASE_START, NF_PAR_END_VALID,
;;;835                                      NANDFLASH_CMD_ERASE_END);
;;;836    
;;;837          eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
00046c  e1a00005          MOV      r0,r5
000470  ebfffffe          BL       eNandFlash_WaitDeviceReady
000474  e1a04000          MOV      r4,r0
                  |L1.1144|
;;;838       }
;;;839       return eResult;
000478  e1a00004          MOV      r0,r4
;;;840    }
00047c  e8bd80f8          POP      {r3-r7,pc}
;;;841    
                          ENDP

                  eIplPrgNand_SelectErase PROC
;;;634    /* TESTED */
;;;635    NandFlashStatus_e eIplPrgNand_SelectErase (NandFlashCfg_st * pstNandCfg,
000480  e92d4ff0          PUSH     {r4-r11,lr}
;;;636                                               uint32_t u32HdrStart,
;;;637                                               uint32_t u32HdrSize,
;;;638                                               uint32_t u32BlStart,
;;;639                                               uint32_t u32BlSize,
;;;640                                               uint32_t u32EpStart,
;;;641                                               uint32_t u32EpSize)
;;;642    {
000484  e24dd01c          SUB      sp,sp,#0x1c
000488  e1a08000          MOV      r8,r0
00048c  e1a09001          MOV      r9,r1
000490  e1a06003          MOV      r6,r3
000494  e59da044          LDR      r10,[sp,#0x44]
;;;643       NandFlashStatus_e eErRes = NANDFLASH_STATUS_UNKNOWN;
000498  e3a00001          MOV      r0,#1
00049c  e58d0018          STR      r0,[sp,#0x18]
;;;644    
;;;645       uint32_t u32BlockBytes = 64;
0004a0  e3a00040          MOV      r0,#0x40
0004a4  e58d0014          STR      r0,[sp,#0x14]
;;;646    
;;;647       uint32_t u32ErBlock_Hdr;
;;;648    
;;;649       uint32_t u32ErBlockNo_BlStart;
;;;650    
;;;651       uint32_t u32ErBlockNo_BlEnd;
;;;652    
;;;653       uint32_t u32ErBlockNo_EpStart;
;;;654    
;;;655       uint32_t u32ErBlockNo_EpEnd;
;;;656    
;;;657       uint32_t u32TabIdx = 0;
0004a8  e3a07000          MOV      r7,#0
;;;658    
;;;659       uint32_t u32BIdx = 0;
0004ac  e3a04000          MOV      r4,#0
;;;660    
;;;661       uint32_t u32BlSizeBytes = (u32BlSize << 2);
0004b0  e59d0040          LDR      r0,[sp,#0x40]
0004b4  e1a00100          LSL      r0,r0,#2
0004b8  e58d0004          STR      r0,[sp,#4]
;;;662    
;;;663       uint32_t u32EpSizeBytes = (u32EpSize << 2);
0004bc  e59d0048          LDR      r0,[sp,#0x48]
0004c0  e1a00100          LSL      r0,r0,#2
0004c4  e58d0000          STR      r0,[sp,#0]
;;;664    
;;;665       /*
;;;666          To Erase blocks before programming them - it is required to identify
;;;667          their numbers. Since all adresses are absolute - it is required to
;;;668          calculate only an offset from the NAND Base Address i.e. subtract from
;;;669          each address the value of the Base Addesss. */
;;;670       u32BlockBytes = (pstNandCfg->u32BlkSize) * (pstNandCfg->u32PageSize);
0004c8  e1c800dc          LDRD     r0,r1,[r8,#0xc]
0004cc  e0000190          MUL      r0,r0,r1
0004d0  e58d0014          STR      r0,[sp,#0x14]
;;;671       u32BlStart = (u32BlStart - u32HdrStart); /* offset only */
0004d4  e0466009          SUB      r6,r6,r9
;;;672       u32EpStart = (u32EpStart - u32HdrStart); /* offset only */
0004d8  e04aa009          SUB      r10,r10,r9
;;;673       u32HdrStart = 0;                         /* offset == 0 */
0004dc  e3a09000          MOV      r9,#0
;;;674       u32ErBlock_Hdr = 0;                      /* Header is always at block 0 */
0004e0  e3a05000          MOV      r5,#0
;;;675    
;;;676       /* Block number, where BL code starts */
;;;677       u32ErBlockNo_BlStart = (u32BlStart / u32BlockBytes);
0004e4  e1a00006          MOV      r0,r6
0004e8  e59d1014          LDR      r1,[sp,#0x14]
0004ec  ebfffffe          BL       __aeabi_uidiv
0004f0  e1a0b000          MOV      r11,r0
;;;678       /* Block number, where BL code ends */
;;;679       u32ErBlockNo_BlEnd = ((u32BlStart + u32BlSizeBytes - 1) / u32BlockBytes);
0004f4  e59d1004          LDR      r1,[sp,#4]
0004f8  e0811006          ADD      r1,r1,r6
0004fc  e2410001          SUB      r0,r1,#1
000500  e59d1014          LDR      r1,[sp,#0x14]
000504  ebfffffe          BL       __aeabi_uidiv
000508  e58d0010          STR      r0,[sp,#0x10]
;;;680    
;;;681       /* Block number, where EP code starts */
;;;682       u32ErBlockNo_EpStart = (u32EpStart / u32BlockBytes);
00050c  e1a0000a          MOV      r0,r10
000510  e59d1014          LDR      r1,[sp,#0x14]
000514  ebfffffe          BL       __aeabi_uidiv
000518  e58d000c          STR      r0,[sp,#0xc]
;;;683       /* Block number, where EP code ends */
;;;684       u32ErBlockNo_EpEnd = ((u32EpStart + u32EpSizeBytes - 1) / u32BlockBytes);
00051c  e59d1000          LDR      r1,[sp,#0]
000520  e081100a          ADD      r1,r1,r10
000524  e2410001          SUB      r0,r1,#1
000528  e59d1014          LDR      r1,[sp,#0x14]
00052c  ebfffffe          BL       __aeabi_uidiv
000530  e58d0008          STR      r0,[sp,#8]
;;;685    
;;;686       /* Always erase block 0 */
;;;687       au32BlocksToErase[u32TabIdx++] = u32ErBlock_Hdr;
000534  e1a00007          MOV      r0,r7
000538  e2877001          ADD      r7,r7,#1
00053c  e59f1664          LDR      r1,|L1.2984|
000540  e7815100          STR      r5,[r1,r0,LSL #2]
;;;688    
;;;689       /* Check, if all fits within Block 0 */
;;;690       if ((u32ErBlock_Hdr != u32ErBlockNo_BlStart) ||
000544  e155000b          CMP      r5,r11
000548  1a000008          BNE      |L1.1392|
;;;691           (u32ErBlock_Hdr != u32ErBlockNo_BlEnd) ||
00054c  e59d0010          LDR      r0,[sp,#0x10]
000550  e1550000          CMP      r5,r0
000554  1a000005          BNE      |L1.1392|
;;;692           (u32ErBlock_Hdr != u32ErBlockNo_EpStart) ||
000558  e59d000c          LDR      r0,[sp,#0xc]
00055c  e1550000          CMP      r5,r0
000560  1a000002          BNE      |L1.1392|
;;;693           (u32ErBlock_Hdr != u32ErBlockNo_EpEnd))
000564  e59d0008          LDR      r0,[sp,#8]
000568  e1550000          CMP      r5,r0
00056c  0a00001c          BEQ      |L1.1508|
                  |L1.1392|
;;;694       {
;;;695          /* Identify Boot Loader Blocks to ERASE */
;;;696          for (u32BIdx = u32ErBlockNo_BlStart; u32BIdx <= u32ErBlockNo_BlEnd;
000570  e1a0400b          MOV      r4,r11
000574  ea000006          B        |L1.1428|
                  |L1.1400|
;;;697               u32BIdx++)
;;;698          {
;;;699             /* Check, if not on the list already */
;;;700             if (u32BIdx != u32ErBlock_Hdr)
000578  e1540005          CMP      r4,r5
00057c  0a000003          BEQ      |L1.1424|
;;;701             {
;;;702                au32BlocksToErase[u32TabIdx++] = u32BIdx;
000580  e1a00007          MOV      r0,r7
000584  e2877001          ADD      r7,r7,#1
000588  e59f1618          LDR      r1,|L1.2984|
00058c  e7814100          STR      r4,[r1,r0,LSL #2]
                  |L1.1424|
000590  e2844001          ADD      r4,r4,#1              ;697
                  |L1.1428|
000594  e59d0010          LDR      r0,[sp,#0x10]         ;696
000598  e1540000          CMP      r4,r0                 ;696
00059c  9afffff5          BLS      |L1.1400|
;;;703             }
;;;704          }
;;;705          /* Identify Emergency Program Blocks to ERASE */
;;;706          for (u32BIdx = u32ErBlockNo_EpStart; u32BIdx <= u32ErBlockNo_EpEnd;
0005a0  e59d400c          LDR      r4,[sp,#0xc]
0005a4  ea00000b          B        |L1.1496|
                  |L1.1448|
;;;707               u32BIdx++)
;;;708          {
;;;709             /* To avoid double-erasing of common blocks: check, if such are not
;;;710                already on the list */
;;;711             if ((u32BIdx != u32ErBlock_Hdr) &&
0005a8  e1540005          CMP      r4,r5
0005ac  0a000008          BEQ      |L1.1492|
;;;712                 ((u32BIdx < u32ErBlockNo_BlStart) ||
0005b0  e154000b          CMP      r4,r11
0005b4  3a000002          BCC      |L1.1476|
;;;713                  (u32BIdx > u32ErBlockNo_BlEnd)))
0005b8  e59d0010          LDR      r0,[sp,#0x10]
0005bc  e1540000          CMP      r4,r0
0005c0  9a000003          BLS      |L1.1492|
                  |L1.1476|
;;;714             {
;;;715                au32BlocksToErase[u32TabIdx++] = u32BIdx;
0005c4  e1a00007          MOV      r0,r7
0005c8  e2877001          ADD      r7,r7,#1
0005cc  e59f15d4          LDR      r1,|L1.2984|
0005d0  e7814100          STR      r4,[r1,r0,LSL #2]
                  |L1.1492|
0005d4  e2844001          ADD      r4,r4,#1              ;707
                  |L1.1496|
0005d8  e59d0008          LDR      r0,[sp,#8]            ;706
0005dc  e1540000          CMP      r4,r0                 ;706
0005e0  9afffff0          BLS      |L1.1448|
                  |L1.1508|
;;;716             }
;;;717          }
;;;718       }
;;;719       else
;;;720       {
;;;721          /* Everything fits within block 0 */
;;;722       }
;;;723       /* Now Erase all blocks from the list */
;;;724       for (u32BIdx = u32ErBlock_Hdr; u32BIdx < u32TabIdx; u32BIdx++)
0005e4  e1a04005          MOV      r4,r5
0005e8  ea000009          B        |L1.1556|
                  |L1.1516|
;;;725       {
;;;726    
;;;727          eErRes = eNandFlash_EraseBlock (pstNandCfg, au32BlocksToErase[u32BIdx]);
0005ec  e59f05b4          LDR      r0,|L1.2984|
0005f0  e7901104          LDR      r1,[r0,r4,LSL #2]
0005f4  e1a00008          MOV      r0,r8
0005f8  ebfffffe          BL       eNandFlash_EraseBlock
0005fc  e58d0018          STR      r0,[sp,#0x18]
;;;728          if (eErRes != NANDFLASH_STATUS_OK)
000600  e59d0018          LDR      r0,[sp,#0x18]
000604  e3500000          CMP      r0,#0
000608  0a000000          BEQ      |L1.1552|
;;;729          {
;;;730             /* Exit loop immediately, in case of erase problem */
;;;731             break;
00060c  ea000002          B        |L1.1564|
                  |L1.1552|
000610  e2844001          ADD      r4,r4,#1              ;724
                  |L1.1556|
000614  e1540007          CMP      r4,r7                 ;724
000618  3afffff3          BCC      |L1.1516|
                  |L1.1564|
00061c  e320f000          NOP      
;;;732          }
;;;733       }
;;;734       return eErRes;
000620  e59d0018          LDR      r0,[sp,#0x18]
000624  e28dd01c          ADD      sp,sp,#0x1c
;;;735    }
000628  e8bd8ff0          POP      {r4-r11,pc}
;;;736    
                          ENDP

                  eNandUtil_FindBlockPageOffset PROC
;;;737    /***************************************************************************/
;;;738    void eNandUtil_FindBlockPageOffset (NandFlashCfg_st * pstCfg,
00062c  e92d5ffc          PUSH     {r2-r12,lr}
;;;739                                        uint32_t pu32NandAddr,
;;;740                                        uint32_t* pu32Block,
;;;741                                        uint32_t* pu32Page,
;;;742                                        uint32_t* pu32PageOffset)
;;;743    {
000630  e1a04000          MOV      r4,r0
000634  e1a05001          MOV      r5,r1
000638  e1a06002          MOV      r6,r2
00063c  e1a07003          MOV      r7,r3
000640  e59d8030          LDR      r8,[sp,#0x30]
;;;744       uint32_t u32BlockBytes;
;;;745       uint32_t u32ByteBlkOffset;
;;;746       uint32_t u32Block;
;;;747       uint32_t u32Page;
;;;748       uint32_t u32PageOffset;
;;;749    
;;;750    
;;;751       /* Calculate number of bytes within 1 block */
;;;752       u32BlockBytes = (pstCfg->u32BlkSize) * (pstCfg->u32PageSize);
000644  e1c400dc          LDRD     r0,r1,[r4,#0xc]
000648  e0090190          MUL      r9,r0,r1
;;;753    
;;;754       /* Block number where the addr is pointing to */
;;;755       u32Block = (pu32NandAddr / u32BlockBytes);
00064c  e1a01009          MOV      r1,r9
000650  e1a00005          MOV      r0,r5
000654  ebfffffe          BL       __aeabi_uidiv
000658  e1a0a000          MOV      r10,r0
;;;756    
;;;757       /* Address offset from the beginning of the block */
;;;758       u32ByteBlkOffset = (pu32NandAddr % u32BlockBytes);
00065c  e1a01009          MOV      r1,r9
000660  e1a00005          MOV      r0,r5
000664  ebfffffe          BL       __aeabi_uidivmod
000668  e58d1004          STR      r1,[sp,#4]
;;;759    
;;;760       /* Page number, in which the addr is pointing to */
;;;761       u32Page = (u32ByteBlkOffset / (pstCfg->u32PageSize));
00066c  e5941010          LDR      r1,[r4,#0x10]
000670  e59d0004          LDR      r0,[sp,#4]
000674  ebfffffe          BL       __aeabi_uidiv
000678  e1a0b000          MOV      r11,r0
;;;762    
;;;763       /* Address offset from the beginning of the page */
;;;764       u32PageOffset = (u32ByteBlkOffset % (pstCfg->u32PageSize));
00067c  e5941010          LDR      r1,[r4,#0x10]
000680  e59d0004          LDR      r0,[sp,#4]
000684  ebfffffe          BL       __aeabi_uidivmod
000688  e58d1000          STR      r1,[sp,#0]
;;;765        /*
;;;766        printf("Blk %d, StrPg %d, PgOff %d\n", u32Block, u32Page, u32PageOffset);
;;;767        */
;;;768       *pu32Block = u32Block;
00068c  e586a000          STR      r10,[r6,#0]
;;;769       *pu32Page = u32Page;
000690  e587b000          STR      r11,[r7,#0]
;;;770       *pu32PageOffset = u32PageOffset;
000694  e59d0000          LDR      r0,[sp,#0]
000698  e5880000          STR      r0,[r8,#0]
;;;771    }
00069c  e8bd9ffc          POP      {r2-r12,pc}
;;;772    
                          ENDP

                  eNandUtil_AutoErase PROC
;;;775    /* TESTED */
;;;776    NandFlashStatus_e eNandUtil_AutoErase (NandFlashCfg_st * pstNandCfg,
0006a0  e92d4ff8          PUSH     {r3-r11,lr}
;;;777                                           uint32_t u32StartAddress,
;;;778                                           uint32_t u32EndAddress,
;;;779                                           uint32_t* pu32ErasedBlocks)
;;;780    {
0006a4  e1a05000          MOV      r5,r0
0006a8  e1a07001          MOV      r7,r1
0006ac  e1a08002          MOV      r8,r2
0006b0  e1a04003          MOV      r4,r3
;;;781       NandFlashStatus_e eErRes = NANDFLASH_STATUS_UNKNOWN;
0006b4  e3a09001          MOV      r9,#1
;;;782    
;;;783       uint32_t u32BlockBytes = 64;
0006b8  e3a00040          MOV      r0,#0x40
0006bc  e58d0000          STR      r0,[sp,#0]
;;;784    
;;;785       uint32_t u32StartBlock;
;;;786    
;;;787       uint32_t u32EndBlock;
;;;788    
;;;789       uint32_t u32BIdx = 0;
0006c0  e3a06000          MOV      r6,#0
;;;790    
;;;791       /* This function assumes that all NAND device is located at offset 0 */
;;;792       u32BlockBytes = (pstNandCfg->u32BlkSize) * (pstNandCfg->u32PageSize);
0006c4  e1c500dc          LDRD     r0,r1,[r5,#0xc]
0006c8  e0000190          MUL      r0,r0,r1
0006cc  e58d0000          STR      r0,[sp,#0]
;;;793    
;;;794       /* Block number, where image starts */
;;;795       u32StartBlock = (u32StartAddress / u32BlockBytes);
0006d0  e1a00007          MOV      r0,r7
0006d4  e59d1000          LDR      r1,[sp,#0]
0006d8  ebfffffe          BL       __aeabi_uidiv
0006dc  e1a0a000          MOV      r10,r0
;;;796       /* Block number, where image ends */
;;;797       u32EndBlock = (u32EndAddress / u32BlockBytes);
0006e0  e1a00008          MOV      r0,r8
0006e4  e59d1000          LDR      r1,[sp,#0]
0006e8  ebfffffe          BL       __aeabi_uidiv
0006ec  e1a0b000          MOV      r11,r0
;;;798    
;;;799       /* ERASE blocks */
;;;800       *pu32ErasedBlocks = 0;
0006f0  e3a00000          MOV      r0,#0
0006f4  e5840000          STR      r0,[r4,#0]
;;;801       for (u32BIdx = u32StartBlock; u32BIdx <= u32EndBlock;  u32BIdx++)
0006f8  e1a0600a          MOV      r6,r10
0006fc  ea00000a          B        |L1.1836|
                  |L1.1792|
;;;802       {
;;;803          eErRes = eNandFlash_EraseBlock (pstNandCfg, u32BIdx);
000700  e1a01006          MOV      r1,r6
000704  e1a00005          MOV      r0,r5
000708  ebfffffe          BL       eNandFlash_EraseBlock
00070c  e1a09000          MOV      r9,r0
;;;804          if (eErRes != NANDFLASH_STATUS_OK)
000710  e3590000          CMP      r9,#0
000714  0a000000          BEQ      |L1.1820|
;;;805          {
;;;806             /* Exit loop immediately, in case of erase problem */
;;;807             /*
;;;808             printf("ERROR %d during ERASE of block %d\n", eErRes, u32BIdx);
;;;809             */
;;;810             break;
000718  ea000005          B        |L1.1844|
                  |L1.1820|
;;;811          }
;;;812          else
;;;813          {
;;;814            (*pu32ErasedBlocks)++; /* increment number of erased blocks */
00071c  e5940000          LDR      r0,[r4,#0]
000720  e2800001          ADD      r0,r0,#1
000724  e5840000          STR      r0,[r4,#0]
000728  e2866001          ADD      r6,r6,#1              ;801
                  |L1.1836|
00072c  e156000b          CMP      r6,r11                ;801
000730  9afffff2          BLS      |L1.1792|
                  |L1.1844|
000734  e320f000          NOP                            ;810
;;;815          }
;;;816       }
;;;817       return eErRes;
000738  e1a00009          MOV      r0,r9
;;;818    }
00073c  e8bd8ff8          POP      {r3-r11,pc}
;;;819    
                          ENDP

                  eNandFlash_ProgramPageBytes PROC
;;;844    /* TESTED */
;;;845    NandFlashStatus_e eNandFlash_ProgramPageBytes (NandFlashCfg_st * pstNandCfg,
000740  e92d4ffe          PUSH     {r1-r11,lr}
;;;846                                                   uint32_t u32BlockNumber,
;;;847                                                   uint32_t u32PageNumber,
;;;848                                                   uint8_t pu8SrcBuf[],
;;;849                                                   uint8_t pu8ExtrBuf[])
;;;850    {
000744  e1a04000          MOV      r4,r0
000748  e1a06001          MOV      r6,r1
00074c  e1a07002          MOV      r7,r2
000750  e1a08003          MOV      r8,r3
000754  e59d9030          LDR      r9,[sp,#0x30]
;;;851       NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;
000758  e3a05001          MOV      r5,#1
;;;852    
;;;853       if ((pstNandCfg == TYPES_NULL_PTR))
00075c  e3540000          CMP      r4,#0
000760  1a000001          BNE      |L1.1900|
;;;854       {
;;;855          eResult = NANDFLASH_STATUS_PTR_ERR;
000764  e3a05004          MOV      r5,#4
000768  ea00004e          B        |L1.2216|
                  |L1.1900|
;;;856       }
;;;857       else
;;;858       {
;;;859          if ((pstNandCfg->eBusWidth == NANDFLASH_BUS_WIDTH_8) &&
00076c  e5d40005          LDRB     r0,[r4,#5]
000770  e3500000          CMP      r0,#0
000774  1a00004a          BNE      |L1.2212|
;;;860              (u32PageNumber < pstNandCfg->u32BlkSize))
000778  e594000c          LDR      r0,[r4,#0xc]
00077c  e1500007          CMP      r0,r7
000780  9a000047          BLS      |L1.2212|
;;;861          {
;;;862             uint32_t u32BufferLen = (uint32_t)(pstNandCfg->u32PageSize);
000784  e594b010          LDR      r11,[r4,#0x10]
;;;863    
;;;864             /* ECC handled differently for devices with internal ECC */
;;;865             if (pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_VENDOR1_ECC)
000788  e5d40004          LDRB     r0,[r4,#4]
00078c  e3500001          CMP      r0,#1
000790  1a000018          BNE      |L1.2040|
;;;866             {
;;;867                vNF_CmdPhaseAxiCplx (pstNandCfg, 0x0U, u32PageNumber,
000794  e3a00000          MOV      r0,#0
000798  e3a02080          MOV      r2,#0x80
00079c  e58d0004          STR      r0,[sp,#4]
0007a0  e58d2000          STR      r2,[sp,#0]
0007a4  e1a03006          MOV      r3,r6
0007a8  e1a02007          MOV      r2,r7
0007ac  e58d0008          STR      r0,[sp,#8]
0007b0  e1a01000          MOV      r1,r0
0007b4  e1a00004          MOV      r0,r4
0007b8  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;868                                     u32BlockNumber, NANDFLASH_CMD_PROGRAM_START,
;;;869                                     NF_PAR_NO_END_CMD, NF_PAR_IGNORE);
;;;870                /*
;;;871                   NF_PAR_ECC_LAST parameter means that the last read-transfer will
;;;872                   close the HW ECC calculation process. */
;;;873                vNF_DataPhaseAxiWrMultiBytes (pstNandCfg, u32BufferLen, pu8SrcBuf,
0007bc  e3a03000          MOV      r3,#0
0007c0  e1a02008          MOV      r2,r8
0007c4  e1a0100b          MOV      r1,r11
0007c8  e1a00004          MOV      r0,r4
0007cc  e58d9000          STR      r9,[sp,#0]
0007d0  ebfffffe          BL       vNF_DataPhaseAxiWrMultiBytes
;;;874                                              NF_PAR_IGNORE, pu8ExtrBuf);
;;;875    
;;;876                /* Spec. defines the wait tWB time: WE# HIGH to busy tWB= 100ns
;;;877                   before the BUSY status is read. Normally it should be handled by
;;;878                   the Memory Controller; confirm it! With Internal ECC wait
;;;879                   tPROG_ECC ==600 us */
;;;880                eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
0007d4  e1a00004          MOV      r0,r4
0007d8  ebfffffe          BL       eNandFlash_WaitDeviceReady
0007dc  e1a05000          MOV      r5,r0
;;;881                if (eResult == NANDFLASH_STATUS_OK)
0007e0  e3550000          CMP      r5,#0
0007e4  1a00002d          BNE      |L1.2208|
;;;882                {
;;;883                   /* Check device's status (0 == ECC OK) */
;;;884                   eResult = eNF_GetDeviceStatus (pstNandCfg);
0007e8  e1a00004          MOV      r0,r4
0007ec  ebfffffe          BL       eNF_GetDeviceStatus
0007f0  e1a05000          MOV      r5,r0
0007f4  ea000029          B        |L1.2208|
                  |L1.2040|
;;;885                   /* ****** FINAL eResult should be available here ****** */
;;;886                }
;;;887                /* ****** FINAL eResult should be available here ****** */
;;;888             }
;;;889             else                               /* 1-bit ECC: ONFI devices */
;;;890             {
;;;891                /* Prepare ECC HW before writing data */
;;;892                eResult = eNF_EccConfigure (pstNandCfg);
0007f8  e1a00004          MOV      r0,r4
0007fc  ebfffffe          BL       eNF_EccConfigure
000800  e1a05000          MOV      r5,r0
;;;893    
;;;894                if (eResult == NANDFLASH_STATUS_OK)
000804  e3550000          CMP      r5,#0
000808  1a000024          BNE      |L1.2208|
;;;895                {
;;;896                   /* AXI write Command Phase followed by the Page Data Phase */
;;;897                   vNF_CmdPhaseAxiCplx (pstNandCfg, 0U, u32PageNumber,
00080c  e3a00000          MOV      r0,#0
000810  e3a02080          MOV      r2,#0x80
000814  e58d0004          STR      r0,[sp,#4]
000818  e58d2000          STR      r2,[sp,#0]
00081c  e1a03006          MOV      r3,r6
000820  e1a02007          MOV      r2,r7
000824  e58d0008          STR      r0,[sp,#8]
000828  e1a01000          MOV      r1,r0
00082c  e1a00004          MOV      r0,r4
000830  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;898                                        u32BlockNumber, NANDFLASH_CMD_PROGRAM_START,
;;;899                                        NF_PAR_NO_END_CMD, NF_PAR_IGNORE);
;;;900                   /* DATA Phase (Extra Block is forbidden in this case) */
;;;901                   vNF_DataPhaseAxiWrMultiBytes (pstNandCfg, u32BufferLen,
000834  e3a03001          MOV      r3,#1
000838  e1a02008          MOV      r2,r8
00083c  e1a0100b          MOV      r1,r11
000840  e1a00004          MOV      r0,r4
000844  e58d9000          STR      r9,[sp,#0]
000848  ebfffffe          BL       vNF_DataPhaseAxiWrMultiBytes
;;;902                                                 pu8SrcBuf, NF_PAR_ECC_LAST,
;;;903                                                 pu8ExtrBuf);
;;;904                   /* Wait until ECC is IDLE */
;;;905                   eResult = eNF_EccWaitIdle (pstNandCfg);
00084c  e1a00004          MOV      r0,r4
000850  ebfffffe          BL       eNF_EccWaitIdle
000854  e1a05000          MOV      r5,r0
;;;906                   if (eResult == NANDFLASH_STATUS_OK)
000858  e3550000          CMP      r5,#0
00085c  1a00000f          BNE      |L1.2208|
;;;907                   {
;;;908                      uint32_t u32Status;
;;;909    
;;;910                      /* Check Last ECC Status */
;;;911                      u32Status = MEMCTRL_ECC_STATUS;
000860  e59f0344          LDR      r0,|L1.2988|
000864  e590a000          LDR      r10,[r0,#0]
;;;912                      u32Status = (u32Status & MEMCTRL_ECC_LAST_STATUS_MSK);
000868  e20aad06          AND      r10,r10,#0x180
;;;913                      if (u32Status == MEMCTRL_ECC_LAST_STATUS_SUCCESS_BITS)
00086c  e35a0000          CMP      r10,#0
000870  1a000008          BNE      |L1.2200|
;;;914                      {
;;;915                         /* Spec. defines the wait tWB time: WE# HIGH to busy tWB=
;;;916                            100ns before the BUSY status is read. Normally it
;;;917                            should be handled by the Memory Controller; confirm it!
;;;918                            With Internal ECC wait tPROG_ECC ==600 us */
;;;919                         eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
000874  e1a00004          MOV      r0,r4
000878  ebfffffe          BL       eNandFlash_WaitDeviceReady
00087c  e1a05000          MOV      r5,r0
;;;920                         if (eResult == NANDFLASH_STATUS_OK)
000880  e3550000          CMP      r5,#0
000884  1a000004          BNE      |L1.2204|
;;;921                         {
;;;922                            /*
;;;923                               Read the device's status word */
;;;924                            eResult = eNF_GetDeviceStatus (pstNandCfg);
000888  e1a00004          MOV      r0,r4
00088c  ebfffffe          BL       eNF_GetDeviceStatus
000890  e1a05000          MOV      r5,r0
000894  ea000000          B        |L1.2204|
                  |L1.2200|
;;;925                            /* ****** FINAL eResult should be available here ******
;;;926                             */
;;;927                         }
;;;928                      }
;;;929                      else
;;;930                      {
;;;931                         /* For details ecc_last_status should be analyzed */
;;;932                         eResult = NANDFLASH_STATUS_ECC_ERR;
000898  e3a0500c          MOV      r5,#0xc
                  |L1.2204|
;;;933                      }
;;;934                   }
00089c  e320f000          NOP      
                  |L1.2208|
;;;935                }
;;;936             }
;;;937          }
0008a0  ea000000          B        |L1.2216|
                  |L1.2212|
;;;938          else
;;;939          {
;;;940             eResult = NANDFLASH_STATUS_USAGE_ERR;
0008a4  e3a05008          MOV      r5,#8
                  |L1.2216|
;;;941          }
;;;942       }
;;;943       return eResult;
0008a8  e1a00005          MOV      r0,r5
;;;944    }
0008ac  e8bd8ffe          POP      {r1-r11,pc}
;;;945    
                          ENDP

                  eNandFlash_ProgramPage16bitWords PROC
;;;947    /* TESTED */
;;;948    NandFlashStatus_e eNandFlash_ProgramPage16bitWords (NandFlashCfg_st *
0008b0  e92d4ffe          PUSH     {r1-r11,lr}
;;;949                                                        pstNandCfg,
;;;950                                                        uint32_t u32BlockNumber,
;;;951                                                        uint32_t u32PageNumber,
;;;952                                                        uint16_t pu16SrcBuf[],
;;;953                                                        uint16_t pu16ExtrBuf[])
;;;954    {
0008b4  e1a04000          MOV      r4,r0
0008b8  e1a06001          MOV      r6,r1
0008bc  e1a07002          MOV      r7,r2
0008c0  e1a08003          MOV      r8,r3
0008c4  e59d9030          LDR      r9,[sp,#0x30]
;;;955       NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;
0008c8  e3a05001          MOV      r5,#1
;;;956    
;;;957       if ((pstNandCfg == TYPES_NULL_PTR))
0008cc  e3540000          CMP      r4,#0
0008d0  1a000001          BNE      |L1.2268|
;;;958       {
;;;959          eResult = NANDFLASH_STATUS_PTR_ERR;
0008d4  e3a05004          MOV      r5,#4
0008d8  ea00004f          B        |L1.2588|
                  |L1.2268|
;;;960       }
;;;961       else
;;;962       {
;;;963          if ((pstNandCfg->eBusWidth == NANDFLASH_BUS_WIDTH_16) &&
0008dc  e5d40005          LDRB     r0,[r4,#5]
0008e0  e3500001          CMP      r0,#1
0008e4  1a00004b          BNE      |L1.2584|
;;;964              (u32PageNumber < pstNandCfg->u32BlkSize))
0008e8  e594000c          LDR      r0,[r4,#0xc]
0008ec  e1500007          CMP      r0,r7
0008f0  9a000048          BLS      |L1.2584|
;;;965          {
;;;966             /* number of 16-bit words in a buffer */
;;;967             uint32_t u32BufferLen = ((pstNandCfg->u32PageSize) >> 1);
0008f4  e5940010          LDR      r0,[r4,#0x10]
0008f8  e1a0b0a0          LSR      r11,r0,#1
;;;968    
;;;969             /*
;;;970                ECC handled differently for devices with internal ECC */
;;;971             if (pstNandCfg->eDeviceType == NANDFLASH_DEVICE_ONFI_VENDOR1_ECC)
0008fc  e5d40004          LDRB     r0,[r4,#4]
000900  e3500001          CMP      r0,#1
000904  1a000018          BNE      |L1.2412|
;;;972             {
;;;973                vNF_CmdPhaseAxiCplx (pstNandCfg, 0x0U, u32PageNumber,
000908  e3a00000          MOV      r0,#0
00090c  e3a02080          MOV      r2,#0x80
000910  e58d0004          STR      r0,[sp,#4]
000914  e58d2000          STR      r2,[sp,#0]
000918  e1a03006          MOV      r3,r6
00091c  e1a02007          MOV      r2,r7
000920  e58d0008          STR      r0,[sp,#8]
000924  e1a01000          MOV      r1,r0
000928  e1a00004          MOV      r0,r4
00092c  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;974                                     u32BlockNumber, NANDFLASH_CMD_PROGRAM_START,
;;;975                                     NF_PAR_NO_END_CMD, NF_PAR_IGNORE);
;;;976                /*
;;;977                   NF_PAR_ECC_LAST parameter means that the last read-transfer will
;;;978                   close the HW ECC calculation process. */
;;;979                vNF_DataPhaseAxiWrMulti16Bits (pstNandCfg, u32BufferLen, pu16SrcBuf,
000930  e3a03000          MOV      r3,#0
000934  e1a02008          MOV      r2,r8
000938  e1a0100b          MOV      r1,r11
00093c  e1a00004          MOV      r0,r4
000940  e58d9000          STR      r9,[sp,#0]
000944  ebfffffe          BL       vNF_DataPhaseAxiWrMulti16Bits
;;;980                                               NF_PAR_IGNORE, pu16ExtrBuf);
;;;981                /* Spec. defines the wait tWB time: WE# HIGH to busy tWB= 100ns
;;;982                   before the BUSY status is read. Normally it should be handled by
;;;983                   the Memory Controller; confirm it! With Internal ECC wait
;;;984                   tPROG_ECC ==600 us */
;;;985                eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
000948  e1a00004          MOV      r0,r4
00094c  ebfffffe          BL       eNandFlash_WaitDeviceReady
000950  e1a05000          MOV      r5,r0
;;;986                if (eResult == NANDFLASH_STATUS_OK)
000954  e3550000          CMP      r5,#0
000958  1a00002d          BNE      |L1.2580|
;;;987                {
;;;988                   /*
;;;989                      Read the device's status word */
;;;990                   eResult = eNF_GetDeviceStatus (pstNandCfg);
00095c  e1a00004          MOV      r0,r4
000960  ebfffffe          BL       eNF_GetDeviceStatus
000964  e1a05000          MOV      r5,r0
000968  ea000029          B        |L1.2580|
                  |L1.2412|
;;;991                   /* ****** FINAL eResult should be available here ****** */
;;;992                }
;;;993                /* ****** FINAL eResult should be available here ****** */
;;;994             }
;;;995             else                               /* 1-bit ECC: ONFI devices */
;;;996             {
;;;997                /* Prepare ECC HW before writing data */
;;;998                eResult = eNF_EccConfigure (pstNandCfg);
00096c  e1a00004          MOV      r0,r4
000970  ebfffffe          BL       eNF_EccConfigure
000974  e1a05000          MOV      r5,r0
;;;999    
;;;1000               if (eResult == NANDFLASH_STATUS_OK)
000978  e3550000          CMP      r5,#0
00097c  1a000024          BNE      |L1.2580|
;;;1001               {
;;;1002                  /* AXI write Command Phase followed by the Page Data Phase */
;;;1003                  vNF_CmdPhaseAxiCplx (pstNandCfg, 0U, u32PageNumber,
000980  e3a00000          MOV      r0,#0
000984  e3a02080          MOV      r2,#0x80
000988  e58d0004          STR      r0,[sp,#4]
00098c  e58d2000          STR      r2,[sp,#0]
000990  e1a03006          MOV      r3,r6
000994  e1a02007          MOV      r2,r7
000998  e58d0008          STR      r0,[sp,#8]
00099c  e1a01000          MOV      r1,r0
0009a0  e1a00004          MOV      r0,r4
0009a4  ebfffffe          BL       vNF_CmdPhaseAxiCplx
;;;1004                                       u32BlockNumber, NANDFLASH_CMD_PROGRAM_START,
;;;1005                                       NF_PAR_NO_END_CMD, NF_PAR_IGNORE);
;;;1006                  /* DATA Phase (Extra Block is forbidden in this case) */
;;;1007                  vNF_DataPhaseAxiWrMulti16Bits (pstNandCfg, u32BufferLen,
0009a8  e3a03001          MOV      r3,#1
0009ac  e1a02008          MOV      r2,r8
0009b0  e1a0100b          MOV      r1,r11
0009b4  e1a00004          MOV      r0,r4
0009b8  e58d9000          STR      r9,[sp,#0]
0009bc  ebfffffe          BL       vNF_DataPhaseAxiWrMulti16Bits
;;;1008                                                 pu16SrcBuf, NF_PAR_ECC_LAST,
;;;1009                                                 pu16ExtrBuf);
;;;1010                  /* Wait until ECC is IDLE */
;;;1011                  eResult = eNF_EccWaitIdle (pstNandCfg);
0009c0  e1a00004          MOV      r0,r4
0009c4  ebfffffe          BL       eNF_EccWaitIdle
0009c8  e1a05000          MOV      r5,r0
;;;1012                  if (eResult == NANDFLASH_STATUS_OK)
0009cc  e3550000          CMP      r5,#0
0009d0  1a00000f          BNE      |L1.2580|
;;;1013                  {
;;;1014                     uint32_t u32Status;
;;;1015   
;;;1016                     /* Check Last ECC Status */
;;;1017                     u32Status = MEMCTRL_ECC_STATUS;
0009d4  e59f01d0          LDR      r0,|L1.2988|
0009d8  e590a000          LDR      r10,[r0,#0]
;;;1018                     u32Status = (u32Status & MEMCTRL_ECC_LAST_STATUS_MSK);
0009dc  e20aad06          AND      r10,r10,#0x180
;;;1019                     if (u32Status == MEMCTRL_ECC_LAST_STATUS_SUCCESS_BITS)
0009e0  e35a0000          CMP      r10,#0
0009e4  1a000008          BNE      |L1.2572|
;;;1020                     {
;;;1021                        /* Spec. defines the wait tWB time: WE# HIGH to busy tWB=
;;;1022                           100ns before the BUSY status is read. Normally it
;;;1023                           should be handled by the Memory Controller; confirm it!
;;;1024                           With Internal ECC wait tPROG_ECC ==600 us */
;;;1025                        eResult = eNandFlash_WaitDeviceReady (pstNandCfg);
0009e8  e1a00004          MOV      r0,r4
0009ec  ebfffffe          BL       eNandFlash_WaitDeviceReady
0009f0  e1a05000          MOV      r5,r0
;;;1026                        if (eResult == NANDFLASH_STATUS_OK)
0009f4  e3550000          CMP      r5,#0
0009f8  1a000004          BNE      |L1.2576|
;;;1027                        {
;;;1028                           /*
;;;1029                              Read the device's status word */
;;;1030                           eResult = eNF_GetDeviceStatus (pstNandCfg);
0009fc  e1a00004          MOV      r0,r4
000a00  ebfffffe          BL       eNF_GetDeviceStatus
000a04  e1a05000          MOV      r5,r0
000a08  ea000000          B        |L1.2576|
                  |L1.2572|
;;;1031                           /* ****** FINAL eResult should be available here ******
;;;1032                            */
;;;1033                        }
;;;1034                     }
;;;1035                     else
;;;1036                     {
;;;1037                        /* For details ecc_last_status should be analyzed */
;;;1038                        eResult = NANDFLASH_STATUS_ECC_ERR;
000a0c  e3a0500c          MOV      r5,#0xc
                  |L1.2576|
;;;1039                     }
;;;1040                  }
000a10  e320f000          NOP      
                  |L1.2580|
;;;1041               }
;;;1042            }
;;;1043         }
000a14  ea000000          B        |L1.2588|
                  |L1.2584|
;;;1044         else
;;;1045         {
;;;1046            eResult = NANDFLASH_STATUS_USAGE_ERR;
000a18  e3a05008          MOV      r5,#8
                  |L1.2588|
;;;1047         }
;;;1048      }
;;;1049      return eResult;
000a1c  e1a00005          MOV      r0,r5
;;;1050   }
000a20  e8bd8ffe          POP      {r1-r11,pc}
;;;1051   
                          ENDP

                  eNandFlash_ProgramPages PROC
;;;1053   /* TESTED: */
;;;1054   NandFlashStatus_e eNandFlash_ProgramPages (NandFlashCfg_st * pstNandCfg,
000a24  e92d4ff8          PUSH     {r3-r11,lr}
;;;1055                                              uint32_t u32BlockNumber,
;;;1056                                              uint32_t u32StartPage,
;;;1057                                              uint32_t u32NoOfPages,
;;;1058                                              uint32_t pu32SrcBuf[],
;;;1059                                              uint32_t pu32ExtrBuf[])
;;;1060   {
000a28  e1a04000          MOV      r4,r0
000a2c  e1a08001          MOV      r8,r1
000a30  e1a06002          MOV      r6,r2
000a34  e1a07003          MOV      r7,r3
000a38  e59d902c          LDR      r9,[sp,#0x2c]
;;;1061      NandFlashStatus_e eResult = NANDFLASH_STATUS_UNKNOWN;
000a3c  e3a0a001          MOV      r10,#1
;;;1062   
;;;1063      if ((pstNandCfg == TYPES_NULL_PTR))
000a40  e3540000          CMP      r4,#0
000a44  1a000001          BNE      |L1.2640|
;;;1064      {
;;;1065         eResult = NANDFLASH_STATUS_PTR_ERR;
000a48  e3a0a004          MOV      r10,#4
000a4c  ea000028          B        |L1.2804|
                  |L1.2640|
;;;1066      }
;;;1067      else
;;;1068      {
;;;1069         /*
;;;1070            Check, if all Pages belong to the current block. */
;;;1071         if (u32NoOfPages > 0U)                /* is anything to read */
000a50  e3570000          CMP      r7,#0
000a54  0a000025          BEQ      |L1.2800|
;;;1072         {
;;;1073            uint32_t u32Idx = u32StartPage;
000a58  e1a05006          MOV      r5,r6
;;;1074   
;;;1075            uint32_t u32SrcAddr = (uint32_t)pu32SrcBuf; /* Source location to read
000a5c  e59db028          LDR      r11,[sp,#0x28]
;;;1076                                                           from */
;;;1077   
;;;1078            do
000a60  e320f000          NOP      
                  |L1.2660|
;;;1079            {
;;;1080               if (u32Idx >= pstNandCfg->u32BlkSize) /* check range/condition! */
000a64  e594000c          LDR      r0,[r4,#0xc]
000a68  e1500005          CMP      r0,r5
000a6c  8a000004          BHI      |L1.2692|
;;;1081               {
;;;1082                  /* This function might cross the total size / number of blocks
;;;1083                     of the NAND device. DO NOT reset StartPage since it is used
;;;1084                     in the loop exit condition. */
;;;1085                  u32BlockNumber++;
000a70  e2888001          ADD      r8,r8,#1
;;;1086                  u32NoOfPages = (u32NoOfPages - (u32Idx - u32StartPage));
000a74  e0450006          SUB      r0,r5,r6
000a78  e0477000          SUB      r7,r7,r0
;;;1087                  /* Read should continue at beginning of the next block */
;;;1088                  u32Idx = 0U;
000a7c  e3a05000          MOV      r5,#0
;;;1089                  u32StartPage = 0U;
000a80  e3a06000          MOV      r6,#0
                  |L1.2692|
;;;1090               }
;;;1091               if (pstNandCfg->eBusWidth == NANDFLASH_BUS_WIDTH_16)
000a84  e5d40005          LDRB     r0,[r4,#5]
000a88  e3500001          CMP      r0,#1
000a8c  1a000007          BNE      |L1.2736|
;;;1092               {
;;;1093                  eResult =
000a90  e1a0300b          MOV      r3,r11
000a94  e1a02005          MOV      r2,r5
000a98  e1a01008          MOV      r1,r8
000a9c  e1a00004          MOV      r0,r4
000aa0  e58d9000          STR      r9,[sp,#0]
000aa4  ebfffffe          BL       eNandFlash_ProgramPage16bitWords
000aa8  e1a0a000          MOV      r10,r0
000aac  ea000006          B        |L1.2764|
                  |L1.2736|
;;;1094                     eNandFlash_ProgramPage16bitWords (pstNandCfg, u32BlockNumber,
;;;1095                                                       u32Idx,
;;;1096                                                       (uint16_t *)u32SrcAddr,
;;;1097                                                       (uint16_t *)pu32ExtrBuf);
;;;1098               }
;;;1099               else
;;;1100               {
;;;1101                  eResult =
000ab0  e1a0300b          MOV      r3,r11
000ab4  e1a02005          MOV      r2,r5
000ab8  e1a01008          MOV      r1,r8
000abc  e1a00004          MOV      r0,r4
000ac0  e58d9000          STR      r9,[sp,#0]
000ac4  ebfffffe          BL       eNandFlash_ProgramPageBytes
000ac8  e1a0a000          MOV      r10,r0
                  |L1.2764|
;;;1102                     eNandFlash_ProgramPageBytes (pstNandCfg, u32BlockNumber,
;;;1103                                                  u32Idx, (uint8_t *)u32SrcAddr,
;;;1104                                                  (uint8_t *)pu32ExtrBuf);
;;;1105               }
;;;1106               u32Idx++;
000acc  e2855001          ADD      r5,r5,#1
;;;1107               u32SrcAddr = (u32SrcAddr + pstNandCfg->u32PageSize);
000ad0  e5940010          LDR      r0,[r4,#0x10]
000ad4  e08bb000          ADD      r11,r11,r0
;;;1108            }
;;;1109            while (((u32Idx < (u32StartPage + u32NoOfPages)) &&
000ad8  e0860007          ADD      r0,r6,r7
000adc  e1500005          CMP      r0,r5
000ae0  9a000001          BLS      |L1.2796|
;;;1110                    (eResult == NANDFLASH_STATUS_OK)));
000ae4  e35a0000          CMP      r10,#0
000ae8  0affffdd          BEQ      |L1.2660|
                  |L1.2796|
;;;1111   
;;;1112            /* ****** FINAL eResult should be available here ****** */
;;;1113         }
000aec  ea000000          B        |L1.2804|
                  |L1.2800|
;;;1114         else
;;;1115         {
;;;1116            eResult = NANDFLASH_STATUS_PARAM_ERR; /* */
000af0  e3a0a009          MOV      r10,#9
                  |L1.2804|
;;;1117         }
;;;1118      }
;;;1119      return eResult;
000af4  e1a0000a          MOV      r0,r10
;;;1120   }
000af8  e8bd8ff8          POP      {r3-r11,pc}
;;;1121   
                          ENDP

                  eNandFlash_ProgramData PROC
;;;1123   /* TESTED: */
;;;1124   NandFlashStatus_e eNandFlash_ProgramData (NandFlashCfg_st * pstCfg,
000afc  e92d4ff0          PUSH     {r4-r11,lr}
;;;1125                                             uint32_t pu32SrcBuf[],
;;;1126                                             uint32_t u32SrcBufLen,
;;;1127                                             uint32_t pu32DstAddr,
;;;1128                                             uint32_t pu32ExtrBuf[])
;;;1129   {
000b00  e24dd014          SUB      sp,sp,#0x14
000b04  e1a04000          MOV      r4,r0
000b08  e1a06001          MOV      r6,r1
000b0c  e1a05002          MOV      r5,r2
000b10  e1a07003          MOV      r7,r3
000b14  e59da038          LDR      r10,[sp,#0x38]
;;;1130      NandFlashStatus_e eNandStatus;
;;;1131   
;;;1132      uint32_t u32BlockBytes;
;;;1133   
;;;1134      uint32_t u32BlockNumber;
;;;1135   
;;;1136      uint32_t u32ByteBlkOffset;
;;;1137   
;;;1138      uint32_t u32StartPage;
;;;1139   
;;;1140      uint32_t u32NoOfPages;
;;;1141   
;;;1142      /* Calculate Block and Page number */
;;;1143      u32BlockBytes = (pstCfg->u32BlkSize) * (pstCfg->u32PageSize);
000b18  e1c400dc          LDRD     r0,r1,[r4,#0xc]
000b1c  e00b0190          MUL      r11,r0,r1
;;;1144      /* Block number where the addr is pointing to */
;;;1145      u32BlockNumber = (pu32DstAddr / u32BlockBytes);
000b20  e1a0100b          MOV      r1,r11
000b24  e1a00007          MOV      r0,r7
000b28  ebfffffe          BL       __aeabi_uidiv
000b2c  e58d0010          STR      r0,[sp,#0x10]
;;;1146      /* Address offset from the beginning of the block */
;;;1147      u32ByteBlkOffset = (pu32DstAddr % u32BlockBytes);
000b30  e1a0100b          MOV      r1,r11
000b34  e1a00007          MOV      r0,r7
000b38  ebfffffe          BL       __aeabi_uidivmod
000b3c  e58d100c          STR      r1,[sp,#0xc]
;;;1148      /* Page number, in which the addr is pointing to */
;;;1149      u32StartPage = (u32ByteBlkOffset / (pstCfg->u32PageSize));
000b40  e5941010          LDR      r1,[r4,#0x10]
000b44  e59d000c          LDR      r0,[sp,#0xc]
000b48  ebfffffe          BL       __aeabi_uidiv
000b4c  e58d0008          STR      r0,[sp,#8]
;;;1150      /* Convert no of words to no of bytes */
;;;1151      u32SrcBufLen = (u32SrcBufLen << 2);
000b50  e1a05105          LSL      r5,r5,#2
;;;1152   
;;;1153      /* Calculate how many pages should be read */
;;;1154      u32NoOfPages = ((u32SrcBufLen) / pstCfg->u32PageSize);
000b54  e1a00005          MOV      r0,r5
000b58  e5941010          LDR      r1,[r4,#0x10]
000b5c  ebfffffe          BL       __aeabi_uidiv
000b60  e1a09000          MOV      r9,r0
;;;1155      /*
;;;1156         Check, if one additional page needs to be programmed */
;;;1157      if (((u32SrcBufLen) % (pstCfg->u32PageSize)) != 0)
000b64  e1a00005          MOV      r0,r5
000b68  e5941010          LDR      r1,[r4,#0x10]
000b6c  ebfffffe          BL       __aeabi_uidivmod
000b70  e3510000          CMP      r1,#0
000b74  0a000000          BEQ      |L1.2940|
;;;1158      {
;;;1159         u32NoOfPages = u32NoOfPages + 1;      /* Another page must be prog. */
000b78  e2899001          ADD      r9,r9,#1
                  |L1.2940|
;;;1160      }
;;;1161      /* Perform NAND data-program */
;;;1162      eNandStatus =
000b7c  e1a03009          MOV      r3,r9
000b80  e88d0440          STM      sp,{r6,r10}
000b84  e1a00004          MOV      r0,r4
000b88  e59d1010          LDR      r1,[sp,#0x10]
000b8c  e59d2008          LDR      r2,[sp,#8]
000b90  ebfffffe          BL       eNandFlash_ProgramPages
000b94  e1a08000          MOV      r8,r0
;;;1163         eNandFlash_ProgramPages (pstCfg, u32BlockNumber, u32StartPage,
;;;1164                                  u32NoOfPages, pu32SrcBuf, pu32ExtrBuf);
;;;1165      return eNandStatus;
000b98  e1a00008          MOV      r0,r8
000b9c  e28dd014          ADD      sp,sp,#0x14
;;;1166   }
000ba0  e8bd8ff0          POP      {r4-r11,pc}
;;;1167   
                          ENDP

                  |L1.2980|
                          DCD      0xc0200000
                  |L1.2984|
                          DCD      au32BlocksToErase
                  |L1.2988|
                          DCD      0xc0200400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  au32BlocksToErase
                          %        4096
